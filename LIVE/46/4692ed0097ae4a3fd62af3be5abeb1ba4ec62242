
/************************************************
*  Filepath: /point_of_sale/static/lib/sha1.js  *
*  Lines: 160                                   *
************************************************/
/* from http://www.movable-type.co.uk/scripts/sha1.html */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  SHA-1 implementation in JavaScript                  (c) Chris Veness 2002-2014 / MIT Licence  */
/*                                                                                                */
/*  - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                              */
/*        http://csrc.nist.gov/groups/ST/toolkit/examples.html                                    */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
(function (_window) {
/* jshint node:true *//* global define, escape, unescape */
'use strict';


/**
 * SHA-1 hash function reference implementation.
 *
 * @namespace
 */
var Sha1 = {};
_window.Sha1 = Sha1;

/**
 * Generates SHA-1 hash of string.
 *
 * @param   {string} msg - (Unicode) string to be hashed.
 * @returns {string} Hash of msg as hex character string.
 */
Sha1.hash = function(msg) {
    // convert string to UTF-8, as SHA only deals with byte-streams
    msg = msg.utf8Encode();

    // constants [§4.2.1]
    var K = [ 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6 ];

    // PREPROCESSING

    msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.1]

    // convert string msg into 512-bit/16-integer blocks arrays of ints [§5.2.1]
    var l = msg.length/4 + 2; // length (in 32-bit integers) of msg + ‘1’ + appended length
    var N = Math.ceil(l/16);  // number of 16-integer-blocks required to hold 'l' ints
    var M = new Array(N);

    for (var i=0; i<N; i++) {
        M[i] = new Array(16);
        for (var j=0; j<16; j++) {  // encode 4 chars per integer, big-endian encoding
            M[i][j] = (msg.charCodeAt(i*64+j*4)<<24) | (msg.charCodeAt(i*64+j*4+1)<<16) |
                (msg.charCodeAt(i*64+j*4+2)<<8) | (msg.charCodeAt(i*64+j*4+3));
        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0
    }
    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]
    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts
    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators
    M[N-1][14] = ((msg.length-1)*8) / Math.pow(2, 32); M[N-1][14] = Math.floor(M[N-1][14]);
    M[N-1][15] = ((msg.length-1)*8) & 0xffffffff;

    // set initial hash value [§5.3.1]
    var H0 = 0x67452301;
    var H1 = 0xefcdab89;
    var H2 = 0x98badcfe;
    var H3 = 0x10325476;
    var H4 = 0xc3d2e1f0;

    // HASH COMPUTATION [§6.1.2]

    var W = new Array(80); var a, b, c, d, e;
    for (var i=0; i<N; i++) {

        // 1 - prepare message schedule 'W'
        for (var t=0;  t<16; t++) W[t] = M[i][t];
        for (var t=16; t<80; t++) W[t] = Sha1.ROTL(W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16], 1);

        // 2 - initialise five working variables a, b, c, d, e with previous hash value
        a = H0; b = H1; c = H2; d = H3; e = H4;

        // 3 - main loop
        for (var t=0; t<80; t++) {
            var s = Math.floor(t/20); // seq for blocks of 'f' functions and 'K' constants
            var T = (Sha1.ROTL(a,5) + Sha1.f(s,b,c,d) + e + K[s] + W[t]) & 0xffffffff;
            e = d;
            d = c;
            c = Sha1.ROTL(b, 30);
            b = a;
            a = T;
        }

        // 4 - compute the new intermediate hash value (note 'addition modulo 2^32')
        H0 = (H0+a) & 0xffffffff;
        H1 = (H1+b) & 0xffffffff;
        H2 = (H2+c) & 0xffffffff;
        H3 = (H3+d) & 0xffffffff;
        H4 = (H4+e) & 0xffffffff;
    }

    return Sha1.toHexStr(H0) + Sha1.toHexStr(H1) + Sha1.toHexStr(H2) +
           Sha1.toHexStr(H3) + Sha1.toHexStr(H4);
};


/**
 * Function 'f' [§4.1.1].
 * @private
 */
Sha1.f = function(s, x, y, z)  {
    switch (s) {
        case 0: return (x & y) ^ (~x & z);           // Ch()
        case 1: return  x ^ y  ^  z;                 // Parity()
        case 2: return (x & y) ^ (x & z) ^ (y & z);  // Maj()
        case 3: return  x ^ y  ^  z;                 // Parity()
    }
};

/**
 * Rotates left (circular left shift) value x by n positions [§3.2.5].
 * @private
 */
Sha1.ROTL = function(x, n) {
    return (x<<n) | (x>>>(32-n));
};


/**
 * Hexadecimal representation of a number.
 * @private
 */
Sha1.toHexStr = function(n) {
    // note can't use toString(16) as it is implementation-dependant,
    // and in IE returns signed numbers when used on full words
    var s="", v;
    for (var i=7; i>=0; i--) { v = (n>>>(i*4)) & 0xf; s += v.toString(16); }
    return s;
};


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */


/** Extend String object with method to encode multi-byte string to utf8
 *  - monsur.hossa.in/2012/07/20/utf-8-in-javascript.html */
if (typeof String.prototype.utf8Encode == 'undefined') {
    String.prototype.utf8Encode = function() {
        return unescape( encodeURIComponent( this ) );
    };
}

/** Extend String object with method to decode utf8 string to multi-byte */
if (typeof String.prototype.utf8Decode == 'undefined') {
    String.prototype.utf8Decode = function() {
        try {
            return decodeURIComponent( escape( this ) );
        } catch (e) {
            return this; // invalid UTF-8? return as-is
        }
    };
}


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
if (typeof module != 'undefined' && module.exports) module.exports = Sha1; // CommonJs export
if (typeof define == 'function' && define.amd) define([], function() { return Sha1; }); // AMD
})(window)
;

/****************************************************
*  Filepath: /point_of_sale/static/lib/waitfont.js  *
*  Lines: 59                                        *
****************************************************/
// http://stackoverflow.com/questions/4383226/using-jquery-to-know-when-font-face-fonts-are-loaded
(function(){
    function waitForWebfonts(fonts, callback) {
        var loadedFonts = 0;
        for(var i = 0, l = fonts.length; i < l; ++i) {
            (function(font) {
                var node = document.createElement('span');
                // Characters that vary significantly among different fonts
                node.innerHTML = 'giItT1WQy@!-/#';
                // Visible - so we can measure it - but not on the screen
                node.style.position      = 'absolute';
                node.style.left          = '-10000px';
                node.style.top           = '-10000px';
                // Large font size makes even subtle changes obvious
                node.style.fontSize      = '300px';
                // Reset any font properties
                node.style.fontFamily    = 'sans-serif';
                node.style.fontVariant   = 'normal';
                node.style.fontStyle     = 'normal';
                node.style.fontWeight    = 'normal';
                node.style.letterSpacing = '0';
                document.body.appendChild(node);

                // Remember width with no applied web font
                var width = node.offsetWidth;

                node.style.fontFamily = font;

                var interval;
                function checkFont() {
                    // Compare current width with original width
                    if(node && node.offsetWidth != width) {
                        ++loadedFonts;
                        node.parentNode.removeChild(node);
                        node = null;
                    }

                    // If all fonts have been loaded
                    if(loadedFonts >= fonts.length) {
                        if(interval) {
                            clearInterval(interval);
                        }
                        if(loadedFonts == fonts.length) {
                            callback();
                            return true;
                        }
                    }
                };

                if(!checkFont()) {
                    interval = setInterval(checkFont, 50);
                }
            })(fonts[i]);
        }
    }
    window.waitForWebfonts = waitForWebfonts;
})();


;

/****************************************************
*  Filepath: /web_editor/static/lib/html2canvas.js  *
*  Lines: 7830                                      *
****************************************************/
/*!
 * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.html2canvas = factory());
}(this, (function () { 'use strict';

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
      return extendStatics(d, b);
  };

  function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var __assign = function() {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };

  function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  }

  function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
          }
      }
      return to.concat(ar || from);
  }

  var Bounds = /** @class */ (function () {
      function Bounds(left, top, width, height) {
          this.left = left;
          this.top = top;
          this.width = width;
          this.height = height;
      }
      Bounds.prototype.add = function (x, y, w, h) {
          return new Bounds(this.left + x, this.top + y, this.width + w, this.height + h);
      };
      Bounds.fromClientRect = function (context, clientRect) {
          return new Bounds(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
      };
      Bounds.fromDOMRectList = function (context, domRectList) {
          var domRect = Array.from(domRectList).find(function (rect) { return rect.width !== 0; });
          return domRect
              ? new Bounds(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height)
              : Bounds.EMPTY;
      };
      Bounds.EMPTY = new Bounds(0, 0, 0, 0);
      return Bounds;
  }());
  var parseBounds = function (context, node) {
      return Bounds.fromClientRect(context, node.getBoundingClientRect());
  };
  var parseDocumentSize = function (document) {
      var body = document.body;
      var documentElement = document.documentElement;
      if (!body || !documentElement) {
          throw new Error("Unable to get document size");
      }
      var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
      var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
      return new Bounds(0, 0, width, height);
  };

  /*
   * css-line-break 2.1.0 <https://github.com/niklasvh/css-line-break#readme>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var toCodePoints$1 = function (str) {
      var codePoints = [];
      var i = 0;
      var length = str.length;
      while (i < length) {
          var value = str.charCodeAt(i++);
          if (value >= 0xd800 && value <= 0xdbff && i < length) {
              var extra = str.charCodeAt(i++);
              if ((extra & 0xfc00) === 0xdc00) {
                  codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
              }
              else {
                  codePoints.push(value);
                  i--;
              }
          }
          else {
              codePoints.push(value);
          }
      }
      return codePoints;
  };
  var fromCodePoint$1 = function () {
      var codePoints = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          codePoints[_i] = arguments[_i];
      }
      if (String.fromCodePoint) {
          return String.fromCodePoint.apply(String, codePoints);
      }
      var length = codePoints.length;
      if (!length) {
          return '';
      }
      var codeUnits = [];
      var index = -1;
      var result = '';
      while (++index < length) {
          var codePoint = codePoints[index];
          if (codePoint <= 0xffff) {
              codeUnits.push(codePoint);
          }
          else {
              codePoint -= 0x10000;
              codeUnits.push((codePoint >> 10) + 0xd800, (codePoint % 0x400) + 0xdc00);
          }
          if (index + 1 === length || codeUnits.length > 0x4000) {
              result += String.fromCharCode.apply(String, codeUnits);
              codeUnits.length = 0;
          }
      }
      return result;
  };
  var chars$2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  // Use a lookup table to find the index.
  var lookup$2 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
      lookup$2[chars$2.charCodeAt(i$2)] = i$2;
  }

  /*
   * utrie 1.0.2 <https://github.com/niklasvh/utrie>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var chars$1$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  // Use a lookup table to find the index.
  var lookup$1$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
      lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
  }
  var decode$1 = function (base64) {
      var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base64[base64.length - 1] === '=') {
          bufferLength--;
          if (base64[base64.length - 2] === '=') {
              bufferLength--;
          }
      }
      var buffer = typeof ArrayBuffer !== 'undefined' &&
          typeof Uint8Array !== 'undefined' &&
          typeof Uint8Array.prototype.slice !== 'undefined'
          ? new ArrayBuffer(bufferLength)
          : new Array(bufferLength);
      var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
      for (i = 0; i < len; i += 4) {
          encoded1 = lookup$1$1[base64.charCodeAt(i)];
          encoded2 = lookup$1$1[base64.charCodeAt(i + 1)];
          encoded3 = lookup$1$1[base64.charCodeAt(i + 2)];
          encoded4 = lookup$1$1[base64.charCodeAt(i + 3)];
          bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
          bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
          bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
      }
      return buffer;
  };
  var polyUint16Array$1 = function (buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i = 0; i < length; i += 2) {
          bytes.push((buffer[i + 1] << 8) | buffer[i]);
      }
      return bytes;
  };
  var polyUint32Array$1 = function (buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i = 0; i < length; i += 4) {
          bytes.push((buffer[i + 3] << 24) | (buffer[i + 2] << 16) | (buffer[i + 1] << 8) | buffer[i]);
      }
      return bytes;
  };

  /** Shift size for getting the index-2 table offset. */
  var UTRIE2_SHIFT_2$1 = 5;
  /** Shift size for getting the index-1 table offset. */
  var UTRIE2_SHIFT_1$1 = 6 + 5;
  /**
   * Shift size for shifting left the index array values.
   * Increases possible data size with 16-bit index values at the cost
   * of compactability.
   * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
   */
  var UTRIE2_INDEX_SHIFT$1 = 2;
  /**
   * Difference between the two shift sizes,
   * for getting an index-1 offset from an index-2 offset. 6=11-5
   */
  var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
  /**
   * The part of the index-2 table for U+D800..U+DBFF stores values for
   * lead surrogate code _units_ not code _points_.
   * Values for lead surrogate code _points_ are indexed with this portion of the table.
   * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
   */
  var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 0x10000 >> UTRIE2_SHIFT_2$1;
  /** Number of entries in a data block. 32=0x20 */
  var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
  /** Mask for getting the lower bits for the in-data-block offset. */
  var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
  var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 0x400 >> UTRIE2_SHIFT_2$1;
  /** Count the lengths of both BMP pieces. 2080=0x820 */
  var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
  /**
   * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
   * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
   */
  var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
  var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */
  /**
   * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
   * Variable length, for code points up to highStart, where the last single-value range starts.
   * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
   * (For 0x100000 supplementary code points U+10000..U+10ffff.)
   *
   * The part of the index-2 table for supplementary code points starts
   * after this index-1 table.
   *
   * Both the index-1 table and the following part of the index-2 table
   * are omitted completely if there is only BMP data.
   */
  var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
  /**
   * Number of index-1 entries for the BMP. 32=0x20
   * This part of the index-1 table is omitted from the serialized form.
   */
  var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 0x10000 >> UTRIE2_SHIFT_1$1;
  /** Number of entries in an index-2 block. 64=0x40 */
  var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
  /** Mask for getting the lower bits for the in-index-2-block offset. */
  var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
  var slice16$1 = function (view, start, end) {
      if (view.slice) {
          return view.slice(start, end);
      }
      return new Uint16Array(Array.prototype.slice.call(view, start, end));
  };
  var slice32$1 = function (view, start, end) {
      if (view.slice) {
          return view.slice(start, end);
      }
      return new Uint32Array(Array.prototype.slice.call(view, start, end));
  };
  var createTrieFromBase64$1 = function (base64, _byteLength) {
      var buffer = decode$1(base64);
      var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
      var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
      var headerLength = 24;
      var index = slice16$1(view16, headerLength / 2, view32[4] / 2);
      var data = view32[5] === 2
          ? slice16$1(view16, (headerLength + view32[4]) / 2)
          : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
      return new Trie$1(view32[0], view32[1], view32[2], view32[3], index, data);
  };
  var Trie$1 = /** @class */ (function () {
      function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {
          this.initialValue = initialValue;
          this.errorValue = errorValue;
          this.highStart = highStart;
          this.highValueIndex = highValueIndex;
          this.index = index;
          this.data = data;
      }
      /**
       * Get the value for a code point as stored in the Trie.
       *
       * @param codePoint the code point
       * @return the value
       */
      Trie.prototype.get = function (codePoint) {
          var ix;
          if (codePoint >= 0) {
              if (codePoint < 0x0d800 || (codePoint > 0x0dbff && codePoint <= 0x0ffff)) {
                  // Ordinary BMP code point, excluding leading surrogates.
                  // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
                  // 16 bit data is stored in the index array itself.
                  ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
                  ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                  return this.data[ix];
              }
              if (codePoint <= 0xffff) {
                  // Lead Surrogate Code Point.  A Separate index section is stored for
                  // lead surrogate code units and code points.
                  //   The main index has the code unit data.
                  //   For this function, we need the code point data.
                  // Note: this expression could be refactored for slightly improved efficiency, but
                  //       surrogate code points will be so rare in practice that it's not worth it.
                  ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + ((codePoint - 0xd800) >> UTRIE2_SHIFT_2$1)];
                  ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                  return this.data[ix];
              }
              if (codePoint < this.highStart) {
                  // Supplemental code point, use two-level lookup.
                  ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
                  ix = this.index[ix];
                  ix += (codePoint >> UTRIE2_SHIFT_2$1) & UTRIE2_INDEX_2_MASK$1;
                  ix = this.index[ix];
                  ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
                  return this.data[ix];
              }
              if (codePoint <= 0x10ffff) {
                  return this.data[this.highValueIndex];
              }
          }
          // Fall through.  The code point is outside of the legal range of 0..0x10ffff.
          return this.errorValue;
      };
      return Trie;
  }());

  /*
   * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var chars$3 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  // Use a lookup table to find the index.
  var lookup$3 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
      lookup$3[chars$3.charCodeAt(i$3)] = i$3;
  }

  var base64$1 = 'KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==';

  var LETTER_NUMBER_MODIFIER = 50;
  // Non-tailorable Line Breaking Classes
  var BK = 1; //  Cause a line break (after)
  var CR$1 = 2; //  Cause a line break (after), except between CR and LF
  var LF$1 = 3; //  Cause a line break (after)
  var CM = 4; //  Prohibit a line break between the character and the preceding character
  var NL = 5; //  Cause a line break (after)
  var WJ = 7; //  Prohibit line breaks before and after
  var ZW = 8; //  Provide a break opportunity
  var GL = 9; //  Prohibit line breaks before and after
  var SP = 10; // Enable indirect line breaks
  var ZWJ$1 = 11; // Prohibit line breaks within joiner sequences
  // Break Opportunities
  var B2 = 12; //  Provide a line break opportunity before and after the character
  var BA = 13; //  Generally provide a line break opportunity after the character
  var BB = 14; //  Generally provide a line break opportunity before the character
  var HY = 15; //  Provide a line break opportunity after the character, except in numeric context
  var CB = 16; //   Provide a line break opportunity contingent on additional information
  // Characters Prohibiting Certain Breaks
  var CL = 17; //  Prohibit line breaks before
  var CP = 18; //  Prohibit line breaks before
  var EX = 19; //  Prohibit line breaks before
  var IN = 20; //  Allow only indirect line breaks between pairs
  var NS = 21; //  Allow only indirect line breaks before
  var OP = 22; //  Prohibit line breaks after
  var QU = 23; //  Act like they are both opening and closing
  // Numeric Context
  var IS = 24; //  Prevent breaks after any and before numeric
  var NU = 25; //  Form numeric expressions for line breaking purposes
  var PO = 26; //  Do not break following a numeric expression
  var PR = 27; //  Do not break in front of a numeric expression
  var SY = 28; //  Prevent a break before; and allow a break after
  // Other Characters
  var AI = 29; //  Act like AL when the resolvedEAW is N; otherwise; act as ID
  var AL = 30; //  Are alphabetic characters or symbols that are used with alphabetic characters
  var CJ = 31; //  Treat as NS or ID for strict or normal breaking.
  var EB = 32; //  Do not break from following Emoji Modifier
  var EM = 33; //  Do not break from preceding Emoji Base
  var H2 = 34; //  Form Korean syllable blocks
  var H3 = 35; //  Form Korean syllable blocks
  var HL = 36; //  Do not break around a following hyphen; otherwise act as Alphabetic
  var ID = 37; //  Break before or after; except in some numeric context
  var JL = 38; //  Form Korean syllable blocks
  var JV = 39; //  Form Korean syllable blocks
  var JT = 40; //  Form Korean syllable blocks
  var RI$1 = 41; //  Keep pairs together. For pairs; break before and after other classes
  var SA = 42; //  Provide a line break opportunity contingent on additional, language-specific context analysis
  var XX = 43; //  Have as yet unknown line breaking behavior or unassigned code positions
  var ea_OP = [0x2329, 0xff08];
  var BREAK_MANDATORY = '!';
  var BREAK_NOT_ALLOWED$1 = '×';
  var BREAK_ALLOWED$1 = '÷';
  var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
  var ALPHABETICS = [AL, HL];
  var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
  var SPACE$1 = [SP, ZW];
  var PREFIX_POSTFIX = [PR, PO];
  var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
  var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
  var HYPHEN = [HY, BA];
  var codePointsToCharacterClasses = function (codePoints, lineBreak) {
      if (lineBreak === void 0) { lineBreak = 'strict'; }
      var types = [];
      var indices = [];
      var categories = [];
      codePoints.forEach(function (codePoint, index) {
          var classType = UnicodeTrie$1.get(codePoint);
          if (classType > LETTER_NUMBER_MODIFIER) {
              categories.push(true);
              classType -= LETTER_NUMBER_MODIFIER;
          }
          else {
              categories.push(false);
          }
          if (['normal', 'auto', 'loose'].indexOf(lineBreak) !== -1) {
              // U+2010, – U+2013, 〜 U+301C, ゠ U+30A0
              if ([0x2010, 0x2013, 0x301c, 0x30a0].indexOf(codePoint) !== -1) {
                  indices.push(index);
                  return types.push(CB);
              }
          }
          if (classType === CM || classType === ZWJ$1) {
              // LB10 Treat any remaining combining mark or ZWJ as AL.
              if (index === 0) {
                  indices.push(index);
                  return types.push(AL);
              }
              // LB9 Do not break a combining character sequence; treat it as if it has the line breaking class of
              // the base character in all of the following rules. Treat ZWJ as if it were CM.
              var prev = types[index - 1];
              if (LINE_BREAKS.indexOf(prev) === -1) {
                  indices.push(indices[index - 1]);
                  return types.push(prev);
              }
              indices.push(index);
              return types.push(AL);
          }
          indices.push(index);
          if (classType === CJ) {
              return types.push(lineBreak === 'strict' ? NS : ID);
          }
          if (classType === SA) {
              return types.push(AL);
          }
          if (classType === AI) {
              return types.push(AL);
          }
          // For supplementary characters, a useful default is to treat characters in the range 10000..1FFFD as AL
          // and characters in the ranges 20000..2FFFD and 30000..3FFFD as ID, until the implementation can be revised
          // to take into account the actual line breaking properties for these characters.
          if (classType === XX) {
              if ((codePoint >= 0x20000 && codePoint <= 0x2fffd) || (codePoint >= 0x30000 && codePoint <= 0x3fffd)) {
                  return types.push(ID);
              }
              else {
                  return types.push(AL);
              }
          }
          types.push(classType);
      });
      return [indices, types, categories];
  };
  var isAdjacentWithSpaceIgnored = function (a, b, currentIndex, classTypes) {
      var current = classTypes[currentIndex];
      if (Array.isArray(a) ? a.indexOf(current) !== -1 : a === current) {
          var i = currentIndex;
          while (i <= classTypes.length) {
              i++;
              var next = classTypes[i];
              if (next === b) {
                  return true;
              }
              if (next !== SP) {
                  break;
              }
          }
      }
      if (current === SP) {
          var i = currentIndex;
          while (i > 0) {
              i--;
              var prev = classTypes[i];
              if (Array.isArray(a) ? a.indexOf(prev) !== -1 : a === prev) {
                  var n = currentIndex;
                  while (n <= classTypes.length) {
                      n++;
                      var next = classTypes[n];
                      if (next === b) {
                          return true;
                      }
                      if (next !== SP) {
                          break;
                      }
                  }
              }
              if (prev !== SP) {
                  break;
              }
          }
      }
      return false;
  };
  var previousNonSpaceClassType = function (currentIndex, classTypes) {
      var i = currentIndex;
      while (i >= 0) {
          var type = classTypes[i];
          if (type === SP) {
              i--;
          }
          else {
              return type;
          }
      }
      return 0;
  };
  var _lineBreakAtIndex = function (codePoints, classTypes, indicies, index, forbiddenBreaks) {
      if (indicies[index] === 0) {
          return BREAK_NOT_ALLOWED$1;
      }
      var currentIndex = index - 1;
      if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
          return BREAK_NOT_ALLOWED$1;
      }
      var beforeIndex = currentIndex - 1;
      var afterIndex = currentIndex + 1;
      var current = classTypes[currentIndex];
      // LB4 Always break after hard line breaks.
      // LB5 Treat CR followed by LF, as well as CR, LF, and NL as hard line breaks.
      var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
      var next = classTypes[afterIndex];
      if (current === CR$1 && next === LF$1) {
          return BREAK_NOT_ALLOWED$1;
      }
      if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
          return BREAK_MANDATORY;
      }
      // LB6 Do not break before hard line breaks.
      if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB7 Do not break before spaces or zero width space.
      if (SPACE$1.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB8 Break before any character following a zero-width space, even if one or more spaces intervene.
      if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
          return BREAK_ALLOWED$1;
      }
      // LB8a Do not break after a zero width joiner.
      if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // zwj emojis
      if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB11 Do not break before or after Word joiner and related characters.
      if (current === WJ || next === WJ) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB12 Do not break after NBSP and related characters.
      if (current === GL) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB12a Do not break before NBSP and related characters, except after spaces and hyphens.
      if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB13 Do not break before ‘]’ or ‘!’ or ‘;’ or ‘/’, even after spaces.
      if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB14 Do not break after ‘[’, even after spaces.
      if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB15 Do not break within ‘”[’, even with intervening spaces.
      if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB16 Do not break between closing punctuation and a nonstarter (lb=NS), even with intervening spaces.
      if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB17 Do not break within ‘——’, even with intervening spaces.
      if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB18 Break after spaces.
      if (current === SP) {
          return BREAK_ALLOWED$1;
      }
      // LB19 Do not break before or after quotation marks, such as ‘ ” ’.
      if (current === QU || next === QU) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB20 Break before and after unresolved CB.
      if (next === CB || current === CB) {
          return BREAK_ALLOWED$1;
      }
      // LB21 Do not break before hyphen-minus, other hyphens, fixed-width spaces, small kana, and other non-starters, or after acute accents.
      if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB21a Don't break after Hebrew + Hyphen.
      if (before === HL && HYPHEN.indexOf(current) !== -1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB21b Don’t break between Solidus and Hebrew letters.
      if (current === SY && next === HL) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB22 Do not break before ellipsis.
      if (next === IN) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB23 Do not break between digits and letters.
      if ((ALPHABETICS.indexOf(next) !== -1 && current === NU) || (ALPHABETICS.indexOf(current) !== -1 && next === NU)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB23a Do not break between numeric prefixes and ideographs, or between ideographs and numeric postfixes.
      if ((current === PR && [ID, EB, EM].indexOf(next) !== -1) ||
          ([ID, EB, EM].indexOf(current) !== -1 && next === PO)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB24 Do not break between numeric prefix/postfix and letters, or between letters and prefix/postfix.
      if ((ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1) ||
          (PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB25 Do not break between the following pairs of classes relevant to numbers:
      if (
      // (PR | PO) × ( OP | HY )? NU
      ([PR, PO].indexOf(current) !== -1 &&
          (next === NU || ([OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU))) ||
          // ( OP | HY ) × NU
          ([OP, HY].indexOf(current) !== -1 && next === NU) ||
          // NU ×	(NU | SY | IS)
          (current === NU && [NU, SY, IS].indexOf(next) !== -1)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // NU (NU | SY | IS)* × (NU | SY | IS | CL | CP)
      if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
          var prevIndex = currentIndex;
          while (prevIndex >= 0) {
              var type = classTypes[prevIndex];
              if (type === NU) {
                  return BREAK_NOT_ALLOWED$1;
              }
              else if ([SY, IS].indexOf(type) !== -1) {
                  prevIndex--;
              }
              else {
                  break;
              }
          }
      }
      // NU (NU | SY | IS)* (CL | CP)? × (PO | PR))
      if ([PR, PO].indexOf(next) !== -1) {
          var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
          while (prevIndex >= 0) {
              var type = classTypes[prevIndex];
              if (type === NU) {
                  return BREAK_NOT_ALLOWED$1;
              }
              else if ([SY, IS].indexOf(type) !== -1) {
                  prevIndex--;
              }
              else {
                  break;
              }
          }
      }
      // LB26 Do not break a Korean syllable.
      if ((JL === current && [JL, JV, H2, H3].indexOf(next) !== -1) ||
          ([JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1) ||
          ([JT, H3].indexOf(current) !== -1 && next === JT)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB27 Treat a Korean Syllable Block the same as ID.
      if ((KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1) ||
          (KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB28 Do not break between alphabetics (“at”).
      if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB29 Do not break between numeric punctuation and alphabetics (“e.g.”).
      if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB30 Do not break between letters, numbers, or ordinary symbols and opening or closing parentheses.
      if ((ALPHABETICS.concat(NU).indexOf(current) !== -1 &&
          next === OP &&
          ea_OP.indexOf(codePoints[afterIndex]) === -1) ||
          (ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP)) {
          return BREAK_NOT_ALLOWED$1;
      }
      // LB30a Break between two regional indicator symbols if and only if there are an even number of regional
      // indicators preceding the position of the break.
      if (current === RI$1 && next === RI$1) {
          var i = indicies[currentIndex];
          var count = 1;
          while (i > 0) {
              i--;
              if (classTypes[i] === RI$1) {
                  count++;
              }
              else {
                  break;
              }
          }
          if (count % 2 !== 0) {
              return BREAK_NOT_ALLOWED$1;
          }
      }
      // LB30b Do not break between an emoji base and an emoji modifier.
      if (current === EB && next === EM) {
          return BREAK_NOT_ALLOWED$1;
      }
      return BREAK_ALLOWED$1;
  };
  var cssFormattedClasses = function (codePoints, options) {
      if (!options) {
          options = { lineBreak: 'normal', wordBreak: 'normal' };
      }
      var _a = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a[0], classTypes = _a[1], isLetterNumber = _a[2];
      if (options.wordBreak === 'break-all' || options.wordBreak === 'break-word') {
          classTypes = classTypes.map(function (type) { return ([NU, AL, SA].indexOf(type) !== -1 ? ID : type); });
      }
      var forbiddenBreakpoints = options.wordBreak === 'keep-all'
          ? isLetterNumber.map(function (letterNumber, i) {
              return letterNumber && codePoints[i] >= 0x4e00 && codePoints[i] <= 0x9fff;
          })
          : undefined;
      return [indicies, classTypes, forbiddenBreakpoints];
  };
  var Break = /** @class */ (function () {
      function Break(codePoints, lineBreak, start, end) {
          this.codePoints = codePoints;
          this.required = lineBreak === BREAK_MANDATORY;
          this.start = start;
          this.end = end;
      }
      Break.prototype.slice = function () {
          return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
      };
      return Break;
  }());
  var LineBreaker = function (str, options) {
      var codePoints = toCodePoints$1(str);
      var _a = cssFormattedClasses(codePoints, options), indicies = _a[0], classTypes = _a[1], forbiddenBreakpoints = _a[2];
      var length = codePoints.length;
      var lastEnd = 0;
      var nextIndex = 0;
      return {
          next: function () {
              if (nextIndex >= length) {
                  return { done: true, value: null };
              }
              var lineBreak = BREAK_NOT_ALLOWED$1;
              while (nextIndex < length &&
                  (lineBreak = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) ===
                      BREAK_NOT_ALLOWED$1) { }
              if (lineBreak !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
                  var value = new Break(codePoints, lineBreak, lastEnd, nextIndex);
                  lastEnd = nextIndex;
                  return { value: value, done: false };
              }
              return { done: true, value: null };
          },
      };
  };

  // https://www.w3.org/TR/css-syntax-3
  var FLAG_UNRESTRICTED = 1 << 0;
  var FLAG_ID = 1 << 1;
  var FLAG_INTEGER = 1 << 2;
  var FLAG_NUMBER = 1 << 3;
  var LINE_FEED = 0x000a;
  var SOLIDUS = 0x002f;
  var REVERSE_SOLIDUS = 0x005c;
  var CHARACTER_TABULATION = 0x0009;
  var SPACE = 0x0020;
  var QUOTATION_MARK = 0x0022;
  var EQUALS_SIGN = 0x003d;
  var NUMBER_SIGN = 0x0023;
  var DOLLAR_SIGN = 0x0024;
  var PERCENTAGE_SIGN = 0x0025;
  var APOSTROPHE = 0x0027;
  var LEFT_PARENTHESIS = 0x0028;
  var RIGHT_PARENTHESIS = 0x0029;
  var LOW_LINE = 0x005f;
  var HYPHEN_MINUS = 0x002d;
  var EXCLAMATION_MARK = 0x0021;
  var LESS_THAN_SIGN = 0x003c;
  var GREATER_THAN_SIGN = 0x003e;
  var COMMERCIAL_AT = 0x0040;
  var LEFT_SQUARE_BRACKET = 0x005b;
  var RIGHT_SQUARE_BRACKET = 0x005d;
  var CIRCUMFLEX_ACCENT = 0x003d;
  var LEFT_CURLY_BRACKET = 0x007b;
  var QUESTION_MARK = 0x003f;
  var RIGHT_CURLY_BRACKET = 0x007d;
  var VERTICAL_LINE = 0x007c;
  var TILDE = 0x007e;
  var CONTROL = 0x0080;
  var REPLACEMENT_CHARACTER = 0xfffd;
  var ASTERISK = 0x002a;
  var PLUS_SIGN = 0x002b;
  var COMMA = 0x002c;
  var COLON = 0x003a;
  var SEMICOLON = 0x003b;
  var FULL_STOP = 0x002e;
  var NULL = 0x0000;
  var BACKSPACE = 0x0008;
  var LINE_TABULATION = 0x000b;
  var SHIFT_OUT = 0x000e;
  var INFORMATION_SEPARATOR_ONE = 0x001f;
  var DELETE = 0x007f;
  var EOF = -1;
  var ZERO = 0x0030;
  var a = 0x0061;
  var e = 0x0065;
  var f = 0x0066;
  var u = 0x0075;
  var z = 0x007a;
  var A = 0x0041;
  var E = 0x0045;
  var F = 0x0046;
  var U = 0x0055;
  var Z = 0x005a;
  var isDigit = function (codePoint) { return codePoint >= ZERO && codePoint <= 0x0039; };
  var isSurrogateCodePoint = function (codePoint) { return codePoint >= 0xd800 && codePoint <= 0xdfff; };
  var isHex = function (codePoint) {
      return isDigit(codePoint) || (codePoint >= A && codePoint <= F) || (codePoint >= a && codePoint <= f);
  };
  var isLowerCaseLetter = function (codePoint) { return codePoint >= a && codePoint <= z; };
  var isUpperCaseLetter = function (codePoint) { return codePoint >= A && codePoint <= Z; };
  var isLetter = function (codePoint) { return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint); };
  var isNonASCIICodePoint = function (codePoint) { return codePoint >= CONTROL; };
  var isWhiteSpace = function (codePoint) {
      return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
  };
  var isNameStartCodePoint = function (codePoint) {
      return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
  };
  var isNameCodePoint = function (codePoint) {
      return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
  };
  var isNonPrintableCodePoint = function (codePoint) {
      return ((codePoint >= NULL && codePoint <= BACKSPACE) ||
          codePoint === LINE_TABULATION ||
          (codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE) ||
          codePoint === DELETE);
  };
  var isValidEscape = function (c1, c2) {
      if (c1 !== REVERSE_SOLIDUS) {
          return false;
      }
      return c2 !== LINE_FEED;
  };
  var isIdentifierStart = function (c1, c2, c3) {
      if (c1 === HYPHEN_MINUS) {
          return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
      }
      else if (isNameStartCodePoint(c1)) {
          return true;
      }
      else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
          return true;
      }
      return false;
  };
  var isNumberStart = function (c1, c2, c3) {
      if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
          if (isDigit(c2)) {
              return true;
          }
          return c2 === FULL_STOP && isDigit(c3);
      }
      if (c1 === FULL_STOP) {
          return isDigit(c2);
      }
      return isDigit(c1);
  };
  var stringToNumber = function (codePoints) {
      var c = 0;
      var sign = 1;
      if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
          if (codePoints[c] === HYPHEN_MINUS) {
              sign = -1;
          }
          c++;
      }
      var integers = [];
      while (isDigit(codePoints[c])) {
          integers.push(codePoints[c++]);
      }
      var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
      if (codePoints[c] === FULL_STOP) {
          c++;
      }
      var fraction = [];
      while (isDigit(codePoints[c])) {
          fraction.push(codePoints[c++]);
      }
      var fracd = fraction.length;
      var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
      if (codePoints[c] === E || codePoints[c] === e) {
          c++;
      }
      var expsign = 1;
      if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
          if (codePoints[c] === HYPHEN_MINUS) {
              expsign = -1;
          }
          c++;
      }
      var exponent = [];
      while (isDigit(codePoints[c])) {
          exponent.push(codePoints[c++]);
      }
      var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
      return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
  };
  var LEFT_PARENTHESIS_TOKEN = {
      type: 2 /* LEFT_PARENTHESIS_TOKEN */
  };
  var RIGHT_PARENTHESIS_TOKEN = {
      type: 3 /* RIGHT_PARENTHESIS_TOKEN */
  };
  var COMMA_TOKEN = { type: 4 /* COMMA_TOKEN */ };
  var SUFFIX_MATCH_TOKEN = { type: 13 /* SUFFIX_MATCH_TOKEN */ };
  var PREFIX_MATCH_TOKEN = { type: 8 /* PREFIX_MATCH_TOKEN */ };
  var COLUMN_TOKEN = { type: 21 /* COLUMN_TOKEN */ };
  var DASH_MATCH_TOKEN = { type: 9 /* DASH_MATCH_TOKEN */ };
  var INCLUDE_MATCH_TOKEN = { type: 10 /* INCLUDE_MATCH_TOKEN */ };
  var LEFT_CURLY_BRACKET_TOKEN = {
      type: 11 /* LEFT_CURLY_BRACKET_TOKEN */
  };
  var RIGHT_CURLY_BRACKET_TOKEN = {
      type: 12 /* RIGHT_CURLY_BRACKET_TOKEN */
  };
  var SUBSTRING_MATCH_TOKEN = { type: 14 /* SUBSTRING_MATCH_TOKEN */ };
  var BAD_URL_TOKEN = { type: 23 /* BAD_URL_TOKEN */ };
  var BAD_STRING_TOKEN = { type: 1 /* BAD_STRING_TOKEN */ };
  var CDO_TOKEN = { type: 25 /* CDO_TOKEN */ };
  var CDC_TOKEN = { type: 24 /* CDC_TOKEN */ };
  var COLON_TOKEN = { type: 26 /* COLON_TOKEN */ };
  var SEMICOLON_TOKEN = { type: 27 /* SEMICOLON_TOKEN */ };
  var LEFT_SQUARE_BRACKET_TOKEN = {
      type: 28 /* LEFT_SQUARE_BRACKET_TOKEN */
  };
  var RIGHT_SQUARE_BRACKET_TOKEN = {
      type: 29 /* RIGHT_SQUARE_BRACKET_TOKEN */
  };
  var WHITESPACE_TOKEN = { type: 31 /* WHITESPACE_TOKEN */ };
  var EOF_TOKEN = { type: 32 /* EOF_TOKEN */ };
  var Tokenizer = /** @class */ (function () {
      function Tokenizer() {
          this._value = [];
      }
      Tokenizer.prototype.write = function (chunk) {
          this._value = this._value.concat(toCodePoints$1(chunk));
      };
      Tokenizer.prototype.read = function () {
          var tokens = [];
          var token = this.consumeToken();
          while (token !== EOF_TOKEN) {
              tokens.push(token);
              token = this.consumeToken();
          }
          return tokens;
      };
      Tokenizer.prototype.consumeToken = function () {
          var codePoint = this.consumeCodePoint();
          switch (codePoint) {
              case QUOTATION_MARK:
                  return this.consumeStringToken(QUOTATION_MARK);
              case NUMBER_SIGN:
                  var c1 = this.peekCodePoint(0);
                  var c2 = this.peekCodePoint(1);
                  var c3 = this.peekCodePoint(2);
                  if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
                      var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
                      var value = this.consumeName();
                      return { type: 5 /* HASH_TOKEN */, value: value, flags: flags };
                  }
                  break;
              case DOLLAR_SIGN:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                      this.consumeCodePoint();
                      return SUFFIX_MATCH_TOKEN;
                  }
                  break;
              case APOSTROPHE:
                  return this.consumeStringToken(APOSTROPHE);
              case LEFT_PARENTHESIS:
                  return LEFT_PARENTHESIS_TOKEN;
              case RIGHT_PARENTHESIS:
                  return RIGHT_PARENTHESIS_TOKEN;
              case ASTERISK:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                      this.consumeCodePoint();
                      return SUBSTRING_MATCH_TOKEN;
                  }
                  break;
              case PLUS_SIGN:
                  if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                      this.reconsumeCodePoint(codePoint);
                      return this.consumeNumericToken();
                  }
                  break;
              case COMMA:
                  return COMMA_TOKEN;
              case HYPHEN_MINUS:
                  var e1 = codePoint;
                  var e2 = this.peekCodePoint(0);
                  var e3 = this.peekCodePoint(1);
                  if (isNumberStart(e1, e2, e3)) {
                      this.reconsumeCodePoint(codePoint);
                      return this.consumeNumericToken();
                  }
                  if (isIdentifierStart(e1, e2, e3)) {
                      this.reconsumeCodePoint(codePoint);
                      return this.consumeIdentLikeToken();
                  }
                  if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
                      this.consumeCodePoint();
                      this.consumeCodePoint();
                      return CDC_TOKEN;
                  }
                  break;
              case FULL_STOP:
                  if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                      this.reconsumeCodePoint(codePoint);
                      return this.consumeNumericToken();
                  }
                  break;
              case SOLIDUS:
                  if (this.peekCodePoint(0) === ASTERISK) {
                      this.consumeCodePoint();
                      while (true) {
                          var c = this.consumeCodePoint();
                          if (c === ASTERISK) {
                              c = this.consumeCodePoint();
                              if (c === SOLIDUS) {
                                  return this.consumeToken();
                              }
                          }
                          if (c === EOF) {
                              return this.consumeToken();
                          }
                      }
                  }
                  break;
              case COLON:
                  return COLON_TOKEN;
              case SEMICOLON:
                  return SEMICOLON_TOKEN;
              case LESS_THAN_SIGN:
                  if (this.peekCodePoint(0) === EXCLAMATION_MARK &&
                      this.peekCodePoint(1) === HYPHEN_MINUS &&
                      this.peekCodePoint(2) === HYPHEN_MINUS) {
                      this.consumeCodePoint();
                      this.consumeCodePoint();
                      return CDO_TOKEN;
                  }
                  break;
              case COMMERCIAL_AT:
                  var a1 = this.peekCodePoint(0);
                  var a2 = this.peekCodePoint(1);
                  var a3 = this.peekCodePoint(2);
                  if (isIdentifierStart(a1, a2, a3)) {
                      var value = this.consumeName();
                      return { type: 7 /* AT_KEYWORD_TOKEN */, value: value };
                  }
                  break;
              case LEFT_SQUARE_BRACKET:
                  return LEFT_SQUARE_BRACKET_TOKEN;
              case REVERSE_SOLIDUS:
                  if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                      this.reconsumeCodePoint(codePoint);
                      return this.consumeIdentLikeToken();
                  }
                  break;
              case RIGHT_SQUARE_BRACKET:
                  return RIGHT_SQUARE_BRACKET_TOKEN;
              case CIRCUMFLEX_ACCENT:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                      this.consumeCodePoint();
                      return PREFIX_MATCH_TOKEN;
                  }
                  break;
              case LEFT_CURLY_BRACKET:
                  return LEFT_CURLY_BRACKET_TOKEN;
              case RIGHT_CURLY_BRACKET:
                  return RIGHT_CURLY_BRACKET_TOKEN;
              case u:
              case U:
                  var u1 = this.peekCodePoint(0);
                  var u2 = this.peekCodePoint(1);
                  if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
                      this.consumeCodePoint();
                      this.consumeUnicodeRangeToken();
                  }
                  this.reconsumeCodePoint(codePoint);
                  return this.consumeIdentLikeToken();
              case VERTICAL_LINE:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                      this.consumeCodePoint();
                      return DASH_MATCH_TOKEN;
                  }
                  if (this.peekCodePoint(0) === VERTICAL_LINE) {
                      this.consumeCodePoint();
                      return COLUMN_TOKEN;
                  }
                  break;
              case TILDE:
                  if (this.peekCodePoint(0) === EQUALS_SIGN) {
                      this.consumeCodePoint();
                      return INCLUDE_MATCH_TOKEN;
                  }
                  break;
              case EOF:
                  return EOF_TOKEN;
          }
          if (isWhiteSpace(codePoint)) {
              this.consumeWhiteSpace();
              return WHITESPACE_TOKEN;
          }
          if (isDigit(codePoint)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeNumericToken();
          }
          if (isNameStartCodePoint(codePoint)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeIdentLikeToken();
          }
          return { type: 6 /* DELIM_TOKEN */, value: fromCodePoint$1(codePoint) };
      };
      Tokenizer.prototype.consumeCodePoint = function () {
          var value = this._value.shift();
          return typeof value === 'undefined' ? -1 : value;
      };
      Tokenizer.prototype.reconsumeCodePoint = function (codePoint) {
          this._value.unshift(codePoint);
      };
      Tokenizer.prototype.peekCodePoint = function (delta) {
          if (delta >= this._value.length) {
              return -1;
          }
          return this._value[delta];
      };
      Tokenizer.prototype.consumeUnicodeRangeToken = function () {
          var digits = [];
          var codePoint = this.consumeCodePoint();
          while (isHex(codePoint) && digits.length < 6) {
              digits.push(codePoint);
              codePoint = this.consumeCodePoint();
          }
          var questionMarks = false;
          while (codePoint === QUESTION_MARK && digits.length < 6) {
              digits.push(codePoint);
              codePoint = this.consumeCodePoint();
              questionMarks = true;
          }
          if (questionMarks) {
              var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function (digit) { return (digit === QUESTION_MARK ? ZERO : digit); })), 16);
              var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function (digit) { return (digit === QUESTION_MARK ? F : digit); })), 16);
              return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start_1, end: end };
          }
          var start = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
          if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
              this.consumeCodePoint();
              codePoint = this.consumeCodePoint();
              var endDigits = [];
              while (isHex(codePoint) && endDigits.length < 6) {
                  endDigits.push(codePoint);
                  codePoint = this.consumeCodePoint();
              }
              var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
              return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start, end: end };
          }
          else {
              return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start, end: start };
          }
      };
      Tokenizer.prototype.consumeIdentLikeToken = function () {
          var value = this.consumeName();
          if (value.toLowerCase() === 'url' && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
              this.consumeCodePoint();
              return this.consumeUrlToken();
          }
          else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
              this.consumeCodePoint();
              return { type: 19 /* FUNCTION_TOKEN */, value: value };
          }
          return { type: 20 /* IDENT_TOKEN */, value: value };
      };
      Tokenizer.prototype.consumeUrlToken = function () {
          var value = [];
          this.consumeWhiteSpace();
          if (this.peekCodePoint(0) === EOF) {
              return { type: 22 /* URL_TOKEN */, value: '' };
          }
          var next = this.peekCodePoint(0);
          if (next === APOSTROPHE || next === QUOTATION_MARK) {
              var stringToken = this.consumeStringToken(this.consumeCodePoint());
              if (stringToken.type === 0 /* STRING_TOKEN */) {
                  this.consumeWhiteSpace();
                  if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                      this.consumeCodePoint();
                      return { type: 22 /* URL_TOKEN */, value: stringToken.value };
                  }
              }
              this.consumeBadUrlRemnants();
              return BAD_URL_TOKEN;
          }
          while (true) {
              var codePoint = this.consumeCodePoint();
              if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
                  return { type: 22 /* URL_TOKEN */, value: fromCodePoint$1.apply(void 0, value) };
              }
              else if (isWhiteSpace(codePoint)) {
                  this.consumeWhiteSpace();
                  if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                      this.consumeCodePoint();
                      return { type: 22 /* URL_TOKEN */, value: fromCodePoint$1.apply(void 0, value) };
                  }
                  this.consumeBadUrlRemnants();
                  return BAD_URL_TOKEN;
              }
              else if (codePoint === QUOTATION_MARK ||
                  codePoint === APOSTROPHE ||
                  codePoint === LEFT_PARENTHESIS ||
                  isNonPrintableCodePoint(codePoint)) {
                  this.consumeBadUrlRemnants();
                  return BAD_URL_TOKEN;
              }
              else if (codePoint === REVERSE_SOLIDUS) {
                  if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                      value.push(this.consumeEscapedCodePoint());
                  }
                  else {
                      this.consumeBadUrlRemnants();
                      return BAD_URL_TOKEN;
                  }
              }
              else {
                  value.push(codePoint);
              }
          }
      };
      Tokenizer.prototype.consumeWhiteSpace = function () {
          while (isWhiteSpace(this.peekCodePoint(0))) {
              this.consumeCodePoint();
          }
      };
      Tokenizer.prototype.consumeBadUrlRemnants = function () {
          while (true) {
              var codePoint = this.consumeCodePoint();
              if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
                  return;
              }
              if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  this.consumeEscapedCodePoint();
              }
          }
      };
      Tokenizer.prototype.consumeStringSlice = function (count) {
          var SLICE_STACK_SIZE = 50000;
          var value = '';
          while (count > 0) {
              var amount = Math.min(SLICE_STACK_SIZE, count);
              value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
              count -= amount;
          }
          this._value.shift();
          return value;
      };
      Tokenizer.prototype.consumeStringToken = function (endingCodePoint) {
          var value = '';
          var i = 0;
          do {
              var codePoint = this._value[i];
              if (codePoint === EOF || codePoint === undefined || codePoint === endingCodePoint) {
                  value += this.consumeStringSlice(i);
                  return { type: 0 /* STRING_TOKEN */, value: value };
              }
              if (codePoint === LINE_FEED) {
                  this._value.splice(0, i);
                  return BAD_STRING_TOKEN;
              }
              if (codePoint === REVERSE_SOLIDUS) {
                  var next = this._value[i + 1];
                  if (next !== EOF && next !== undefined) {
                      if (next === LINE_FEED) {
                          value += this.consumeStringSlice(i);
                          i = -1;
                          this._value.shift();
                      }
                      else if (isValidEscape(codePoint, next)) {
                          value += this.consumeStringSlice(i);
                          value += fromCodePoint$1(this.consumeEscapedCodePoint());
                          i = -1;
                      }
                  }
              }
              i++;
          } while (true);
      };
      Tokenizer.prototype.consumeNumber = function () {
          var repr = [];
          var type = FLAG_INTEGER;
          var c1 = this.peekCodePoint(0);
          if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
              repr.push(this.consumeCodePoint());
          }
          while (isDigit(this.peekCodePoint(0))) {
              repr.push(this.consumeCodePoint());
          }
          c1 = this.peekCodePoint(0);
          var c2 = this.peekCodePoint(1);
          if (c1 === FULL_STOP && isDigit(c2)) {
              repr.push(this.consumeCodePoint(), this.consumeCodePoint());
              type = FLAG_NUMBER;
              while (isDigit(this.peekCodePoint(0))) {
                  repr.push(this.consumeCodePoint());
              }
          }
          c1 = this.peekCodePoint(0);
          c2 = this.peekCodePoint(1);
          var c3 = this.peekCodePoint(2);
          if ((c1 === E || c1 === e) && (((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3)) || isDigit(c2))) {
              repr.push(this.consumeCodePoint(), this.consumeCodePoint());
              type = FLAG_NUMBER;
              while (isDigit(this.peekCodePoint(0))) {
                  repr.push(this.consumeCodePoint());
              }
          }
          return [stringToNumber(repr), type];
      };
      Tokenizer.prototype.consumeNumericToken = function () {
          var _a = this.consumeNumber(), number = _a[0], flags = _a[1];
          var c1 = this.peekCodePoint(0);
          var c2 = this.peekCodePoint(1);
          var c3 = this.peekCodePoint(2);
          if (isIdentifierStart(c1, c2, c3)) {
              var unit = this.consumeName();
              return { type: 15 /* DIMENSION_TOKEN */, number: number, flags: flags, unit: unit };
          }
          if (c1 === PERCENTAGE_SIGN) {
              this.consumeCodePoint();
              return { type: 16 /* PERCENTAGE_TOKEN */, number: number, flags: flags };
          }
          return { type: 17 /* NUMBER_TOKEN */, number: number, flags: flags };
      };
      Tokenizer.prototype.consumeEscapedCodePoint = function () {
          var codePoint = this.consumeCodePoint();
          if (isHex(codePoint)) {
              var hex = fromCodePoint$1(codePoint);
              while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
                  hex += fromCodePoint$1(this.consumeCodePoint());
              }
              if (isWhiteSpace(this.peekCodePoint(0))) {
                  this.consumeCodePoint();
              }
              var hexCodePoint = parseInt(hex, 16);
              if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 0x10ffff) {
                  return REPLACEMENT_CHARACTER;
              }
              return hexCodePoint;
          }
          if (codePoint === EOF) {
              return REPLACEMENT_CHARACTER;
          }
          return codePoint;
      };
      Tokenizer.prototype.consumeName = function () {
          var result = '';
          while (true) {
              var codePoint = this.consumeCodePoint();
              if (isNameCodePoint(codePoint)) {
                  result += fromCodePoint$1(codePoint);
              }
              else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                  result += fromCodePoint$1(this.consumeEscapedCodePoint());
              }
              else {
                  this.reconsumeCodePoint(codePoint);
                  return result;
              }
          }
      };
      return Tokenizer;
  }());

  var Parser = /** @class */ (function () {
      function Parser(tokens) {
          this._tokens = tokens;
      }
      Parser.create = function (value) {
          var tokenizer = new Tokenizer();
          tokenizer.write(value);
          return new Parser(tokenizer.read());
      };
      Parser.parseValue = function (value) {
          return Parser.create(value).parseComponentValue();
      };
      Parser.parseValues = function (value) {
          return Parser.create(value).parseComponentValues();
      };
      Parser.prototype.parseComponentValue = function () {
          var token = this.consumeToken();
          while (token.type === 31 /* WHITESPACE_TOKEN */) {
              token = this.consumeToken();
          }
          if (token.type === 32 /* EOF_TOKEN */) {
              throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
          }
          this.reconsumeToken(token);
          var value = this.consumeComponentValue();
          do {
              token = this.consumeToken();
          } while (token.type === 31 /* WHITESPACE_TOKEN */);
          if (token.type === 32 /* EOF_TOKEN */) {
              return value;
          }
          throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
      };
      Parser.prototype.parseComponentValues = function () {
          var values = [];
          while (true) {
              var value = this.consumeComponentValue();
              if (value.type === 32 /* EOF_TOKEN */) {
                  return values;
              }
              values.push(value);
              values.push();
          }
      };
      Parser.prototype.consumeComponentValue = function () {
          var token = this.consumeToken();
          switch (token.type) {
              case 11 /* LEFT_CURLY_BRACKET_TOKEN */:
              case 28 /* LEFT_SQUARE_BRACKET_TOKEN */:
              case 2 /* LEFT_PARENTHESIS_TOKEN */:
                  return this.consumeSimpleBlock(token.type);
              case 19 /* FUNCTION_TOKEN */:
                  return this.consumeFunction(token);
          }
          return token;
      };
      Parser.prototype.consumeSimpleBlock = function (type) {
          var block = { type: type, values: [] };
          var token = this.consumeToken();
          while (true) {
              if (token.type === 32 /* EOF_TOKEN */ || isEndingTokenFor(token, type)) {
                  return block;
              }
              this.reconsumeToken(token);
              block.values.push(this.consumeComponentValue());
              token = this.consumeToken();
          }
      };
      Parser.prototype.consumeFunction = function (functionToken) {
          var cssFunction = {
              name: functionToken.value,
              values: [],
              type: 18 /* FUNCTION */
          };
          while (true) {
              var token = this.consumeToken();
              if (token.type === 32 /* EOF_TOKEN */ || token.type === 3 /* RIGHT_PARENTHESIS_TOKEN */) {
                  return cssFunction;
              }
              this.reconsumeToken(token);
              cssFunction.values.push(this.consumeComponentValue());
          }
      };
      Parser.prototype.consumeToken = function () {
          var token = this._tokens.shift();
          return typeof token === 'undefined' ? EOF_TOKEN : token;
      };
      Parser.prototype.reconsumeToken = function (token) {
          this._tokens.unshift(token);
      };
      return Parser;
  }());
  var isDimensionToken = function (token) { return token.type === 15 /* DIMENSION_TOKEN */; };
  var isNumberToken = function (token) { return token.type === 17 /* NUMBER_TOKEN */; };
  var isIdentToken = function (token) { return token.type === 20 /* IDENT_TOKEN */; };
  var isStringToken = function (token) { return token.type === 0 /* STRING_TOKEN */; };
  var isIdentWithValue = function (token, value) {
      return isIdentToken(token) && token.value === value;
  };
  var nonWhiteSpace = function (token) { return token.type !== 31 /* WHITESPACE_TOKEN */; };
  var nonFunctionArgSeparator = function (token) {
      return token.type !== 31 /* WHITESPACE_TOKEN */ && token.type !== 4 /* COMMA_TOKEN */;
  };
  var parseFunctionArgs = function (tokens) {
      var args = [];
      var arg = [];
      tokens.forEach(function (token) {
          if (token.type === 4 /* COMMA_TOKEN */) {
              if (arg.length === 0) {
                  throw new Error("Error parsing function args, zero tokens for arg");
              }
              args.push(arg);
              arg = [];
              return;
          }
          if (token.type !== 31 /* WHITESPACE_TOKEN */) {
              arg.push(token);
          }
      });
      if (arg.length) {
          args.push(arg);
      }
      return args;
  };
  var isEndingTokenFor = function (token, type) {
      if (type === 11 /* LEFT_CURLY_BRACKET_TOKEN */ && token.type === 12 /* RIGHT_CURLY_BRACKET_TOKEN */) {
          return true;
      }
      if (type === 28 /* LEFT_SQUARE_BRACKET_TOKEN */ && token.type === 29 /* RIGHT_SQUARE_BRACKET_TOKEN */) {
          return true;
      }
      return type === 2 /* LEFT_PARENTHESIS_TOKEN */ && token.type === 3 /* RIGHT_PARENTHESIS_TOKEN */;
  };

  var isLength = function (token) {
      return token.type === 17 /* NUMBER_TOKEN */ || token.type === 15 /* DIMENSION_TOKEN */;
  };

  var isLengthPercentage = function (token) {
      return token.type === 16 /* PERCENTAGE_TOKEN */ || isLength(token);
  };
  var parseLengthPercentageTuple = function (tokens) {
      return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
  };
  var ZERO_LENGTH = {
      type: 17 /* NUMBER_TOKEN */,
      number: 0,
      flags: FLAG_INTEGER
  };
  var FIFTY_PERCENT = {
      type: 16 /* PERCENTAGE_TOKEN */,
      number: 50,
      flags: FLAG_INTEGER
  };
  var HUNDRED_PERCENT = {
      type: 16 /* PERCENTAGE_TOKEN */,
      number: 100,
      flags: FLAG_INTEGER
  };
  var getAbsoluteValueForTuple = function (tuple, width, height) {
      var x = tuple[0], y = tuple[1];
      return [getAbsoluteValue(x, width), getAbsoluteValue(typeof y !== 'undefined' ? y : x, height)];
  };
  var getAbsoluteValue = function (token, parent) {
      if (token.type === 16 /* PERCENTAGE_TOKEN */) {
          return (token.number / 100) * parent;
      }
      if (isDimensionToken(token)) {
          switch (token.unit) {
              case 'rem':
              case 'em':
                  return 16 * token.number; // TODO use correct font-size
              case 'px':
              default:
                  return token.number;
          }
      }
      return token.number;
  };

  var DEG = 'deg';
  var GRAD = 'grad';
  var RAD = 'rad';
  var TURN = 'turn';
  var angle = {
      name: 'angle',
      parse: function (_context, value) {
          if (value.type === 15 /* DIMENSION_TOKEN */) {
              switch (value.unit) {
                  case DEG:
                      return (Math.PI * value.number) / 180;
                  case GRAD:
                      return (Math.PI / 200) * value.number;
                  case RAD:
                      return value.number;
                  case TURN:
                      return Math.PI * 2 * value.number;
              }
          }
          throw new Error("Unsupported angle type");
      }
  };
  var isAngle = function (value) {
      if (value.type === 15 /* DIMENSION_TOKEN */) {
          if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
              return true;
          }
      }
      return false;
  };
  var parseNamedSide = function (tokens) {
      var sideOrCorner = tokens
          .filter(isIdentToken)
          .map(function (ident) { return ident.value; })
          .join(' ');
      switch (sideOrCorner) {
          case 'to bottom right':
          case 'to right bottom':
          case 'left top':
          case 'top left':
              return [ZERO_LENGTH, ZERO_LENGTH];
          case 'to top':
          case 'bottom':
              return deg(0);
          case 'to bottom left':
          case 'to left bottom':
          case 'right top':
          case 'top right':
              return [ZERO_LENGTH, HUNDRED_PERCENT];
          case 'to right':
          case 'left':
              return deg(90);
          case 'to top left':
          case 'to left top':
          case 'right bottom':
          case 'bottom right':
              return [HUNDRED_PERCENT, HUNDRED_PERCENT];
          case 'to bottom':
          case 'top':
              return deg(180);
          case 'to top right':
          case 'to right top':
          case 'left bottom':
          case 'bottom left':
              return [HUNDRED_PERCENT, ZERO_LENGTH];
          case 'to left':
          case 'right':
              return deg(270);
      }
      return 0;
  };
  var deg = function (deg) { return (Math.PI * deg) / 180; };

  var color$1 = {
      name: 'color',
      parse: function (context, value) {
          if (value.type === 18 /* FUNCTION */) {
              var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
              if (typeof colorFunction === 'undefined') {
                  throw new Error("Attempting to parse an unsupported color function \"" + value.name + "\"");
              }
              return colorFunction(context, value.values);
          }
          if (value.type === 5 /* HASH_TOKEN */) {
              if (value.value.length === 3) {
                  var r = value.value.substring(0, 1);
                  var g = value.value.substring(1, 2);
                  var b = value.value.substring(2, 3);
                  return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);
              }
              if (value.value.length === 4) {
                  var r = value.value.substring(0, 1);
                  var g = value.value.substring(1, 2);
                  var b = value.value.substring(2, 3);
                  var a = value.value.substring(3, 4);
                  return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a + a, 16) / 255);
              }
              if (value.value.length === 6) {
                  var r = value.value.substring(0, 2);
                  var g = value.value.substring(2, 4);
                  var b = value.value.substring(4, 6);
                  return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);
              }
              if (value.value.length === 8) {
                  var r = value.value.substring(0, 2);
                  var g = value.value.substring(2, 4);
                  var b = value.value.substring(4, 6);
                  var a = value.value.substring(6, 8);
                  return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a, 16) / 255);
              }
          }
          if (value.type === 20 /* IDENT_TOKEN */) {
              var namedColor = COLORS[value.value.toUpperCase()];
              if (typeof namedColor !== 'undefined') {
                  return namedColor;
              }
          }
          return COLORS.TRANSPARENT;
      }
  };
  var isTransparent = function (color) { return (0xff & color) === 0; };
  var asString = function (color) {
      var alpha = 0xff & color;
      var blue = 0xff & (color >> 8);
      var green = 0xff & (color >> 16);
      var red = 0xff & (color >> 24);
      return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
  };
  var pack = function (r, g, b, a) {
      return ((r << 24) | (g << 16) | (b << 8) | (Math.round(a * 255) << 0)) >>> 0;
  };
  var getTokenColorValue = function (token, i) {
      if (token.type === 17 /* NUMBER_TOKEN */) {
          return token.number;
      }
      if (token.type === 16 /* PERCENTAGE_TOKEN */) {
          var max = i === 3 ? 1 : 255;
          return i === 3 ? (token.number / 100) * max : Math.round((token.number / 100) * max);
      }
      return 0;
  };
  var rgb = function (_context, args) {
      var tokens = args.filter(nonFunctionArgSeparator);
      if (tokens.length === 3) {
          var _a = tokens.map(getTokenColorValue), r = _a[0], g = _a[1], b = _a[2];
          return pack(r, g, b, 1);
      }
      if (tokens.length === 4) {
          var _b = tokens.map(getTokenColorValue), r = _b[0], g = _b[1], b = _b[2], a = _b[3];
          return pack(r, g, b, a);
      }
      return 0;
  };
  function hue2rgb(t1, t2, hue) {
      if (hue < 0) {
          hue += 1;
      }
      if (hue >= 1) {
          hue -= 1;
      }
      if (hue < 1 / 6) {
          return (t2 - t1) * hue * 6 + t1;
      }
      else if (hue < 1 / 2) {
          return t2;
      }
      else if (hue < 2 / 3) {
          return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
      }
      else {
          return t1;
      }
  }
  var hsl = function (context, args) {
      var tokens = args.filter(nonFunctionArgSeparator);
      var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
      var h = (hue.type === 17 /* NUMBER_TOKEN */ ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
      var s = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
      var l = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
      var a = typeof alpha !== 'undefined' && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
      if (s === 0) {
          return pack(l * 255, l * 255, l * 255, 1);
      }
      var t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
      var t1 = l * 2 - t2;
      var r = hue2rgb(t1, t2, h + 1 / 3);
      var g = hue2rgb(t1, t2, h);
      var b = hue2rgb(t1, t2, h - 1 / 3);
      return pack(r * 255, g * 255, b * 255, a);
  };
  var SUPPORTED_COLOR_FUNCTIONS = {
      hsl: hsl,
      hsla: hsl,
      rgb: rgb,
      rgba: rgb
  };
  var parseColor = function (context, value) {
      return color$1.parse(context, Parser.create(value).parseComponentValue());
  };
  var COLORS = {
      ALICEBLUE: 0xf0f8ffff,
      ANTIQUEWHITE: 0xfaebd7ff,
      AQUA: 0x00ffffff,
      AQUAMARINE: 0x7fffd4ff,
      AZURE: 0xf0ffffff,
      BEIGE: 0xf5f5dcff,
      BISQUE: 0xffe4c4ff,
      BLACK: 0x000000ff,
      BLANCHEDALMOND: 0xffebcdff,
      BLUE: 0x0000ffff,
      BLUEVIOLET: 0x8a2be2ff,
      BROWN: 0xa52a2aff,
      BURLYWOOD: 0xdeb887ff,
      CADETBLUE: 0x5f9ea0ff,
      CHARTREUSE: 0x7fff00ff,
      CHOCOLATE: 0xd2691eff,
      CORAL: 0xff7f50ff,
      CORNFLOWERBLUE: 0x6495edff,
      CORNSILK: 0xfff8dcff,
      CRIMSON: 0xdc143cff,
      CYAN: 0x00ffffff,
      DARKBLUE: 0x00008bff,
      DARKCYAN: 0x008b8bff,
      DARKGOLDENROD: 0xb886bbff,
      DARKGRAY: 0xa9a9a9ff,
      DARKGREEN: 0x006400ff,
      DARKGREY: 0xa9a9a9ff,
      DARKKHAKI: 0xbdb76bff,
      DARKMAGENTA: 0x8b008bff,
      DARKOLIVEGREEN: 0x556b2fff,
      DARKORANGE: 0xff8c00ff,
      DARKORCHID: 0x9932ccff,
      DARKRED: 0x8b0000ff,
      DARKSALMON: 0xe9967aff,
      DARKSEAGREEN: 0x8fbc8fff,
      DARKSLATEBLUE: 0x483d8bff,
      DARKSLATEGRAY: 0x2f4f4fff,
      DARKSLATEGREY: 0x2f4f4fff,
      DARKTURQUOISE: 0x00ced1ff,
      DARKVIOLET: 0x9400d3ff,
      DEEPPINK: 0xff1493ff,
      DEEPSKYBLUE: 0x00bfffff,
      DIMGRAY: 0x696969ff,
      DIMGREY: 0x696969ff,
      DODGERBLUE: 0x1e90ffff,
      FIREBRICK: 0xb22222ff,
      FLORALWHITE: 0xfffaf0ff,
      FORESTGREEN: 0x228b22ff,
      FUCHSIA: 0xff00ffff,
      GAINSBORO: 0xdcdcdcff,
      GHOSTWHITE: 0xf8f8ffff,
      GOLD: 0xffd700ff,
      GOLDENROD: 0xdaa520ff,
      GRAY: 0x808080ff,
      GREEN: 0x008000ff,
      GREENYELLOW: 0xadff2fff,
      GREY: 0x808080ff,
      HONEYDEW: 0xf0fff0ff,
      HOTPINK: 0xff69b4ff,
      INDIANRED: 0xcd5c5cff,
      INDIGO: 0x4b0082ff,
      IVORY: 0xfffff0ff,
      KHAKI: 0xf0e68cff,
      LAVENDER: 0xe6e6faff,
      LAVENDERBLUSH: 0xfff0f5ff,
      LAWNGREEN: 0x7cfc00ff,
      LEMONCHIFFON: 0xfffacdff,
      LIGHTBLUE: 0xadd8e6ff,
      LIGHTCORAL: 0xf08080ff,
      LIGHTCYAN: 0xe0ffffff,
      LIGHTGOLDENRODYELLOW: 0xfafad2ff,
      LIGHTGRAY: 0xd3d3d3ff,
      LIGHTGREEN: 0x90ee90ff,
      LIGHTGREY: 0xd3d3d3ff,
      LIGHTPINK: 0xffb6c1ff,
      LIGHTSALMON: 0xffa07aff,
      LIGHTSEAGREEN: 0x20b2aaff,
      LIGHTSKYBLUE: 0x87cefaff,
      LIGHTSLATEGRAY: 0x778899ff,
      LIGHTSLATEGREY: 0x778899ff,
      LIGHTSTEELBLUE: 0xb0c4deff,
      LIGHTYELLOW: 0xffffe0ff,
      LIME: 0x00ff00ff,
      LIMEGREEN: 0x32cd32ff,
      LINEN: 0xfaf0e6ff,
      MAGENTA: 0xff00ffff,
      MAROON: 0x800000ff,
      MEDIUMAQUAMARINE: 0x66cdaaff,
      MEDIUMBLUE: 0x0000cdff,
      MEDIUMORCHID: 0xba55d3ff,
      MEDIUMPURPLE: 0x9370dbff,
      MEDIUMSEAGREEN: 0x3cb371ff,
      MEDIUMSLATEBLUE: 0x7b68eeff,
      MEDIUMSPRINGGREEN: 0x00fa9aff,
      MEDIUMTURQUOISE: 0x48d1ccff,
      MEDIUMVIOLETRED: 0xc71585ff,
      MIDNIGHTBLUE: 0x191970ff,
      MINTCREAM: 0xf5fffaff,
      MISTYROSE: 0xffe4e1ff,
      MOCCASIN: 0xffe4b5ff,
      NAVAJOWHITE: 0xffdeadff,
      NAVY: 0x000080ff,
      OLDLACE: 0xfdf5e6ff,
      OLIVE: 0x808000ff,
      OLIVEDRAB: 0x6b8e23ff,
      ORANGE: 0xffa500ff,
      ORANGERED: 0xff4500ff,
      ORCHID: 0xda70d6ff,
      PALEGOLDENROD: 0xeee8aaff,
      PALEGREEN: 0x98fb98ff,
      PALETURQUOISE: 0xafeeeeff,
      PALEVIOLETRED: 0xdb7093ff,
      PAPAYAWHIP: 0xffefd5ff,
      PEACHPUFF: 0xffdab9ff,
      PERU: 0xcd853fff,
      PINK: 0xffc0cbff,
      PLUM: 0xdda0ddff,
      POWDERBLUE: 0xb0e0e6ff,
      PURPLE: 0x800080ff,
      REBECCAPURPLE: 0x663399ff,
      RED: 0xff0000ff,
      ROSYBROWN: 0xbc8f8fff,
      ROYALBLUE: 0x4169e1ff,
      SADDLEBROWN: 0x8b4513ff,
      SALMON: 0xfa8072ff,
      SANDYBROWN: 0xf4a460ff,
      SEAGREEN: 0x2e8b57ff,
      SEASHELL: 0xfff5eeff,
      SIENNA: 0xa0522dff,
      SILVER: 0xc0c0c0ff,
      SKYBLUE: 0x87ceebff,
      SLATEBLUE: 0x6a5acdff,
      SLATEGRAY: 0x708090ff,
      SLATEGREY: 0x708090ff,
      SNOW: 0xfffafaff,
      SPRINGGREEN: 0x00ff7fff,
      STEELBLUE: 0x4682b4ff,
      TAN: 0xd2b48cff,
      TEAL: 0x008080ff,
      THISTLE: 0xd8bfd8ff,
      TOMATO: 0xff6347ff,
      TRANSPARENT: 0x00000000,
      TURQUOISE: 0x40e0d0ff,
      VIOLET: 0xee82eeff,
      WHEAT: 0xf5deb3ff,
      WHITE: 0xffffffff,
      WHITESMOKE: 0xf5f5f5ff,
      YELLOW: 0xffff00ff,
      YELLOWGREEN: 0x9acd32ff
  };

  var backgroundClip = {
      name: 'background-clip',
      initialValue: 'border-box',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return tokens.map(function (token) {
              if (isIdentToken(token)) {
                  switch (token.value) {
                      case 'padding-box':
                          return 1 /* PADDING_BOX */;
                      case 'content-box':
                          return 2 /* CONTENT_BOX */;
                  }
              }
              return 0 /* BORDER_BOX */;
          });
      }
  };

  var backgroundColor = {
      name: "background-color",
      initialValue: 'transparent',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'color'
  };

  var parseColorStop = function (context, args) {
      var color = color$1.parse(context, args[0]);
      var stop = args[1];
      return stop && isLengthPercentage(stop) ? { color: color, stop: stop } : { color: color, stop: null };
  };
  var processColorStops = function (stops, lineLength) {
      var first = stops[0];
      var last = stops[stops.length - 1];
      if (first.stop === null) {
          first.stop = ZERO_LENGTH;
      }
      if (last.stop === null) {
          last.stop = HUNDRED_PERCENT;
      }
      var processStops = [];
      var previous = 0;
      for (var i = 0; i < stops.length; i++) {
          var stop_1 = stops[i].stop;
          if (stop_1 !== null) {
              var absoluteValue = getAbsoluteValue(stop_1, lineLength);
              if (absoluteValue > previous) {
                  processStops.push(absoluteValue);
              }
              else {
                  processStops.push(previous);
              }
              previous = absoluteValue;
          }
          else {
              processStops.push(null);
          }
      }
      var gapBegin = null;
      for (var i = 0; i < processStops.length; i++) {
          var stop_2 = processStops[i];
          if (stop_2 === null) {
              if (gapBegin === null) {
                  gapBegin = i;
              }
          }
          else if (gapBegin !== null) {
              var gapLength = i - gapBegin;
              var beforeGap = processStops[gapBegin - 1];
              var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
              for (var g = 1; g <= gapLength; g++) {
                  processStops[gapBegin + g - 1] = gapValue * g;
              }
              gapBegin = null;
          }
      }
      return stops.map(function (_a, i) {
          var color = _a.color;
          return { color: color, stop: Math.max(Math.min(1, processStops[i] / lineLength), 0) };
      });
  };
  var getAngleFromCorner = function (corner, width, height) {
      var centerX = width / 2;
      var centerY = height / 2;
      var x = getAbsoluteValue(corner[0], width) - centerX;
      var y = centerY - getAbsoluteValue(corner[1], height);
      return (Math.atan2(y, x) + Math.PI * 2) % (Math.PI * 2);
  };
  var calculateGradientDirection = function (angle, width, height) {
      var radian = typeof angle === 'number' ? angle : getAngleFromCorner(angle, width, height);
      var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
      var halfWidth = width / 2;
      var halfHeight = height / 2;
      var halfLineLength = lineLength / 2;
      var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
      var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
      return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
  };
  var distance = function (a, b) { return Math.sqrt(a * a + b * b); };
  var findCorner = function (width, height, x, y, closest) {
      var corners = [
          [0, 0],
          [0, height],
          [width, 0],
          [width, height]
      ];
      return corners.reduce(function (stat, corner) {
          var cx = corner[0], cy = corner[1];
          var d = distance(x - cx, y - cy);
          if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {
              return {
                  optimumCorner: corner,
                  optimumDistance: d
              };
          }
          return stat;
      }, {
          optimumDistance: closest ? Infinity : -Infinity,
          optimumCorner: null
      }).optimumCorner;
  };
  var calculateRadius = function (gradient, x, y, width, height) {
      var rx = 0;
      var ry = 0;
      switch (gradient.size) {
          case 0 /* CLOSEST_SIDE */:
              // The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradient’s center.
              // If the shape is an ellipse, it exactly meets the closest side in each dimension.
              if (gradient.shape === 0 /* CIRCLE */) {
                  rx = ry = Math.min(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
              }
              else if (gradient.shape === 1 /* ELLIPSE */) {
                  rx = Math.min(Math.abs(x), Math.abs(x - width));
                  ry = Math.min(Math.abs(y), Math.abs(y - height));
              }
              break;
          case 2 /* CLOSEST_CORNER */:
              // The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradient’s center.
              // If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.
              if (gradient.shape === 0 /* CIRCLE */) {
                  rx = ry = Math.min(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
              }
              else if (gradient.shape === 1 /* ELLIPSE */) {
                  // Compute the ratio ry/rx (which is to be the same as for "closest-side")
                  var c = Math.min(Math.abs(y), Math.abs(y - height)) / Math.min(Math.abs(x), Math.abs(x - width));
                  var _a = findCorner(width, height, x, y, true), cx = _a[0], cy = _a[1];
                  rx = distance(cx - x, (cy - y) / c);
                  ry = c * rx;
              }
              break;
          case 1 /* FARTHEST_SIDE */:
              // Same as closest-side, except the ending shape is sized based on the farthest side(s)
              if (gradient.shape === 0 /* CIRCLE */) {
                  rx = ry = Math.max(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
              }
              else if (gradient.shape === 1 /* ELLIPSE */) {
                  rx = Math.max(Math.abs(x), Math.abs(x - width));
                  ry = Math.max(Math.abs(y), Math.abs(y - height));
              }
              break;
          case 3 /* FARTHEST_CORNER */:
              // Same as closest-corner, except the ending shape is sized based on the farthest corner.
              // If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.
              if (gradient.shape === 0 /* CIRCLE */) {
                  rx = ry = Math.max(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
              }
              else if (gradient.shape === 1 /* ELLIPSE */) {
                  // Compute the ratio ry/rx (which is to be the same as for "farthest-side")
                  var c = Math.max(Math.abs(y), Math.abs(y - height)) / Math.max(Math.abs(x), Math.abs(x - width));
                  var _b = findCorner(width, height, x, y, false), cx = _b[0], cy = _b[1];
                  rx = distance(cx - x, (cy - y) / c);
                  ry = c * rx;
              }
              break;
      }
      if (Array.isArray(gradient.size)) {
          rx = getAbsoluteValue(gradient.size[0], width);
          ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
      }
      return [rx, ry];
  };

  var linearGradient = function (context, tokens) {
      var angle$1 = deg(180);
      var stops = [];
      parseFunctionArgs(tokens).forEach(function (arg, i) {
          if (i === 0) {
              var firstToken = arg[0];
              if (firstToken.type === 20 /* IDENT_TOKEN */ && firstToken.value === 'to') {
                  angle$1 = parseNamedSide(arg);
                  return;
              }
              else if (isAngle(firstToken)) {
                  angle$1 = angle.parse(context, firstToken);
                  return;
              }
          }
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
      });
      return { angle: angle$1, stops: stops, type: 1 /* LINEAR_GRADIENT */ };
  };

  var prefixLinearGradient = function (context, tokens) {
      var angle$1 = deg(180);
      var stops = [];
      parseFunctionArgs(tokens).forEach(function (arg, i) {
          if (i === 0) {
              var firstToken = arg[0];
              if (firstToken.type === 20 /* IDENT_TOKEN */ &&
                  ['top', 'left', 'right', 'bottom'].indexOf(firstToken.value) !== -1) {
                  angle$1 = parseNamedSide(arg);
                  return;
              }
              else if (isAngle(firstToken)) {
                  angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
                  return;
              }
          }
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
      });
      return {
          angle: angle$1,
          stops: stops,
          type: 1 /* LINEAR_GRADIENT */
      };
  };

  var webkitGradient = function (context, tokens) {
      var angle = deg(180);
      var stops = [];
      var type = 1 /* LINEAR_GRADIENT */;
      var shape = 0 /* CIRCLE */;
      var size = 3 /* FARTHEST_CORNER */;
      var position = [];
      parseFunctionArgs(tokens).forEach(function (arg, i) {
          var firstToken = arg[0];
          if (i === 0) {
              if (isIdentToken(firstToken) && firstToken.value === 'linear') {
                  type = 1 /* LINEAR_GRADIENT */;
                  return;
              }
              else if (isIdentToken(firstToken) && firstToken.value === 'radial') {
                  type = 2 /* RADIAL_GRADIENT */;
                  return;
              }
          }
          if (firstToken.type === 18 /* FUNCTION */) {
              if (firstToken.name === 'from') {
                  var color = color$1.parse(context, firstToken.values[0]);
                  stops.push({ stop: ZERO_LENGTH, color: color });
              }
              else if (firstToken.name === 'to') {
                  var color = color$1.parse(context, firstToken.values[0]);
                  stops.push({ stop: HUNDRED_PERCENT, color: color });
              }
              else if (firstToken.name === 'color-stop') {
                  var values = firstToken.values.filter(nonFunctionArgSeparator);
                  if (values.length === 2) {
                      var color = color$1.parse(context, values[1]);
                      var stop_1 = values[0];
                      if (isNumberToken(stop_1)) {
                          stops.push({
                              stop: { type: 16 /* PERCENTAGE_TOKEN */, number: stop_1.number * 100, flags: stop_1.flags },
                              color: color
                          });
                      }
                  }
              }
          }
      });
      return type === 1 /* LINEAR_GRADIENT */
          ? {
              angle: (angle + deg(180)) % deg(360),
              stops: stops,
              type: type
          }
          : { size: size, shape: shape, stops: stops, position: position, type: type };
  };

  var CLOSEST_SIDE = 'closest-side';
  var FARTHEST_SIDE = 'farthest-side';
  var CLOSEST_CORNER = 'closest-corner';
  var FARTHEST_CORNER = 'farthest-corner';
  var CIRCLE = 'circle';
  var ELLIPSE = 'ellipse';
  var COVER = 'cover';
  var CONTAIN = 'contain';
  var radialGradient = function (context, tokens) {
      var shape = 0 /* CIRCLE */;
      var size = 3 /* FARTHEST_CORNER */;
      var stops = [];
      var position = [];
      parseFunctionArgs(tokens).forEach(function (arg, i) {
          var isColorStop = true;
          if (i === 0) {
              var isAtPosition_1 = false;
              isColorStop = arg.reduce(function (acc, token) {
                  if (isAtPosition_1) {
                      if (isIdentToken(token)) {
                          switch (token.value) {
                              case 'center':
                                  position.push(FIFTY_PERCENT);
                                  return acc;
                              case 'top':
                              case 'left':
                                  position.push(ZERO_LENGTH);
                                  return acc;
                              case 'right':
                              case 'bottom':
                                  position.push(HUNDRED_PERCENT);
                                  return acc;
                          }
                      }
                      else if (isLengthPercentage(token) || isLength(token)) {
                          position.push(token);
                      }
                  }
                  else if (isIdentToken(token)) {
                      switch (token.value) {
                          case CIRCLE:
                              shape = 0 /* CIRCLE */;
                              return false;
                          case ELLIPSE:
                              shape = 1 /* ELLIPSE */;
                              return false;
                          case 'at':
                              isAtPosition_1 = true;
                              return false;
                          case CLOSEST_SIDE:
                              size = 0 /* CLOSEST_SIDE */;
                              return false;
                          case COVER:
                          case FARTHEST_SIDE:
                              size = 1 /* FARTHEST_SIDE */;
                              return false;
                          case CONTAIN:
                          case CLOSEST_CORNER:
                              size = 2 /* CLOSEST_CORNER */;
                              return false;
                          case FARTHEST_CORNER:
                              size = 3 /* FARTHEST_CORNER */;
                              return false;
                      }
                  }
                  else if (isLength(token) || isLengthPercentage(token)) {
                      if (!Array.isArray(size)) {
                          size = [];
                      }
                      size.push(token);
                      return false;
                  }
                  return acc;
              }, isColorStop);
          }
          if (isColorStop) {
              var colorStop = parseColorStop(context, arg);
              stops.push(colorStop);
          }
      });
      return { size: size, shape: shape, stops: stops, position: position, type: 2 /* RADIAL_GRADIENT */ };
  };

  var prefixRadialGradient = function (context, tokens) {
      var shape = 0 /* CIRCLE */;
      var size = 3 /* FARTHEST_CORNER */;
      var stops = [];
      var position = [];
      parseFunctionArgs(tokens).forEach(function (arg, i) {
          var isColorStop = true;
          if (i === 0) {
              isColorStop = arg.reduce(function (acc, token) {
                  if (isIdentToken(token)) {
                      switch (token.value) {
                          case 'center':
                              position.push(FIFTY_PERCENT);
                              return false;
                          case 'top':
                          case 'left':
                              position.push(ZERO_LENGTH);
                              return false;
                          case 'right':
                          case 'bottom':
                              position.push(HUNDRED_PERCENT);
                              return false;
                      }
                  }
                  else if (isLengthPercentage(token) || isLength(token)) {
                      position.push(token);
                      return false;
                  }
                  return acc;
              }, isColorStop);
          }
          else if (i === 1) {
              isColorStop = arg.reduce(function (acc, token) {
                  if (isIdentToken(token)) {
                      switch (token.value) {
                          case CIRCLE:
                              shape = 0 /* CIRCLE */;
                              return false;
                          case ELLIPSE:
                              shape = 1 /* ELLIPSE */;
                              return false;
                          case CONTAIN:
                          case CLOSEST_SIDE:
                              size = 0 /* CLOSEST_SIDE */;
                              return false;
                          case FARTHEST_SIDE:
                              size = 1 /* FARTHEST_SIDE */;
                              return false;
                          case CLOSEST_CORNER:
                              size = 2 /* CLOSEST_CORNER */;
                              return false;
                          case COVER:
                          case FARTHEST_CORNER:
                              size = 3 /* FARTHEST_CORNER */;
                              return false;
                      }
                  }
                  else if (isLength(token) || isLengthPercentage(token)) {
                      if (!Array.isArray(size)) {
                          size = [];
                      }
                      size.push(token);
                      return false;
                  }
                  return acc;
              }, isColorStop);
          }
          if (isColorStop) {
              var colorStop = parseColorStop(context, arg);
              stops.push(colorStop);
          }
      });
      return { size: size, shape: shape, stops: stops, position: position, type: 2 /* RADIAL_GRADIENT */ };
  };

  var isLinearGradient = function (background) {
      return background.type === 1 /* LINEAR_GRADIENT */;
  };
  var isRadialGradient = function (background) {
      return background.type === 2 /* RADIAL_GRADIENT */;
  };
  var image = {
      name: 'image',
      parse: function (context, value) {
          if (value.type === 22 /* URL_TOKEN */) {
              var image_1 = { url: value.value, type: 0 /* URL */ };
              context.cache.addImage(value.value);
              return image_1;
          }
          if (value.type === 18 /* FUNCTION */) {
              var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
              if (typeof imageFunction === 'undefined') {
                  throw new Error("Attempting to parse an unsupported image function \"" + value.name + "\"");
              }
              return imageFunction(context, value.values);
          }
          throw new Error("Unsupported image type " + value.type);
      }
  };
  function isSupportedImage(value) {
      return (!(value.type === 20 /* IDENT_TOKEN */ && value.value === 'none') &&
          (value.type !== 18 /* FUNCTION */ || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]));
  }
  var SUPPORTED_IMAGE_FUNCTIONS = {
      'linear-gradient': linearGradient,
      '-moz-linear-gradient': prefixLinearGradient,
      '-ms-linear-gradient': prefixLinearGradient,
      '-o-linear-gradient': prefixLinearGradient,
      '-webkit-linear-gradient': prefixLinearGradient,
      'radial-gradient': radialGradient,
      '-moz-radial-gradient': prefixRadialGradient,
      '-ms-radial-gradient': prefixRadialGradient,
      '-o-radial-gradient': prefixRadialGradient,
      '-webkit-radial-gradient': prefixRadialGradient,
      '-webkit-gradient': webkitGradient
  };

  var backgroundImage = {
      name: 'background-image',
      initialValue: 'none',
      type: 1 /* LIST */,
      prefix: false,
      parse: function (context, tokens) {
          if (tokens.length === 0) {
              return [];
          }
          var first = tokens[0];
          if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
              return [];
          }
          return tokens
              .filter(function (value) { return nonFunctionArgSeparator(value) && isSupportedImage(value); })
              .map(function (value) { return image.parse(context, value); });
      }
  };

  var backgroundOrigin = {
      name: 'background-origin',
      initialValue: 'border-box',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return tokens.map(function (token) {
              if (isIdentToken(token)) {
                  switch (token.value) {
                      case 'padding-box':
                          return 1 /* PADDING_BOX */;
                      case 'content-box':
                          return 2 /* CONTENT_BOX */;
                  }
              }
              return 0 /* BORDER_BOX */;
          });
      }
  };

  var backgroundPosition = {
      name: 'background-position',
      initialValue: '0% 0%',
      type: 1 /* LIST */,
      prefix: false,
      parse: function (_context, tokens) {
          return parseFunctionArgs(tokens)
              .map(function (values) { return values.filter(isLengthPercentage); })
              .map(parseLengthPercentageTuple);
      }
  };

  var backgroundRepeat = {
      name: 'background-repeat',
      initialValue: 'repeat',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return parseFunctionArgs(tokens)
              .map(function (values) {
              return values
                  .filter(isIdentToken)
                  .map(function (token) { return token.value; })
                  .join(' ');
          })
              .map(parseBackgroundRepeat);
      }
  };
  var parseBackgroundRepeat = function (value) {
      switch (value) {
          case 'no-repeat':
              return 1 /* NO_REPEAT */;
          case 'repeat-x':
          case 'repeat no-repeat':
              return 2 /* REPEAT_X */;
          case 'repeat-y':
          case 'no-repeat repeat':
              return 3 /* REPEAT_Y */;
          case 'repeat':
          default:
              return 0 /* REPEAT */;
      }
  };

  var BACKGROUND_SIZE;
  (function (BACKGROUND_SIZE) {
      BACKGROUND_SIZE["AUTO"] = "auto";
      BACKGROUND_SIZE["CONTAIN"] = "contain";
      BACKGROUND_SIZE["COVER"] = "cover";
  })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
  var backgroundSize = {
      name: 'background-size',
      initialValue: '0',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return parseFunctionArgs(tokens).map(function (values) { return values.filter(isBackgroundSizeInfoToken); });
      }
  };
  var isBackgroundSizeInfoToken = function (value) {
      return isIdentToken(value) || isLengthPercentage(value);
  };

  var borderColorForSide = function (side) { return ({
      name: "border-" + side + "-color",
      initialValue: 'transparent',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'color'
  }); };
  var borderTopColor = borderColorForSide('top');
  var borderRightColor = borderColorForSide('right');
  var borderBottomColor = borderColorForSide('bottom');
  var borderLeftColor = borderColorForSide('left');

  var borderRadiusForSide = function (side) { return ({
      name: "border-radius-" + side,
      initialValue: '0 0',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
      }
  }); };
  var borderTopLeftRadius = borderRadiusForSide('top-left');
  var borderTopRightRadius = borderRadiusForSide('top-right');
  var borderBottomRightRadius = borderRadiusForSide('bottom-right');
  var borderBottomLeftRadius = borderRadiusForSide('bottom-left');

  var borderStyleForSide = function (side) { return ({
      name: "border-" + side + "-style",
      initialValue: 'solid',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, style) {
          switch (style) {
              case 'none':
                  return 0 /* NONE */;
              case 'dashed':
                  return 2 /* DASHED */;
              case 'dotted':
                  return 3 /* DOTTED */;
              case 'double':
                  return 4 /* DOUBLE */;
          }
          return 1 /* SOLID */;
      }
  }); };
  var borderTopStyle = borderStyleForSide('top');
  var borderRightStyle = borderStyleForSide('right');
  var borderBottomStyle = borderStyleForSide('bottom');
  var borderLeftStyle = borderStyleForSide('left');

  var borderWidthForSide = function (side) { return ({
      name: "border-" + side + "-width",
      initialValue: '0',
      type: 0 /* VALUE */,
      prefix: false,
      parse: function (_context, token) {
          if (isDimensionToken(token)) {
              return token.number;
          }
          return 0;
      }
  }); };
  var borderTopWidth = borderWidthForSide('top');
  var borderRightWidth = borderWidthForSide('right');
  var borderBottomWidth = borderWidthForSide('bottom');
  var borderLeftWidth = borderWidthForSide('left');

  var color = {
      name: "color",
      initialValue: 'transparent',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'color'
  };

  var direction = {
      name: 'direction',
      initialValue: 'ltr',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, direction) {
          switch (direction) {
              case 'rtl':
                  return 1 /* RTL */;
              case 'ltr':
              default:
                  return 0 /* LTR */;
          }
      }
  };

  var display = {
      name: 'display',
      initialValue: 'inline-block',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return tokens.filter(isIdentToken).reduce(function (bit, token) {
              return bit | parseDisplayValue(token.value);
          }, 0 /* NONE */);
      }
  };
  var parseDisplayValue = function (display) {
      switch (display) {
          case 'block':
          case '-webkit-box':
              return 2 /* BLOCK */;
          case 'inline':
              return 4 /* INLINE */;
          case 'run-in':
              return 8 /* RUN_IN */;
          case 'flow':
              return 16 /* FLOW */;
          case 'flow-root':
              return 32 /* FLOW_ROOT */;
          case 'table':
              return 64 /* TABLE */;
          case 'flex':
          case '-webkit-flex':
              return 128 /* FLEX */;
          case 'grid':
          case '-ms-grid':
              return 256 /* GRID */;
          case 'ruby':
              return 512 /* RUBY */;
          case 'subgrid':
              return 1024 /* SUBGRID */;
          case 'list-item':
              return 2048 /* LIST_ITEM */;
          case 'table-row-group':
              return 4096 /* TABLE_ROW_GROUP */;
          case 'table-header-group':
              return 8192 /* TABLE_HEADER_GROUP */;
          case 'table-footer-group':
              return 16384 /* TABLE_FOOTER_GROUP */;
          case 'table-row':
              return 32768 /* TABLE_ROW */;
          case 'table-cell':
              return 65536 /* TABLE_CELL */;
          case 'table-column-group':
              return 131072 /* TABLE_COLUMN_GROUP */;
          case 'table-column':
              return 262144 /* TABLE_COLUMN */;
          case 'table-caption':
              return 524288 /* TABLE_CAPTION */;
          case 'ruby-base':
              return 1048576 /* RUBY_BASE */;
          case 'ruby-text':
              return 2097152 /* RUBY_TEXT */;
          case 'ruby-base-container':
              return 4194304 /* RUBY_BASE_CONTAINER */;
          case 'ruby-text-container':
              return 8388608 /* RUBY_TEXT_CONTAINER */;
          case 'contents':
              return 16777216 /* CONTENTS */;
          case 'inline-block':
              return 33554432 /* INLINE_BLOCK */;
          case 'inline-list-item':
              return 67108864 /* INLINE_LIST_ITEM */;
          case 'inline-table':
              return 134217728 /* INLINE_TABLE */;
          case 'inline-flex':
              return 268435456 /* INLINE_FLEX */;
          case 'inline-grid':
              return 536870912 /* INLINE_GRID */;
      }
      return 0 /* NONE */;
  };

  var float = {
      name: 'float',
      initialValue: 'none',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, float) {
          switch (float) {
              case 'left':
                  return 1 /* LEFT */;
              case 'right':
                  return 2 /* RIGHT */;
              case 'inline-start':
                  return 3 /* INLINE_START */;
              case 'inline-end':
                  return 4 /* INLINE_END */;
          }
          return 0 /* NONE */;
      }
  };

  var letterSpacing = {
      name: 'letter-spacing',
      initialValue: '0',
      prefix: false,
      type: 0 /* VALUE */,
      parse: function (_context, token) {
          if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'normal') {
              return 0;
          }
          if (token.type === 17 /* NUMBER_TOKEN */) {
              return token.number;
          }
          if (token.type === 15 /* DIMENSION_TOKEN */) {
              return token.number;
          }
          return 0;
      }
  };

  var LINE_BREAK;
  (function (LINE_BREAK) {
      LINE_BREAK["NORMAL"] = "normal";
      LINE_BREAK["STRICT"] = "strict";
  })(LINE_BREAK || (LINE_BREAK = {}));
  var lineBreak = {
      name: 'line-break',
      initialValue: 'normal',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, lineBreak) {
          switch (lineBreak) {
              case 'strict':
                  return LINE_BREAK.STRICT;
              case 'normal':
              default:
                  return LINE_BREAK.NORMAL;
          }
      }
  };

  var lineHeight = {
      name: 'line-height',
      initialValue: 'normal',
      prefix: false,
      type: 4 /* TOKEN_VALUE */
  };
  var computeLineHeight = function (token, fontSize) {
      if (isIdentToken(token) && token.value === 'normal') {
          return 1.2 * fontSize;
      }
      else if (token.type === 17 /* NUMBER_TOKEN */) {
          return fontSize * token.number;
      }
      else if (isLengthPercentage(token)) {
          return getAbsoluteValue(token, fontSize);
      }
      return fontSize;
  };

  var listStyleImage = {
      name: 'list-style-image',
      initialValue: 'none',
      type: 0 /* VALUE */,
      prefix: false,
      parse: function (context, token) {
          if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'none') {
              return null;
          }
          return image.parse(context, token);
      }
  };

  var listStylePosition = {
      name: 'list-style-position',
      initialValue: 'outside',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, position) {
          switch (position) {
              case 'inside':
                  return 0 /* INSIDE */;
              case 'outside':
              default:
                  return 1 /* OUTSIDE */;
          }
      }
  };

  var listStyleType = {
      name: 'list-style-type',
      initialValue: 'none',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, type) {
          switch (type) {
              case 'disc':
                  return 0 /* DISC */;
              case 'circle':
                  return 1 /* CIRCLE */;
              case 'square':
                  return 2 /* SQUARE */;
              case 'decimal':
                  return 3 /* DECIMAL */;
              case 'cjk-decimal':
                  return 4 /* CJK_DECIMAL */;
              case 'decimal-leading-zero':
                  return 5 /* DECIMAL_LEADING_ZERO */;
              case 'lower-roman':
                  return 6 /* LOWER_ROMAN */;
              case 'upper-roman':
                  return 7 /* UPPER_ROMAN */;
              case 'lower-greek':
                  return 8 /* LOWER_GREEK */;
              case 'lower-alpha':
                  return 9 /* LOWER_ALPHA */;
              case 'upper-alpha':
                  return 10 /* UPPER_ALPHA */;
              case 'arabic-indic':
                  return 11 /* ARABIC_INDIC */;
              case 'armenian':
                  return 12 /* ARMENIAN */;
              case 'bengali':
                  return 13 /* BENGALI */;
              case 'cambodian':
                  return 14 /* CAMBODIAN */;
              case 'cjk-earthly-branch':
                  return 15 /* CJK_EARTHLY_BRANCH */;
              case 'cjk-heavenly-stem':
                  return 16 /* CJK_HEAVENLY_STEM */;
              case 'cjk-ideographic':
                  return 17 /* CJK_IDEOGRAPHIC */;
              case 'devanagari':
                  return 18 /* DEVANAGARI */;
              case 'ethiopic-numeric':
                  return 19 /* ETHIOPIC_NUMERIC */;
              case 'georgian':
                  return 20 /* GEORGIAN */;
              case 'gujarati':
                  return 21 /* GUJARATI */;
              case 'gurmukhi':
                  return 22 /* GURMUKHI */;
              case 'hebrew':
                  return 22 /* HEBREW */;
              case 'hiragana':
                  return 23 /* HIRAGANA */;
              case 'hiragana-iroha':
                  return 24 /* HIRAGANA_IROHA */;
              case 'japanese-formal':
                  return 25 /* JAPANESE_FORMAL */;
              case 'japanese-informal':
                  return 26 /* JAPANESE_INFORMAL */;
              case 'kannada':
                  return 27 /* KANNADA */;
              case 'katakana':
                  return 28 /* KATAKANA */;
              case 'katakana-iroha':
                  return 29 /* KATAKANA_IROHA */;
              case 'khmer':
                  return 30 /* KHMER */;
              case 'korean-hangul-formal':
                  return 31 /* KOREAN_HANGUL_FORMAL */;
              case 'korean-hanja-formal':
                  return 32 /* KOREAN_HANJA_FORMAL */;
              case 'korean-hanja-informal':
                  return 33 /* KOREAN_HANJA_INFORMAL */;
              case 'lao':
                  return 34 /* LAO */;
              case 'lower-armenian':
                  return 35 /* LOWER_ARMENIAN */;
              case 'malayalam':
                  return 36 /* MALAYALAM */;
              case 'mongolian':
                  return 37 /* MONGOLIAN */;
              case 'myanmar':
                  return 38 /* MYANMAR */;
              case 'oriya':
                  return 39 /* ORIYA */;
              case 'persian':
                  return 40 /* PERSIAN */;
              case 'simp-chinese-formal':
                  return 41 /* SIMP_CHINESE_FORMAL */;
              case 'simp-chinese-informal':
                  return 42 /* SIMP_CHINESE_INFORMAL */;
              case 'tamil':
                  return 43 /* TAMIL */;
              case 'telugu':
                  return 44 /* TELUGU */;
              case 'thai':
                  return 45 /* THAI */;
              case 'tibetan':
                  return 46 /* TIBETAN */;
              case 'trad-chinese-formal':
                  return 47 /* TRAD_CHINESE_FORMAL */;
              case 'trad-chinese-informal':
                  return 48 /* TRAD_CHINESE_INFORMAL */;
              case 'upper-armenian':
                  return 49 /* UPPER_ARMENIAN */;
              case 'disclosure-open':
                  return 50 /* DISCLOSURE_OPEN */;
              case 'disclosure-closed':
                  return 51 /* DISCLOSURE_CLOSED */;
              case 'none':
              default:
                  return -1 /* NONE */;
          }
      }
  };

  var marginForSide = function (side) { return ({
      name: "margin-" + side,
      initialValue: '0',
      prefix: false,
      type: 4 /* TOKEN_VALUE */
  }); };
  var marginTop = marginForSide('top');
  var marginRight = marginForSide('right');
  var marginBottom = marginForSide('bottom');
  var marginLeft = marginForSide('left');

  var overflow = {
      name: 'overflow',
      initialValue: 'visible',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return tokens.filter(isIdentToken).map(function (overflow) {
              switch (overflow.value) {
                  case 'hidden':
                      return 1 /* HIDDEN */;
                  case 'scroll':
                      return 2 /* SCROLL */;
                  case 'clip':
                      return 3 /* CLIP */;
                  case 'auto':
                      return 4 /* AUTO */;
                  case 'visible':
                  default:
                      return 0 /* VISIBLE */;
              }
          });
      }
  };

  var overflowWrap = {
      name: 'overflow-wrap',
      initialValue: 'normal',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, overflow) {
          switch (overflow) {
              case 'break-word':
                  return "break-word" /* BREAK_WORD */;
              case 'normal':
              default:
                  return "normal" /* NORMAL */;
          }
      }
  };

  var paddingForSide = function (side) { return ({
      name: "padding-" + side,
      initialValue: '0',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'length-percentage'
  }); };
  var paddingTop = paddingForSide('top');
  var paddingRight = paddingForSide('right');
  var paddingBottom = paddingForSide('bottom');
  var paddingLeft = paddingForSide('left');

  var textAlign = {
      name: 'text-align',
      initialValue: 'left',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, textAlign) {
          switch (textAlign) {
              case 'right':
                  return 2 /* RIGHT */;
              case 'center':
              case 'justify':
                  return 1 /* CENTER */;
              case 'left':
              default:
                  return 0 /* LEFT */;
          }
      }
  };

  var position = {
      name: 'position',
      initialValue: 'static',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, position) {
          switch (position) {
              case 'relative':
                  return 1 /* RELATIVE */;
              case 'absolute':
                  return 2 /* ABSOLUTE */;
              case 'fixed':
                  return 3 /* FIXED */;
              case 'sticky':
                  return 4 /* STICKY */;
          }
          return 0 /* STATIC */;
      }
  };

  var textShadow = {
      name: 'text-shadow',
      initialValue: 'none',
      type: 1 /* LIST */,
      prefix: false,
      parse: function (context, tokens) {
          if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {
              return [];
          }
          return parseFunctionArgs(tokens).map(function (values) {
              var shadow = {
                  color: COLORS.TRANSPARENT,
                  offsetX: ZERO_LENGTH,
                  offsetY: ZERO_LENGTH,
                  blur: ZERO_LENGTH
              };
              var c = 0;
              for (var i = 0; i < values.length; i++) {
                  var token = values[i];
                  if (isLength(token)) {
                      if (c === 0) {
                          shadow.offsetX = token;
                      }
                      else if (c === 1) {
                          shadow.offsetY = token;
                      }
                      else {
                          shadow.blur = token;
                      }
                      c++;
                  }
                  else {
                      shadow.color = color$1.parse(context, token);
                  }
              }
              return shadow;
          });
      }
  };

  var textTransform = {
      name: 'text-transform',
      initialValue: 'none',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, textTransform) {
          switch (textTransform) {
              case 'uppercase':
                  return 2 /* UPPERCASE */;
              case 'lowercase':
                  return 1 /* LOWERCASE */;
              case 'capitalize':
                  return 3 /* CAPITALIZE */;
          }
          return 0 /* NONE */;
      }
  };

  var transform$1 = {
      name: 'transform',
      initialValue: 'none',
      prefix: true,
      type: 0 /* VALUE */,
      parse: function (_context, token) {
          if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'none') {
              return null;
          }
          if (token.type === 18 /* FUNCTION */) {
              var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
              if (typeof transformFunction === 'undefined') {
                  throw new Error("Attempting to parse an unsupported transform function \"" + token.name + "\"");
              }
              return transformFunction(token.values);
          }
          return null;
      }
  };
  var matrix = function (args) {
      var values = args.filter(function (arg) { return arg.type === 17 /* NUMBER_TOKEN */; }).map(function (arg) { return arg.number; });
      return values.length === 6 ? values : null;
  };
  // doesn't support 3D transforms at the moment
  var matrix3d = function (args) {
      var values = args.filter(function (arg) { return arg.type === 17 /* NUMBER_TOKEN */; }).map(function (arg) { return arg.number; });
      var a1 = values[0], b1 = values[1]; values[2]; values[3]; var a2 = values[4], b2 = values[5]; values[6]; values[7]; values[8]; values[9]; values[10]; values[11]; var a4 = values[12], b4 = values[13]; values[14]; values[15];
      return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
  };
  var SUPPORTED_TRANSFORM_FUNCTIONS = {
      matrix: matrix,
      matrix3d: matrix3d
  };

  var DEFAULT_VALUE = {
      type: 16 /* PERCENTAGE_TOKEN */,
      number: 50,
      flags: FLAG_INTEGER
  };
  var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
  var transformOrigin = {
      name: 'transform-origin',
      initialValue: '50% 50%',
      prefix: true,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          var origins = tokens.filter(isLengthPercentage);
          if (origins.length !== 2) {
              return DEFAULT;
          }
          return [origins[0], origins[1]];
      }
  };

  var visibility = {
      name: 'visible',
      initialValue: 'none',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, visibility) {
          switch (visibility) {
              case 'hidden':
                  return 1 /* HIDDEN */;
              case 'collapse':
                  return 2 /* COLLAPSE */;
              case 'visible':
              default:
                  return 0 /* VISIBLE */;
          }
      }
  };

  var WORD_BREAK;
  (function (WORD_BREAK) {
      WORD_BREAK["NORMAL"] = "normal";
      WORD_BREAK["BREAK_ALL"] = "break-all";
      WORD_BREAK["KEEP_ALL"] = "keep-all";
  })(WORD_BREAK || (WORD_BREAK = {}));
  var wordBreak = {
      name: 'word-break',
      initialValue: 'normal',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, wordBreak) {
          switch (wordBreak) {
              case 'break-all':
                  return WORD_BREAK.BREAK_ALL;
              case 'keep-all':
                  return WORD_BREAK.KEEP_ALL;
              case 'normal':
              default:
                  return WORD_BREAK.NORMAL;
          }
      }
  };

  var zIndex = {
      name: 'z-index',
      initialValue: 'auto',
      prefix: false,
      type: 0 /* VALUE */,
      parse: function (_context, token) {
          if (token.type === 20 /* IDENT_TOKEN */) {
              return { auto: true, order: 0 };
          }
          if (isNumberToken(token)) {
              return { auto: false, order: token.number };
          }
          throw new Error("Invalid z-index number parsed");
      }
  };

  var time = {
      name: 'time',
      parse: function (_context, value) {
          if (value.type === 15 /* DIMENSION_TOKEN */) {
              switch (value.unit.toLowerCase()) {
                  case 's':
                      return 1000 * value.number;
                  case 'ms':
                      return value.number;
              }
          }
          throw new Error("Unsupported time type");
      }
  };

  var opacity = {
      name: 'opacity',
      initialValue: '1',
      type: 0 /* VALUE */,
      prefix: false,
      parse: function (_context, token) {
          if (isNumberToken(token)) {
              return token.number;
          }
          return 1;
      }
  };

  var textDecorationColor = {
      name: "text-decoration-color",
      initialValue: 'transparent',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'color'
  };

  var textDecorationLine = {
      name: 'text-decoration-line',
      initialValue: 'none',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          return tokens
              .filter(isIdentToken)
              .map(function (token) {
              switch (token.value) {
                  case 'underline':
                      return 1 /* UNDERLINE */;
                  case 'overline':
                      return 2 /* OVERLINE */;
                  case 'line-through':
                      return 3 /* LINE_THROUGH */;
                  case 'none':
                      return 4 /* BLINK */;
              }
              return 0 /* NONE */;
          })
              .filter(function (line) { return line !== 0 /* NONE */; });
      }
  };

  var fontFamily = {
      name: "font-family",
      initialValue: '',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          var accumulator = [];
          var results = [];
          tokens.forEach(function (token) {
              switch (token.type) {
                  case 20 /* IDENT_TOKEN */:
                  case 0 /* STRING_TOKEN */:
                      accumulator.push(token.value);
                      break;
                  case 17 /* NUMBER_TOKEN */:
                      accumulator.push(token.number.toString());
                      break;
                  case 4 /* COMMA_TOKEN */:
                      results.push(accumulator.join(' '));
                      accumulator.length = 0;
                      break;
              }
          });
          if (accumulator.length) {
              results.push(accumulator.join(' '));
          }
          return results.map(function (result) { return (result.indexOf(' ') === -1 ? result : "'" + result + "'"); });
      }
  };

  var fontSize = {
      name: "font-size",
      initialValue: '0',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'length'
  };

  var fontWeight = {
      name: 'font-weight',
      initialValue: 'normal',
      type: 0 /* VALUE */,
      prefix: false,
      parse: function (_context, token) {
          if (isNumberToken(token)) {
              return token.number;
          }
          if (isIdentToken(token)) {
              switch (token.value) {
                  case 'bold':
                      return 700;
                  case 'normal':
                  default:
                      return 400;
              }
          }
          return 400;
      }
  };

  var fontVariant = {
      name: 'font-variant',
      initialValue: 'none',
      type: 1 /* LIST */,
      prefix: false,
      parse: function (_context, tokens) {
          return tokens.filter(isIdentToken).map(function (token) { return token.value; });
      }
  };

  var fontStyle = {
      name: 'font-style',
      initialValue: 'normal',
      prefix: false,
      type: 2 /* IDENT_VALUE */,
      parse: function (_context, overflow) {
          switch (overflow) {
              case 'oblique':
                  return "oblique" /* OBLIQUE */;
              case 'italic':
                  return "italic" /* ITALIC */;
              case 'normal':
              default:
                  return "normal" /* NORMAL */;
          }
      }
  };

  var contains = function (bit, value) { return (bit & value) !== 0; };

  var content = {
      name: 'content',
      initialValue: 'none',
      type: 1 /* LIST */,
      prefix: false,
      parse: function (_context, tokens) {
          if (tokens.length === 0) {
              return [];
          }
          var first = tokens[0];
          if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
              return [];
          }
          return tokens;
      }
  };

  var counterIncrement = {
      name: 'counter-increment',
      initialValue: 'none',
      prefix: true,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          if (tokens.length === 0) {
              return null;
          }
          var first = tokens[0];
          if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
              return null;
          }
          var increments = [];
          var filtered = tokens.filter(nonWhiteSpace);
          for (var i = 0; i < filtered.length; i++) {
              var counter = filtered[i];
              var next = filtered[i + 1];
              if (counter.type === 20 /* IDENT_TOKEN */) {
                  var increment = next && isNumberToken(next) ? next.number : 1;
                  increments.push({ counter: counter.value, increment: increment });
              }
          }
          return increments;
      }
  };

  var counterReset = {
      name: 'counter-reset',
      initialValue: 'none',
      prefix: true,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          if (tokens.length === 0) {
              return [];
          }
          var resets = [];
          var filtered = tokens.filter(nonWhiteSpace);
          for (var i = 0; i < filtered.length; i++) {
              var counter = filtered[i];
              var next = filtered[i + 1];
              if (isIdentToken(counter) && counter.value !== 'none') {
                  var reset = next && isNumberToken(next) ? next.number : 0;
                  resets.push({ counter: counter.value, reset: reset });
              }
          }
          return resets;
      }
  };

  var duration = {
      name: 'duration',
      initialValue: '0s',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (context, tokens) {
          return tokens.filter(isDimensionToken).map(function (token) { return time.parse(context, token); });
      }
  };

  var quotes = {
      name: 'quotes',
      initialValue: 'none',
      prefix: true,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          if (tokens.length === 0) {
              return null;
          }
          var first = tokens[0];
          if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
              return null;
          }
          var quotes = [];
          var filtered = tokens.filter(isStringToken);
          if (filtered.length % 2 !== 0) {
              return null;
          }
          for (var i = 0; i < filtered.length; i += 2) {
              var open_1 = filtered[i].value;
              var close_1 = filtered[i + 1].value;
              quotes.push({ open: open_1, close: close_1 });
          }
          return quotes;
      }
  };
  var getQuote = function (quotes, depth, open) {
      if (!quotes) {
          return '';
      }
      var quote = quotes[Math.min(depth, quotes.length - 1)];
      if (!quote) {
          return '';
      }
      return open ? quote.open : quote.close;
  };

  var boxShadow = {
      name: 'box-shadow',
      initialValue: 'none',
      type: 1 /* LIST */,
      prefix: false,
      parse: function (context, tokens) {
          if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {
              return [];
          }
          return parseFunctionArgs(tokens).map(function (values) {
              var shadow = {
                  color: 0x000000ff,
                  offsetX: ZERO_LENGTH,
                  offsetY: ZERO_LENGTH,
                  blur: ZERO_LENGTH,
                  spread: ZERO_LENGTH,
                  inset: false
              };
              var c = 0;
              for (var i = 0; i < values.length; i++) {
                  var token = values[i];
                  if (isIdentWithValue(token, 'inset')) {
                      shadow.inset = true;
                  }
                  else if (isLength(token)) {
                      if (c === 0) {
                          shadow.offsetX = token;
                      }
                      else if (c === 1) {
                          shadow.offsetY = token;
                      }
                      else if (c === 2) {
                          shadow.blur = token;
                      }
                      else {
                          shadow.spread = token;
                      }
                      c++;
                  }
                  else {
                      shadow.color = color$1.parse(context, token);
                  }
              }
              return shadow;
          });
      }
  };

  var paintOrder = {
      name: 'paint-order',
      initialValue: 'normal',
      prefix: false,
      type: 1 /* LIST */,
      parse: function (_context, tokens) {
          var DEFAULT_VALUE = [0 /* FILL */, 1 /* STROKE */, 2 /* MARKERS */];
          var layers = [];
          tokens.filter(isIdentToken).forEach(function (token) {
              switch (token.value) {
                  case 'stroke':
                      layers.push(1 /* STROKE */);
                      break;
                  case 'fill':
                      layers.push(0 /* FILL */);
                      break;
                  case 'markers':
                      layers.push(2 /* MARKERS */);
                      break;
              }
          });
          DEFAULT_VALUE.forEach(function (value) {
              if (layers.indexOf(value) === -1) {
                  layers.push(value);
              }
          });
          return layers;
      }
  };

  var webkitTextStrokeColor = {
      name: "-webkit-text-stroke-color",
      initialValue: 'currentcolor',
      prefix: false,
      type: 3 /* TYPE_VALUE */,
      format: 'color'
  };

  var webkitTextStrokeWidth = {
      name: "-webkit-text-stroke-width",
      initialValue: '0',
      type: 0 /* VALUE */,
      prefix: false,
      parse: function (_context, token) {
          if (isDimensionToken(token)) {
              return token.number;
          }
          return 0;
      }
  };

  var CSSParsedDeclaration = /** @class */ (function () {
      function CSSParsedDeclaration(context, declaration) {
          var _a, _b;
          this.animationDuration = parse(context, duration, declaration.animationDuration);
          this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
          this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
          this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
          this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
          this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
          this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
          this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
          this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
          this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
          this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
          this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
          this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
          this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
          this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
          this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
          this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
          this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
          this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
          this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
          this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
          this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
          this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
          this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
          this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
          this.color = parse(context, color, declaration.color);
          this.direction = parse(context, direction, declaration.direction);
          this.display = parse(context, display, declaration.display);
          this.float = parse(context, float, declaration.cssFloat);
          this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
          this.fontSize = parse(context, fontSize, declaration.fontSize);
          this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
          this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
          this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
          this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
          this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
          this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
          this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
          this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
          this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
          this.marginTop = parse(context, marginTop, declaration.marginTop);
          this.marginRight = parse(context, marginRight, declaration.marginRight);
          this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
          this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
          this.opacity = parse(context, opacity, declaration.opacity);
          var overflowTuple = parse(context, overflow, declaration.overflow);
          this.overflowX = overflowTuple[0];
          this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
          this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
          this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
          this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
          this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
          this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
          this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
          this.position = parse(context, position, declaration.position);
          this.textAlign = parse(context, textAlign, declaration.textAlign);
          this.textDecorationColor = parse(context, textDecorationColor, (_a = declaration.textDecorationColor) !== null && _a !== void 0 ? _a : declaration.color);
          this.textDecorationLine = parse(context, textDecorationLine, (_b = declaration.textDecorationLine) !== null && _b !== void 0 ? _b : declaration.textDecoration);
          this.textShadow = parse(context, textShadow, declaration.textShadow);
          this.textTransform = parse(context, textTransform, declaration.textTransform);
          this.transform = parse(context, transform$1, declaration.transform);
          this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
          this.visibility = parse(context, visibility, declaration.visibility);
          this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
          this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
          this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
          this.zIndex = parse(context, zIndex, declaration.zIndex);
      }
      CSSParsedDeclaration.prototype.isVisible = function () {
          return this.display > 0 && this.opacity > 0 && this.visibility === 0 /* VISIBLE */;
      };
      CSSParsedDeclaration.prototype.isTransparent = function () {
          return isTransparent(this.backgroundColor);
      };
      CSSParsedDeclaration.prototype.isTransformed = function () {
          return this.transform !== null;
      };
      CSSParsedDeclaration.prototype.isPositioned = function () {
          return this.position !== 0 /* STATIC */;
      };
      CSSParsedDeclaration.prototype.isPositionedWithZIndex = function () {
          return this.isPositioned() && !this.zIndex.auto;
      };
      CSSParsedDeclaration.prototype.isFloating = function () {
          return this.float !== 0 /* NONE */;
      };
      CSSParsedDeclaration.prototype.isInlineLevel = function () {
          return (contains(this.display, 4 /* INLINE */) ||
              contains(this.display, 33554432 /* INLINE_BLOCK */) ||
              contains(this.display, 268435456 /* INLINE_FLEX */) ||
              contains(this.display, 536870912 /* INLINE_GRID */) ||
              contains(this.display, 67108864 /* INLINE_LIST_ITEM */) ||
              contains(this.display, 134217728 /* INLINE_TABLE */));
      };
      return CSSParsedDeclaration;
  }());
  var CSSParsedPseudoDeclaration = /** @class */ (function () {
      function CSSParsedPseudoDeclaration(context, declaration) {
          this.content = parse(context, content, declaration.content);
          this.quotes = parse(context, quotes, declaration.quotes);
      }
      return CSSParsedPseudoDeclaration;
  }());
  var CSSParsedCounterDeclaration = /** @class */ (function () {
      function CSSParsedCounterDeclaration(context, declaration) {
          this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);
          this.counterReset = parse(context, counterReset, declaration.counterReset);
      }
      return CSSParsedCounterDeclaration;
  }());
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var parse = function (context, descriptor, style) {
      var tokenizer = new Tokenizer();
      var value = style !== null && typeof style !== 'undefined' ? style.toString() : descriptor.initialValue;
      tokenizer.write(value);
      var parser = new Parser(tokenizer.read());
      switch (descriptor.type) {
          case 2 /* IDENT_VALUE */:
              var token = parser.parseComponentValue();
              return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
          case 0 /* VALUE */:
              return descriptor.parse(context, parser.parseComponentValue());
          case 1 /* LIST */:
              return descriptor.parse(context, parser.parseComponentValues());
          case 4 /* TOKEN_VALUE */:
              return parser.parseComponentValue();
          case 3 /* TYPE_VALUE */:
              switch (descriptor.format) {
                  case 'angle':
                      return angle.parse(context, parser.parseComponentValue());
                  case 'color':
                      return color$1.parse(context, parser.parseComponentValue());
                  case 'image':
                      return image.parse(context, parser.parseComponentValue());
                  case 'length':
                      var length_1 = parser.parseComponentValue();
                      return isLength(length_1) ? length_1 : ZERO_LENGTH;
                  case 'length-percentage':
                      var value_1 = parser.parseComponentValue();
                      return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
                  case 'time':
                      return time.parse(context, parser.parseComponentValue());
              }
              break;
      }
  };

  var elementDebuggerAttribute = 'data-html2canvas-debug';
  var getElementDebugType = function (element) {
      var attribute = element.getAttribute(elementDebuggerAttribute);
      switch (attribute) {
          case 'all':
              return 1 /* ALL */;
          case 'clone':
              return 2 /* CLONE */;
          case 'parse':
              return 3 /* PARSE */;
          case 'render':
              return 4 /* RENDER */;
          default:
              return 0 /* NONE */;
      }
  };
  var isDebugging = function (element, type) {
      var elementType = getElementDebugType(element);
      return elementType === 1 /* ALL */ || type === elementType;
  };

  var ElementContainer = /** @class */ (function () {
      function ElementContainer(context, element) {
          this.context = context;
          this.textNodes = [];
          this.elements = [];
          this.flags = 0;
          if (isDebugging(element, 3 /* PARSE */)) {
              debugger;
          }
          this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
          if (isHTMLElementNode(element)) {
              if (this.styles.animationDuration.some(function (duration) { return duration > 0; })) {
                  element.style.animationDuration = '0s';
              }
              if (this.styles.transform !== null) {
                  // getBoundingClientRect takes transforms into account
                  element.style.transform = 'none';
              }
          }
          this.bounds = parseBounds(this.context, element);
          if (isDebugging(element, 4 /* RENDER */)) {
              this.flags |= 16 /* DEBUG_RENDER */;
          }
      }
      return ElementContainer;
  }());

  /*
   * text-segmentation 1.0.3 <https://github.com/niklasvh/text-segmentation>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var base64 = 'AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=';

  /*
   * utrie 1.0.2 <https://github.com/niklasvh/utrie>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var chars$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  // Use a lookup table to find the index.
  var lookup$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  for (var i$1 = 0; i$1 < chars$1.length; i$1++) {
      lookup$1[chars$1.charCodeAt(i$1)] = i$1;
  }
  var decode = function (base64) {
      var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base64[base64.length - 1] === '=') {
          bufferLength--;
          if (base64[base64.length - 2] === '=') {
              bufferLength--;
          }
      }
      var buffer = typeof ArrayBuffer !== 'undefined' &&
          typeof Uint8Array !== 'undefined' &&
          typeof Uint8Array.prototype.slice !== 'undefined'
          ? new ArrayBuffer(bufferLength)
          : new Array(bufferLength);
      var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
      for (i = 0; i < len; i += 4) {
          encoded1 = lookup$1[base64.charCodeAt(i)];
          encoded2 = lookup$1[base64.charCodeAt(i + 1)];
          encoded3 = lookup$1[base64.charCodeAt(i + 2)];
          encoded4 = lookup$1[base64.charCodeAt(i + 3)];
          bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
          bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
          bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
      }
      return buffer;
  };
  var polyUint16Array = function (buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i = 0; i < length; i += 2) {
          bytes.push((buffer[i + 1] << 8) | buffer[i]);
      }
      return bytes;
  };
  var polyUint32Array = function (buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i = 0; i < length; i += 4) {
          bytes.push((buffer[i + 3] << 24) | (buffer[i + 2] << 16) | (buffer[i + 1] << 8) | buffer[i]);
      }
      return bytes;
  };

  /** Shift size for getting the index-2 table offset. */
  var UTRIE2_SHIFT_2 = 5;
  /** Shift size for getting the index-1 table offset. */
  var UTRIE2_SHIFT_1 = 6 + 5;
  /**
   * Shift size for shifting left the index array values.
   * Increases possible data size with 16-bit index values at the cost
   * of compactability.
   * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
   */
  var UTRIE2_INDEX_SHIFT = 2;
  /**
   * Difference between the two shift sizes,
   * for getting an index-1 offset from an index-2 offset. 6=11-5
   */
  var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
  /**
   * The part of the index-2 table for U+D800..U+DBFF stores values for
   * lead surrogate code _units_ not code _points_.
   * Values for lead surrogate code _points_ are indexed with this portion of the table.
   * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
   */
  var UTRIE2_LSCP_INDEX_2_OFFSET = 0x10000 >> UTRIE2_SHIFT_2;
  /** Number of entries in a data block. 32=0x20 */
  var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
  /** Mask for getting the lower bits for the in-data-block offset. */
  var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
  var UTRIE2_LSCP_INDEX_2_LENGTH = 0x400 >> UTRIE2_SHIFT_2;
  /** Count the lengths of both BMP pieces. 2080=0x820 */
  var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
  /**
   * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
   * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
   */
  var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
  var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */
  /**
   * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
   * Variable length, for code points up to highStart, where the last single-value range starts.
   * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
   * (For 0x100000 supplementary code points U+10000..U+10ffff.)
   *
   * The part of the index-2 table for supplementary code points starts
   * after this index-1 table.
   *
   * Both the index-1 table and the following part of the index-2 table
   * are omitted completely if there is only BMP data.
   */
  var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
  /**
   * Number of index-1 entries for the BMP. 32=0x20
   * This part of the index-1 table is omitted from the serialized form.
   */
  var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> UTRIE2_SHIFT_1;
  /** Number of entries in an index-2 block. 64=0x40 */
  var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
  /** Mask for getting the lower bits for the in-index-2-block offset. */
  var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
  var slice16 = function (view, start, end) {
      if (view.slice) {
          return view.slice(start, end);
      }
      return new Uint16Array(Array.prototype.slice.call(view, start, end));
  };
  var slice32 = function (view, start, end) {
      if (view.slice) {
          return view.slice(start, end);
      }
      return new Uint32Array(Array.prototype.slice.call(view, start, end));
  };
  var createTrieFromBase64 = function (base64, _byteLength) {
      var buffer = decode(base64);
      var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
      var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
      var headerLength = 24;
      var index = slice16(view16, headerLength / 2, view32[4] / 2);
      var data = view32[5] === 2
          ? slice16(view16, (headerLength + view32[4]) / 2)
          : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
      return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);
  };
  var Trie = /** @class */ (function () {
      function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {
          this.initialValue = initialValue;
          this.errorValue = errorValue;
          this.highStart = highStart;
          this.highValueIndex = highValueIndex;
          this.index = index;
          this.data = data;
      }
      /**
       * Get the value for a code point as stored in the Trie.
       *
       * @param codePoint the code point
       * @return the value
       */
      Trie.prototype.get = function (codePoint) {
          var ix;
          if (codePoint >= 0) {
              if (codePoint < 0x0d800 || (codePoint > 0x0dbff && codePoint <= 0x0ffff)) {
                  // Ordinary BMP code point, excluding leading surrogates.
                  // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
                  // 16 bit data is stored in the index array itself.
                  ix = this.index[codePoint >> UTRIE2_SHIFT_2];
                  ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                  return this.data[ix];
              }
              if (codePoint <= 0xffff) {
                  // Lead Surrogate Code Point.  A Separate index section is stored for
                  // lead surrogate code units and code points.
                  //   The main index has the code unit data.
                  //   For this function, we need the code point data.
                  // Note: this expression could be refactored for slightly improved efficiency, but
                  //       surrogate code points will be so rare in practice that it's not worth it.
                  ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + ((codePoint - 0xd800) >> UTRIE2_SHIFT_2)];
                  ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                  return this.data[ix];
              }
              if (codePoint < this.highStart) {
                  // Supplemental code point, use two-level lookup.
                  ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
                  ix = this.index[ix];
                  ix += (codePoint >> UTRIE2_SHIFT_2) & UTRIE2_INDEX_2_MASK;
                  ix = this.index[ix];
                  ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                  return this.data[ix];
              }
              if (codePoint <= 0x10ffff) {
                  return this.data[this.highValueIndex];
              }
          }
          // Fall through.  The code point is outside of the legal range of 0..0x10ffff.
          return this.errorValue;
      };
      return Trie;
  }());

  /*
   * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  // Use a lookup table to find the index.
  var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
      lookup[chars.charCodeAt(i)] = i;
  }

  var Prepend = 1;
  var CR = 2;
  var LF = 3;
  var Control = 4;
  var Extend = 5;
  var SpacingMark = 7;
  var L = 8;
  var V = 9;
  var T = 10;
  var LV = 11;
  var LVT = 12;
  var ZWJ = 13;
  var Extended_Pictographic = 14;
  var RI = 15;
  var toCodePoints = function (str) {
      var codePoints = [];
      var i = 0;
      var length = str.length;
      while (i < length) {
          var value = str.charCodeAt(i++);
          if (value >= 0xd800 && value <= 0xdbff && i < length) {
              var extra = str.charCodeAt(i++);
              if ((extra & 0xfc00) === 0xdc00) {
                  codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
              }
              else {
                  codePoints.push(value);
                  i--;
              }
          }
          else {
              codePoints.push(value);
          }
      }
      return codePoints;
  };
  var fromCodePoint = function () {
      var codePoints = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          codePoints[_i] = arguments[_i];
      }
      if (String.fromCodePoint) {
          return String.fromCodePoint.apply(String, codePoints);
      }
      var length = codePoints.length;
      if (!length) {
          return '';
      }
      var codeUnits = [];
      var index = -1;
      var result = '';
      while (++index < length) {
          var codePoint = codePoints[index];
          if (codePoint <= 0xffff) {
              codeUnits.push(codePoint);
          }
          else {
              codePoint -= 0x10000;
              codeUnits.push((codePoint >> 10) + 0xd800, (codePoint % 0x400) + 0xdc00);
          }
          if (index + 1 === length || codeUnits.length > 0x4000) {
              result += String.fromCharCode.apply(String, codeUnits);
              codeUnits.length = 0;
          }
      }
      return result;
  };
  var UnicodeTrie = createTrieFromBase64(base64);
  var BREAK_NOT_ALLOWED = '×';
  var BREAK_ALLOWED = '÷';
  var codePointToClass = function (codePoint) { return UnicodeTrie.get(codePoint); };
  var _graphemeBreakAtIndex = function (_codePoints, classTypes, index) {
      var prevIndex = index - 2;
      var prev = classTypes[prevIndex];
      var current = classTypes[index - 1];
      var next = classTypes[index];
      // GB3 Do not break between a CR and LF
      if (current === CR && next === LF) {
          return BREAK_NOT_ALLOWED;
      }
      // GB4 Otherwise, break before and after controls.
      if (current === CR || current === LF || current === Control) {
          return BREAK_ALLOWED;
      }
      // GB5
      if (next === CR || next === LF || next === Control) {
          return BREAK_ALLOWED;
      }
      // Do not break Hangul syllable sequences.
      // GB6
      if (current === L && [L, V, LV, LVT].indexOf(next) !== -1) {
          return BREAK_NOT_ALLOWED;
      }
      // GB7
      if ((current === LV || current === V) && (next === V || next === T)) {
          return BREAK_NOT_ALLOWED;
      }
      // GB8
      if ((current === LVT || current === T) && next === T) {
          return BREAK_NOT_ALLOWED;
      }
      // GB9 Do not break before extending characters or ZWJ.
      if (next === ZWJ || next === Extend) {
          return BREAK_NOT_ALLOWED;
      }
      // Do not break before SpacingMarks, or after Prepend characters.
      // GB9a
      if (next === SpacingMark) {
          return BREAK_NOT_ALLOWED;
      }
      // GB9a
      if (current === Prepend) {
          return BREAK_NOT_ALLOWED;
      }
      // GB11 Do not break within emoji modifier sequences or emoji zwj sequences.
      if (current === ZWJ && next === Extended_Pictographic) {
          while (prev === Extend) {
              prev = classTypes[--prevIndex];
          }
          if (prev === Extended_Pictographic) {
              return BREAK_NOT_ALLOWED;
          }
      }
      // GB12 Do not break within emoji flag sequences.
      // That is, do not break between regional indicator (RI) symbols
      // if there is an odd number of RI characters before the break point.
      if (current === RI && next === RI) {
          var countRI = 0;
          while (prev === RI) {
              countRI++;
              prev = classTypes[--prevIndex];
          }
          if (countRI % 2 === 0) {
              return BREAK_NOT_ALLOWED;
          }
      }
      return BREAK_ALLOWED;
  };
  var GraphemeBreaker = function (str) {
      var codePoints = toCodePoints(str);
      var length = codePoints.length;
      var index = 0;
      var lastEnd = 0;
      var classTypes = codePoints.map(codePointToClass);
      return {
          next: function () {
              if (index >= length) {
                  return { done: true, value: null };
              }
              var graphemeBreak = BREAK_NOT_ALLOWED;
              while (index < length &&
                  (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index)) === BREAK_NOT_ALLOWED) { }
              if (graphemeBreak !== BREAK_NOT_ALLOWED || index === length) {
                  var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index));
                  lastEnd = index;
                  return { value: value, done: false };
              }
              return { done: true, value: null };
          },
      };
  };
  var splitGraphemes = function (str) {
      var breaker = GraphemeBreaker(str);
      var graphemes = [];
      var bk;
      while (!(bk = breaker.next()).done) {
          if (bk.value) {
              graphemes.push(bk.value.slice());
          }
      }
      return graphemes;
  };

  var testRangeBounds = function (document) {
      var TEST_HEIGHT = 123;
      if (document.createRange) {
          var range = document.createRange();
          if (range.getBoundingClientRect) {
              var testElement = document.createElement('boundtest');
              testElement.style.height = TEST_HEIGHT + "px";
              testElement.style.display = 'block';
              document.body.appendChild(testElement);
              range.selectNode(testElement);
              var rangeBounds = range.getBoundingClientRect();
              var rangeHeight = Math.round(rangeBounds.height);
              document.body.removeChild(testElement);
              if (rangeHeight === TEST_HEIGHT) {
                  return true;
              }
          }
      }
      return false;
  };
  var testIOSLineBreak = function (document) {
      var testElement = document.createElement('boundtest');
      testElement.style.width = '50px';
      testElement.style.display = 'block';
      testElement.style.fontSize = '12px';
      testElement.style.letterSpacing = '0px';
      testElement.style.wordSpacing = '0px';
      document.body.appendChild(testElement);
      var range = document.createRange();
      testElement.innerHTML = typeof ''.repeat === 'function' ? '&#128104;'.repeat(10) : '';
      var node = testElement.firstChild;
      var textList = toCodePoints$1(node.data).map(function (i) { return fromCodePoint$1(i); });
      var offset = 0;
      var prev = {};
      // ios 13 does not handle range getBoundingClientRect line changes correctly #2177
      var supports = textList.every(function (text, i) {
          range.setStart(node, offset);
          range.setEnd(node, offset + text.length);
          var rect = range.getBoundingClientRect();
          offset += text.length;
          var boundAhead = rect.x > prev.x || rect.y > prev.y;
          prev = rect;
          if (i === 0) {
              return true;
          }
          return boundAhead;
      });
      document.body.removeChild(testElement);
      return supports;
  };
  var testCORS = function () { return typeof new Image().crossOrigin !== 'undefined'; };
  var testResponseType = function () { return typeof new XMLHttpRequest().responseType === 'string'; };
  var testSVG = function (document) {
      var img = new Image();
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
      if (!ctx) {
          return false;
      }
      img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
      try {
          ctx.drawImage(img, 0, 0);
          canvas.toDataURL();
      }
      catch (e) {
          return false;
      }
      return true;
  };
  var isGreenPixel = function (data) {
      return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
  };
  var testForeignObject = function (document) {
      var canvas = document.createElement('canvas');
      var size = 100;
      canvas.width = size;
      canvas.height = size;
      var ctx = canvas.getContext('2d');
      if (!ctx) {
          return Promise.reject(false);
      }
      ctx.fillStyle = 'rgb(0, 255, 0)';
      ctx.fillRect(0, 0, size, size);
      var img = new Image();
      var greenImageSrc = canvas.toDataURL();
      img.src = greenImageSrc;
      var svg = createForeignObjectSVG(size, size, 0, 0, img);
      ctx.fillStyle = 'red';
      ctx.fillRect(0, 0, size, size);
      return loadSerializedSVG$1(svg)
          .then(function (img) {
          ctx.drawImage(img, 0, 0);
          var data = ctx.getImageData(0, 0, size, size).data;
          ctx.fillStyle = 'red';
          ctx.fillRect(0, 0, size, size);
          var node = document.createElement('div');
          node.style.backgroundImage = "url(" + greenImageSrc + ")";
          node.style.height = size + "px";
          // Firefox 55 does not render inline <img /> tags
          return isGreenPixel(data)
              ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node))
              : Promise.reject(false);
      })
          .then(function (img) {
          ctx.drawImage(img, 0, 0);
          // Edge does not render background-images
          return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
      })
          .catch(function () { return false; });
  };
  var createForeignObjectSVG = function (width, height, x, y, node) {
      var xmlns = 'http://www.w3.org/2000/svg';
      var svg = document.createElementNS(xmlns, 'svg');
      var foreignObject = document.createElementNS(xmlns, 'foreignObject');
      svg.setAttributeNS(null, 'width', width.toString());
      svg.setAttributeNS(null, 'height', height.toString());
      foreignObject.setAttributeNS(null, 'width', '100%');
      foreignObject.setAttributeNS(null, 'height', '100%');
      foreignObject.setAttributeNS(null, 'x', x.toString());
      foreignObject.setAttributeNS(null, 'y', y.toString());
      foreignObject.setAttributeNS(null, 'externalResourcesRequired', 'true');
      svg.appendChild(foreignObject);
      foreignObject.appendChild(node);
      return svg;
  };
  var loadSerializedSVG$1 = function (svg) {
      return new Promise(function (resolve, reject) {
          var img = new Image();
          img.onload = function () { return resolve(img); };
          img.onerror = reject;
          img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
      });
  };
  var FEATURES = {
      get SUPPORT_RANGE_BOUNDS() {
          var value = testRangeBounds(document);
          Object.defineProperty(FEATURES, 'SUPPORT_RANGE_BOUNDS', { value: value });
          return value;
      },
      get SUPPORT_WORD_BREAKING() {
          var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
          Object.defineProperty(FEATURES, 'SUPPORT_WORD_BREAKING', { value: value });
          return value;
      },
      get SUPPORT_SVG_DRAWING() {
          var value = testSVG(document);
          Object.defineProperty(FEATURES, 'SUPPORT_SVG_DRAWING', { value: value });
          return value;
      },
      get SUPPORT_FOREIGNOBJECT_DRAWING() {
          var value = typeof Array.from === 'function' && typeof window.fetch === 'function'
              ? testForeignObject(document)
              : Promise.resolve(false);
          Object.defineProperty(FEATURES, 'SUPPORT_FOREIGNOBJECT_DRAWING', { value: value });
          return value;
      },
      get SUPPORT_CORS_IMAGES() {
          var value = testCORS();
          Object.defineProperty(FEATURES, 'SUPPORT_CORS_IMAGES', { value: value });
          return value;
      },
      get SUPPORT_RESPONSE_TYPE() {
          var value = testResponseType();
          Object.defineProperty(FEATURES, 'SUPPORT_RESPONSE_TYPE', { value: value });
          return value;
      },
      get SUPPORT_CORS_XHR() {
          var value = 'withCredentials' in new XMLHttpRequest();
          Object.defineProperty(FEATURES, 'SUPPORT_CORS_XHR', { value: value });
          return value;
      },
      get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          var value = !!(typeof Intl !== 'undefined' && Intl.Segmenter);
          Object.defineProperty(FEATURES, 'SUPPORT_NATIVE_TEXT_SEGMENTATION', { value: value });
          return value;
      }
  };

  var TextBounds = /** @class */ (function () {
      function TextBounds(text, bounds) {
          this.text = text;
          this.bounds = bounds;
      }
      return TextBounds;
  }());
  var parseTextBounds = function (context, value, styles, node) {
      var textList = breakText(value, styles);
      var textBounds = [];
      var offset = 0;
      textList.forEach(function (text) {
          if (styles.textDecorationLine.length || text.trim().length > 0) {
              if (FEATURES.SUPPORT_RANGE_BOUNDS) {
                  var clientRects = createRange(node, offset, text.length).getClientRects();
                  if (clientRects.length > 1) {
                      var subSegments = segmentGraphemes(text);
                      var subOffset_1 = 0;
                      subSegments.forEach(function (subSegment) {
                          textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node, subOffset_1 + offset, subSegment.length).getClientRects())));
                          subOffset_1 += subSegment.length;
                      });
                  }
                  else {
                      textBounds.push(new TextBounds(text, Bounds.fromDOMRectList(context, clientRects)));
                  }
              }
              else {
                  var replacementNode = node.splitText(text.length);
                  textBounds.push(new TextBounds(text, getWrapperBounds(context, node)));
                  node = replacementNode;
              }
          }
          else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
              node = node.splitText(text.length);
          }
          offset += text.length;
      });
      return textBounds;
  };
  var getWrapperBounds = function (context, node) {
      var ownerDocument = node.ownerDocument;
      if (ownerDocument) {
          var wrapper = ownerDocument.createElement('html2canvaswrapper');
          wrapper.appendChild(node.cloneNode(true));
          var parentNode = node.parentNode;
          if (parentNode) {
              parentNode.replaceChild(wrapper, node);
              var bounds = parseBounds(context, wrapper);
              if (wrapper.firstChild) {
                  parentNode.replaceChild(wrapper.firstChild, wrapper);
              }
              return bounds;
          }
      }
      return Bounds.EMPTY;
  };
  var createRange = function (node, offset, length) {
      var ownerDocument = node.ownerDocument;
      if (!ownerDocument) {
          throw new Error('Node has no owner document');
      }
      var range = ownerDocument.createRange();
      range.setStart(node, offset);
      range.setEnd(node, offset + length);
      return range;
  };
  var segmentGraphemes = function (value) {
      if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          var segmenter = new Intl.Segmenter(void 0, { granularity: 'grapheme' });
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return Array.from(segmenter.segment(value)).map(function (segment) { return segment.segment; });
      }
      return splitGraphemes(value);
  };
  var segmentWords = function (value, styles) {
      if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          var segmenter = new Intl.Segmenter(void 0, {
              granularity: 'word'
          });
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          return Array.from(segmenter.segment(value)).map(function (segment) { return segment.segment; });
      }
      return breakWords(value, styles);
  };
  var breakText = function (value, styles) {
      return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
  };
  // https://drafts.csswg.org/css-text/#word-separator
  var wordSeparators = [0x0020, 0x00a0, 0x1361, 0x10100, 0x10101, 0x1039, 0x1091];
  var breakWords = function (str, styles) {
      var breaker = LineBreaker(str, {
          lineBreak: styles.lineBreak,
          wordBreak: styles.overflowWrap === "break-word" /* BREAK_WORD */ ? 'break-word' : styles.wordBreak
      });
      var words = [];
      var bk;
      var _loop_1 = function () {
          if (bk.value) {
              var value = bk.value.slice();
              var codePoints = toCodePoints$1(value);
              var word_1 = '';
              codePoints.forEach(function (codePoint) {
                  if (wordSeparators.indexOf(codePoint) === -1) {
                      word_1 += fromCodePoint$1(codePoint);
                  }
                  else {
                      if (word_1.length) {
                          words.push(word_1);
                      }
                      words.push(fromCodePoint$1(codePoint));
                      word_1 = '';
                  }
              });
              if (word_1.length) {
                  words.push(word_1);
              }
          }
      };
      while (!(bk = breaker.next()).done) {
          _loop_1();
      }
      return words;
  };

  var TextContainer = /** @class */ (function () {
      function TextContainer(context, node, styles) {
          this.text = transform(node.data, styles.textTransform);
          this.textBounds = parseTextBounds(context, this.text, styles, node);
      }
      return TextContainer;
  }());
  var transform = function (text, transform) {
      switch (transform) {
          case 1 /* LOWERCASE */:
              return text.toLowerCase();
          case 3 /* CAPITALIZE */:
              return text.replace(CAPITALIZE, capitalize);
          case 2 /* UPPERCASE */:
              return text.toUpperCase();
          default:
              return text;
      }
  };
  var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
  var capitalize = function (m, p1, p2) {
      if (m.length > 0) {
          return p1 + p2.toUpperCase();
      }
      return m;
  };

  var ImageElementContainer = /** @class */ (function (_super) {
      __extends(ImageElementContainer, _super);
      function ImageElementContainer(context, img) {
          var _this = _super.call(this, context, img) || this;
          _this.src = img.currentSrc || img.src;
          _this.intrinsicWidth = img.naturalWidth;
          _this.intrinsicHeight = img.naturalHeight;
          _this.context.cache.addImage(_this.src);
          return _this;
      }
      return ImageElementContainer;
  }(ElementContainer));

  var CanvasElementContainer = /** @class */ (function (_super) {
      __extends(CanvasElementContainer, _super);
      function CanvasElementContainer(context, canvas) {
          var _this = _super.call(this, context, canvas) || this;
          _this.canvas = canvas;
          _this.intrinsicWidth = canvas.width;
          _this.intrinsicHeight = canvas.height;
          return _this;
      }
      return CanvasElementContainer;
  }(ElementContainer));

  var SVGElementContainer = /** @class */ (function (_super) {
      __extends(SVGElementContainer, _super);
      function SVGElementContainer(context, img) {
          var _this = _super.call(this, context, img) || this;
          var s = new XMLSerializer();
          var bounds = parseBounds(context, img);
          img.setAttribute('width', bounds.width + "px");
          img.setAttribute('height', bounds.height + "px");
          _this.svg = "data:image/svg+xml," + encodeURIComponent(s.serializeToString(img));
          _this.intrinsicWidth = img.width.baseVal.value;
          _this.intrinsicHeight = img.height.baseVal.value;
          _this.context.cache.addImage(_this.svg);
          return _this;
      }
      return SVGElementContainer;
  }(ElementContainer));

  var LIElementContainer = /** @class */ (function (_super) {
      __extends(LIElementContainer, _super);
      function LIElementContainer(context, element) {
          var _this = _super.call(this, context, element) || this;
          _this.value = element.value;
          return _this;
      }
      return LIElementContainer;
  }(ElementContainer));

  var OLElementContainer = /** @class */ (function (_super) {
      __extends(OLElementContainer, _super);
      function OLElementContainer(context, element) {
          var _this = _super.call(this, context, element) || this;
          _this.start = element.start;
          _this.reversed = typeof element.reversed === 'boolean' && element.reversed === true;
          return _this;
      }
      return OLElementContainer;
  }(ElementContainer));

  var CHECKBOX_BORDER_RADIUS = [
      {
          type: 15 /* DIMENSION_TOKEN */,
          flags: 0,
          unit: 'px',
          number: 3
      }
  ];
  var RADIO_BORDER_RADIUS = [
      {
          type: 16 /* PERCENTAGE_TOKEN */,
          flags: 0,
          number: 50
      }
  ];
  var reformatInputBounds = function (bounds) {
      if (bounds.width > bounds.height) {
          return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
      }
      else if (bounds.width < bounds.height) {
          return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
      }
      return bounds;
  };
  var getInputValue = function (node) {
      var value = node.type === PASSWORD ? new Array(node.value.length + 1).join('\u2022') : node.value;
      return value.length === 0 ? node.placeholder || '' : value;
  };
  var CHECKBOX = 'checkbox';
  var RADIO = 'radio';
  var PASSWORD = 'password';
  var INPUT_COLOR = 0x2a2a2aff;
  var InputElementContainer = /** @class */ (function (_super) {
      __extends(InputElementContainer, _super);
      function InputElementContainer(context, input) {
          var _this = _super.call(this, context, input) || this;
          _this.type = input.type.toLowerCase();
          _this.checked = input.checked;
          _this.value = getInputValue(input);
          if (_this.type === CHECKBOX || _this.type === RADIO) {
              _this.styles.backgroundColor = 0xdededeff;
              _this.styles.borderTopColor =
                  _this.styles.borderRightColor =
                      _this.styles.borderBottomColor =
                          _this.styles.borderLeftColor =
                              0xa5a5a5ff;
              _this.styles.borderTopWidth =
                  _this.styles.borderRightWidth =
                      _this.styles.borderBottomWidth =
                          _this.styles.borderLeftWidth =
                              1;
              _this.styles.borderTopStyle =
                  _this.styles.borderRightStyle =
                      _this.styles.borderBottomStyle =
                          _this.styles.borderLeftStyle =
                              1 /* SOLID */;
              _this.styles.backgroundClip = [0 /* BORDER_BOX */];
              _this.styles.backgroundOrigin = [0 /* BORDER_BOX */];
              _this.bounds = reformatInputBounds(_this.bounds);
          }
          switch (_this.type) {
              case CHECKBOX:
                  _this.styles.borderTopRightRadius =
                      _this.styles.borderTopLeftRadius =
                          _this.styles.borderBottomRightRadius =
                              _this.styles.borderBottomLeftRadius =
                                  CHECKBOX_BORDER_RADIUS;
                  break;
              case RADIO:
                  _this.styles.borderTopRightRadius =
                      _this.styles.borderTopLeftRadius =
                          _this.styles.borderBottomRightRadius =
                              _this.styles.borderBottomLeftRadius =
                                  RADIO_BORDER_RADIUS;
                  break;
          }
          return _this;
      }
      return InputElementContainer;
  }(ElementContainer));

  var SelectElementContainer = /** @class */ (function (_super) {
      __extends(SelectElementContainer, _super);
      function SelectElementContainer(context, element) {
          var _this = _super.call(this, context, element) || this;
          var option = element.options[element.selectedIndex || 0];
          _this.value = option ? option.text || '' : '';
          return _this;
      }
      return SelectElementContainer;
  }(ElementContainer));

  var TextareaElementContainer = /** @class */ (function (_super) {
      __extends(TextareaElementContainer, _super);
      function TextareaElementContainer(context, element) {
          var _this = _super.call(this, context, element) || this;
          _this.value = element.value;
          return _this;
      }
      return TextareaElementContainer;
  }(ElementContainer));

  var IFrameElementContainer = /** @class */ (function (_super) {
      __extends(IFrameElementContainer, _super);
      function IFrameElementContainer(context, iframe) {
          var _this = _super.call(this, context, iframe) || this;
          _this.src = iframe.src;
          _this.width = parseInt(iframe.width, 10) || 0;
          _this.height = parseInt(iframe.height, 10) || 0;
          _this.backgroundColor = _this.styles.backgroundColor;
          try {
              if (iframe.contentWindow &&
                  iframe.contentWindow.document &&
                  iframe.contentWindow.document.documentElement) {
                  _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
                  // http://www.w3.org/TR/css3-background/#special-backgrounds
                  var documentBackgroundColor = iframe.contentWindow.document.documentElement
                      ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor)
                      : COLORS.TRANSPARENT;
                  var bodyBackgroundColor = iframe.contentWindow.document.body
                      ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor)
                      : COLORS.TRANSPARENT;
                  _this.backgroundColor = isTransparent(documentBackgroundColor)
                      ? isTransparent(bodyBackgroundColor)
                          ? _this.styles.backgroundColor
                          : bodyBackgroundColor
                      : documentBackgroundColor;
              }
          }
          catch (e) { }
          return _this;
      }
      return IFrameElementContainer;
  }(ElementContainer));

  var LIST_OWNERS = ['OL', 'UL', 'MENU'];
  var parseNodeTree = function (context, node, parent, root) {
      for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
          nextNode = childNode.nextSibling;
          if (isTextNode(childNode) && childNode.data.trim().length > 0) {
              parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
          }
          else if (isElementNode(childNode)) {
              if (isSlotElement(childNode) && childNode.assignedNodes) {
                  childNode.assignedNodes().forEach(function (childNode) { return parseNodeTree(context, childNode, parent, root); });
              }
              else {
                  var container = createContainer(context, childNode);
                  if (container.styles.isVisible()) {
                      if (createsRealStackingContext(childNode, container, root)) {
                          container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;
                      }
                      else if (createsStackingContext(container.styles)) {
                          container.flags |= 2 /* CREATES_STACKING_CONTEXT */;
                      }
                      if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
                          container.flags |= 8 /* IS_LIST_OWNER */;
                      }
                      parent.elements.push(container);
                      childNode.slot;
                      if (childNode.shadowRoot) {
                          parseNodeTree(context, childNode.shadowRoot, container, root);
                      }
                      else if (!isTextareaElement(childNode) &&
                          !isSVGElement(childNode) &&
                          !isSelectElement(childNode)) {
                          parseNodeTree(context, childNode, container, root);
                      }
                  }
              }
          }
      }
  };
  var createContainer = function (context, element) {
      if (isImageElement(element)) {
          return new ImageElementContainer(context, element);
      }
      if (isCanvasElement(element)) {
          return new CanvasElementContainer(context, element);
      }
      if (isSVGElement(element)) {
          return new SVGElementContainer(context, element);
      }
      if (isLIElement(element)) {
          return new LIElementContainer(context, element);
      }
      if (isOLElement(element)) {
          return new OLElementContainer(context, element);
      }
      if (isInputElement(element)) {
          return new InputElementContainer(context, element);
      }
      if (isSelectElement(element)) {
          return new SelectElementContainer(context, element);
      }
      if (isTextareaElement(element)) {
          return new TextareaElementContainer(context, element);
      }
      if (isIFrameElement(element)) {
          return new IFrameElementContainer(context, element);
      }
      return new ElementContainer(context, element);
  };
  var parseTree = function (context, element) {
      var container = createContainer(context, element);
      container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;
      parseNodeTree(context, element, container, container);
      return container;
  };
  var createsRealStackingContext = function (node, container, root) {
      return (container.styles.isPositionedWithZIndex() ||
          container.styles.opacity < 1 ||
          container.styles.isTransformed() ||
          (isBodyElement(node) && root.styles.isTransparent()));
  };
  var createsStackingContext = function (styles) { return styles.isPositioned() || styles.isFloating(); };
  var isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
  var isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
  var isHTMLElementNode = function (node) {
      return isElementNode(node) && typeof node.style !== 'undefined' && !isSVGElementNode(node);
  };
  var isSVGElementNode = function (element) {
      return typeof element.className === 'object';
  };
  var isLIElement = function (node) { return node.tagName === 'LI'; };
  var isOLElement = function (node) { return node.tagName === 'OL'; };
  var isInputElement = function (node) { return node.tagName === 'INPUT'; };
  var isHTMLElement = function (node) { return node.tagName === 'HTML'; };
  var isSVGElement = function (node) { return node.tagName === 'svg'; };
  var isBodyElement = function (node) { return node.tagName === 'BODY'; };
  var isCanvasElement = function (node) { return node.tagName === 'CANVAS'; };
  var isVideoElement = function (node) { return node.tagName === 'VIDEO'; };
  var isImageElement = function (node) { return node.tagName === 'IMG'; };
  var isIFrameElement = function (node) { return node.tagName === 'IFRAME'; };
  var isStyleElement = function (node) { return node.tagName === 'STYLE'; };
  var isScriptElement = function (node) { return node.tagName === 'SCRIPT'; };
  var isTextareaElement = function (node) { return node.tagName === 'TEXTAREA'; };
  var isSelectElement = function (node) { return node.tagName === 'SELECT'; };
  var isSlotElement = function (node) { return node.tagName === 'SLOT'; };
  // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
  var isCustomElement = function (node) { return node.tagName.indexOf('-') > 0; };

  var CounterState = /** @class */ (function () {
      function CounterState() {
          this.counters = {};
      }
      CounterState.prototype.getCounterValue = function (name) {
          var counter = this.counters[name];
          if (counter && counter.length) {
              return counter[counter.length - 1];
          }
          return 1;
      };
      CounterState.prototype.getCounterValues = function (name) {
          var counter = this.counters[name];
          return counter ? counter : [];
      };
      CounterState.prototype.pop = function (counters) {
          var _this = this;
          counters.forEach(function (counter) { return _this.counters[counter].pop(); });
      };
      CounterState.prototype.parse = function (style) {
          var _this = this;
          var counterIncrement = style.counterIncrement;
          var counterReset = style.counterReset;
          var canReset = true;
          if (counterIncrement !== null) {
              counterIncrement.forEach(function (entry) {
                  var counter = _this.counters[entry.counter];
                  if (counter && entry.increment !== 0) {
                      canReset = false;
                      if (!counter.length) {
                          counter.push(1);
                      }
                      counter[Math.max(0, counter.length - 1)] += entry.increment;
                  }
              });
          }
          var counterNames = [];
          if (canReset) {
              counterReset.forEach(function (entry) {
                  var counter = _this.counters[entry.counter];
                  counterNames.push(entry.counter);
                  if (!counter) {
                      counter = _this.counters[entry.counter] = [];
                  }
                  counter.push(entry.reset);
              });
          }
          return counterNames;
      };
      return CounterState;
  }());
  var ROMAN_UPPER = {
      integers: [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
      values: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']
  };
  var ARMENIAN = {
      integers: [
          9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70,
          60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
      ],
      values: [
          'Ք',
          'Փ',
          'Ւ',
          'Ց',
          'Ր',
          'Տ',
          'Վ',
          'Ս',
          'Ռ',
          'Ջ',
          'Պ',
          'Չ',
          'Ո',
          'Շ',
          'Ն',
          'Յ',
          'Մ',
          'Ճ',
          'Ղ',
          'Ձ',
          'Հ',
          'Կ',
          'Ծ',
          'Խ',
          'Լ',
          'Ի',
          'Ժ',
          'Թ',
          'Ը',
          'Է',
          'Զ',
          'Ե',
          'Դ',
          'Գ',
          'Բ',
          'Ա'
      ]
  };
  var HEBREW = {
      integers: [
          10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20,
          19, 18, 17, 16, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
      ],
      values: [
          'י׳',
          'ט׳',
          'ח׳',
          'ז׳',
          'ו׳',
          'ה׳',
          'ד׳',
          'ג׳',
          'ב׳',
          'א׳',
          'ת',
          'ש',
          'ר',
          'ק',
          'צ',
          'פ',
          'ע',
          'ס',
          'נ',
          'מ',
          'ל',
          'כ',
          'יט',
          'יח',
          'יז',
          'טז',
          'טו',
          'י',
          'ט',
          'ח',
          'ז',
          'ו',
          'ה',
          'ד',
          'ג',
          'ב',
          'א'
      ]
  };
  var GEORGIAN = {
      integers: [
          10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90,
          80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
      ],
      values: [
          'ჵ',
          'ჰ',
          'ჯ',
          'ჴ',
          'ხ',
          'ჭ',
          'წ',
          'ძ',
          'ც',
          'ჩ',
          'შ',
          'ყ',
          'ღ',
          'ქ',
          'ფ',
          'ჳ',
          'ტ',
          'ს',
          'რ',
          'ჟ',
          'პ',
          'ო',
          'ჲ',
          'ნ',
          'მ',
          'ლ',
          'კ',
          'ი',
          'თ',
          'ჱ',
          'ზ',
          'ვ',
          'ე',
          'დ',
          'გ',
          'ბ',
          'ა'
      ]
  };
  var createAdditiveCounter = function (value, min, max, symbols, fallback, suffix) {
      if (value < min || value > max) {
          return createCounterText(value, fallback, suffix.length > 0);
      }
      return (symbols.integers.reduce(function (string, integer, index) {
          while (value >= integer) {
              value -= integer;
              string += symbols.values[index];
          }
          return string;
      }, '') + suffix);
  };
  var createCounterStyleWithSymbolResolver = function (value, codePointRangeLength, isNumeric, resolver) {
      var string = '';
      do {
          if (!isNumeric) {
              value--;
          }
          string = resolver(value) + string;
          value /= codePointRangeLength;
      } while (value * codePointRangeLength >= codePointRangeLength);
      return string;
  };
  var createCounterStyleFromRange = function (value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
      var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
      return ((value < 0 ? '-' : '') +
          (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function (codePoint) {
              return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
          }) +
              suffix));
  };
  var createCounterStyleFromSymbols = function (value, symbols, suffix) {
      if (suffix === void 0) { suffix = '. '; }
      var codePointRangeLength = symbols.length;
      return (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function (codePoint) { return symbols[Math.floor(codePoint % codePointRangeLength)]; }) + suffix);
  };
  var CJK_ZEROS = 1 << 0;
  var CJK_TEN_COEFFICIENTS = 1 << 1;
  var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
  var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
  var createCJKCounter = function (value, numbers, multipliers, negativeSign, suffix, flags) {
      if (value < -9999 || value > 9999) {
          return createCounterText(value, 4 /* CJK_DECIMAL */, suffix.length > 0);
      }
      var tmp = Math.abs(value);
      var string = suffix;
      if (tmp === 0) {
          return numbers[0] + string;
      }
      for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
          var coefficient = tmp % 10;
          if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== '') {
              string = numbers[coefficient] + string;
          }
          else if (coefficient > 1 ||
              (coefficient === 1 && digit === 0) ||
              (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS)) ||
              (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100) ||
              (coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS))) {
              string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : '') + string;
          }
          else if (coefficient === 1 && digit > 0) {
              string = multipliers[digit - 1] + string;
          }
          tmp = Math.floor(tmp / 10);
      }
      return (value < 0 ? negativeSign : '') + string;
  };
  var CHINESE_INFORMAL_MULTIPLIERS = '十百千萬';
  var CHINESE_FORMAL_MULTIPLIERS = '拾佰仟萬';
  var JAPANESE_NEGATIVE = 'マイナス';
  var KOREAN_NEGATIVE = '마이너스';
  var createCounterText = function (value, type, appendSuffix) {
      var defaultSuffix = appendSuffix ? '. ' : '';
      var cjkSuffix = appendSuffix ? '、' : '';
      var koreanSuffix = appendSuffix ? ', ' : '';
      var spaceSuffix = appendSuffix ? ' ' : '';
      switch (type) {
          case 0 /* DISC */:
              return '•' + spaceSuffix;
          case 1 /* CIRCLE */:
              return '◦' + spaceSuffix;
          case 2 /* SQUARE */:
              return '◾' + spaceSuffix;
          case 5 /* DECIMAL_LEADING_ZERO */:
              var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
              return string.length < 4 ? "0" + string : string;
          case 4 /* CJK_DECIMAL */:
              return createCounterStyleFromSymbols(value, '〇一二三四五六七八九', cjkSuffix);
          case 6 /* LOWER_ROMAN */:
              return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3 /* DECIMAL */, defaultSuffix).toLowerCase();
          case 7 /* UPPER_ROMAN */:
              return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3 /* DECIMAL */, defaultSuffix);
          case 8 /* LOWER_GREEK */:
              return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
          case 9 /* LOWER_ALPHA */:
              return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
          case 10 /* UPPER_ALPHA */:
              return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
          case 11 /* ARABIC_INDIC */:
              return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
          case 12 /* ARMENIAN */:
          case 49 /* UPPER_ARMENIAN */:
              return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3 /* DECIMAL */, defaultSuffix);
          case 35 /* LOWER_ARMENIAN */:
              return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3 /* DECIMAL */, defaultSuffix).toLowerCase();
          case 13 /* BENGALI */:
              return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
          case 14 /* CAMBODIAN */:
          case 30 /* KHMER */:
              return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
          case 15 /* CJK_EARTHLY_BRANCH */:
              return createCounterStyleFromSymbols(value, '子丑寅卯辰巳午未申酉戌亥', cjkSuffix);
          case 16 /* CJK_HEAVENLY_STEM */:
              return createCounterStyleFromSymbols(value, '甲乙丙丁戊己庚辛壬癸', cjkSuffix);
          case 17 /* CJK_IDEOGRAPHIC */:
          case 48 /* TRAD_CHINESE_INFORMAL */:
              return createCJKCounter(value, '零一二三四五六七八九', CHINESE_INFORMAL_MULTIPLIERS, '負', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 47 /* TRAD_CHINESE_FORMAL */:
              return createCJKCounter(value, '零壹貳參肆伍陸柒捌玖', CHINESE_FORMAL_MULTIPLIERS, '負', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 42 /* SIMP_CHINESE_INFORMAL */:
              return createCJKCounter(value, '零一二三四五六七八九', CHINESE_INFORMAL_MULTIPLIERS, '负', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 41 /* SIMP_CHINESE_FORMAL */:
              return createCJKCounter(value, '零壹贰叁肆伍陆柒捌玖', CHINESE_FORMAL_MULTIPLIERS, '负', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
          case 26 /* JAPANESE_INFORMAL */:
              return createCJKCounter(value, '〇一二三四五六七八九', '十百千万', JAPANESE_NEGATIVE, cjkSuffix, 0);
          case 25 /* JAPANESE_FORMAL */:
              return createCJKCounter(value, '零壱弐参四伍六七八九', '拾百千万', JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 31 /* KOREAN_HANGUL_FORMAL */:
              return createCJKCounter(value, '영일이삼사오육칠팔구', '십백천만', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 33 /* KOREAN_HANJA_INFORMAL */:
              return createCJKCounter(value, '零一二三四五六七八九', '十百千萬', KOREAN_NEGATIVE, koreanSuffix, 0);
          case 32 /* KOREAN_HANJA_FORMAL */:
              return createCJKCounter(value, '零壹貳參四五六七八九', '拾百千', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
          case 18 /* DEVANAGARI */:
              return createCounterStyleFromRange(value, 0x966, 0x96f, true, defaultSuffix);
          case 20 /* GEORGIAN */:
              return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3 /* DECIMAL */, defaultSuffix);
          case 21 /* GUJARATI */:
              return createCounterStyleFromRange(value, 0xae6, 0xaef, true, defaultSuffix);
          case 22 /* GURMUKHI */:
              return createCounterStyleFromRange(value, 0xa66, 0xa6f, true, defaultSuffix);
          case 22 /* HEBREW */:
              return createAdditiveCounter(value, 1, 10999, HEBREW, 3 /* DECIMAL */, defaultSuffix);
          case 23 /* HIRAGANA */:
              return createCounterStyleFromSymbols(value, 'あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをん');
          case 24 /* HIRAGANA_IROHA */:
              return createCounterStyleFromSymbols(value, 'いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす');
          case 27 /* KANNADA */:
              return createCounterStyleFromRange(value, 0xce6, 0xcef, true, defaultSuffix);
          case 28 /* KATAKANA */:
              return createCounterStyleFromSymbols(value, 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲン', cjkSuffix);
          case 29 /* KATAKANA_IROHA */:
              return createCounterStyleFromSymbols(value, 'イロハニホヘトチリヌルヲワカヨタレソツネナラムウヰノオクヤマケフコエテアサキユメミシヱヒモセス', cjkSuffix);
          case 34 /* LAO */:
              return createCounterStyleFromRange(value, 0xed0, 0xed9, true, defaultSuffix);
          case 37 /* MONGOLIAN */:
              return createCounterStyleFromRange(value, 0x1810, 0x1819, true, defaultSuffix);
          case 38 /* MYANMAR */:
              return createCounterStyleFromRange(value, 0x1040, 0x1049, true, defaultSuffix);
          case 39 /* ORIYA */:
              return createCounterStyleFromRange(value, 0xb66, 0xb6f, true, defaultSuffix);
          case 40 /* PERSIAN */:
              return createCounterStyleFromRange(value, 0x6f0, 0x6f9, true, defaultSuffix);
          case 43 /* TAMIL */:
              return createCounterStyleFromRange(value, 0xbe6, 0xbef, true, defaultSuffix);
          case 44 /* TELUGU */:
              return createCounterStyleFromRange(value, 0xc66, 0xc6f, true, defaultSuffix);
          case 45 /* THAI */:
              return createCounterStyleFromRange(value, 0xe50, 0xe59, true, defaultSuffix);
          case 46 /* TIBETAN */:
              return createCounterStyleFromRange(value, 0xf20, 0xf29, true, defaultSuffix);
          case 3 /* DECIMAL */:
          default:
              return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
      }
  };

  var IGNORE_ATTRIBUTE = 'data-html2canvas-ignore';
  var DocumentCloner = /** @class */ (function () {
      function DocumentCloner(context, element, options) {
          this.context = context;
          this.options = options;
          this.scrolledElements = [];
          this.referenceElement = element;
          this.counters = new CounterState();
          this.quoteDepth = 0;
          if (!element.ownerDocument) {
              throw new Error('Cloned element does not have an owner document');
          }
          this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
      }
      DocumentCloner.prototype.toIFrame = function (ownerDocument, windowSize) {
          var _this = this;
          var iframe = createIFrameContainer(ownerDocument, windowSize);
          if (!iframe.contentWindow) {
              return Promise.reject("Unable to find iframe window");
          }
          var scrollX = ownerDocument.defaultView.pageXOffset;
          var scrollY = ownerDocument.defaultView.pageYOffset;
          var cloneWindow = iframe.contentWindow;
          var documentClone = cloneWindow.document;
          /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
           if window url is about:blank, we can assign the url to current by writing onto the document
           */
          var iframeLoad = iframeLoader(iframe).then(function () { return __awaiter(_this, void 0, void 0, function () {
              var onclone, referenceElement;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          this.scrolledElements.forEach(restoreNodeScroll);
                          if (cloneWindow) {
                              cloneWindow.scrollTo(windowSize.left, windowSize.top);
                              if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) &&
                                  (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                                  this.context.logger.warn('Unable to restore scroll position for cloned document');
                                  this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                              }
                          }
                          onclone = this.options.onclone;
                          referenceElement = this.clonedReferenceElement;
                          if (typeof referenceElement === 'undefined') {
                              return [2 /*return*/, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                          }
                          if (!(documentClone.fonts && documentClone.fonts.ready)) return [3 /*break*/, 2];
                          return [4 /*yield*/, documentClone.fonts.ready];
                      case 1:
                          _a.sent();
                          _a.label = 2;
                      case 2:
                          if (!/(AppleWebKit)/g.test(navigator.userAgent)) return [3 /*break*/, 4];
                          return [4 /*yield*/, imagesReady(documentClone)];
                      case 3:
                          _a.sent();
                          _a.label = 4;
                      case 4:
                          if (typeof onclone === 'function') {
                              return [2 /*return*/, Promise.resolve()
                                      .then(function () { return onclone(documentClone, referenceElement); })
                                      .then(function () { return iframe; })];
                          }
                          return [2 /*return*/, iframe];
                  }
              });
          }); });
          documentClone.open();
          documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
          // Chrome scrolls the parent document for some reason after the write to the cloned window???
          restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
          documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
          documentClone.close();
          return iframeLoad;
      };
      DocumentCloner.prototype.createElementClone = function (node) {
          if (isDebugging(node, 2 /* CLONE */)) {
              debugger;
          }
          if (isCanvasElement(node)) {
              return this.createCanvasClone(node);
          }
          if (isVideoElement(node)) {
              return this.createVideoClone(node);
          }
          if (isStyleElement(node)) {
              return this.createStyleClone(node);
          }
          var clone = node.cloneNode(false);
          if (isImageElement(clone)) {
              if (isImageElement(node) && node.currentSrc && node.currentSrc !== node.src) {
                  clone.src = node.currentSrc;
                  clone.srcset = '';
              }
              if (clone.loading === 'lazy') {
                  clone.loading = 'eager';
              }
          }
          if (isCustomElement(clone)) {
              return this.createCustomElementClone(clone);
          }
          return clone;
      };
      DocumentCloner.prototype.createCustomElementClone = function (node) {
          var clone = document.createElement('html2canvascustomelement');
          copyCSSStyles(node.style, clone);
          return clone;
      };
      DocumentCloner.prototype.createStyleClone = function (node) {
          try {
              var sheet = node.sheet;
              if (sheet && sheet.cssRules) {
                  var css = [].slice.call(sheet.cssRules, 0).reduce(function (css, rule) {
                      if (rule && typeof rule.cssText === 'string') {
                          return css + rule.cssText;
                      }
                      return css;
                  }, '');
                  var style = node.cloneNode(false);
                  style.textContent = css;
                  return style;
              }
          }
          catch (e) {
              // accessing node.sheet.cssRules throws a DOMException
              this.context.logger.error('Unable to access cssRules property', e);
              if (e.name !== 'SecurityError') {
                  throw e;
              }
          }
          return node.cloneNode(false);
      };
      DocumentCloner.prototype.createCanvasClone = function (canvas) {
          var _a;
          if (this.options.inlineImages && canvas.ownerDocument) {
              var img = canvas.ownerDocument.createElement('img');
              try {
                  img.src = canvas.toDataURL();
                  return img;
              }
              catch (e) {
                  this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
              }
          }
          var clonedCanvas = canvas.cloneNode(false);
          try {
              clonedCanvas.width = canvas.width;
              clonedCanvas.height = canvas.height;
              var ctx = canvas.getContext('2d');
              var clonedCtx = clonedCanvas.getContext('2d');
              if (clonedCtx) {
                  if (!this.options.allowTaint && ctx) {
                      clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
                  }
                  else {
                      var gl = (_a = canvas.getContext('webgl2')) !== null && _a !== void 0 ? _a : canvas.getContext('webgl');
                      if (gl) {
                          var attribs = gl.getContextAttributes();
                          if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
                              this.context.logger.warn('Unable to clone WebGL context as it has preserveDrawingBuffer=false', canvas);
                          }
                      }
                      clonedCtx.drawImage(canvas, 0, 0);
                  }
              }
              return clonedCanvas;
          }
          catch (e) {
              this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
          }
          return clonedCanvas;
      };
      DocumentCloner.prototype.createVideoClone = function (video) {
          var canvas = video.ownerDocument.createElement('canvas');
          canvas.width = video.offsetWidth;
          canvas.height = video.offsetHeight;
          var ctx = canvas.getContext('2d');
          try {
              if (ctx) {
                  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                  if (!this.options.allowTaint) {
                      ctx.getImageData(0, 0, canvas.width, canvas.height);
                  }
              }
              return canvas;
          }
          catch (e) {
              this.context.logger.info("Unable to clone video as it is tainted", video);
          }
          var blankCanvas = video.ownerDocument.createElement('canvas');
          blankCanvas.width = video.offsetWidth;
          blankCanvas.height = video.offsetHeight;
          return blankCanvas;
      };
      DocumentCloner.prototype.appendChildNode = function (clone, child, copyStyles) {
          if (!isElementNode(child) ||
              (!isScriptElement(child) &&
                  !child.hasAttribute(IGNORE_ATTRIBUTE) &&
                  (typeof this.options.ignoreElements !== 'function' || !this.options.ignoreElements(child)))) {
              if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
                  clone.appendChild(this.cloneNode(child, copyStyles));
              }
          }
      };
      DocumentCloner.prototype.cloneChildNodes = function (node, clone, copyStyles) {
          var _this = this;
          for (var child = node.shadowRoot ? node.shadowRoot.firstChild : node.firstChild; child; child = child.nextSibling) {
              if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === 'function') {
                  var assignedNodes = child.assignedNodes();
                  if (assignedNodes.length) {
                      assignedNodes.forEach(function (assignedNode) { return _this.appendChildNode(clone, assignedNode, copyStyles); });
                  }
              }
              else {
                  this.appendChildNode(clone, child, copyStyles);
              }
          }
      };
      DocumentCloner.prototype.cloneNode = function (node, copyStyles) {
          if (isTextNode(node)) {
              return document.createTextNode(node.data);
          }
          if (!node.ownerDocument) {
              return node.cloneNode(false);
          }
          var window = node.ownerDocument.defaultView;
          if (window && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {
              var clone = this.createElementClone(node);
              clone.style.transitionProperty = 'none';
              var style = window.getComputedStyle(node);
              var styleBefore = window.getComputedStyle(node, ':before');
              var styleAfter = window.getComputedStyle(node, ':after');
              if (this.referenceElement === node && isHTMLElementNode(clone)) {
                  this.clonedReferenceElement = clone;
              }
              if (isBodyElement(clone)) {
                  createPseudoHideStyles(clone);
              }
              var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
              var before = this.resolvePseudoContent(node, clone, styleBefore, PseudoElementType.BEFORE);
              if (isCustomElement(node)) {
                  copyStyles = true;
              }
              if (!isVideoElement(node)) {
                  this.cloneChildNodes(node, clone, copyStyles);
              }
              if (before) {
                  clone.insertBefore(before, clone.firstChild);
              }
              var after = this.resolvePseudoContent(node, clone, styleAfter, PseudoElementType.AFTER);
              if (after) {
                  clone.appendChild(after);
              }
              this.counters.pop(counters);
              if ((style && (this.options.copyStyles || isSVGElementNode(node)) && !isIFrameElement(node)) ||
                  copyStyles) {
                  copyCSSStyles(style, clone);
              }
              if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
                  this.scrolledElements.push([clone, node.scrollLeft, node.scrollTop]);
              }
              if ((isTextareaElement(node) || isSelectElement(node)) &&
                  (isTextareaElement(clone) || isSelectElement(clone))) {
                  clone.value = node.value;
              }
              return clone;
          }
          return node.cloneNode(false);
      };
      DocumentCloner.prototype.resolvePseudoContent = function (node, clone, style, pseudoElt) {
          var _this = this;
          if (!style) {
              return;
          }
          var value = style.content;
          var document = clone.ownerDocument;
          if (!document || !value || value === 'none' || value === '-moz-alt-content' || style.display === 'none') {
              return;
          }
          this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
          var declaration = new CSSParsedPseudoDeclaration(this.context, style);
          var anonymousReplacedElement = document.createElement('html2canvaspseudoelement');
          copyCSSStyles(style, anonymousReplacedElement);
          declaration.content.forEach(function (token) {
              if (token.type === 0 /* STRING_TOKEN */) {
                  anonymousReplacedElement.appendChild(document.createTextNode(token.value));
              }
              else if (token.type === 22 /* URL_TOKEN */) {
                  var img = document.createElement('img');
                  img.src = token.value;
                  img.style.opacity = '1';
                  anonymousReplacedElement.appendChild(img);
              }
              else if (token.type === 18 /* FUNCTION */) {
                  if (token.name === 'attr') {
                      var attr = token.values.filter(isIdentToken);
                      if (attr.length) {
                          anonymousReplacedElement.appendChild(document.createTextNode(node.getAttribute(attr[0].value) || ''));
                      }
                  }
                  else if (token.name === 'counter') {
                      var _a = token.values.filter(nonFunctionArgSeparator), counter = _a[0], counterStyle = _a[1];
                      if (counter && isIdentToken(counter)) {
                          var counterState = _this.counters.getCounterValue(counter.value);
                          var counterType = counterStyle && isIdentToken(counterStyle)
                              ? listStyleType.parse(_this.context, counterStyle.value)
                              : 3 /* DECIMAL */;
                          anonymousReplacedElement.appendChild(document.createTextNode(createCounterText(counterState, counterType, false)));
                      }
                  }
                  else if (token.name === 'counters') {
                      var _b = token.values.filter(nonFunctionArgSeparator), counter = _b[0], delim = _b[1], counterStyle = _b[2];
                      if (counter && isIdentToken(counter)) {
                          var counterStates = _this.counters.getCounterValues(counter.value);
                          var counterType_1 = counterStyle && isIdentToken(counterStyle)
                              ? listStyleType.parse(_this.context, counterStyle.value)
                              : 3 /* DECIMAL */;
                          var separator = delim && delim.type === 0 /* STRING_TOKEN */ ? delim.value : '';
                          var text = counterStates
                              .map(function (value) { return createCounterText(value, counterType_1, false); })
                              .join(separator);
                          anonymousReplacedElement.appendChild(document.createTextNode(text));
                      }
                  }
                  else ;
              }
              else if (token.type === 20 /* IDENT_TOKEN */) {
                  switch (token.value) {
                      case 'open-quote':
                          anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
                          break;
                      case 'close-quote':
                          anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
                          break;
                      default:
                          // safari doesn't parse string tokens correctly because of lack of quotes
                          anonymousReplacedElement.appendChild(document.createTextNode(token.value));
                  }
              }
          });
          anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
          var newClassName = pseudoElt === PseudoElementType.BEFORE
              ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE
              : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
          if (isSVGElementNode(clone)) {
              clone.className.baseValue += newClassName;
          }
          else {
              clone.className += newClassName;
          }
          return anonymousReplacedElement;
      };
      DocumentCloner.destroy = function (container) {
          if (container.parentNode) {
              container.parentNode.removeChild(container);
              return true;
          }
          return false;
      };
      return DocumentCloner;
  }());
  var PseudoElementType;
  (function (PseudoElementType) {
      PseudoElementType[PseudoElementType["BEFORE"] = 0] = "BEFORE";
      PseudoElementType[PseudoElementType["AFTER"] = 1] = "AFTER";
  })(PseudoElementType || (PseudoElementType = {}));
  var createIFrameContainer = function (ownerDocument, bounds) {
      var cloneIframeContainer = ownerDocument.createElement('iframe');
      cloneIframeContainer.className = 'html2canvas-container';
      cloneIframeContainer.style.visibility = 'hidden';
      cloneIframeContainer.style.position = 'fixed';
      cloneIframeContainer.style.left = '-10000px';
      cloneIframeContainer.style.top = '0px';
      cloneIframeContainer.style.border = '0';
      cloneIframeContainer.width = bounds.width.toString();
      cloneIframeContainer.height = bounds.height.toString();
      cloneIframeContainer.scrolling = 'no'; // ios won't scroll without it
      cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, 'true');
      ownerDocument.body.appendChild(cloneIframeContainer);
      return cloneIframeContainer;
  };
  var imageReady = function (img) {
      return new Promise(function (resolve) {
          if (img.complete) {
              resolve();
              return;
          }
          if (!img.src) {
              resolve();
              return;
          }
          img.onload = resolve;
          img.onerror = resolve;
      });
  };
  var imagesReady = function (document) {
      return Promise.all([].slice.call(document.images, 0).map(imageReady));
  };
  var iframeLoader = function (iframe) {
      return new Promise(function (resolve, reject) {
          var cloneWindow = iframe.contentWindow;
          if (!cloneWindow) {
              return reject("No window assigned for iframe");
          }
          var documentClone = cloneWindow.document;
          cloneWindow.onload = iframe.onload = function () {
              cloneWindow.onload = iframe.onload = null;
              var interval = setInterval(function () {
                  if (documentClone.body.childNodes.length > 0 && documentClone.readyState === 'complete') {
                      clearInterval(interval);
                      resolve(iframe);
                  }
              }, 50);
          };
      });
  };
  var ignoredStyleProperties = [
      'all',
      'd',
      'content' // Safari shows pseudoelements if content is set
  ];
  var copyCSSStyles = function (style, target) {
      // Edge does not provide value for cssText
      for (var i = style.length - 1; i >= 0; i--) {
          var property = style.item(i);
          if (ignoredStyleProperties.indexOf(property) === -1) {
              target.style.setProperty(property, style.getPropertyValue(property));
          }
      }
      return target;
  };
  var serializeDoctype = function (doctype) {
      var str = '';
      if (doctype) {
          str += '<!DOCTYPE ';
          if (doctype.name) {
              str += doctype.name;
          }
          if (doctype.internalSubset) {
              str += doctype.internalSubset;
          }
          if (doctype.publicId) {
              str += "\"" + doctype.publicId + "\"";
          }
          if (doctype.systemId) {
              str += "\"" + doctype.systemId + "\"";
          }
          str += '>';
      }
      return str;
  };
  var restoreOwnerScroll = function (ownerDocument, x, y) {
      if (ownerDocument &&
          ownerDocument.defaultView &&
          (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
          ownerDocument.defaultView.scrollTo(x, y);
      }
  };
  var restoreNodeScroll = function (_a) {
      var element = _a[0], x = _a[1], y = _a[2];
      element.scrollLeft = x;
      element.scrollTop = y;
  };
  var PSEUDO_BEFORE = ':before';
  var PSEUDO_AFTER = ':after';
  var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = '___html2canvas___pseudoelement_before';
  var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = '___html2canvas___pseudoelement_after';
  var PSEUDO_HIDE_ELEMENT_STYLE = "{\n    content: \"\" !important;\n    display: none !important;\n}";
  var createPseudoHideStyles = function (body) {
      createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
  };
  var createStyles = function (body, styles) {
      var document = body.ownerDocument;
      if (document) {
          var style = document.createElement('style');
          style.textContent = styles;
          body.appendChild(style);
      }
  };

  var CacheStorage = /** @class */ (function () {
      function CacheStorage() {
      }
      CacheStorage.getOrigin = function (url) {
          var link = CacheStorage._link;
          if (!link) {
              return 'about:blank';
          }
          link.href = url;
          link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/
          return link.protocol + link.hostname + link.port;
      };
      CacheStorage.isSameOrigin = function (src) {
          return CacheStorage.getOrigin(src) === CacheStorage._origin;
      };
      CacheStorage.setContext = function (window) {
          CacheStorage._link = window.document.createElement('a');
          CacheStorage._origin = CacheStorage.getOrigin(window.location.href);
      };
      CacheStorage._origin = 'about:blank';
      return CacheStorage;
  }());
  var Cache = /** @class */ (function () {
      function Cache(context, _options) {
          this.context = context;
          this._options = _options;
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          this._cache = {};
      }
      Cache.prototype.addImage = function (src) {
          var result = Promise.resolve();
          if (this.has(src)) {
              return result;
          }
          if (isBlobImage(src) || isRenderable(src)) {
              (this._cache[src] = this.loadImage(src)).catch(function () {
                  // prevent unhandled rejection
              });
              return result;
          }
          return result;
      };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Cache.prototype.match = function (src) {
          return this._cache[src];
      };
      Cache.prototype.loadImage = function (key) {
          return __awaiter(this, void 0, void 0, function () {
              var isSameOrigin, useCORS, useProxy, src;
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          isSameOrigin = CacheStorage.isSameOrigin(key);
                          useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
                          useProxy = !isInlineImage(key) &&
                              !isSameOrigin &&
                              !isBlobImage(key) &&
                              typeof this._options.proxy === 'string' &&
                              FEATURES.SUPPORT_CORS_XHR &&
                              !useCORS;
                          if (!isSameOrigin &&
                              this._options.allowTaint === false &&
                              !isInlineImage(key) &&
                              !isBlobImage(key) &&
                              !useProxy &&
                              !useCORS) {
                              return [2 /*return*/];
                          }
                          src = key;
                          if (!useProxy) return [3 /*break*/, 2];
                          return [4 /*yield*/, this.proxy(src)];
                      case 1:
                          src = _a.sent();
                          _a.label = 2;
                      case 2:
                          this.context.logger.debug("Added image " + key.substring(0, 256));
                          return [4 /*yield*/, new Promise(function (resolve, reject) {
                                  var img = new Image();
                                  img.onload = function () { return resolve(img); };
                                  img.onerror = reject;
                                  //ios safari 10.3 taints canvas with data urls unless crossOrigin is set to anonymous
                                  if (isInlineBase64Image(src) || useCORS) {
                                      img.crossOrigin = 'anonymous';
                                  }
                                  img.src = src;
                                  if (img.complete === true) {
                                      // Inline XML images may fail to parse, throwing an Error later on
                                      setTimeout(function () { return resolve(img); }, 500);
                                  }
                                  if (_this._options.imageTimeout > 0) {
                                      setTimeout(function () { return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image"); }, _this._options.imageTimeout);
                                  }
                              })];
                      case 3: return [2 /*return*/, _a.sent()];
                  }
              });
          });
      };
      Cache.prototype.has = function (key) {
          return typeof this._cache[key] !== 'undefined';
      };
      Cache.prototype.keys = function () {
          return Promise.resolve(Object.keys(this._cache));
      };
      Cache.prototype.proxy = function (src) {
          var _this = this;
          var proxy = this._options.proxy;
          if (!proxy) {
              throw new Error('No proxy defined');
          }
          var key = src.substring(0, 256);
          return new Promise(function (resolve, reject) {
              var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? 'blob' : 'text';
              var xhr = new XMLHttpRequest();
              xhr.onload = function () {
                  if (xhr.status === 200) {
                      if (responseType === 'text') {
                          resolve(xhr.response);
                      }
                      else {
                          var reader_1 = new FileReader();
                          reader_1.addEventListener('load', function () { return resolve(reader_1.result); }, false);
                          reader_1.addEventListener('error', function (e) { return reject(e); }, false);
                          reader_1.readAsDataURL(xhr.response);
                      }
                  }
                  else {
                      reject("Failed to proxy resource " + key + " with status code " + xhr.status);
                  }
              };
              xhr.onerror = reject;
              var queryString = proxy.indexOf('?') > -1 ? '&' : '?';
              xhr.open('GET', "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
              if (responseType !== 'text' && xhr instanceof XMLHttpRequest) {
                  xhr.responseType = responseType;
              }
              if (_this._options.imageTimeout) {
                  var timeout_1 = _this._options.imageTimeout;
                  xhr.timeout = timeout_1;
                  xhr.ontimeout = function () { return reject("Timed out (" + timeout_1 + "ms) proxying " + key); };
              }
              xhr.send();
          });
      };
      return Cache;
  }());
  var INLINE_SVG = /^data:image\/svg\+xml/i;
  var INLINE_BASE64 = /^data:image\/.*;base64,/i;
  var INLINE_IMG = /^data:image\/.*/i;
  var isRenderable = function (src) { return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src); };
  var isInlineImage = function (src) { return INLINE_IMG.test(src); };
  var isInlineBase64Image = function (src) { return INLINE_BASE64.test(src); };
  var isBlobImage = function (src) { return src.substr(0, 4) === 'blob'; };
  var isSVG = function (src) { return src.substr(-3).toLowerCase() === 'svg' || INLINE_SVG.test(src); };

  var Vector = /** @class */ (function () {
      function Vector(x, y) {
          this.type = 0 /* VECTOR */;
          this.x = x;
          this.y = y;
      }
      Vector.prototype.add = function (deltaX, deltaY) {
          return new Vector(this.x + deltaX, this.y + deltaY);
      };
      return Vector;
  }());

  var lerp = function (a, b, t) {
      return new Vector(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t);
  };
  var BezierCurve = /** @class */ (function () {
      function BezierCurve(start, startControl, endControl, end) {
          this.type = 1 /* BEZIER_CURVE */;
          this.start = start;
          this.startControl = startControl;
          this.endControl = endControl;
          this.end = end;
      }
      BezierCurve.prototype.subdivide = function (t, firstHalf) {
          var ab = lerp(this.start, this.startControl, t);
          var bc = lerp(this.startControl, this.endControl, t);
          var cd = lerp(this.endControl, this.end, t);
          var abbc = lerp(ab, bc, t);
          var bccd = lerp(bc, cd, t);
          var dest = lerp(abbc, bccd, t);
          return firstHalf ? new BezierCurve(this.start, ab, abbc, dest) : new BezierCurve(dest, bccd, cd, this.end);
      };
      BezierCurve.prototype.add = function (deltaX, deltaY) {
          return new BezierCurve(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
      };
      BezierCurve.prototype.reverse = function () {
          return new BezierCurve(this.end, this.endControl, this.startControl, this.start);
      };
      return BezierCurve;
  }());
  var isBezierCurve = function (path) { return path.type === 1 /* BEZIER_CURVE */; };

  var BoundCurves = /** @class */ (function () {
      function BoundCurves(element) {
          var styles = element.styles;
          var bounds = element.bounds;
          var _a = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a[0], tlv = _a[1];
          var _b = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b[0], trv = _b[1];
          var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
          var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
          var factors = [];
          factors.push((tlh + trh) / bounds.width);
          factors.push((blh + brh) / bounds.width);
          factors.push((tlv + blv) / bounds.height);
          factors.push((trv + brv) / bounds.height);
          var maxFactor = Math.max.apply(Math, factors);
          if (maxFactor > 1) {
              tlh /= maxFactor;
              tlv /= maxFactor;
              trh /= maxFactor;
              trv /= maxFactor;
              brh /= maxFactor;
              brv /= maxFactor;
              blh /= maxFactor;
              blv /= maxFactor;
          }
          var topWidth = bounds.width - trh;
          var rightHeight = bounds.height - brv;
          var bottomWidth = bounds.width - brh;
          var leftHeight = bounds.height - blv;
          var borderTopWidth = styles.borderTopWidth;
          var borderRightWidth = styles.borderRightWidth;
          var borderBottomWidth = styles.borderBottomWidth;
          var borderLeftWidth = styles.borderLeftWidth;
          var paddingTop = getAbsoluteValue(styles.paddingTop, element.bounds.width);
          var paddingRight = getAbsoluteValue(styles.paddingRight, element.bounds.width);
          var paddingBottom = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
          var paddingLeft = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
          this.topLeftBorderDoubleOuterBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth / 3, bounds.top + borderTopWidth / 3, tlh - borderLeftWidth / 3, tlv - borderTopWidth / 3, CORNER.TOP_LEFT)
                  : new Vector(bounds.left + borderLeftWidth / 3, bounds.top + borderTopWidth / 3);
          this.topRightBorderDoubleOuterBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth / 3, trh - borderRightWidth / 3, trv - borderTopWidth / 3, CORNER.TOP_RIGHT)
                  : new Vector(bounds.left + bounds.width - borderRightWidth / 3, bounds.top + borderTopWidth / 3);
          this.bottomRightBorderDoubleOuterBox =
              brh > 0 || brv > 0
                  ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth / 3, brv - borderBottomWidth / 3, CORNER.BOTTOM_RIGHT)
                  : new Vector(bounds.left + bounds.width - borderRightWidth / 3, bounds.top + bounds.height - borderBottomWidth / 3);
          this.bottomLeftBorderDoubleOuterBox =
              blh > 0 || blv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth / 3, bounds.top + leftHeight, blh - borderLeftWidth / 3, blv - borderBottomWidth / 3, CORNER.BOTTOM_LEFT)
                  : new Vector(bounds.left + borderLeftWidth / 3, bounds.top + bounds.height - borderBottomWidth / 3);
          this.topLeftBorderDoubleInnerBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3, tlh - (borderLeftWidth * 2) / 3, tlv - (borderTopWidth * 2) / 3, CORNER.TOP_LEFT)
                  : new Vector(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3);
          this.topRightBorderDoubleInnerBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + topWidth, bounds.top + (borderTopWidth * 2) / 3, trh - (borderRightWidth * 2) / 3, trv - (borderTopWidth * 2) / 3, CORNER.TOP_RIGHT)
                  : new Vector(bounds.left + bounds.width - (borderRightWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3);
          this.bottomRightBorderDoubleInnerBox =
              brh > 0 || brv > 0
                  ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - (borderRightWidth * 2) / 3, brv - (borderBottomWidth * 2) / 3, CORNER.BOTTOM_RIGHT)
                  : new Vector(bounds.left + bounds.width - (borderRightWidth * 2) / 3, bounds.top + bounds.height - (borderBottomWidth * 2) / 3);
          this.bottomLeftBorderDoubleInnerBox =
              blh > 0 || blv > 0
                  ? getCurvePoints(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + leftHeight, blh - (borderLeftWidth * 2) / 3, blv - (borderBottomWidth * 2) / 3, CORNER.BOTTOM_LEFT)
                  : new Vector(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + bounds.height - (borderBottomWidth * 2) / 3);
          this.topLeftBorderStroke =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth / 2, bounds.top + borderTopWidth / 2, tlh - borderLeftWidth / 2, tlv - borderTopWidth / 2, CORNER.TOP_LEFT)
                  : new Vector(bounds.left + borderLeftWidth / 2, bounds.top + borderTopWidth / 2);
          this.topRightBorderStroke =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth / 2, trh - borderRightWidth / 2, trv - borderTopWidth / 2, CORNER.TOP_RIGHT)
                  : new Vector(bounds.left + bounds.width - borderRightWidth / 2, bounds.top + borderTopWidth / 2);
          this.bottomRightBorderStroke =
              brh > 0 || brv > 0
                  ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth / 2, brv - borderBottomWidth / 2, CORNER.BOTTOM_RIGHT)
                  : new Vector(bounds.left + bounds.width - borderRightWidth / 2, bounds.top + bounds.height - borderBottomWidth / 2);
          this.bottomLeftBorderStroke =
              blh > 0 || blv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth / 2, bounds.top + leftHeight, blh - borderLeftWidth / 2, blv - borderBottomWidth / 2, CORNER.BOTTOM_LEFT)
                  : new Vector(bounds.left + borderLeftWidth / 2, bounds.top + bounds.height - borderBottomWidth / 2);
          this.topLeftBorderBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT)
                  : new Vector(bounds.left, bounds.top);
          this.topRightBorderBox =
              trh > 0 || trv > 0
                  ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT)
                  : new Vector(bounds.left + bounds.width, bounds.top);
          this.bottomRightBorderBox =
              brh > 0 || brv > 0
                  ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT)
                  : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
          this.bottomLeftBorderBox =
              blh > 0 || blv > 0
                  ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT)
                  : new Vector(bounds.left, bounds.top + bounds.height);
          this.topLeftPaddingBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth, bounds.top + borderTopWidth, Math.max(0, tlh - borderLeftWidth), Math.max(0, tlv - borderTopWidth), CORNER.TOP_LEFT)
                  : new Vector(bounds.left + borderLeftWidth, bounds.top + borderTopWidth);
          this.topRightPaddingBox =
              trh > 0 || trv > 0
                  ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth), bounds.top + borderTopWidth, topWidth > bounds.width + borderRightWidth ? 0 : Math.max(0, trh - borderRightWidth), Math.max(0, trv - borderTopWidth), CORNER.TOP_RIGHT)
                  : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + borderTopWidth);
          this.bottomRightPaddingBox =
              brh > 0 || brv > 0
                  ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth), Math.max(0, brh - borderRightWidth), Math.max(0, brv - borderBottomWidth), CORNER.BOTTOM_RIGHT)
                  : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + bounds.height - borderBottomWidth);
          this.bottomLeftPaddingBox =
              blh > 0 || blv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth), Math.max(0, blh - borderLeftWidth), Math.max(0, blv - borderBottomWidth), CORNER.BOTTOM_LEFT)
                  : new Vector(bounds.left + borderLeftWidth, bounds.top + bounds.height - borderBottomWidth);
          this.topLeftContentBox =
              tlh > 0 || tlv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop, Math.max(0, tlh - (borderLeftWidth + paddingLeft)), Math.max(0, tlv - (borderTopWidth + paddingTop)), CORNER.TOP_LEFT)
                  : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop);
          this.topRightContentBox =
              trh > 0 || trv > 0
                  ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth + paddingLeft), bounds.top + borderTopWidth + paddingTop, topWidth > bounds.width + borderLeftWidth + paddingLeft ? 0 : trh - borderLeftWidth + paddingLeft, trv - (borderTopWidth + paddingTop), CORNER.TOP_RIGHT)
                  : new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + borderTopWidth + paddingTop);
          this.bottomRightContentBox =
              brh > 0 || brv > 0
                  ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth + paddingLeft)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth + paddingTop), Math.max(0, brh - (borderRightWidth + paddingRight)), brv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_RIGHT)
                  : new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + bounds.height - (borderBottomWidth + paddingBottom));
          this.bottomLeftContentBox =
              blh > 0 || blv > 0
                  ? getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth + paddingLeft)), blv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_LEFT)
                  : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + bounds.height - (borderBottomWidth + paddingBottom));
      }
      return BoundCurves;
  }());
  var CORNER;
  (function (CORNER) {
      CORNER[CORNER["TOP_LEFT"] = 0] = "TOP_LEFT";
      CORNER[CORNER["TOP_RIGHT"] = 1] = "TOP_RIGHT";
      CORNER[CORNER["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
      CORNER[CORNER["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
  })(CORNER || (CORNER = {}));
  var getCurvePoints = function (x, y, r1, r2, position) {
      var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
      var ox = r1 * kappa; // control point offset horizontal
      var oy = r2 * kappa; // control point offset vertical
      var xm = x + r1; // x-middle
      var ym = y + r2; // y-middle
      switch (position) {
          case CORNER.TOP_LEFT:
              return new BezierCurve(new Vector(x, ym), new Vector(x, ym - oy), new Vector(xm - ox, y), new Vector(xm, y));
          case CORNER.TOP_RIGHT:
              return new BezierCurve(new Vector(x, y), new Vector(x + ox, y), new Vector(xm, ym - oy), new Vector(xm, ym));
          case CORNER.BOTTOM_RIGHT:
              return new BezierCurve(new Vector(xm, y), new Vector(xm, y + oy), new Vector(x + ox, ym), new Vector(x, ym));
          case CORNER.BOTTOM_LEFT:
          default:
              return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x, y + oy), new Vector(x, y));
      }
  };
  var calculateBorderBoxPath = function (curves) {
      return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
  };
  var calculateContentBoxPath = function (curves) {
      return [
          curves.topLeftContentBox,
          curves.topRightContentBox,
          curves.bottomRightContentBox,
          curves.bottomLeftContentBox
      ];
  };
  var calculatePaddingBoxPath = function (curves) {
      return [
          curves.topLeftPaddingBox,
          curves.topRightPaddingBox,
          curves.bottomRightPaddingBox,
          curves.bottomLeftPaddingBox
      ];
  };

  var TransformEffect = /** @class */ (function () {
      function TransformEffect(offsetX, offsetY, matrix) {
          this.offsetX = offsetX;
          this.offsetY = offsetY;
          this.matrix = matrix;
          this.type = 0 /* TRANSFORM */;
          this.target = 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */;
      }
      return TransformEffect;
  }());
  var ClipEffect = /** @class */ (function () {
      function ClipEffect(path, target) {
          this.path = path;
          this.target = target;
          this.type = 1 /* CLIP */;
      }
      return ClipEffect;
  }());
  var OpacityEffect = /** @class */ (function () {
      function OpacityEffect(opacity) {
          this.opacity = opacity;
          this.type = 2 /* OPACITY */;
          this.target = 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */;
      }
      return OpacityEffect;
  }());
  var isTransformEffect = function (effect) {
      return effect.type === 0 /* TRANSFORM */;
  };
  var isClipEffect = function (effect) { return effect.type === 1 /* CLIP */; };
  var isOpacityEffect = function (effect) { return effect.type === 2 /* OPACITY */; };

  var equalPath = function (a, b) {
      if (a.length === b.length) {
          return a.some(function (v, i) { return v === b[i]; });
      }
      return false;
  };
  var transformPath = function (path, deltaX, deltaY, deltaW, deltaH) {
      return path.map(function (point, index) {
          switch (index) {
              case 0:
                  return point.add(deltaX, deltaY);
              case 1:
                  return point.add(deltaX + deltaW, deltaY);
              case 2:
                  return point.add(deltaX + deltaW, deltaY + deltaH);
              case 3:
                  return point.add(deltaX, deltaY + deltaH);
          }
          return point;
      });
  };

  var StackingContext = /** @class */ (function () {
      function StackingContext(container) {
          this.element = container;
          this.inlineLevel = [];
          this.nonInlineLevel = [];
          this.negativeZIndex = [];
          this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
          this.positiveZIndex = [];
          this.nonPositionedFloats = [];
          this.nonPositionedInlineLevel = [];
      }
      return StackingContext;
  }());
  var ElementPaint = /** @class */ (function () {
      function ElementPaint(container, parent) {
          this.container = container;
          this.parent = parent;
          this.effects = [];
          this.curves = new BoundCurves(this.container);
          if (this.container.styles.opacity < 1) {
              this.effects.push(new OpacityEffect(this.container.styles.opacity));
          }
          if (this.container.styles.transform !== null) {
              var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
              var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
              var matrix = this.container.styles.transform;
              this.effects.push(new TransformEffect(offsetX, offsetY, matrix));
          }
          if (this.container.styles.overflowX !== 0 /* VISIBLE */) {
              var borderBox = calculateBorderBoxPath(this.curves);
              var paddingBox = calculatePaddingBoxPath(this.curves);
              if (equalPath(borderBox, paddingBox)) {
                  this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));
              }
              else {
                  this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */));
                  this.effects.push(new ClipEffect(paddingBox, 4 /* CONTENT */));
              }
          }
      }
      ElementPaint.prototype.getEffects = function (target) {
          var inFlow = [2 /* ABSOLUTE */, 3 /* FIXED */].indexOf(this.container.styles.position) === -1;
          var parent = this.parent;
          var effects = this.effects.slice(0);
          while (parent) {
              var croplessEffects = parent.effects.filter(function (effect) { return !isClipEffect(effect); });
              if (inFlow || parent.container.styles.position !== 0 /* STATIC */ || !parent.parent) {
                  effects.unshift.apply(effects, croplessEffects);
                  inFlow = [2 /* ABSOLUTE */, 3 /* FIXED */].indexOf(parent.container.styles.position) === -1;
                  if (parent.container.styles.overflowX !== 0 /* VISIBLE */) {
                      var borderBox = calculateBorderBoxPath(parent.curves);
                      var paddingBox = calculatePaddingBoxPath(parent.curves);
                      if (!equalPath(borderBox, paddingBox)) {
                          effects.unshift(new ClipEffect(paddingBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));
                      }
                  }
              }
              else {
                  effects.unshift.apply(effects, croplessEffects);
              }
              parent = parent.parent;
          }
          return effects.filter(function (effect) { return contains(effect.target, target); });
      };
      return ElementPaint;
  }());
  var parseStackTree = function (parent, stackingContext, realStackingContext, listItems) {
      parent.container.elements.forEach(function (child) {
          var treatAsRealStackingContext = contains(child.flags, 4 /* CREATES_REAL_STACKING_CONTEXT */);
          var createsStackingContext = contains(child.flags, 2 /* CREATES_STACKING_CONTEXT */);
          var paintContainer = new ElementPaint(child, parent);
          if (contains(child.styles.display, 2048 /* LIST_ITEM */)) {
              listItems.push(paintContainer);
          }
          var listOwnerItems = contains(child.flags, 8 /* IS_LIST_OWNER */) ? [] : listItems;
          if (treatAsRealStackingContext || createsStackingContext) {
              var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
              var stack = new StackingContext(paintContainer);
              if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
                  var order_1 = child.styles.zIndex.order;
                  if (order_1 < 0) {
                      var index_1 = 0;
                      parentStack.negativeZIndex.some(function (current, i) {
                          if (order_1 > current.element.container.styles.zIndex.order) {
                              index_1 = i;
                              return false;
                          }
                          else if (index_1 > 0) {
                              return true;
                          }
                          return false;
                      });
                      parentStack.negativeZIndex.splice(index_1, 0, stack);
                  }
                  else if (order_1 > 0) {
                      var index_2 = 0;
                      parentStack.positiveZIndex.some(function (current, i) {
                          if (order_1 >= current.element.container.styles.zIndex.order) {
                              index_2 = i + 1;
                              return false;
                          }
                          else if (index_2 > 0) {
                              return true;
                          }
                          return false;
                      });
                      parentStack.positiveZIndex.splice(index_2, 0, stack);
                  }
                  else {
                      parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
                  }
              }
              else {
                  if (child.styles.isFloating()) {
                      parentStack.nonPositionedFloats.push(stack);
                  }
                  else {
                      parentStack.nonPositionedInlineLevel.push(stack);
                  }
              }
              parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
          }
          else {
              if (child.styles.isInlineLevel()) {
                  stackingContext.inlineLevel.push(paintContainer);
              }
              else {
                  stackingContext.nonInlineLevel.push(paintContainer);
              }
              parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
          }
          if (contains(child.flags, 8 /* IS_LIST_OWNER */)) {
              processListItems(child, listOwnerItems);
          }
      });
  };
  var processListItems = function (owner, elements) {
      var numbering = owner instanceof OLElementContainer ? owner.start : 1;
      var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
      for (var i = 0; i < elements.length; i++) {
          var item = elements[i];
          if (item.container instanceof LIElementContainer &&
              typeof item.container.value === 'number' &&
              item.container.value !== 0) {
              numbering = item.container.value;
          }
          item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
          numbering += reversed ? -1 : 1;
      }
  };
  var parseStackingContexts = function (container) {
      var paintContainer = new ElementPaint(container, null);
      var root = new StackingContext(paintContainer);
      var listItems = [];
      parseStackTree(paintContainer, root, root, listItems);
      processListItems(paintContainer.container, listItems);
      return root;
  };

  var parsePathForBorder = function (curves, borderSide) {
      switch (borderSide) {
          case 0:
              return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
          case 1:
              return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
          case 2:
              return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
          case 3:
          default:
              return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
      }
  };
  var parsePathForBorderDoubleOuter = function (curves, borderSide) {
      switch (borderSide) {
          case 0:
              return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
          case 1:
              return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
          case 2:
              return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
          case 3:
          default:
              return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
      }
  };
  var parsePathForBorderDoubleInner = function (curves, borderSide) {
      switch (borderSide) {
          case 0:
              return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
          case 1:
              return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
          case 2:
              return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
          case 3:
          default:
              return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
      }
  };
  var parsePathForBorderStroke = function (curves, borderSide) {
      switch (borderSide) {
          case 0:
              return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
          case 1:
              return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
          case 2:
              return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
          case 3:
          default:
              return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
      }
  };
  var createStrokePathFromCurves = function (outer1, outer2) {
      var path = [];
      if (isBezierCurve(outer1)) {
          path.push(outer1.subdivide(0.5, false));
      }
      else {
          path.push(outer1);
      }
      if (isBezierCurve(outer2)) {
          path.push(outer2.subdivide(0.5, true));
      }
      else {
          path.push(outer2);
      }
      return path;
  };
  var createPathFromCurves = function (outer1, inner1, outer2, inner2) {
      var path = [];
      if (isBezierCurve(outer1)) {
          path.push(outer1.subdivide(0.5, false));
      }
      else {
          path.push(outer1);
      }
      if (isBezierCurve(outer2)) {
          path.push(outer2.subdivide(0.5, true));
      }
      else {
          path.push(outer2);
      }
      if (isBezierCurve(inner2)) {
          path.push(inner2.subdivide(0.5, true).reverse());
      }
      else {
          path.push(inner2);
      }
      if (isBezierCurve(inner1)) {
          path.push(inner1.subdivide(0.5, false).reverse());
      }
      else {
          path.push(inner1);
      }
      return path;
  };

  var paddingBox = function (element) {
      var bounds = element.bounds;
      var styles = element.styles;
      return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
  };
  var contentBox = function (element) {
      var styles = element.styles;
      var bounds = element.bounds;
      var paddingLeft = getAbsoluteValue(styles.paddingLeft, bounds.width);
      var paddingRight = getAbsoluteValue(styles.paddingRight, bounds.width);
      var paddingTop = getAbsoluteValue(styles.paddingTop, bounds.width);
      var paddingBottom = getAbsoluteValue(styles.paddingBottom, bounds.width);
      return bounds.add(paddingLeft + styles.borderLeftWidth, paddingTop + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft + paddingRight), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop + paddingBottom));
  };

  var calculateBackgroundPositioningArea = function (backgroundOrigin, element) {
      if (backgroundOrigin === 0 /* BORDER_BOX */) {
          return element.bounds;
      }
      if (backgroundOrigin === 2 /* CONTENT_BOX */) {
          return contentBox(element);
      }
      return paddingBox(element);
  };
  var calculateBackgroundPaintingArea = function (backgroundClip, element) {
      if (backgroundClip === 0 /* BORDER_BOX */) {
          return element.bounds;
      }
      if (backgroundClip === 2 /* CONTENT_BOX */) {
          return contentBox(element);
      }
      return paddingBox(element);
  };
  var calculateBackgroundRendering = function (container, index, intrinsicSize) {
      var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index), container);
      var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index), container);
      var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index), intrinsicSize, backgroundPositioningArea);
      var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
      var position = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
      var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index), position, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
      var offsetX = Math.round(backgroundPositioningArea.left + position[0]);
      var offsetY = Math.round(backgroundPositioningArea.top + position[1]);
      return [path, offsetX, offsetY, sizeWidth, sizeHeight];
  };
  var isAuto = function (token) { return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO; };
  var hasIntrinsicValue = function (value) { return typeof value === 'number'; };
  var calculateBackgroundSize = function (size, _a, bounds) {
      var intrinsicWidth = _a[0], intrinsicHeight = _a[1], intrinsicProportion = _a[2];
      var first = size[0], second = size[1];
      if (!first) {
          return [0, 0];
      }
      if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
          return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
      }
      var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
      if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
          if (hasIntrinsicValue(intrinsicProportion)) {
              var targetRatio = bounds.width / bounds.height;
              return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER)
                  ? [bounds.width, bounds.width / intrinsicProportion]
                  : [bounds.height * intrinsicProportion, bounds.height];
          }
          return [bounds.width, bounds.height];
      }
      var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
      var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
      var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
      // If the background-size is auto or auto auto:
      if (isAuto(first) && (!second || isAuto(second))) {
          // If the image has both horizontal and vertical intrinsic dimensions, it's rendered at that size.
          if (hasIntrinsicWidth && hasIntrinsicHeight) {
              return [intrinsicWidth, intrinsicHeight];
          }
          // If the image has no intrinsic dimensions and has no intrinsic proportions,
          // it's rendered at the size of the background positioning area.
          if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
              return [bounds.width, bounds.height];
          }
          // TODO If the image has no intrinsic dimensions but has intrinsic proportions, it's rendered as if contain had been specified instead.
          // If the image has only one intrinsic dimension and has intrinsic proportions, it's rendered at the size corresponding to that one dimension.
          // The other dimension is computed using the specified dimension and the intrinsic proportions.
          if (hasIntrinsicDimensions && hasIntrinsicProportion) {
              var width_1 = hasIntrinsicWidth
                  ? intrinsicWidth
                  : intrinsicHeight * intrinsicProportion;
              var height_1 = hasIntrinsicHeight
                  ? intrinsicHeight
                  : intrinsicWidth / intrinsicProportion;
              return [width_1, height_1];
          }
          // If the image has only one intrinsic dimension but has no intrinsic proportions,
          // it's rendered using the specified dimension and the other dimension of the background positioning area.
          var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
          var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
          return [width_2, height_2];
      }
      // If the image has intrinsic proportions, it's stretched to the specified dimension.
      // The unspecified dimension is computed using the specified dimension and the intrinsic proportions.
      if (hasIntrinsicProportion) {
          var width_3 = 0;
          var height_3 = 0;
          if (isLengthPercentage(first)) {
              width_3 = getAbsoluteValue(first, bounds.width);
          }
          else if (isLengthPercentage(second)) {
              height_3 = getAbsoluteValue(second, bounds.height);
          }
          if (isAuto(first)) {
              width_3 = height_3 * intrinsicProportion;
          }
          else if (!second || isAuto(second)) {
              height_3 = width_3 / intrinsicProportion;
          }
          return [width_3, height_3];
      }
      // If the image has no intrinsic proportions, it's stretched to the specified dimension.
      // The unspecified dimension is computed using the image's corresponding intrinsic dimension,
      // if there is one. If there is no such intrinsic dimension,
      // it becomes the corresponding dimension of the background positioning area.
      var width = null;
      var height = null;
      if (isLengthPercentage(first)) {
          width = getAbsoluteValue(first, bounds.width);
      }
      else if (second && isLengthPercentage(second)) {
          height = getAbsoluteValue(second, bounds.height);
      }
      if (width !== null && (!second || isAuto(second))) {
          height =
              hasIntrinsicWidth && hasIntrinsicHeight
                  ? (width / intrinsicWidth) * intrinsicHeight
                  : bounds.height;
      }
      if (height !== null && isAuto(first)) {
          width =
              hasIntrinsicWidth && hasIntrinsicHeight
                  ? (height / intrinsicHeight) * intrinsicWidth
                  : bounds.width;
      }
      if (width !== null && height !== null) {
          return [width, height];
      }
      throw new Error("Unable to calculate background-size for element");
  };
  var getBackgroundValueForIndex = function (values, index) {
      var value = values[index];
      if (typeof value === 'undefined') {
          return values[0];
      }
      return value;
  };
  var calculateBackgroundRepeatPath = function (repeat, _a, _b, backgroundPositioningArea, backgroundPaintingArea) {
      var x = _a[0], y = _a[1];
      var width = _b[0], height = _b[1];
      switch (repeat) {
          case 2 /* REPEAT_X */:
              return [
                  new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y)),
                  new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y)),
                  new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y)),
                  new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y))
              ];
          case 3 /* REPEAT_Y */:
              return [
                  new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top)),
                  new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top)),
                  new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
                  new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
              ];
          case 1 /* NO_REPEAT */:
              return [
                  new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y)),
                  new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y)),
                  new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y + height)),
                  new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y + height))
              ];
          default:
              return [
                  new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
                  new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
                  new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
                  new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
              ];
      }
  };

  var SMALL_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

  var SAMPLE_TEXT = 'Hidden Text';
  var FontMetrics = /** @class */ (function () {
      function FontMetrics(document) {
          this._data = {};
          this._document = document;
      }
      FontMetrics.prototype.parseMetrics = function (fontFamily, fontSize) {
          var container = this._document.createElement('div');
          var img = this._document.createElement('img');
          var span = this._document.createElement('span');
          var body = this._document.body;
          container.style.visibility = 'hidden';
          container.style.fontFamily = fontFamily;
          container.style.fontSize = fontSize;
          container.style.margin = '0';
          container.style.padding = '0';
          container.style.whiteSpace = 'nowrap';
          body.appendChild(container);
          img.src = SMALL_IMAGE;
          img.width = 1;
          img.height = 1;
          img.style.margin = '0';
          img.style.padding = '0';
          img.style.verticalAlign = 'baseline';
          span.style.fontFamily = fontFamily;
          span.style.fontSize = fontSize;
          span.style.margin = '0';
          span.style.padding = '0';
          span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
          container.appendChild(span);
          container.appendChild(img);
          var baseline = img.offsetTop - span.offsetTop + 2;
          container.removeChild(span);
          container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
          container.style.lineHeight = 'normal';
          img.style.verticalAlign = 'super';
          var middle = img.offsetTop - container.offsetTop + 2;
          body.removeChild(container);
          return { baseline: baseline, middle: middle };
      };
      FontMetrics.prototype.getMetrics = function (fontFamily, fontSize) {
          var key = fontFamily + " " + fontSize;
          if (typeof this._data[key] === 'undefined') {
              this._data[key] = this.parseMetrics(fontFamily, fontSize);
          }
          return this._data[key];
      };
      return FontMetrics;
  }());

  var Renderer = /** @class */ (function () {
      function Renderer(context, options) {
          this.context = context;
          this.options = options;
      }
      return Renderer;
  }());

  var MASK_OFFSET = 10000;
  var CanvasRenderer = /** @class */ (function (_super) {
      __extends(CanvasRenderer, _super);
      function CanvasRenderer(context, options) {
          var _this = _super.call(this, context, options) || this;
          _this._activeEffects = [];
          _this.canvas = options.canvas ? options.canvas : document.createElement('canvas');
          _this.ctx = _this.canvas.getContext('2d');
          if (!options.canvas) {
              _this.canvas.width = Math.floor(options.width * options.scale);
              _this.canvas.height = Math.floor(options.height * options.scale);
              _this.canvas.style.width = options.width + "px";
              _this.canvas.style.height = options.height + "px";
          }
          _this.fontMetrics = new FontMetrics(document);
          _this.ctx.scale(_this.options.scale, _this.options.scale);
          _this.ctx.translate(-options.x, -options.y);
          _this.ctx.textBaseline = 'bottom';
          _this._activeEffects = [];
          _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
          return _this;
      }
      CanvasRenderer.prototype.applyEffects = function (effects) {
          var _this = this;
          while (this._activeEffects.length) {
              this.popEffect();
          }
          effects.forEach(function (effect) { return _this.applyEffect(effect); });
      };
      CanvasRenderer.prototype.applyEffect = function (effect) {
          this.ctx.save();
          if (isOpacityEffect(effect)) {
              this.ctx.globalAlpha = effect.opacity;
          }
          if (isTransformEffect(effect)) {
              this.ctx.translate(effect.offsetX, effect.offsetY);
              this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
              this.ctx.translate(-effect.offsetX, -effect.offsetY);
          }
          if (isClipEffect(effect)) {
              this.path(effect.path);
              this.ctx.clip();
          }
          this._activeEffects.push(effect);
      };
      CanvasRenderer.prototype.popEffect = function () {
          this._activeEffects.pop();
          this.ctx.restore();
      };
      CanvasRenderer.prototype.renderStack = function (stack) {
          return __awaiter(this, void 0, void 0, function () {
              var styles;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          styles = stack.element.container.styles;
                          if (!styles.isVisible()) return [3 /*break*/, 2];
                          return [4 /*yield*/, this.renderStackContent(stack)];
                      case 1:
                          _a.sent();
                          _a.label = 2;
                      case 2: return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.renderNode = function (paint) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (contains(paint.container.flags, 16 /* DEBUG_RENDER */)) {
                              debugger;
                          }
                          if (!paint.container.styles.isVisible()) return [3 /*break*/, 3];
                          return [4 /*yield*/, this.renderNodeBackgroundAndBorders(paint)];
                      case 1:
                          _a.sent();
                          return [4 /*yield*/, this.renderNodeContent(paint)];
                      case 2:
                          _a.sent();
                          _a.label = 3;
                      case 3: return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.renderTextWithLetterSpacing = function (text, letterSpacing, baseline) {
          var _this = this;
          if (letterSpacing === 0) {
              this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + baseline);
          }
          else {
              var letters = segmentGraphemes(text.text);
              letters.reduce(function (left, letter) {
                  _this.ctx.fillText(letter, left, text.bounds.top + baseline);
                  return left + _this.ctx.measureText(letter).width;
              }, text.bounds.left);
          }
      };
      CanvasRenderer.prototype.createFontStyle = function (styles) {
          var fontVariant = styles.fontVariant
              .filter(function (variant) { return variant === 'normal' || variant === 'small-caps'; })
              .join('');
          var fontFamily = fixIOSSystemFonts(styles.fontFamily).join(', ');
          var fontSize = isDimensionToken(styles.fontSize)
              ? "" + styles.fontSize.number + styles.fontSize.unit
              : styles.fontSize.number + "px";
          return [
              [styles.fontStyle, fontVariant, styles.fontWeight, fontSize, fontFamily].join(' '),
              fontFamily,
              fontSize
          ];
      };
      CanvasRenderer.prototype.renderTextNode = function (text, styles) {
          return __awaiter(this, void 0, void 0, function () {
              var _a, font, fontFamily, fontSize, _b, baseline, middle, paintOrder;
              var _this = this;
              return __generator(this, function (_c) {
                  _a = this.createFontStyle(styles), font = _a[0], fontFamily = _a[1], fontSize = _a[2];
                  this.ctx.font = font;
                  this.ctx.direction = styles.direction === 1 /* RTL */ ? 'rtl' : 'ltr';
                  this.ctx.textAlign = 'left';
                  this.ctx.textBaseline = 'alphabetic';
                  _b = this.fontMetrics.getMetrics(fontFamily, fontSize), baseline = _b.baseline, middle = _b.middle;
                  paintOrder = styles.paintOrder;
                  text.textBounds.forEach(function (text) {
                      paintOrder.forEach(function (paintOrderLayer) {
                          switch (paintOrderLayer) {
                              case 0 /* FILL */:
                                  _this.ctx.fillStyle = asString(styles.color);
                                  _this.renderTextWithLetterSpacing(text, styles.letterSpacing, baseline);
                                  var textShadows = styles.textShadow;
                                  if (textShadows.length && text.text.trim().length) {
                                      textShadows
                                          .slice(0)
                                          .reverse()
                                          .forEach(function (textShadow) {
                                          _this.ctx.shadowColor = asString(textShadow.color);
                                          _this.ctx.shadowOffsetX = textShadow.offsetX.number * _this.options.scale;
                                          _this.ctx.shadowOffsetY = textShadow.offsetY.number * _this.options.scale;
                                          _this.ctx.shadowBlur = textShadow.blur.number;
                                          _this.renderTextWithLetterSpacing(text, styles.letterSpacing, baseline);
                                      });
                                      _this.ctx.shadowColor = '';
                                      _this.ctx.shadowOffsetX = 0;
                                      _this.ctx.shadowOffsetY = 0;
                                      _this.ctx.shadowBlur = 0;
                                  }
                                  if (styles.textDecorationLine.length) {
                                      _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                                      styles.textDecorationLine.forEach(function (textDecorationLine) {
                                          switch (textDecorationLine) {
                                              case 1 /* UNDERLINE */:
                                                  // Draws a line at the baseline of the font
                                                  // TODO As some browsers display the line as more than 1px if the font-size is big,
                                                  // need to take that into account both in position and size
                                                  _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top + baseline), text.bounds.width, 1);
                                                  break;
                                              case 2 /* OVERLINE */:
                                                  _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top), text.bounds.width, 1);
                                                  break;
                                              case 3 /* LINE_THROUGH */:
                                                  // TODO try and find exact position for line-through
                                                  _this.ctx.fillRect(text.bounds.left, Math.ceil(text.bounds.top + middle), text.bounds.width, 1);
                                                  break;
                                          }
                                      });
                                  }
                                  break;
                              case 1 /* STROKE */:
                                  if (styles.webkitTextStrokeWidth && text.text.trim().length) {
                                      _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                                      _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                                      // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                      _this.ctx.lineJoin = !!window.chrome ? 'miter' : 'round';
                                      _this.ctx.strokeText(text.text, text.bounds.left, text.bounds.top + baseline);
                                  }
                                  _this.ctx.strokeStyle = '';
                                  _this.ctx.lineWidth = 0;
                                  _this.ctx.lineJoin = 'miter';
                                  break;
                          }
                      });
                  });
                  return [2 /*return*/];
              });
          });
      };
      CanvasRenderer.prototype.renderReplacedElement = function (container, curves, image) {
          if (image && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
              var box = contentBox(container);
              var path = calculatePaddingBoxPath(curves);
              this.path(path);
              this.ctx.save();
              this.ctx.clip();
              this.ctx.drawImage(image, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
              this.ctx.restore();
          }
      };
      CanvasRenderer.prototype.renderNodeContent = function (paint) {
          return __awaiter(this, void 0, void 0, function () {
              var container, curves, styles, _i, _a, child, image, image, iframeRenderer, canvas, size, _b, fontFamily, fontSize, baseline, bounds, x, textBounds, img, image, url, fontFamily, bounds;
              return __generator(this, function (_c) {
                  switch (_c.label) {
                      case 0:
                          this.applyEffects(paint.getEffects(4 /* CONTENT */));
                          container = paint.container;
                          curves = paint.curves;
                          styles = container.styles;
                          _i = 0, _a = container.textNodes;
                          _c.label = 1;
                      case 1:
                          if (!(_i < _a.length)) return [3 /*break*/, 4];
                          child = _a[_i];
                          return [4 /*yield*/, this.renderTextNode(child, styles)];
                      case 2:
                          _c.sent();
                          _c.label = 3;
                      case 3:
                          _i++;
                          return [3 /*break*/, 1];
                      case 4:
                          if (!(container instanceof ImageElementContainer)) return [3 /*break*/, 8];
                          _c.label = 5;
                      case 5:
                          _c.trys.push([5, 7, , 8]);
                          return [4 /*yield*/, this.context.cache.match(container.src)];
                      case 6:
                          image = _c.sent();
                          this.renderReplacedElement(container, curves, image);
                          return [3 /*break*/, 8];
                      case 7:
                          _c.sent();
                          this.context.logger.error("Error loading image " + container.src);
                          return [3 /*break*/, 8];
                      case 8:
                          if (container instanceof CanvasElementContainer) {
                              this.renderReplacedElement(container, curves, container.canvas);
                          }
                          if (!(container instanceof SVGElementContainer)) return [3 /*break*/, 12];
                          _c.label = 9;
                      case 9:
                          _c.trys.push([9, 11, , 12]);
                          return [4 /*yield*/, this.context.cache.match(container.svg)];
                      case 10:
                          image = _c.sent();
                          this.renderReplacedElement(container, curves, image);
                          return [3 /*break*/, 12];
                      case 11:
                          _c.sent();
                          this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
                          return [3 /*break*/, 12];
                      case 12:
                          if (!(container instanceof IFrameElementContainer && container.tree)) return [3 /*break*/, 14];
                          iframeRenderer = new CanvasRenderer(this.context, {
                              scale: this.options.scale,
                              backgroundColor: container.backgroundColor,
                              x: 0,
                              y: 0,
                              width: container.width,
                              height: container.height
                          });
                          return [4 /*yield*/, iframeRenderer.render(container.tree)];
                      case 13:
                          canvas = _c.sent();
                          if (container.width && container.height) {
                              this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
                          }
                          _c.label = 14;
                      case 14:
                          if (container instanceof InputElementContainer) {
                              size = Math.min(container.bounds.width, container.bounds.height);
                              if (container.type === CHECKBOX) {
                                  if (container.checked) {
                                      this.ctx.save();
                                      this.path([
                                          new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                                          new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                                          new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                                          new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                                          new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                                          new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                                          new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                                      ]);
                                      this.ctx.fillStyle = asString(INPUT_COLOR);
                                      this.ctx.fill();
                                      this.ctx.restore();
                                  }
                              }
                              else if (container.type === RADIO) {
                                  if (container.checked) {
                                      this.ctx.save();
                                      this.ctx.beginPath();
                                      this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                                      this.ctx.fillStyle = asString(INPUT_COLOR);
                                      this.ctx.fill();
                                      this.ctx.restore();
                                  }
                              }
                          }
                          if (isTextInputElement(container) && container.value.length) {
                              _b = this.createFontStyle(styles), fontFamily = _b[0], fontSize = _b[1];
                              baseline = this.fontMetrics.getMetrics(fontFamily, fontSize).baseline;
                              this.ctx.font = fontFamily;
                              this.ctx.fillStyle = asString(styles.color);
                              this.ctx.textBaseline = 'alphabetic';
                              this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                              bounds = contentBox(container);
                              x = 0;
                              switch (container.styles.textAlign) {
                                  case 1 /* CENTER */:
                                      x += bounds.width / 2;
                                      break;
                                  case 2 /* RIGHT */:
                                      x += bounds.width;
                                      break;
                              }
                              textBounds = bounds.add(x, 0, 0, -bounds.height / 2 + 1);
                              this.ctx.save();
                              this.path([
                                  new Vector(bounds.left, bounds.top),
                                  new Vector(bounds.left + bounds.width, bounds.top),
                                  new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                                  new Vector(bounds.left, bounds.top + bounds.height)
                              ]);
                              this.ctx.clip();
                              this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
                              this.ctx.restore();
                              this.ctx.textBaseline = 'alphabetic';
                              this.ctx.textAlign = 'left';
                          }
                          if (!contains(container.styles.display, 2048 /* LIST_ITEM */)) return [3 /*break*/, 20];
                          if (!(container.styles.listStyleImage !== null)) return [3 /*break*/, 19];
                          img = container.styles.listStyleImage;
                          if (!(img.type === 0 /* URL */)) return [3 /*break*/, 18];
                          image = void 0;
                          url = img.url;
                          _c.label = 15;
                      case 15:
                          _c.trys.push([15, 17, , 18]);
                          return [4 /*yield*/, this.context.cache.match(url)];
                      case 16:
                          image = _c.sent();
                          this.ctx.drawImage(image, container.bounds.left - (image.width + 10), container.bounds.top);
                          return [3 /*break*/, 18];
                      case 17:
                          _c.sent();
                          this.context.logger.error("Error loading list-style-image " + url);
                          return [3 /*break*/, 18];
                      case 18: return [3 /*break*/, 20];
                      case 19:
                          if (paint.listValue && container.styles.listStyleType !== -1 /* NONE */) {
                              fontFamily = this.createFontStyle(styles)[0];
                              this.ctx.font = fontFamily;
                              this.ctx.fillStyle = asString(styles.color);
                              this.ctx.textBaseline = 'middle';
                              this.ctx.textAlign = 'right';
                              bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                              this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
                              this.ctx.textBaseline = 'bottom';
                              this.ctx.textAlign = 'left';
                          }
                          _c.label = 20;
                      case 20: return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.renderStackContent = function (stack) {
          return __awaiter(this, void 0, void 0, function () {
              var _i, _a, child, _b, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
              return __generator(this, function (_p) {
                  switch (_p.label) {
                      case 0:
                          if (contains(stack.element.container.flags, 16 /* DEBUG_RENDER */)) {
                              debugger;
                          }
                          // https://www.w3.org/TR/css-position-3/#painting-order
                          // 1. the background and borders of the element forming the stacking context.
                          return [4 /*yield*/, this.renderNodeBackgroundAndBorders(stack.element)];
                      case 1:
                          // https://www.w3.org/TR/css-position-3/#painting-order
                          // 1. the background and borders of the element forming the stacking context.
                          _p.sent();
                          _i = 0, _a = stack.negativeZIndex;
                          _p.label = 2;
                      case 2:
                          if (!(_i < _a.length)) return [3 /*break*/, 5];
                          child = _a[_i];
                          return [4 /*yield*/, this.renderStack(child)];
                      case 3:
                          _p.sent();
                          _p.label = 4;
                      case 4:
                          _i++;
                          return [3 /*break*/, 2];
                      case 5: 
                      // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
                      return [4 /*yield*/, this.renderNodeContent(stack.element)];
                      case 6:
                          // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
                          _p.sent();
                          _b = 0, _c = stack.nonInlineLevel;
                          _p.label = 7;
                      case 7:
                          if (!(_b < _c.length)) return [3 /*break*/, 10];
                          child = _c[_b];
                          return [4 /*yield*/, this.renderNode(child)];
                      case 8:
                          _p.sent();
                          _p.label = 9;
                      case 9:
                          _b++;
                          return [3 /*break*/, 7];
                      case 10:
                          _d = 0, _e = stack.nonPositionedFloats;
                          _p.label = 11;
                      case 11:
                          if (!(_d < _e.length)) return [3 /*break*/, 14];
                          child = _e[_d];
                          return [4 /*yield*/, this.renderStack(child)];
                      case 12:
                          _p.sent();
                          _p.label = 13;
                      case 13:
                          _d++;
                          return [3 /*break*/, 11];
                      case 14:
                          _f = 0, _g = stack.nonPositionedInlineLevel;
                          _p.label = 15;
                      case 15:
                          if (!(_f < _g.length)) return [3 /*break*/, 18];
                          child = _g[_f];
                          return [4 /*yield*/, this.renderStack(child)];
                      case 16:
                          _p.sent();
                          _p.label = 17;
                      case 17:
                          _f++;
                          return [3 /*break*/, 15];
                      case 18:
                          _h = 0, _j = stack.inlineLevel;
                          _p.label = 19;
                      case 19:
                          if (!(_h < _j.length)) return [3 /*break*/, 22];
                          child = _j[_h];
                          return [4 /*yield*/, this.renderNode(child)];
                      case 20:
                          _p.sent();
                          _p.label = 21;
                      case 21:
                          _h++;
                          return [3 /*break*/, 19];
                      case 22:
                          _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
                          _p.label = 23;
                      case 23:
                          if (!(_k < _l.length)) return [3 /*break*/, 26];
                          child = _l[_k];
                          return [4 /*yield*/, this.renderStack(child)];
                      case 24:
                          _p.sent();
                          _p.label = 25;
                      case 25:
                          _k++;
                          return [3 /*break*/, 23];
                      case 26:
                          _m = 0, _o = stack.positiveZIndex;
                          _p.label = 27;
                      case 27:
                          if (!(_m < _o.length)) return [3 /*break*/, 30];
                          child = _o[_m];
                          return [4 /*yield*/, this.renderStack(child)];
                      case 28:
                          _p.sent();
                          _p.label = 29;
                      case 29:
                          _m++;
                          return [3 /*break*/, 27];
                      case 30: return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.mask = function (paths) {
          this.ctx.beginPath();
          this.ctx.moveTo(0, 0);
          this.ctx.lineTo(this.canvas.width, 0);
          this.ctx.lineTo(this.canvas.width, this.canvas.height);
          this.ctx.lineTo(0, this.canvas.height);
          this.ctx.lineTo(0, 0);
          this.formatPath(paths.slice(0).reverse());
          this.ctx.closePath();
      };
      CanvasRenderer.prototype.path = function (paths) {
          this.ctx.beginPath();
          this.formatPath(paths);
          this.ctx.closePath();
      };
      CanvasRenderer.prototype.formatPath = function (paths) {
          var _this = this;
          paths.forEach(function (point, index) {
              var start = isBezierCurve(point) ? point.start : point;
              if (index === 0) {
                  _this.ctx.moveTo(start.x, start.y);
              }
              else {
                  _this.ctx.lineTo(start.x, start.y);
              }
              if (isBezierCurve(point)) {
                  _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
              }
          });
      };
      CanvasRenderer.prototype.renderRepeat = function (path, pattern, offsetX, offsetY) {
          this.path(path);
          this.ctx.fillStyle = pattern;
          this.ctx.translate(offsetX, offsetY);
          this.ctx.fill();
          this.ctx.translate(-offsetX, -offsetY);
      };
      CanvasRenderer.prototype.resizeImage = function (image, width, height) {
          var _a;
          if (image.width === width && image.height === height) {
              return image;
          }
          var ownerDocument = (_a = this.canvas.ownerDocument) !== null && _a !== void 0 ? _a : document;
          var canvas = ownerDocument.createElement('canvas');
          canvas.width = Math.max(1, width);
          canvas.height = Math.max(1, height);
          var ctx = canvas.getContext('2d');
          ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, width, height);
          return canvas;
      };
      CanvasRenderer.prototype.renderBackgroundImage = function (container) {
          return __awaiter(this, void 0, void 0, function () {
              var index, _loop_1, this_1, _i, _a, backgroundImage;
              return __generator(this, function (_b) {
                  switch (_b.label) {
                      case 0:
                          index = container.styles.backgroundImage.length - 1;
                          _loop_1 = function (backgroundImage) {
                              var image, url, _c, path, x, y, width, height, pattern, _d, path, x, y, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position, x, y, _g, rx, ry, radialGradient_1, midX, midY, f, invF;
                              return __generator(this, function (_h) {
                                  switch (_h.label) {
                                      case 0:
                                          if (!(backgroundImage.type === 0 /* URL */)) return [3 /*break*/, 5];
                                          image = void 0;
                                          url = backgroundImage.url;
                                          _h.label = 1;
                                      case 1:
                                          _h.trys.push([1, 3, , 4]);
                                          return [4 /*yield*/, this_1.context.cache.match(url)];
                                      case 2:
                                          image = _h.sent();
                                          return [3 /*break*/, 4];
                                      case 3:
                                          _h.sent();
                                          this_1.context.logger.error("Error loading background-image " + url);
                                          return [3 /*break*/, 4];
                                      case 4:
                                          if (image) {
                                              _c = calculateBackgroundRendering(container, index, [
                                                  image.width,
                                                  image.height,
                                                  image.width / image.height
                                              ]), path = _c[0], x = _c[1], y = _c[2], width = _c[3], height = _c[4];
                                              pattern = this_1.ctx.createPattern(this_1.resizeImage(image, width, height), 'repeat');
                                              this_1.renderRepeat(path, pattern, x, y);
                                          }
                                          return [3 /*break*/, 6];
                                      case 5:
                                          if (isLinearGradient(backgroundImage)) {
                                              _d = calculateBackgroundRendering(container, index, [null, null, null]), path = _d[0], x = _d[1], y = _d[2], width = _d[3], height = _d[4];
                                              _e = calculateGradientDirection(backgroundImage.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                                              canvas = document.createElement('canvas');
                                              canvas.width = width;
                                              canvas.height = height;
                                              ctx = canvas.getContext('2d');
                                              gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                                              processColorStops(backgroundImage.stops, lineLength).forEach(function (colorStop) {
                                                  return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                                              });
                                              ctx.fillStyle = gradient_1;
                                              ctx.fillRect(0, 0, width, height);
                                              if (width > 0 && height > 0) {
                                                  pattern = this_1.ctx.createPattern(canvas, 'repeat');
                                                  this_1.renderRepeat(path, pattern, x, y);
                                              }
                                          }
                                          else if (isRadialGradient(backgroundImage)) {
                                              _f = calculateBackgroundRendering(container, index, [
                                                  null,
                                                  null,
                                                  null
                                              ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                                              position = backgroundImage.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage.position;
                                              x = getAbsoluteValue(position[0], width);
                                              y = getAbsoluteValue(position[position.length - 1], height);
                                              _g = calculateRadius(backgroundImage, x, y, width, height), rx = _g[0], ry = _g[1];
                                              if (rx > 0 && ry > 0) {
                                                  radialGradient_1 = this_1.ctx.createRadialGradient(left + x, top_1 + y, 0, left + x, top_1 + y, rx);
                                                  processColorStops(backgroundImage.stops, rx * 2).forEach(function (colorStop) {
                                                      return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                                                  });
                                                  this_1.path(path);
                                                  this_1.ctx.fillStyle = radialGradient_1;
                                                  if (rx !== ry) {
                                                      midX = container.bounds.left + 0.5 * container.bounds.width;
                                                      midY = container.bounds.top + 0.5 * container.bounds.height;
                                                      f = ry / rx;
                                                      invF = 1 / f;
                                                      this_1.ctx.save();
                                                      this_1.ctx.translate(midX, midY);
                                                      this_1.ctx.transform(1, 0, 0, f, 0, 0);
                                                      this_1.ctx.translate(-midX, -midY);
                                                      this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                                                      this_1.ctx.restore();
                                                  }
                                                  else {
                                                      this_1.ctx.fill();
                                                  }
                                              }
                                          }
                                          _h.label = 6;
                                      case 6:
                                          index--;
                                          return [2 /*return*/];
                                  }
                              });
                          };
                          this_1 = this;
                          _i = 0, _a = container.styles.backgroundImage.slice(0).reverse();
                          _b.label = 1;
                      case 1:
                          if (!(_i < _a.length)) return [3 /*break*/, 4];
                          backgroundImage = _a[_i];
                          return [5 /*yield**/, _loop_1(backgroundImage)];
                      case 2:
                          _b.sent();
                          _b.label = 3;
                      case 3:
                          _i++;
                          return [3 /*break*/, 1];
                      case 4: return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.renderSolidBorder = function (color, side, curvePoints) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  this.path(parsePathForBorder(curvePoints, side));
                  this.ctx.fillStyle = asString(color);
                  this.ctx.fill();
                  return [2 /*return*/];
              });
          });
      };
      CanvasRenderer.prototype.renderDoubleBorder = function (color, width, side, curvePoints) {
          return __awaiter(this, void 0, void 0, function () {
              var outerPaths, innerPaths;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (!(width < 3)) return [3 /*break*/, 2];
                          return [4 /*yield*/, this.renderSolidBorder(color, side, curvePoints)];
                      case 1:
                          _a.sent();
                          return [2 /*return*/];
                      case 2:
                          outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
                          this.path(outerPaths);
                          this.ctx.fillStyle = asString(color);
                          this.ctx.fill();
                          innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
                          this.path(innerPaths);
                          this.ctx.fill();
                          return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.renderNodeBackgroundAndBorders = function (paint) {
          return __awaiter(this, void 0, void 0, function () {
              var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          this.applyEffects(paint.getEffects(2 /* BACKGROUND_BORDERS */));
                          styles = paint.container.styles;
                          hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
                          borders = [
                              { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
                              { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
                              { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
                              { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
                          ];
                          backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
                          if (!(hasBackground || styles.boxShadow.length)) return [3 /*break*/, 2];
                          this.ctx.save();
                          this.path(backgroundPaintingArea);
                          this.ctx.clip();
                          if (!isTransparent(styles.backgroundColor)) {
                              this.ctx.fillStyle = asString(styles.backgroundColor);
                              this.ctx.fill();
                          }
                          return [4 /*yield*/, this.renderBackgroundImage(paint.container)];
                      case 1:
                          _a.sent();
                          this.ctx.restore();
                          styles.boxShadow
                              .slice(0)
                              .reverse()
                              .forEach(function (shadow) {
                              _this.ctx.save();
                              var borderBoxArea = calculateBorderBoxPath(paint.curves);
                              var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                              var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                              if (shadow.inset) {
                                  _this.path(borderBoxArea);
                                  _this.ctx.clip();
                                  _this.mask(shadowPaintingArea);
                              }
                              else {
                                  _this.mask(borderBoxArea);
                                  _this.ctx.clip();
                                  _this.path(shadowPaintingArea);
                              }
                              _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                              _this.ctx.shadowOffsetY = shadow.offsetY.number;
                              _this.ctx.shadowColor = asString(shadow.color);
                              _this.ctx.shadowBlur = shadow.blur.number;
                              _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : 'rgba(0,0,0,1)';
                              _this.ctx.fill();
                              _this.ctx.restore();
                          });
                          _a.label = 2;
                      case 2:
                          side = 0;
                          _i = 0, borders_1 = borders;
                          _a.label = 3;
                      case 3:
                          if (!(_i < borders_1.length)) return [3 /*break*/, 13];
                          border = borders_1[_i];
                          if (!(border.style !== 0 /* NONE */ && !isTransparent(border.color) && border.width > 0)) return [3 /*break*/, 11];
                          if (!(border.style === 2 /* DASHED */)) return [3 /*break*/, 5];
                          return [4 /*yield*/, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 2 /* DASHED */)];
                      case 4:
                          _a.sent();
                          return [3 /*break*/, 11];
                      case 5:
                          if (!(border.style === 3 /* DOTTED */)) return [3 /*break*/, 7];
                          return [4 /*yield*/, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 3 /* DOTTED */)];
                      case 6:
                          _a.sent();
                          return [3 /*break*/, 11];
                      case 7:
                          if (!(border.style === 4 /* DOUBLE */)) return [3 /*break*/, 9];
                          return [4 /*yield*/, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
                      case 8:
                          _a.sent();
                          return [3 /*break*/, 11];
                      case 9: return [4 /*yield*/, this.renderSolidBorder(border.color, side, paint.curves)];
                      case 10:
                          _a.sent();
                          _a.label = 11;
                      case 11:
                          side++;
                          _a.label = 12;
                      case 12:
                          _i++;
                          return [3 /*break*/, 3];
                      case 13: return [2 /*return*/];
                  }
              });
          });
      };
      CanvasRenderer.prototype.renderDashedDottedBorder = function (color, width, side, curvePoints, style) {
          return __awaiter(this, void 0, void 0, function () {
              var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
              return __generator(this, function (_a) {
                  this.ctx.save();
                  strokePaths = parsePathForBorderStroke(curvePoints, side);
                  boxPaths = parsePathForBorder(curvePoints, side);
                  if (style === 2 /* DASHED */) {
                      this.path(boxPaths);
                      this.ctx.clip();
                  }
                  if (isBezierCurve(boxPaths[0])) {
                      startX = boxPaths[0].start.x;
                      startY = boxPaths[0].start.y;
                  }
                  else {
                      startX = boxPaths[0].x;
                      startY = boxPaths[0].y;
                  }
                  if (isBezierCurve(boxPaths[1])) {
                      endX = boxPaths[1].end.x;
                      endY = boxPaths[1].end.y;
                  }
                  else {
                      endX = boxPaths[1].x;
                      endY = boxPaths[1].y;
                  }
                  if (side === 0 || side === 2) {
                      length = Math.abs(startX - endX);
                  }
                  else {
                      length = Math.abs(startY - endY);
                  }
                  this.ctx.beginPath();
                  if (style === 3 /* DOTTED */) {
                      this.formatPath(strokePaths);
                  }
                  else {
                      this.formatPath(boxPaths.slice(0, 2));
                  }
                  dashLength = width < 3 ? width * 3 : width * 2;
                  spaceLength = width < 3 ? width * 2 : width;
                  if (style === 3 /* DOTTED */) {
                      dashLength = width;
                      spaceLength = width;
                  }
                  useLineDash = true;
                  if (length <= dashLength * 2) {
                      useLineDash = false;
                  }
                  else if (length <= dashLength * 2 + spaceLength) {
                      multiplier = length / (2 * dashLength + spaceLength);
                      dashLength *= multiplier;
                      spaceLength *= multiplier;
                  }
                  else {
                      numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
                      minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
                      maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
                      spaceLength =
                          maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace)
                              ? minSpace
                              : maxSpace;
                  }
                  if (useLineDash) {
                      if (style === 3 /* DOTTED */) {
                          this.ctx.setLineDash([0, dashLength + spaceLength]);
                      }
                      else {
                          this.ctx.setLineDash([dashLength, spaceLength]);
                      }
                  }
                  if (style === 3 /* DOTTED */) {
                      this.ctx.lineCap = 'round';
                      this.ctx.lineWidth = width;
                  }
                  else {
                      this.ctx.lineWidth = width * 2 + 1.1;
                  }
                  this.ctx.strokeStyle = asString(color);
                  this.ctx.stroke();
                  this.ctx.setLineDash([]);
                  // dashed round edge gap
                  if (style === 2 /* DASHED */) {
                      if (isBezierCurve(boxPaths[0])) {
                          path1 = boxPaths[3];
                          path2 = boxPaths[0];
                          this.ctx.beginPath();
                          this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                          this.ctx.stroke();
                      }
                      if (isBezierCurve(boxPaths[1])) {
                          path1 = boxPaths[1];
                          path2 = boxPaths[2];
                          this.ctx.beginPath();
                          this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                          this.ctx.stroke();
                      }
                  }
                  this.ctx.restore();
                  return [2 /*return*/];
              });
          });
      };
      CanvasRenderer.prototype.render = function (element) {
          return __awaiter(this, void 0, void 0, function () {
              var stack;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (this.options.backgroundColor) {
                              this.ctx.fillStyle = asString(this.options.backgroundColor);
                              this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
                          }
                          stack = parseStackingContexts(element);
                          return [4 /*yield*/, this.renderStack(stack)];
                      case 1:
                          _a.sent();
                          this.applyEffects([]);
                          return [2 /*return*/, this.canvas];
                  }
              });
          });
      };
      return CanvasRenderer;
  }(Renderer));
  var isTextInputElement = function (container) {
      if (container instanceof TextareaElementContainer) {
          return true;
      }
      else if (container instanceof SelectElementContainer) {
          return true;
      }
      else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
          return true;
      }
      return false;
  };
  var calculateBackgroundCurvedPaintingArea = function (clip, curves) {
      switch (clip) {
          case 0 /* BORDER_BOX */:
              return calculateBorderBoxPath(curves);
          case 2 /* CONTENT_BOX */:
              return calculateContentBoxPath(curves);
          case 1 /* PADDING_BOX */:
          default:
              return calculatePaddingBoxPath(curves);
      }
  };
  var canvasTextAlign = function (textAlign) {
      switch (textAlign) {
          case 1 /* CENTER */:
              return 'center';
          case 2 /* RIGHT */:
              return 'right';
          case 0 /* LEFT */:
          default:
              return 'left';
      }
  };
  // see https://github.com/niklasvh/html2canvas/pull/2645
  var iOSBrokenFonts = ['-apple-system', 'system-ui'];
  var fixIOSSystemFonts = function (fontFamilies) {
      return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent)
          ? fontFamilies.filter(function (fontFamily) { return iOSBrokenFonts.indexOf(fontFamily) === -1; })
          : fontFamilies;
  };

  var ForeignObjectRenderer = /** @class */ (function (_super) {
      __extends(ForeignObjectRenderer, _super);
      function ForeignObjectRenderer(context, options) {
          var _this = _super.call(this, context, options) || this;
          _this.canvas = options.canvas ? options.canvas : document.createElement('canvas');
          _this.ctx = _this.canvas.getContext('2d');
          _this.options = options;
          _this.canvas.width = Math.floor(options.width * options.scale);
          _this.canvas.height = Math.floor(options.height * options.scale);
          _this.canvas.style.width = options.width + "px";
          _this.canvas.style.height = options.height + "px";
          _this.ctx.scale(_this.options.scale, _this.options.scale);
          _this.ctx.translate(-options.x, -options.y);
          _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
          return _this;
      }
      ForeignObjectRenderer.prototype.render = function (element) {
          return __awaiter(this, void 0, void 0, function () {
              var svg, img;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
                          return [4 /*yield*/, loadSerializedSVG(svg)];
                      case 1:
                          img = _a.sent();
                          if (this.options.backgroundColor) {
                              this.ctx.fillStyle = asString(this.options.backgroundColor);
                              this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
                          }
                          this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
                          return [2 /*return*/, this.canvas];
                  }
              });
          });
      };
      return ForeignObjectRenderer;
  }(Renderer));
  var loadSerializedSVG = function (svg) {
      return new Promise(function (resolve, reject) {
          var img = new Image();
          img.onload = function () {
              resolve(img);
          };
          img.onerror = reject;
          img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
      });
  };

  var Logger = /** @class */ (function () {
      function Logger(_a) {
          var id = _a.id, enabled = _a.enabled;
          this.id = id;
          this.enabled = enabled;
          this.start = Date.now();
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Logger.prototype.debug = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this.enabled) {
              // eslint-disable-next-line no-console
              if (typeof window !== 'undefined' && window.console && typeof console.debug === 'function') {
                  // eslint-disable-next-line no-console
                  console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              }
              else {
                  this.info.apply(this, args);
              }
          }
      };
      Logger.prototype.getTime = function () {
          return Date.now() - this.start;
      };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Logger.prototype.info = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this.enabled) {
              // eslint-disable-next-line no-console
              if (typeof window !== 'undefined' && window.console && typeof console.info === 'function') {
                  // eslint-disable-next-line no-console
                  console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              }
          }
      };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Logger.prototype.warn = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this.enabled) {
              // eslint-disable-next-line no-console
              if (typeof window !== 'undefined' && window.console && typeof console.warn === 'function') {
                  // eslint-disable-next-line no-console
                  console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              }
              else {
                  this.info.apply(this, args);
              }
          }
      };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Logger.prototype.error = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this.enabled) {
              // eslint-disable-next-line no-console
              if (typeof window !== 'undefined' && window.console && typeof console.error === 'function') {
                  // eslint-disable-next-line no-console
                  console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
              }
              else {
                  this.info.apply(this, args);
              }
          }
      };
      Logger.instances = {};
      return Logger;
  }());

  var Context = /** @class */ (function () {
      function Context(options, windowBounds) {
          var _a;
          this.windowBounds = windowBounds;
          this.instanceName = "#" + Context.instanceCount++;
          this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
          this.cache = (_a = options.cache) !== null && _a !== void 0 ? _a : new Cache(this, options);
      }
      Context.instanceCount = 1;
      return Context;
  }());

  var html2canvas = function (element, options) {
      if (options === void 0) { options = {}; }
      return renderElement(element, options);
  };
  if (typeof window !== 'undefined') {
      CacheStorage.setContext(window);
  }
  var renderElement = function (element, opts) { return __awaiter(void 0, void 0, void 0, function () {
      var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a, width, height, left, top, backgroundColor, renderOptions, canvas, renderer, root, renderer;
      var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
      return __generator(this, function (_u) {
          switch (_u.label) {
              case 0:
                  if (!element || typeof element !== 'object') {
                      return [2 /*return*/, Promise.reject('Invalid element provided as first argument')];
                  }
                  ownerDocument = element.ownerDocument;
                  if (!ownerDocument) {
                      throw new Error("Element is not attached to a Document");
                  }
                  defaultView = ownerDocument.defaultView;
                  if (!defaultView) {
                      throw new Error("Document is not attached to a Window");
                  }
                  resourceOptions = {
                      allowTaint: (_b = opts.allowTaint) !== null && _b !== void 0 ? _b : false,
                      imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15000,
                      proxy: opts.proxy,
                      useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
                  };
                  contextOptions = __assign({ logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache }, resourceOptions);
                  windowOptions = {
                      windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
                      windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
                      scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
                      scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
                  };
                  windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
                  context = new Context(contextOptions, windowBounds);
                  foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
                  cloneOptions = {
                      allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
                      onclone: opts.onclone,
                      ignoreElements: opts.ignoreElements,
                      inlineImages: foreignObjectRendering,
                      copyStyles: foreignObjectRendering
                  };
                  context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
                  documentCloner = new DocumentCloner(context, element, cloneOptions);
                  clonedElement = documentCloner.clonedReferenceElement;
                  if (!clonedElement) {
                      return [2 /*return*/, Promise.reject("Unable to find element in cloned iframe")];
                  }
                  return [4 /*yield*/, documentCloner.toIFrame(ownerDocument, windowBounds)];
              case 1:
                  container = _u.sent();
                  _a = isBodyElement(clonedElement) || isHTMLElement(clonedElement)
                      ? parseDocumentSize(clonedElement.ownerDocument)
                      : parseBounds(context, clonedElement), width = _a.width, height = _a.height, left = _a.left, top = _a.top;
                  backgroundColor = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
                  renderOptions = {
                      canvas: opts.canvas,
                      backgroundColor: backgroundColor,
                      scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
                      x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
                      y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
                      width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
                      height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
                  };
                  if (!foreignObjectRendering) return [3 /*break*/, 3];
                  context.logger.debug("Document cloned, using foreign object rendering");
                  renderer = new ForeignObjectRenderer(context, renderOptions);
                  return [4 /*yield*/, renderer.render(clonedElement)];
              case 2:
                  canvas = _u.sent();
                  return [3 /*break*/, 5];
              case 3:
                  context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
                  context.logger.debug("Starting DOM parsing");
                  root = parseTree(context, clonedElement);
                  if (backgroundColor === root.styles.backgroundColor) {
                      root.styles.backgroundColor = COLORS.TRANSPARENT;
                  }
                  context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
                  renderer = new CanvasRenderer(context, renderOptions);
                  return [4 /*yield*/, renderer.render(root)];
              case 4:
                  canvas = _u.sent();
                  _u.label = 5;
              case 5:
                  if ((_t = opts.removeContainer) !== null && _t !== void 0 ? _t : true) {
                      if (!DocumentCloner.destroy(container)) {
                          context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
                      }
                  }
                  context.logger.debug("Finished rendering");
                  return [2 /*return*/, canvas];
          }
      });
  }); };
  var parseBackgroundColor = function (context, element, backgroundColorOverride) {
      var ownerDocument = element.ownerDocument;
      // http://www.w3.org/TR/css3-background/#special-backgrounds
      var documentBackgroundColor = ownerDocument.documentElement
          ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor)
          : COLORS.TRANSPARENT;
      var bodyBackgroundColor = ownerDocument.body
          ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor)
          : COLORS.TRANSPARENT;
      var defaultBackgroundColor = typeof backgroundColorOverride === 'string'
          ? parseColor(context, backgroundColorOverride)
          : backgroundColorOverride === null
              ? COLORS.TRANSPARENT
              : 0xffffffff;
      return element === ownerDocument.documentElement
          ? isTransparent(documentBackgroundColor)
              ? isTransparent(bodyBackgroundColor)
                  ? defaultBackgroundColor
                  : bodyBackgroundColor
              : documentBackgroundColor
          : defaultBackgroundColor;
  };

  return html2canvas;

})));
//# sourceMappingURL=html2canvas.js.map
;

/*****************************************************
*  Filepath: /point_of_sale/static/src/js/Chrome.js  *
*  Lines: 545                                        *
*****************************************************/
odoo.define('point_of_sale.Chrome', function(require) {
    'use strict';

    const { loadCSS } = require('@web/core/assets');
    const { useListener } = require("@web/core/utils/hooks");
    const BarcodeParser = require('barcodes.BarcodeParser');
    const PosComponent = require('point_of_sale.PosComponent');
    const NumberBuffer = require('point_of_sale.NumberBuffer');
    const Registries = require('point_of_sale.Registries');
    const IndependentToOrderScreen = require('point_of_sale.IndependentToOrderScreen');
    const { identifyError, batched } = require('point_of_sale.utils');
    const { odooExceptionTitleMap } = require("@web/core/errors/error_dialogs");
    const { ConnectionLostError, ConnectionAbortedError, RPCError } = require('@web/core/network/rpc_service');
    const { useBus } = require("@web/core/utils/hooks");
    const { debounce } = require("@web/core/utils/timing");
    const { Transition } = require("@web/core/transition");

    const {
        onError,
        onMounted,
        onWillDestroy,
        useExternalListener,
        useRef,
        useState,
        useSubEnv,
        reactive,
    } = owl;

    /**
     * Chrome is the root component of the PoS App.
     */
    class Chrome extends PosComponent {
        setup() {
            super.setup();
            useExternalListener(window, 'beforeunload', this._onBeforeUnload);
            useListener('show-main-screen', this.__showScreen);
            useListener('toggle-debug-widget', debounce(this._toggleDebugWidget, 100));
            useListener('toggle-mobile-searchbar', this._toggleMobileSearchBar);
            useListener('show-temp-screen', this.__showTempScreen);
            useListener('close-temp-screen', this.__closeTempScreen);
            useListener('close-pos', this._closePos);
            useListener('loading-skip-callback', () => this.env.proxy.stop_searching());
            useListener('play-sound', this._onPlaySound);
            useListener('set-sync-status', this._onSetSyncStatus);
            useListener('show-notification', this._onShowNotification);
            useListener('close-notification', this._onCloseNotification);
            useListener('connect-to-proxy', this.connect_to_proxy);
            useBus(this.env.posbus, 'start-cash-control', this.openCashControl);
            NumberBuffer.activate();

            this.state = useState({
                uiState: 'LOADING', // 'LOADING' | 'READY' | 'CLOSING'
                debugWidgetIsShown: true,
                mobileSearchBarIsShown: false,
                hasBigScrollBars: false,
                sound: { src: null },
                notification: {
                    isShown: false,
                    message: '',
                    duration: 2000,
                },
                loadingSkipButtonIsShown: false,
            });

            this.mainScreen = useState({ name: null, component: null });
            this.mainScreenProps = {};

            this.tempScreen = useState({ isShown: false, name: null, component: null });
            this.tempScreenProps = {};

            this.progressbar = useRef('progressbar');

            this.previous_touch_y_coordinate = -1;

            const pos = reactive(this.env.pos, batched(() => this.render(true)))
            useSubEnv({ pos });

            onMounted(() => {
                // remove default webclient handlers that induce click delay
                $(document).off();
                $(window).off();
                $('html').off();
                $('body').off();
            });

            onWillDestroy(() => {
                this.env.pos.destroy();
            });

            onError((error) => {
                // error is an OwlError object.
                console.error(error.cause);
            });

            this.props.setupIsDone(this);
        }

        // GETTERS //

        get customerFacingDisplayButtonIsShown() {
            return this.env.pos.config.iface_customer_facing_display;
        }

        /**
         * Used to give the `state.mobileSearchBarIsShown` value to main screen props
         */
        get mainScreenPropsFielded() {
            return Object.assign({}, this.mainScreenProps, {
                mobileSearchBarIsShown: this.state.mobileSearchBarIsShown,
            });
        }

        /**
         * Startup screen can be based on pos config so the startup screen
         * is only determined after pos data is completely loaded.
         *
         * NOTE: Wait for pos data to be completed before calling this getter.
         */
        get startScreen() {
            if (this.state.uiState !== 'READY') {
                console.warn(
                    `Accessing startScreen of Chrome component before 'state.uiState' to be 'READY' is not recommended.`
                );
            }
            return { name: 'ProductScreen' };
        }

        // CONTROL METHODS //

        /**
         * Call this function after the Chrome component is mounted.
         * This will load pos and assign it to the environment.
         */
        async start() {
            try {
                await this.env.pos.load_server_data();
                await this.setupBarcodeParser();
                if(this.env.pos.config.use_proxy){
                    await this.connect_to_proxy();
                }
                // Load the saved `env.pos.toRefundLines` from localStorage when
                // the PosGlobalState is ready.
                Object.assign(this.env.pos.toRefundLines, this.env.pos.db.load('TO_REFUND_LINES') || {});
                this._buildChrome();
                this._closeOtherTabs();
                this.env.pos.selectedCategoryId = this.env.pos.config.start_category && this.env.pos.config.iface_start_categ_id
                    ? this.env.pos.config.iface_start_categ_id[0]
                    : 0;
                this.state.uiState = 'READY';
                this._showStartScreen();
                setTimeout(() => this._runBackgroundTasks());
            } catch (error) {
                let title = 'Unknown Error',
                    body;

                if (error.message && [100, 200, 404, -32098].includes(error.message.code)) {
                    // this is the signature of rpc error
                    if (error.message.code === -32098) {
                        title = 'Network Failure (XmlHttpRequestError)';
                        body =
                            'The Point of Sale could not be loaded due to a network problem.\n' +
                            'Please check your internet connection.';
                    } else if (error.message.code === 200) {
                        title = error.message.data.message || this.env._t('Server Error');
                        body =
                            error.message.data.debug ||
                            this.env._t(
                                'The server encountered an error while receiving your order.'
                            );
                    }
                } else if (error instanceof Error) {
                    title = error.message;
                    if (error.cause) {
                        body = error.cause.message;
                    } else {
                        body = error.stack;
                    }
                }

                await this.showPopup('ErrorTracebackPopup', {
                    title,
                    body,
                    exitButtonIsShown: true,
                });
            }
        }

        _runBackgroundTasks() {
            // push order in the background, no need to await
            this.env.pos.push_orders();
            // Allow using the app even if not all the images are loaded.
            // Basically, preload the images in the background.
            this._preloadImages();
            if (this.env.pos.config.limited_partners_loading && this.env.pos.config.partner_load_background) {
                // Wrap in fresh reactive: none of the reads during loading should subscribe to anything
                reactive(this.env.pos).loadPartnersBackground();
            }
            if (this.env.pos.config.limited_products_loading && this.env.pos.config.product_load_background) {
                // Wrap in fresh reactive: none of the reads during loading should subscribe to anything
                reactive(this.env.pos).loadProductsBackground().then(() => {
                    this.render(true);
                });
            }
        }

        setupBarcodeParser() {
            if (!this.env.pos.company.nomenclature_id) {
                const errorMessage = this.env._t("The barcode nomenclature setting is not configured. " +
                    "Make sure to configure it on your Point of Sale configuration settings");
                throw new Error(this.env._t("Missing barcode nomenclature"), { cause: { message: errorMessage } });

            }
            const barcode_parser = new BarcodeParser({ nomenclature_id: this.env.pos.company.nomenclature_id });
            this.env.barcode_reader.set_barcode_parser(barcode_parser);
            const fallbackNomenclature = this.env.pos.company.fallback_nomenclature_id;
            if (fallbackNomenclature) {
                const fallbackBarcodeParser = new BarcodeParser({ nomenclature_id: fallbackNomenclature });
                this.env.barcode_reader.setFallbackBarcodeParser(fallbackBarcodeParser);
            }
            return barcode_parser.is_loaded();
        }

        connect_to_proxy() {
            return new Promise((resolve, reject) => {
                this.env.barcode_reader.disconnect_from_proxy();
                this.state.loadingSkipButtonIsShown = true;
                this.env.proxy.autoconnect({
                    force_ip: this.env.pos.config.proxy_ip || undefined,
                    progress: function(prog){},
                }).then(
                    () => {
                        if (this.env.pos.config.iface_scan_via_proxy) {
                            this.env.barcode_reader.connect_to_proxy();
                        }
                        resolve();
                    },
                    (statusText, url) => {
                        // this should reject so that it can be captured when we wait for pos.ready
                        // in the chrome component.
                        // then, if it got really rejected, we can show the error.
                        if (statusText == 'error' && window.location.protocol == 'https:') {
                            reject({
                                title: this.env._t('HTTPS connection to IoT Box failed'),
                                body: _.str.sprintf(
                                    this.env._t('Make sure you are using IoT Box v18.12 or higher. Navigate to %s to accept the certificate of your IoT Box.'),
                                    url
                                ),
                                popup: 'alert',
                            });
                        } else {
                            resolve();
                        }
                    }
                );
            });
        }

        openCashControl() {
            if (this.shouldShowCashControl()) {
                this.showPopup('CashOpeningPopup');
            }
        }

        shouldShowCashControl() {
            return this.env.pos.config.cash_control && this.env.pos.pos_session.state == 'opening_control';
        }

        // EVENT HANDLERS //

        _showStartScreen() {
            const { name, props } = this.startScreen;
            this.showScreen(name, props);
        }
        _getSavedScreen(order) {
            return order.get_screen_data();
        }
        __showTempScreen(event) {
            const { name, props, resolve } = event.detail;
            this.tempScreen.isShown = true;
            this.tempScreen.name = name;
            this.tempScreen.component = this.constructor.components[name];
            this.tempScreenProps = Object.assign({}, props, { resolve });
        }
        __closeTempScreen() {
            this.tempScreen.isShown = false;
            this.tempScreen.name = null;
        }
        __showScreen({ detail: { name, props = {} } }) {
            const component = this.constructor.components[name];
            // 1. Set the information of the screen to display.
            this.mainScreen.name = name;
            this.mainScreen.component = component;
            this.mainScreenProps = props;

            // 2. Save the screen to the order.
            //  - This screen is shown when the order is selected.
            if (!(component.prototype instanceof IndependentToOrderScreen) && name !== "ReprintReceiptScreen") {
                this._setScreenData(name, props);
            }
        }
        /**
         * Set the latest screen to the current order. This is done so that
         * when the order is selected again, the ui returns to the latest screen
         * saved in the order.
         *
         * @param {string} name Screen name
         * @param {Object} props props for the Screen component
         */
        _setScreenData(name, props) {
            const order = this.env.pos.get_order();
            if (order) {
                order.set_screen_data({ name, props });
            }
        }
        async _closePos() {
            // If pos is not properly loaded, we just go back to /web without
            // doing anything in the order data.
            if (!this.env.pos || this.env.pos.db.get_orders().length === 0) {
                window.location = '/web#action=point_of_sale.action_client_pos_menu';
            }

            if (this.env.pos.db.get_orders().length) {
                // If there are orders in the db left unsynced, we try to sync.
                // If sync successful, close without asking.
                // Otherwise, ask again saying that some orders are not yet synced.
                try {
                    await this.env.pos.push_orders();
                    window.location = '/web#action=point_of_sale.action_client_pos_menu';
                } catch (error) {
                    console.warn(error);
                    const reason = this.env.pos.failed
                        ? this.env._t(
                              'Some orders could not be submitted to ' +
                                  'the server due to configuration errors. ' +
                                  'You can exit the Point of Sale, but do ' +
                                  'not close the session before the issue ' +
                                  'has been resolved.'
                          )
                        : this.env._t(
                              'Some orders could not be submitted to ' +
                                  'the server due to internet connection issues. ' +
                                  'You can exit the Point of Sale, but do ' +
                                  'not close the session before the issue ' +
                                  'has been resolved.'
                          );
                    const { confirmed } = await this.showPopup('ConfirmPopup', {
                        title: this.env._t('Offline Orders'),
                        body: reason,
                    });
                    if (confirmed) {
                        this.state.uiState = 'CLOSING';
                        this.state.loadingSkipButtonIsShown = false;
                        window.location = '/web#action=point_of_sale.action_client_pos_menu';
                    }
                }
            }
        }
        _toggleDebugWidget() {
            this.state.debugWidgetIsShown = !this.state.debugWidgetIsShown;
        }
        _toggleMobileSearchBar({ detail: isSearchBarEnabled }) {
            if (isSearchBarEnabled !== null) {
                this.state.mobileSearchBarIsShown = isSearchBarEnabled;
            } else {
                this.state.mobileSearchBarIsShown = !this.state.mobileSearchBarIsShown;
            }
        }
        _onPlaySound({ detail: name }) {
            let src;
            if (name === 'error') {
                src = "/point_of_sale/static/src/sounds/error.wav";
            } else if (name === 'bell') {
                src = "/point_of_sale/static/src/sounds/bell.wav";
            }
            this.state.sound.src = src;
        }
        _onSetSyncStatus({ detail: { status, pending }}) {
            this.env.pos.synch.status = status;
            this.env.pos.synch.pending = pending;
        }
        _onShowNotification({ detail: { message, duration } }) {
            this.state.notification.isShown = true;
            this.state.notification.message = message;
            this.state.notification.duration = duration;
        }
        _onCloseNotification() {
            this.state.notification.isShown = false;
        }
        /**
         * Save `env.pos.toRefundLines` in localStorage on beforeunload - closing the
         * browser, reloading or going to other page.
         */
        _onBeforeUnload() {
            this.env.pos.db.save('TO_REFUND_LINES', this.env.pos.toRefundLines);
        }

        get isTicketScreenShown() {
            return this.mainScreen.name === 'TicketScreen';
        }

        // MISC METHODS //
        _preloadImages() {
            for (let product of this.env.pos.db.get_product_by_category(0)) {
                const image = new Image();
                image.src = `/web/image?model=product.product&field=image_128&id=${product.id}&unique=${product.__last_update}`;
            }
            for (let category of Object.values(this.env.pos.db.category_by_id)) {
                if (category.id == 0) continue;
                const image = new Image();
                image.src = `/web/image?model=pos.category&field=image_128&id=${category.id}&unique=${category.write_date}`;
            }
            const staticImages = ['backspace.png', 'bc-arrow-big.png'];
            for (let imageName of staticImages) {
                const image = new Image();
                image.src = `/point_of_sale/static/src/img/${imageName}`;
            }
        }

        _buildChrome() {
            if ($.browser.chrome) {
                var chrome_version = $.browser.version.split('.')[0];
                if (parseInt(chrome_version, 10) >= 50) {
                    loadCSS('/point_of_sale/static/src/css/chrome50.css');
                }
            }

            if (this.env.pos.config.iface_big_scrollbars) {
                this.state.hasBigScrollBars = true;
            }

            this._disableBackspaceBack();
        }
        // prevent backspace from performing a 'back' navigation
        _disableBackspaceBack() {
            $(document).on('keydown', function (e) {
                if (e.which === 8 && !$(e.target).is('input, textarea')) {
                    e.preventDefault();
                }
            });
        }
        _closeOtherTabs() {
            localStorage['message'] = '';
            localStorage['message'] = JSON.stringify({
                message: 'close_tabs',
                session: this.env.pos.pos_session.id,
            });

            window.addEventListener(
                'storage',
                (event) => {
                    if (event.key === 'message' && event.newValue) {
                        const msg = JSON.parse(event.newValue);
                        if (
                            msg.message === 'close_tabs' &&
                            msg.session == this.env.pos.pos_session.id
                        ) {
                            console.info(
                                'POS / Session opened in another window. EXITING POS'
                            );
                            this._closePos();
                        }
                    }
                },
                false
            );
        }
        showCashMoveButton() {
            return this.env.pos && this.env.pos.config && this.env.pos.config.cash_control;
        }

        // UNEXPECTED ERROR HANDLING //

        /**
         * This method is used to handle unexpected errors. It is registered to
         * the `error_handlers` service when this component is properly mounted.
         * See `onMounted` hook of the `ChromeAdapter` component.
         * @param {*} env
         * @param {UncaughtClientError | UncaughtPromiseError} error
         * @param {*} originalError
         * @returns {boolean}
         */
        errorHandler(env, error, originalError) {
            if (!env.pos) return false;
            const errorToHandle = identifyError(originalError);
            // Assume that the unhandled falsey rejections can be ignored.
            if (errorToHandle) {
                this._errorHandler(error, errorToHandle);
            }
            return true;
        }

        _errorHandler(error, errorToHandle) {
            if (errorToHandle instanceof RPCError) {
                const { message, data } = errorToHandle;
                if (odooExceptionTitleMap.has(errorToHandle.exceptionName)) {
                    const title = odooExceptionTitleMap.get(errorToHandle.exceptionName).toString();
                    this.showPopup('ErrorPopup', { title, body: data.message });
                } else {
                    this.showPopup('ErrorTracebackPopup', {
                        title: message,
                        body: data.message + '\n' + data.debug + '\n',
                    });
                }
            } else if (errorToHandle instanceof ConnectionLostError) {
                this.showPopup('OfflineErrorPopup', {
                    title: this.env._t('Connection is lost'),
                    body: this.env._t('Check the internet connection then try again.'),
                });
            } else if (errorToHandle instanceof ConnectionAbortedError) {
                this.showPopup('OfflineErrorPopup', {
                    title: this.env._t('Connection is aborted'),
                    body: this.env._t('Check the internet connection then try again.'),
                });
            } else if (errorToHandle instanceof Error) {
                // If `errorToHandle` is a normal Error (such as TypeError),
                // the annotated traceback can be found from `error`.
                this.showPopup('ErrorTracebackPopup', {
                    // Hopefully the message is translated.
                    title: `${errorToHandle.name}: ${errorToHandle.message}`,
                    body: error.traceback,
                });
            } else {
                // Hey developer. It's your fault that the error reach here.
                // Please, throw an Error object in order to get stack trace of the error.
                // At least we can find the file that throws the error when you look
                // at the console.
                this.showPopup('ErrorPopup', {
                    title: this.env._t('Unknown Error'),
                    body: this.env._t('Unable to show information about this error.'),
                });
                console.error('Unknown error. Unable to show information about this error.', errorToHandle);
            }
        }
    }
    Chrome.template = 'Chrome';
    Object.defineProperty(Chrome, "components", {
        get () {
            return Object.assign({ Transition }, PosComponent.components);
        }
    })

    Registries.Component.add(Chrome);

    return Chrome;
});
;

/***************************************************************************
*  Filepath: /point_of_sale/static/src/js/ChromeWidgets/CashMoveButton.js  *
*  Lines: 60                                                               *
***************************************************************************/
odoo.define('point_of_sale.CashMoveButton', function (require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');
    const { _t } = require('web.core');
    const { renderToString } = require('@web/core/utils/render');

    const TRANSLATED_CASH_MOVE_TYPE = {
        in: _t('in'),
        out: _t('out'),
    };

    class CashMoveButton extends PosComponent {
        async onClick() {
            const { confirmed, payload } = await this.showPopup('CashMovePopup');
            if (!confirmed) return;
            const { type, amount, reason } = payload;
            const translatedType = TRANSLATED_CASH_MOVE_TYPE[type];
            const formattedAmount = this.env.pos.format_currency(amount);
            if (!amount) {
                return this.showNotification(
                    _.str.sprintf(this.env._t('Cash in/out of %s is ignored.'), formattedAmount),
                    3000
                );
            }
            const extras = { formattedAmount, translatedType };
            await this.rpc({
                model: 'pos.session',
                method: 'try_cash_in_out',
                args: [[this.env.pos.pos_session.id], type, amount, reason, extras],
            });
            if (this.env.proxy.printer) {
                const renderedReceipt = renderToString('point_of_sale.CashMoveReceipt', {
                    _receipt: this._getReceiptInfo({ ...payload, translatedType, formattedAmount }),
                });
                const printResult = await this.env.proxy.printer.print_receipt(renderedReceipt);
                if (!printResult.successful) {
                    this.showPopup('ErrorPopup', { title: printResult.message.title, body: printResult.message.body });
                }
            }
            this.showNotification(
                _.str.sprintf(this.env._t('Successfully made a cash %s of %s.'), type, formattedAmount),
                3000
            );
        }
        _getReceiptInfo(payload) {
            const result = { ...payload };
            result.cashier = this.env.pos.get_cashier();
            result.company = this.env.pos.company;
            result.date = new Date().toLocaleString();
            return result;
        }
    }
    CashMoveButton.template = 'point_of_sale.CashMoveButton';

    Registries.Component.add(CashMoveButton);

    return CashMoveButton;
});
;

/************************************************************************
*  Filepath: /point_of_sale/static/src/js/ChromeWidgets/CashierName.js  *
*  Lines: 24                                                            *
************************************************************************/
odoo.define('point_of_sale.CashierName', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    // Previously UsernameWidget
    class CashierName extends PosComponent {
        get username() {
            const { name } = this.env.pos.get_cashier();
            return name ? name : '';
        }
        get avatar() {
            const user_id = this.env.pos.get_cashier_user_id();
            const id = user_id ? user_id : -1;
            return `/web/image/res.users/${id}/avatar_128`;
        }
    }
    CashierName.template = 'CashierName';

    Registries.Component.add(CashierName);

    return CashierName;
});
;

/****************************************************************************************
*  Filepath: /point_of_sale/static/src/js/ChromeWidgets/CustomerFacingDisplayButton.js  *
*  Lines: 106                                                                           *
****************************************************************************************/
odoo.define('point_of_sale.CustomerFacingDisplayButton', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    const { useState } = owl;

    class CustomerFacingDisplayButton extends PosComponent {
        setup() {
            super.setup();
            this.local = this.env.pos.config.iface_customer_facing_display_local && !this.env.pos.config.iface_customer_facing_display_via_proxy;
            this.state = useState({ status: this.local ? 'success' : 'failure' });
            this._start();
        }
        get message() {
            return {
                success: '',
                warning: this.env._t('Connected, Not Owned'),
                failure: this.env._t('Disconnected'),
                not_found: this.env._t('Customer Screen Unsupported. Please upgrade the IoT Box'),
            }[this.state.status];
        }
        onClick() {
            if (this.local) {
                return this.onClickLocal();
            } else {
                return this.onClickProxy();
            }
        }
        async onClickLocal() {
            this.env.pos.customer_display = window.open('', 'Customer Display', 'height=600,width=900');
            const renderedHtml = await this.env.pos.render_html_for_customer_facing_display();
            var $renderedHtml = $('<div>').html(renderedHtml);
            $(this.env.pos.customer_display.document.body).html($renderedHtml.find('.pos-customer_facing_display'));
            $(this.env.pos.customer_display.document.head).html($renderedHtml.find('.resources').html());
        }
        async onClickProxy() {
            try {
                const renderedHtml = await this.env.pos.render_html_for_customer_facing_display();
                let ownership = await this.env.proxy.take_ownership_over_customer_screen(
                    renderedHtml
                );
                if (typeof ownership === 'string') {
                    ownership = JSON.parse(ownership);
                }
                if (ownership.status === 'success') {
                    this.state.status = 'success';
                } else {
                    this.state.status = 'warning';
                }
                if (!this.env.proxy.posbox_supports_display) {
                    this.env.proxy.posbox_supports_display = true;
                    this._start();
                }
            } catch (error) {
                if (typeof error == 'undefined') {
                    this.state.status = 'failure';
                } else {
                    this.state.status = 'not_found';
                }
            }
        }
        _start() {
            if (this.local) {
                return;
            }

            const self = this;
            async function loop() {
                if (self.env.proxy.posbox_supports_display) {
                    try {
                        let ownership = await self.env.proxy.test_ownership_of_customer_screen();
                        if (typeof ownership === 'string') {
                            ownership = JSON.parse(ownership);
                        }
                        if (ownership.status === 'OWNER') {
                            self.state.status = 'success';
                        } else {
                            self.state.status = 'warning';
                        }
                        setTimeout(loop, 3000);
                    } catch (error) {
                        if (error.abort) {
                            // Stop the loop
                            return;
                        }
                        if (typeof error == 'undefined') {
                            self.state.status = 'failure';
                        } else {
                            self.state.status = 'not_found';
                            self.env.proxy.posbox_supports_display = false;
                        }
                        setTimeout(loop, 3000);
                    }
                }
            }
            loop();
        }
    }
    CustomerFacingDisplayButton.template = 'CustomerFacingDisplayButton';

    Registries.Component.add(CustomerFacingDisplayButton);

    return CustomerFacingDisplayButton;
});
;

/************************************************************************
*  Filepath: /point_of_sale/static/src/js/ChromeWidgets/DebugWidget.js  *
*  Lines: 163                                                           *
************************************************************************/
odoo.define('point_of_sale.DebugWidget', function (require) {
    'use strict';

    const { getFileAsText } = require('point_of_sale.utils');
    const { parse } = require('web.field_utils');
    const NumberBuffer = require('point_of_sale.NumberBuffer');
    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    const { onMounted, onWillUnmount, useRef, useState } = owl;

    class DebugWidget extends PosComponent {
        setup() {
            super.setup();
            this.state = useState({
                barcodeInput: '',
                weightInput: '',
                isPaidOrdersReady: false,
                isUnpaidOrdersReady: false,
                buffer: NumberBuffer.get(),
            });

            // NOTE: Perhaps this can still be improved.
            // What we do here is loop thru the `event` elements
            // then we assign animation that happens when the event is triggered
            // in the proxy. E.g. if open_cashbox is sent, the open_cashbox element
            // changes color from '#6CD11D' to '#1E1E1E' for a duration of 2sec.
            this.eventElementsRef = {};
            this.animations = {};
            for (let eventName of ['open_cashbox', 'print_receipt', 'scale_read']) {
                this.eventElementsRef[eventName] = useRef(eventName);
                this.env.proxy.add_notification(
                    eventName,
                    (() => {
                        if (this.animations[eventName]) {
                            this.animations[eventName].cancel();
                        }
                        const eventElement = this.eventElementsRef[eventName].el;
                        eventElement.style.backgroundColor = '#6CD11D';
                        this.animations[eventName] = eventElement.animate(
                            { backgroundColor: ['#6CD11D', '#1E1E1E'] },
                            2000
                        );
                    }).bind(this)
                );
            }

            onMounted(() => {
                NumberBuffer.on('buffer-update', this, this._onBufferUpdate);
            });

            onWillUnmount(() => {
                NumberBuffer.off('buffer-update', this, this._onBufferUpdate);
            });
        }
        toggleWidget() {
            this.state.isShown = !this.state.isShown;
        }
        setWeight() {
            var weightInKg = parse.float(this.state.weightInput);
            if (!isNaN(weightInKg)) {
                this.env.proxy.debug_set_weight(weightInKg);
            }
        }
        resetWeight() {
            this.state.weightInput = '';
            this.env.proxy.debug_reset_weight();
        }
        async barcodeScan() {
            await this.env.barcode_reader.scan(this.state.barcodeInput);
        }
        async barcodeScanEAN() {
            const ean = this.env.barcode_reader.barcode_parser.sanitize_ean(
                this.state.barcodeInput || '0'
            );
            this.state.barcodeInput = ean;
            await this.env.barcode_reader.scan(ean);
        }
        async deleteOrders() {
            const { confirmed } = await this.showPopup('ConfirmPopup', {
                title: this.env._t('Delete Paid Orders ?'),
                body: this.env._t(
                    'This operation will permanently destroy all paid orders from the local storage. You will lose all the data. This operation cannot be undone.'
                ),
            });
            if (confirmed) {
                this.env.pos.db.remove_all_orders();
                this.env.pos.set_synch('connected', 0);
            }
        }
        async deleteUnpaidOrders() {
            const { confirmed } = await this.showPopup('ConfirmPopup', {
                title: this.env._t('Delete Unpaid Orders ?'),
                body: this.env._t(
                    'This operation will destroy all unpaid orders in the browser. You will lose all the unsaved data and exit the point of sale. This operation cannot be undone.'
                ),
            });
            if (confirmed) {
                this.env.pos.db.remove_all_unpaid_orders();
                window.location = '/';
            }
        }
        _createBlob(contents) {
            if (typeof contents !== 'string') {
                contents = JSON.stringify(contents, null, 2);
            }
            return new Blob([contents]);
        }
        // IMPROVEMENT: Duplicated codes for downloading paid and unpaid orders.
        // The implementation can be better.
        preparePaidOrders() {
            try {
                this.paidOrdersBlob = this._createBlob(this.env.pos.export_paid_orders());
                this.state.isPaidOrdersReady = true;
            } catch (error) {
                console.warn(error);
            }
        }
        get paidOrdersFilename() {
            return `${this.env._t('paid orders')} ${moment().format('YYYY-MM-DD-HH-mm-ss')}.json`;
        }
        get paidOrdersURL() {
            var URL = window.URL || window.webkitURL;
            return URL.createObjectURL(this.paidOrdersBlob);
        }
        prepareUnpaidOrders() {
            try {
                this.unpaidOrdersBlob = this._createBlob(this.env.pos.export_unpaid_orders());
                this.state.isUnpaidOrdersReady = true;
            } catch (error) {
                console.warn(error);
            }
        }
        get unpaidOrdersFilename() {
            return `${this.env._t('unpaid orders')} ${moment().format('YYYY-MM-DD-HH-mm-ss')}.json`;
        }
        get unpaidOrdersURL() {
            var URL = window.URL || window.webkitURL;
            return URL.createObjectURL(this.unpaidOrdersBlob);
        }
        async importOrders(event) {
            const file = event.target.files[0];
            if (file) {
                const report = this.env.pos.import_orders(await getFileAsText(file));
                await this.showPopup('OrderImportPopup', { report });
            }
        }
        refreshDisplay() {
            this.env.proxy.message('display_refresh', {});
        }
        _onBufferUpdate(buffer) {
            this.state.buffer = buffer;
        }
        get bufferRepr() {
            return `"${this.state.buffer}"`;
        }
    }
    DebugWidget.template = 'DebugWidget';

    Registries.Component.add(DebugWidget);

    return DebugWidget;
});
;

/*************************************************************************
*  Filepath: /point_of_sale/static/src/js/ChromeWidgets/HeaderButton.js  *
*  Lines: 36                                                             *
*************************************************************************/
odoo.define('point_of_sale.HeaderButton', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');
    const { ConnectionLostError, ConnectionAbortedError } = require('@web/core/network/rpc_service')
    const { identifyError } = require('point_of_sale.utils');

    // Previously HeaderButtonWidget
    // This is the close session button
    class HeaderButton extends PosComponent {
        async onClick() {
            try {
                const info = await this.env.pos.getClosePosInfo();
                this.showPopup('ClosePosPopup', { info: info, keepBehind: true });
            } catch (e) {
                if (identifyError(e) instanceof ConnectionAbortedError||ConnectionLostError) {
                    this.showPopup('OfflineErrorPopup', {
                        title: this.env._t('Network Error'),
                        body: this.env._t('Please check your internet connection and try again.'),
                    });
                } else {
                    this.showPopup('ErrorPopup', {
                        title: this.env._t('Unknown Error'),
                        body: this.env._t('An unknown error prevents us from getting closing information.'),
                    });
                }
            }
        }
    }
    HeaderButton.template = 'HeaderButton';

    Registries.Component.add(HeaderButton);

    return HeaderButton;
});
;

/************************************************************************
*  Filepath: /point_of_sale/static/src/js/ChromeWidgets/ProxyStatus.js  *
*  Lines: 83                                                            *
************************************************************************/
odoo.define('point_of_sale.ProxyStatus', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    const { onMounted, onWillUnmount, useState } = owl;

    // Previously ProxyStatusWidget
    class ProxyStatus extends PosComponent {
        setup() {
            super.setup();
            const initialProxyStatus = this.env.proxy.get('status');
            this.state = useState({
                status: initialProxyStatus.status,
                msg: initialProxyStatus.msg,
            });
            this.statuses = ['connected', 'connecting', 'disconnected', 'warning'];
            this.index = 0;

            onMounted(() => {
                this.env.proxy.on('change:status', this, this._onChangeStatus);
            });

            onWillUnmount(() => {
                this.env.proxy.off('change:status', this, this._onChangeStatus);
            });
        }
        _onChangeStatus(posProxy, statusChange) {
            this._setStatus(statusChange.newValue);
        }
        _setStatus(newStatus) {
            if (newStatus.status === 'connected') {
                var warning = false;
                var msg = '';
                if (this.env.pos.config.iface_scan_via_proxy) {
                    var scannerStatus = newStatus.drivers.scanner
                        ? newStatus.drivers.scanner.status
                        : false;
                    if (scannerStatus != 'connected' && scannerStatus != 'connecting') {
                        warning = true;
                        msg += this.env._t('Scanner');
                    }
                }
                if (
                    this.env.pos.config.iface_print_via_proxy ||
                    this.env.pos.config.iface_cashdrawer
                ) {
                    var printerStatus = newStatus.drivers.printer
                        ? newStatus.drivers.printer.status
                        : false;
                    if (printerStatus != 'connected' && printerStatus != 'connecting') {
                        warning = true;
                        msg = msg ? msg + ' & ' : msg;
                        msg += this.env._t('Printer');
                    }
                }
                if (this.env.pos.config.iface_electronic_scale) {
                    var scaleStatus = newStatus.drivers.scale
                        ? newStatus.drivers.scale.status
                        : false;
                    if (scaleStatus != 'connected' && scaleStatus != 'connecting') {
                        warning = true;
                        msg = msg ? msg + ' & ' : msg;
                        msg += this.env._t('Scale');
                    }
                }
                msg = msg ? msg + ' ' + this.env._t('Offline') : msg;

                this.state.status = warning ? 'warning' : 'connected';
                this.state.msg = msg;
            } else {
                this.state.status = newStatus.status;
                this.state.msg = newStatus.msg || '';
            }
        }
    }
    ProxyStatus.template = 'ProxyStatus';

    Registries.Component.add(ProxyStatus);

    return ProxyStatus;
});
;

/******************************************************************************
*  Filepath: /point_of_sale/static/src/js/ChromeWidgets/SaleDetailsButton.js  *
*  Lines: 39                                                                  *
******************************************************************************/
odoo.define('point_of_sale.SaleDetailsButton', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');
    const { renderToString } = require('@web/core/utils/render');

    class SaleDetailsButton extends PosComponent {
        async onClick() {
            // IMPROVEMENT: Perhaps put this logic in a parent component
            // so that for unit testing, we can check if this simple
            // component correctly triggers an event.
            const saleDetails = await this.rpc({
                model: 'report.point_of_sale.report_saledetails',
                method: 'get_sale_details',
                args: [false, false, false, [this.env.pos.pos_session.id]],
            });
            const report = renderToString(
                'SaleDetailsReport',
                Object.assign({}, saleDetails, {
                    date: new Date().toLocaleString(),
                    pos: this.env.pos,
                })
            );
            const printResult = await this.env.proxy.printer.print_receipt(report);
            if (!printResult.successful) {
                await this.showPopup('ErrorPopup', {
                    title: printResult.message.title,
                    body: printResult.message.body,
                });
            }
        }
    }
    SaleDetailsButton.template = 'SaleDetailsButton';

    Registries.Component.add(SaleDetailsButton);

    return SaleDetailsButton;
});
;

/*****************************************************************************
*  Filepath: /point_of_sale/static/src/js/ChromeWidgets/SyncNotification.js  *
*  Lines: 17                                                                 *
*****************************************************************************/
odoo.define('point_of_sale.SyncNotification', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    class SyncNotification extends PosComponent {
        onClick() {
            this.env.pos.push_orders(null, { show_error: true });
        }
    }
    SyncNotification.template = 'SyncNotification';

    Registries.Component.add(SyncNotification);

    return SyncNotification;
});
;

/*************************************************************************
*  Filepath: /point_of_sale/static/src/js/ChromeWidgets/TicketButton.js  *
*  Lines: 28                                                             *
*************************************************************************/
odoo.define('point_of_sale.TicketButton', function (require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    class TicketButton extends PosComponent {
        onClick() {
            if (this.props.isTicketScreenShown) {
                this.env.posbus.trigger('ticket-button-clicked');
            } else {
                this.showScreen('TicketScreen');
            }
        }
        get count() {
            if (this.env.pos) {
                return this.env.pos.get_order_list().length;
            } else {
                return 0;
            }
        }
    }
    TicketButton.template = 'TicketButton';

    Registries.Component.add(TicketButton);

    return TicketButton;
});
;

/************************************************************
*  Filepath: /point_of_sale/static/src/js/ClassRegistry.js  *
*  Lines: 262                                               *
************************************************************/
odoo.define('point_of_sale.ClassRegistry', function (require) {
    'use strict';

    /**
     * **Usage:**
     * ```
     * const Registry = new ClassRegistry();
     *
     * class A {}
     * Registry.add(A);
     *
     * const AExt1 = A => class extends A {}
     * Registry.extend(A, AExt1)
     *
     * const B = A => class extends A {}
     * Registry.addByExtending(B, A)
     *
     * const AExt2 = A => class extends A {}
     * Registry.extend(A, AExt2)
     *
     * Registry.get(A)
     * // above returns: AExt2 -> AExt1 -> A
     * // Basically, 'A' in the registry points to
     * // the inheritance chain above.
     *
     * Registry.get(B)
     * // above returns: B -> AExt2 -> AExt1 -> A
     * // Even though B extends A before applying all
     * // the extensions of A, when getting it from the
     * // registry, the return points to a class with
     * // inheritance chain that includes all the extensions
     * // of 'A'.
     *
     * Registry.freeze()
     * // Example 'B' above is lazy. Basically, it is only
     * // computed when we call `get` from the registry.
     * // If we know that no more dynamic inheritances will happen,
     * // we can freeze the registry and cache the final form
     * // of each class in the registry.
     * ```
     *
     * IMPROVEMENT:
     * * So far, mixin can be accomplished by creating a method
     *  the takes a class and returns a class expression. This is then
     *  used before the extends keyword like so:
     *
     *  ```js
     *  class A {}
     *  Registry.add(A)
     *  const Mixin = x => class extends x {}
     *  //                          apply mixin
     *  //                              |
     *  //                              v
     *  const B = x => class extends Mixin(x) {}
     *  Registry.addByExtending(B, A)
     *  ```
     *
     *  In the example, `|B| => B -> Mixin -> A`, and this is pretty convenient
     *  already. However, this can still be improved since classes are only
     *  compiled after `Registry.freeze()`. Perhaps, we can make the
     *  Mixins extensible as well, such as so:
     *
     *  ```
     *  class A {}
     *  Registry.add(A)
     *  const Mixin = x => class extends x {}
     *  Registry.add(Mixin)
     *  const OtherMixin = x => class extends x {}
     *  Registry.add(OtherMixin)
     *  const B = x => class extends x {}
     *  Registry.addByExtending(B, A, [Mixin, OtherMixin])
     *  const ExtendMixin = x => class extends x {}
     *  Registry.extend(Mixin, ExtendMixin)
     *  ```
     *
     *  In the above, after `Registry.freeze()`,
     *  `|B| => B -> OtherMixin -> ExtendMixin -> Mixin -> A`
     */
    class ClassRegistry {
        constructor() {
            // base name map
            this.baseNameMap = {};
            // Object that maps `baseClass` to the class implementation extended in-place.
            this.includedMap = new Map();
            // Object that maps `baseClassCB` to the array of callbacks to generate the extended class.
            this.extendedCBMap = new Map();
            // Object that maps `baseClassCB` extended class to the `baseClass` of its super in the includedMap.
            this.extendedSuperMap = new Map();
            // For faster access, we can `freeze` the registry so that instead of dynamically generating
            // the extended classes, it is taken from the cache instead.
            this.cache = new Map();
        }
        /**
         * Add a new class in the Registry.
         * @param {Function} baseClass `class`
         */
        add(baseClass) {
            this.includedMap.set(baseClass, []);
            this.baseNameMap[baseClass.name] = baseClass;
        }
        /**
         * Add a new class in the Registry based on other class
         * in the registry.
         * @param {Function} baseClassCB `class -> class`
         * @param {Function} base `class | class -> class`
         */
        addByExtending(baseClassCB, base) {
            this.extendedCBMap.set(baseClassCB, [baseClassCB]);
            this.extendedSuperMap.set(baseClassCB, base);
            this.baseNameMap[baseClassCB.name] = baseClassCB;
        }
        /**
         * Extend in-place a class in the registry. E.g.
         * ```
         * // Using the following notation:
         * //  * |A| -  compiled class in the registry
         * //  *  A  -  class or an extension callback
         * //  * |A| => A2 -> A1 -> A
         * //       -  the above means, compiled class A
         * //          points to the class inheritance derived from
         * //          A2(A1(A))
         *
         * class A {};
         * Registry.add(A);
         * // |A| => A
         *
         * let A1 = x => class extends x {};
         * Registry.extend(A, A1);
         * // |A| => A1 -> A
         *
         * let B = x => class extends x {};
         * Registry.addByExtending(B, A);
         * // |B| => B -> |A|
         * // |B| => B -> A1 -> A
         *
         * let B1 = x => class extends x {};
         * Registry.extend(B, B1);
         * // |B| => B1 -> B -> |A|
         *
         * let C = x => class extends x {};
         * Registry.addByExtending(C, B);
         * // |C| => C -> |B|
         *
         * let B2 = x => class extends x {};
         * Registry.extend(B, B2);
         * // |B| => B2 -> B1 -> B -> |A|
         *
         * // Overall:
         * // |A| => A1 -> A
         * // |B| => B2 -> B1 -> B -> A1 -> A
         * // |C| => C -> B2 -> B1 -> B -> A1 -> A
         * ```
         * @param {Function} base `class | class -> class`
         * @param {Function} extensionCB `class -> class`
         */
        extend(base, extensionCB) {
            if (typeof base === 'string') {
                base = this.baseNameMap[base];
            }
            let extensionArray;
            if (this.includedMap.get(base)) {
                extensionArray = this.includedMap.get(base);
            } else if (this.extendedCBMap.get(base)) {
                extensionArray = this.extendedCBMap.get(base);
            } else {
                throw new Error(
                    `'${base.name}' is not in the Registry. Add it to Registry before extending.`
                );
            }
            extensionArray.push(extensionCB);
            const locOfNewExtension = extensionArray.length - 1;
            const self = this;
            const oldCompiled = this.isFrozen ? this.cache.get(base) : null;
            return {
                remove() {
                    extensionArray.splice(locOfNewExtension, 1);
                    self._recompute(base, oldCompiled);
                },
                compile() {
                    self._recompute(base);
                }
            };
        }
        _compile(base) {
            let res;
            if (this.includedMap.has(base)) {
                res = this.includedMap.get(base).reduce((acc, ext) => ext(acc), base);
            } else {
                const superClass = this.extendedSuperMap.get(base);
                const extensionCBs = this.extendedCBMap.get(base);
                res = extensionCBs.reduce((acc, ext) => ext(acc), this._compile(superClass));
            }
            Object.defineProperty(res, 'name', { value: base.name });
            return res;
        }
        /**
         * Return the compiled class (containing all the extensions) of the base class.
         * @param {Function} base `class | class -> class` function used in adding the class
         */
        get(base) {
            if (typeof base === 'string') {
                base = this.baseNameMap[base];
            }
            if (this.isFrozen) {
                return this.cache.get(base);
            }
            return this._compile(base);
        }
        /**
         * Uses the callbacks registered in the registry to compile the classes.
         */
        freeze() {
            // Step: Compile the `included classes`.
            for (let [baseClass, extensionCBs] of this.includedMap.entries()) {
                const compiled = extensionCBs.reduce((acc, ext) => ext(acc), baseClass);
                this.cache.set(baseClass, compiled);
            }

            // Step: Compile the `extended classes` based on `included classes`.
            // Also gather those the are based on `extended classes`.
            const remaining = [];
            for (let [baseClassCB, extensionCBArray] of this.extendedCBMap.entries()) {
                const compiled = this.cache.get(this.extendedSuperMap.get(baseClassCB));
                if (!compiled) {
                    remaining.push([baseClassCB, extensionCBArray]);
                    continue;
                }
                const extendedClass = extensionCBArray.reduce(
                    (acc, extensionCB) => extensionCB(acc),
                    compiled
                );
                this.cache.set(baseClassCB, extendedClass);
            }

            // Step: Compile the `extended classes` based on `extended classes`.
            for (let [baseClassCB, extensionCBArray] of remaining) {
                const compiled = this.cache.get(this.extendedSuperMap.get(baseClassCB));
                const extendedClass = extensionCBArray.reduce(
                    (acc, extensionCB) => extensionCB(acc),
                    compiled
                );
                this.cache.set(baseClassCB, extendedClass);
            }

            // Step: Set the name of the compiled classess
            for (let [base, compiledClass] of this.cache.entries()) {
                Object.defineProperty(compiledClass, 'name', { value: base.name });
            }

            // Step: Set the flag to true;
            this.isFrozen = true;
        }
        _recompute(base, old) {
            if (typeof base === 'string') {
                base = this.baseNameMap[base];
            }
            return old ? old : this._compile(base);
        }
    }

    return ClassRegistry;
});
;

/****************************************************************
*  Filepath: /point_of_sale/static/src/js/ComponentRegistry.js  *
*  Lines: 29                                                    *
****************************************************************/
odoo.define('point_of_sale.ComponentRegistry', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const ClassRegistry = require('point_of_sale.ClassRegistry');

    class ComponentRegistry extends ClassRegistry {
        freeze() {
            super.freeze();
            // Make sure PosComponent has the compiled classes.
            // This way, we don't need to explicitly declare that
            // a set of components is children of another.
            PosComponent.components = {};
            for (let [base, compiledClass] of this.cache.entries()) {
                PosComponent.components[base.name] = compiledClass;
            }
        }
        _recompute(base, old) {
            const res = super._recompute(base, old);
            if (typeof base === 'string') {
                base = this.baseNameMap[base];
            }
            PosComponent.components[base.name] = res;
            return res;
        }
    }

    return ComponentRegistry;
});
;

/******************************************************************
*  Filepath: /point_of_sale/static/src/js/ControlButtonsMixin.js  *
*  Lines: 107                                                     *
******************************************************************/
odoo.define('point_of_sale.ControlButtonsMixin', function (require) {
    'use strict';

    const Registries = require('point_of_sale.Registries');

    /**
     * Component that has this mixin allows the use of `addControlButton`.
     * All added control buttons that satisfies the condition can be accessed
     * thru the `controlButtons` field of the Component's instance. These
     * control buttons can then be rendered in the Component.
     * @param {Function} x superclass
     */
    const ControlButtonsMixin = (x) => {
        const controlButtonsToPosition = [];
        const sortedControlButtons = [];

        class Extended extends x {
            get controlButtons() {
                return sortedControlButtons
                    .filter((cb) => {
                        return cb.condition ? cb.condition.bind(this)() : true;
                    })
                    .map((cb) =>
                        Object.assign({}, cb, { component: Registries.Component.get(cb.component) })
                    );
            }
        }
        /**
         * @param {Object} controlButton
         * @param {Function} controlButton.component
         *      Base class that is added in the Registries.Component.
         * @param {Function} controlButton.condition zero argument function that is bound
         *      to the instance of ProductScreen, such that `this.env.pos` can be used
         *      inside the function.
         * @param {Array} [controlButton.position] array of two elements
         *      [locator, relativeTo]
         *      locator: string -> any of ('before', 'after', 'replace')
         *      relativeTo: string -> other controlButtons component name
         */
        Extended.addControlButton = function (controlButton) {
            // We set the name first.
            if (!controlButton.name) {
                controlButton.name = controlButton.component.name;
            }

            // If no position is set, we just push it to the array.
            if (!controlButton.position) {
                sortedControlButtons.push(controlButton);
            } else {
                controlButtonsToPosition.push(controlButton);
            }
        };

        /**
         * Call this static method to make the added control buttons in proper
         * order.
         * NOTE: This isn't necessarily a fast algorithm. I doubt that the number
         * of control buttons will exceed an order of hundreds, so for practical
         * purposes, it is enough.
         */
        Extended.sortControlButtons = function () {
            function setControlButton(locator, index, cb) {
                if (locator == 'replace') {
                    sortedControlButtons[index] = cb;
                } else if (locator == 'before') {
                    sortedControlButtons.splice(index, 0, cb);
                } else if (locator == 'after') {
                    sortedControlButtons.splice(index + 1, 0, cb);
                }
            }
            function locate(cb) {
                const [locator, reference] = cb.position;
                const index = sortedControlButtons.findIndex((cb) => cb.name == reference);
                return [locator, index, reference];
            }
            const cbMissingReference = [];
            // 1. First pass. If the reference control button isn't there, collect it for second pass.
            for (let cb of controlButtonsToPosition) {
                const [locator, index] = locate(cb);
                if (index == -1) {
                    cbMissingReference.push(cb);
                    continue;
                }
                setControlButton(locator, index, cb);
            }
            // 2. Second pass.
            // If during the first pass, 1 -> 2, 2 -> 3, 3 -> 4, 4 -> 5 and 5 is already
            // in the sorted control buttons, then 1, 2, 3 & 4 are put in `cbMissingReference`.
            // This only means 2 things about the objects in `cbMissingReference`:
            //  i) They are referencing the cb after them
            //  ii) They really have missing reference.
            // Thus, we have to iterate the cb with missing reference in reverse.
            for (let cb of cbMissingReference.reverse()) {
                const [locator, index, reference] = locate(cb);
                if (index == -1) {
                    console.warn(`'${cb.name}' is not properly position because '${reference}' is not found. Is '${reference}' spelled correctly?`);
                    sortedControlButtons.push(cb);
                } else {
                    setControlButton(locator, index, cb);
                }
            }
        }
        return Extended;
    };

    return ControlButtonsMixin;
});
;

/**************************************************
*  Filepath: /point_of_sale/static/src/js/Gui.js  *
*  Lines: 64                                      *
**************************************************/
odoo.define('point_of_sale.Gui', function (require) {
    'use strict';

    const { status } = owl;

    /**
     * This module bridges the data classes (such as those defined in
     * models.js) to the view (Component) but not vice versa.
     *
     * The idea is to be able to perform side-effects to the user interface
     * during calculation. Think of console.log during times we want to see
     * the result of calculations. This is no different, except that instead
     * of printing something in the console, we access a method in the user
     * interface then the user interface reacts, e.g. calling `showPopup`.
     *
     * This however can be dangerous to the user interface as it can be possible
     * that a rendered component is destroyed during the calculation. Because of
     * this, we are going to limit external ui controls to those safe ones to
     * use such as:
     *  - `showPopup`
     *  - `showTempScreen`
     *
     * IMPROVEMENT: After all, this Gui layer seems to be a good abstraction because
     * there is a complete decoupling between data and view despite the data being
     * able to use selected functionalities in the view layer. More formalized
     * implementation is welcome.
     */

    const config = {};

    /**
     * Call this when the user interface is ready. Provide the component
     * that will be used to control the ui.
     * @param {component} component component having the ui methods.
     */
    const configureGui = ({ component }) => {
        config.component = component;
        config.availableMethods = new Set([
            'showScreen',
            'showPopup',
            'showTempScreen',
            'playSound',
            'setSyncStatus',
            'showNotification',
        ]);
    };

    /**
     * Import this and consume like so: `Gui.showPopup(<PopupName>, <props>)`.
     * Like you would call `showPopup` in a component.
     */
    const Gui = new Proxy(config, {
        get(target, key) {
            const { component, availableMethods } = target;
            if (!component) throw new Error(`Call 'configureGui' before using Gui.`);
            const isMounted = status(component) === 'mounted';
            if (availableMethods.has(key) && isMounted) {
                return component[key].bind(component);
            }
        },
    });

    return { configureGui, Gui };
});
;

/*************************************************************************
*  Filepath: /point_of_sale/static/src/js/Misc/AbstractReceiptScreen.js  *
*  Lines: 67                                                             *
*************************************************************************/
odoo.define('point_of_sale.AbstractReceiptScreen', function (require) {
    'use strict';

    const { nextFrame } = require('point_of_sale.utils');
    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    const { useRef } = owl;

    /**
     * This relies on the assumption that there is a reference to
     * `order-receipt` so it is important to declare a `t-ref` to
     * `order-receipt` in the template of the Component that extends
     * this abstract component.
     */
    class AbstractReceiptScreen extends PosComponent {
        setup() {
            super.setup();
            this.orderReceipt = useRef('order-receipt');
        }
        async _printReceipt() {
            if (this.env.proxy.printer) {
                const printResult = await this.env.proxy.printer.print_receipt(this.orderReceipt.el.innerHTML);
                if (printResult.successful) {
                    return true;
                } else {
                    await this.showPopup('ErrorPopup', {
                        title: printResult.message.title,
                        body: printResult.message.body,
                    });
                    const { confirmed } = await this.showPopup('ConfirmPopup', {
                        title: printResult.message.title,
                        body: 'Do you want to print using the web printer?',
                    });
                    if (confirmed) {
                        // We want to call the _printWeb when the popup is fully gone
                        // from the screen which happens after the next animation frame.
                        await nextFrame();
                        return await this._printWeb();
                    }
                    return false;
                }
            } else {
                return await this._printWeb();
            }
        }
        async _printWeb() {
            try {
                window.print();
                return true;
            } catch (_err) {
                await this.showPopup('ErrorPopup', {
                    title: this.env._t('Printing is not supported on some browsers'),
                    body: this.env._t(
                        'Printing is not supported on some browsers due to no default printing protocol ' +
                            'is available. It is possible to print your tickets by making use of an IoT Box.'
                    ),
                });
                return false;
            }
        }
    }

    Registries.Component.add(AbstractReceiptScreen);

    return AbstractReceiptScreen;
});
;

/******************************************************************
*  Filepath: /point_of_sale/static/src/js/Misc/CurrencyAmount.js  *
*  Lines: 13                                                      *
******************************************************************/
odoo.define('point_of_sale.CurrencyAmount', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    class CurrencyAmount extends PosComponent {}
    CurrencyAmount.template = 'CurrencyAmount';

    Registries.Component.add(CurrencyAmount);

    return CurrencyAmount;
});
;

/*************************************************************
*  Filepath: /point_of_sale/static/src/js/Misc/Draggable.js  *
*  Lines: 145                                                *
*************************************************************/
odoo.define('point_of_sale.Draggable', function(require) {
    'use strict';

    const { useListener } = require("@web/core/utils/hooks");
    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    const { onMounted, useExternalListener } = owl;

    /**
     * Wrap an element or a component with { position: absolute } to make it
     * draggable around the limitArea or the nearest positioned ancestor.
     *
     * e.g.
     * ```
     * <div class="limit-area">
     *   <Draggable limitArea="'.limit-area'">
     *     <div class="popup">
     *       <header class="drag-handle"></header>
     *     </div>
     *     <div class="popup body"></div>
     *   </Draggable>
     * </div>
     * ```
     *
     * In the above snippet, if the popup div is { position: absolute },
     * then it becomes draggable around the .limit-area element if it is dragged
     * thru its Header -- because of the .drag-handle element.
     *
     * @trigger 'drag-end' when dragging ended with payload `{ loc: { top, left } }`
     */
    class Draggable extends PosComponent {
        setup() {
            super.setup();
            this.isDragging = false;
            this.dx = 0;
            this.dy = 0;
            // drag with mouse
            useExternalListener(document, 'mousemove', this.move);
            useExternalListener(document, 'mouseup', this.endDrag);
            // drag with touch
            useExternalListener(document, 'touchmove', this.move);
            useExternalListener(document, 'touchend', this.endDrag);

            useListener('mousedown', '.drag-handle', this.startDrag);
            useListener('touchstart', '.drag-handle', this.startDrag);

            onMounted(() => {
                this.limitArea = this.props.limitArea
                    ? document.querySelector(this.props.limitArea)
                    : this.el.offsetParent;
                if (!this.limitArea) return;
                this.limitAreaBoundingRect = this.limitArea.getBoundingClientRect();
                if (this.limitArea === this.el.offsetParent) {
                    this.limitLeft = 0;
                    this.limitTop = 0;
                    this.limitRight = this.limitAreaBoundingRect.width;
                    this.limitBottom = this.limitAreaBoundingRect.height;
                } else {
                    this.limitLeft = -this.el.offsetParent.offsetLeft;
                    this.limitTop = -this.el.offsetParent.offsetTop;
                    this.limitRight =
                        this.limitAreaBoundingRect.width - this.el.offsetParent.offsetLeft;
                    this.limitBottom =
                        this.limitAreaBoundingRect.height - this.el.offsetParent.offsetTop;
                }
                this.limitAreaWidth = this.limitAreaBoundingRect.width;
                this.limitAreaHeight = this.limitAreaBoundingRect.height;
    
                // absolutely position the element then remove the transform.
                const elBoundingRect = this.el.getBoundingClientRect();
                this.el.style.top = `${elBoundingRect.top}px`;
                this.el.style.left = `${elBoundingRect.left}px`;
                this.el.style.transform = 'none';
            });
        }
        startDrag(event) {
            let realEvent;
            if (event instanceof CustomEvent) {
                realEvent = event.detail;
            } else {
                realEvent = event;
            }
            const { x, y } = this._getEventLoc(realEvent);
            this.isDragging = true;
            this.dx = this.el.offsetLeft - x;
            this.dy = this.el.offsetTop - y;
            event.stopPropagation();
        }
        move(event) {
            if (this.isDragging) {
                const { x: pointerX, y: pointerY } = this._getEventLoc(event);
                const posLeft = this._getPosLeft(pointerX, this.dx);
                const posTop = this._getPosTop(pointerY, this.dy);
                this.el.style.left = `${posLeft}px`;
                this.el.style.top = `${posTop}px`;
            }
        }
        endDrag() {
            if (this.isDragging) {
                this.isDragging = false;
                this.trigger('drag-end', {
                    loc: { top: this.el.offsetTop, left: this.el.offsetLeft },
                });
            }
        }
        _getEventLoc(event) {
            let coordX, coordY;
            if (event.touches && event.touches[0]) {
                coordX = event.touches[0].clientX;
                coordY = event.touches[0].clientY;
            } else {
                coordX = event.clientX;
                coordY = event.clientY;
            }
            return {
                x: coordX,
                y: coordY,
            };
        }
        _getPosLeft(pointerX, dx) {
            const posLeft = pointerX + dx;
            if (posLeft < this.limitLeft) {
                return this.limitLeft;
            } else if (posLeft > this.limitRight - this.el.offsetWidth) {
                return this.limitRight - this.el.offsetWidth;
            }
            return posLeft;
        }
        _getPosTop(pointerY, dy) {
            const posTop = pointerY + dy;
            if (posTop < this.limitTop) {
                return this.limitTop;
            } else if (posTop > this.limitBottom - this.el.offsetHeight) {
                return this.limitBottom - this.el.offsetHeight;
            }
            return posTop;
        }
    }
    Draggable.template = 'Draggable';

    Registries.Component.add(Draggable);

    return Draggable;
});
;

/****************************************************************************
*  Filepath: /point_of_sale/static/src/js/Misc/IndependentToOrderScreen.js  *
*  Lines: 15                                                                *
****************************************************************************/
odoo.define('point_of_sale.IndependentToOrderScreen', function (require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');

    class IndependentToOrderScreen extends PosComponent {
        close() {
            const order = this.env.pos.get_order();
            const { name: screenName } = order.get_screen_data();
            this.showScreen(screenName);
        }
    }

    return IndependentToOrderScreen;
});
;

/*********************************************************************
*  Filepath: /point_of_sale/static/src/js/Misc/MobileOrderWidget.js  *
*  Lines: 25                                                         *
*********************************************************************/
odoo.define('point_of_sale.MobileOrderWidget', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    class MobileOrderWidget extends PosComponent {
        get order() {
            return this.env.pos.get_order();
        }
        get total() {
            const _total = this.order ? this.order.get_total_with_tax() : 0;
            return this.env.pos.format_currency(_total);
        }
        get items_number() {
            return this.order ? this.order.orderlines.reduce((items_number,line) => items_number + line.quantity, 0) : 0;
        }
    }

    MobileOrderWidget.template = 'MobileOrderWidget';

    Registries.Component.add(MobileOrderWidget);

    return MobileOrderWidget;
});
;

/*********************************************************************
*  Filepath: /point_of_sale/static/src/js/Misc/NotificationSound.js  *
*  Lines: 19                                                         *
*********************************************************************/
odoo.define('point_of_sale.NotificationSound', function (require) {
    'use strict';

    const { useListener } = require("@web/core/utils/hooks");
    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    class NotificationSound extends PosComponent {
        setup() {
            super.setup();
            useListener('ended', () => (this.props.sound.src = null));
        }
    }
    NotificationSound.template = 'NotificationSound';

    Registries.Component.add(NotificationSound);

    return NotificationSound;
});
;

/****************************************************************
*  Filepath: /point_of_sale/static/src/js/Misc/NumberBuffer.js  *
*  Lines: 311                                                   *
****************************************************************/
odoo.define('point_of_sale.NumberBuffer', function(require) {
    'use strict';

    const { useListener } = require("@web/core/utils/hooks");
    const { parse } = require('web.field_utils');
    const { barcodeService } = require('@barcodes/barcode_service');
    const { _t } = require('web.core');
    const { Gui } = require('point_of_sale.Gui');

    const { EventBus, onMounted, onWillUnmount, useComponent, useExternalListener } = owl;
    const INPUT_KEYS = new Set(
        ['Delete', 'Backspace', '+1', '+2', '+5', '+10', '+20', '+50'].concat('0123456789+-.,'.split(''))
    );
    const CONTROL_KEYS = new Set(['Enter', 'Esc']);
    const ALLOWED_KEYS = new Set([...INPUT_KEYS, ...CONTROL_KEYS]);
    const getDefaultConfig = () => ({
        decimalPoint: false,
        triggerAtEnter: false,
        triggerAtEsc: false,
        triggerAtInput: false,
        nonKeyboardInputEvent: false,
        useWithBarcode: false,
    });

    /**
     * This is a singleton.
     *
     * Only one component can `use` the buffer at a time.
     * This is done by keeping track of each component (and its
     * corresponding state and config) using a stack (bufferHolderStack).
     * The component on top of the stack is the one that currently
     * `holds` the buffer.
     *
     * When the current component is unmounted, the top of the stack
     * is popped and NumberBuffer is set up again for the new component
     * on top of the stack.
     *
     * Usage
     * =====
     * - Activate in the construction of root component. `NumberBuffer.activate()`
     * - Use the buffer in a child component by calling `NumberBuffer.use(<config>)`
     *   in the constructor of the child component.
     * - The component that `uses` the buffer has access to the following instance
     *   methods of the NumberBuffer:
     *   - get()
     *   - set(val)
     *   - reset()
     *   - getFloat()
     *   - capture()
     *
     * Note
     * ====
     * - No need to instantiate as it is a singleton created before exporting in this module.
     *
     * Possible Improvements
     * =====================
     * - Relieve the buffer from responsibility of handling `Enter` and other control keys.
     * - Make the constants (ALLOWED_KEYS, etc.) more configurable.
     * - Write more integration tests. NumberPopup can be used as test component.
     */
    class NumberBuffer extends EventBus {
        constructor() {
            super();
            this.isReset = false;
            this.bufferHolderStack = [];
        }
        /**
         * @returns {String} value of the buffer, e.g. '-95.79'
         */
        get() {
            return this.state ? this.state.buffer : null;
        }
        /**
         * Takes a string that is convertible to float, and set it as
         * value of the buffer. e.g. val = '2.99';
         *
         * @param {String} val
         */
        set(val) {
            this.state.buffer = !isNaN(parseFloat(val)) ? val : '';
            this.trigger('buffer-update', this.state.buffer);
        }
        /**
         * Resets the buffer to empty string.
         */
        reset() {
            this.isReset = true;
            this.state.buffer = '';
            this.trigger('buffer-update', this.state.buffer);
        }
        /**
         * Calling this function, we immediately invoke the `handler` method
         * that handles the contents of the input events buffer (`eventsBuffer`).
         * This is helpful when we don't want to wait for the timeout that
         * is supposed to invoke the handler.
         */
        capture() {
            if (this.handler) {
                clearTimeout(this._timeout);
                this.handler();
                delete this.handler;
            }
        }
        /**
         * @returns {number} float equivalent of the value of buffer
         */
        getFloat() {
            return parse.float(this.get());
        }
        /**
         * Add keyup listener to window via the useExternalListener hook.
         * When the component calling this is unmounted, the listener is also
         * removed from window.
         */
        activate() {
            this.defaultDecimalPoint = _t.database.parameters.decimal_point;
            useExternalListener(window, 'keyup', this._onKeyboardInput.bind(this));
        }
        /**
         * @param {Object} config Use to setup the buffer
         * @param {String|null} config.decimalPoint The decimal character.
         * @param {String|null} config.triggerAtEnter Event triggered when 'Enter' key is pressed.
         * @param {String|null} config.triggerAtEsc Event triggered when 'Esc' key is pressed.
         * @param {String|null} config.triggerAtInput Event triggered for every accepted input.
         * @param {String|null} config.nonKeyboardInputEvent Also listen to a non-keyboard input event
         *      that carries a payload of { key }. The key is checked if it is a valid input. If valid,
         *      the number buffer is modified just as it is modified when a keyboard key is pressed.
         * @param {Boolean} config.useWithBarcode Whether this buffer is used with barcode.
         * @emits config.triggerAtEnter when 'Enter' key is pressed.
         * @emits config.triggerAtEsc when 'Esc' key is pressed.
         * @emits config.triggerAtInput when an input is accepted.
         */
        use(config) {
            this.eventsBuffer = [];
            const currentComponent = useComponent();
            config = Object.assign(getDefaultConfig(), config);
            onMounted(() => {
                this.bufferHolderStack.push({
                    component: currentComponent,
                    state: config.state ? config.state : { buffer: '', toStartOver: false },
                    config,
                });
                this._setUp();
            });
            onWillUnmount(() => {
                this.bufferHolderStack.pop();
                this._setUp();
            });
            // Add listener that accepts non keyboard inputs
            if (typeof config.nonKeyboardInputEvent === 'string') {
                useListener(config.nonKeyboardInputEvent, this._onNonKeyboardInput.bind(this));
            }
        }
        get _currentBufferHolder() {
            return this.bufferHolderStack[this.bufferHolderStack.length - 1];
        }
        _setUp() {
            if (!this._currentBufferHolder) return;
            const { component, state, config } = this._currentBufferHolder;
            this.component = component;
            this.state = state;
            this.config = config;
            this.decimalPoint = config.decimalPoint || this.defaultDecimalPoint;
            this.maxTimeBetweenKeys = this.config.useWithBarcode
                ? barcodeService.maxTimeBetweenKeysInMs
                : 0;
        }
        _onKeyboardInput(event) {
            return this._bufferEvents(this._onInput(event => event.key))(event);
        }
        _onNonKeyboardInput(event) {
            return this._bufferEvents(this._onInput(event => event.detail.key))(event);
        }
        _bufferEvents(handler) {
            return event => {
                if (['INPUT', 'TEXTAREA'].includes(event.target.tagName) || !this.eventsBuffer) return;
                clearTimeout(this._timeout);
                this.eventsBuffer.push(event);
                this._timeout = setTimeout(handler, this.maxTimeBetweenKeys);
                this.handler = handler
            };
        }
        _onInput(keyAccessor) {
            return () => {
                if (this.eventsBuffer.length <= 2) {
                    // Check first the buffer if its contents are all valid
                    // number input.
                    for (let event of this.eventsBuffer) {
                        if (!ALLOWED_KEYS.has(keyAccessor(event))) {
                            this.eventsBuffer = [];
                            return;
                        }
                    }
                    // At this point, all the events in buffer
                    // contains number input. It's now okay to handle
                    // each input.
                    for (let event of this.eventsBuffer) {
                        this._handleInput(keyAccessor(event));
                        event.preventDefault();
                        event.stopPropagation();
                    }
                }
                this.eventsBuffer = [];
            };
        }
        _handleInput(key) {
            if (key === 'Enter' && this.config.triggerAtEnter) {
                this.component.trigger(this.config.triggerAtEnter, this.state);
            } else if (key === 'Esc' && this.config.triggerAtEsc) {
                this.component.trigger(this.config.triggerAtEsc, this.state);
            } else if (INPUT_KEYS.has(key)) {
                this._updateBuffer(key);
                if (this.config.triggerAtInput)
                    this.component.trigger(this.config.triggerAtInput, { buffer: this.state.buffer, key });
            }
        }
        /**
         * Updates the current buffer state using the given input.
         * @param {String} input valid input
         */
        _updateBuffer(input) {
            const isEmpty = val => {
                return val === '' || val === null;
            };
            if (input === undefined || input === null) return;
            let isFirstInput = isEmpty(this.state.buffer);
            if (input === ',' || input === '.') {
                if (this.state.toStartOver) {
                    this.state.buffer = '';
                }
                if (isFirstInput) {
                    this.state.buffer = '0' + this.decimalPoint;
                } else if (!this.state.buffer.length || this.state.buffer === '-') {
                    this.state.buffer += '0' + this.decimalPoint;
                } else if (this.state.buffer.indexOf(this.decimalPoint) < 0) {
                    this.state.buffer = this.state.buffer + this.decimalPoint;
                }
            } else if (input === 'Delete') {
                if (this.isReset) {
                    this.state.buffer = '';
                    this.isReset = false;
                    return;
                }
                this.state.buffer = isEmpty(this.state.buffer) ? null : '';
            } else if (input === 'Backspace') {
                if (this.isReset) {
                    this.state.buffer = '';
                    this.isReset = false;
                    return;
                }
                if (this.state.toStartOver) {
                    this.state.buffer = '';
                }
                const buffer = this.state.buffer;
                if (isEmpty(buffer)) {
                    this.state.buffer = null;
                } else {
                    const nCharToRemove = buffer[buffer.length - 1] === this.decimalPoint ? 2 : 1;
                    this.state.buffer = buffer.substring(0, buffer.length - nCharToRemove);
                }
            } else if (input === '+') {
                if (this.state.buffer[0] === '-') {
                    this.state.buffer = this.state.buffer.substring(1, this.state.buffer.length);
                }
            } else if (input === '-') {
                if (isFirstInput) {
                    this.state.buffer = '-0';
                } else if (this.state.buffer[0] === '-') {
                    this.state.buffer = this.state.buffer.substring(1, this.state.buffer.length);
                } else {
                    this.state.buffer = '-' + this.state.buffer;
                }
            } else if (input[0] === '+' && !isNaN(parseFloat(input))) {
                // when input is like '+10', '+50', etc
                const inputValue = parse.float(input.slice(1));
                const currentBufferValue = this.state.buffer ? parse.float(this.state.buffer) : 0;
                this.state.buffer = this.component.env.pos.formatFixed(
                    inputValue + currentBufferValue
                );
            } else if (!isNaN(parseInt(input, 10))) {
                if (this.state.toStartOver) {  // when we want to erase the current buffer for a new value
                    this.state.buffer = '';
                }
                if (isFirstInput) {
                    this.state.buffer = '' + input;
                } else if (this.state.buffer.length > 12) {
                    Gui.playSound('bell');
                } else {
                    this.state.buffer += input;
                }
            }
            if (this.state.buffer === '-') {
                this.state.buffer = '';
            }
            // once an input is accepted and updated the buffer,
            // the buffer should not be in reset state anymore.
            this.isReset = false;
            // it should not be in a start the buffer over state anymore.
            this.state.toStartOver = false;

            if (this.config.maxValue && this.state.buffer > this.config.maxValue) {
                this.state.buffer = this.config.maxValue.toString();
                this.config.maxValueReached();
            }

            this.trigger('buffer-update', this.state.buffer);
        }
    }

    return new NumberBuffer();
});
;

/*************************************************************
*  Filepath: /point_of_sale/static/src/js/Misc/SearchBar.js  *
*  Lines: 110                                                *
*************************************************************/
odoo.define('point_of_sale.SearchBar', function (require) {
    'use strict';

    const { useAutofocus, useListener } = require("@web/core/utils/hooks");
    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    const { useExternalListener, useState } = owl;

    /**
     * This is a simple configurable search bar component. It has search fields
     * and selection filter. Search fields allow the users to specify the type
     * of their searches. The filter is a dropdown menu for selection. Depending on
     * user's action, this component emits corresponding event with the action
     * information (payload).
     *
     * TODO: This component can be made more generic and be able to replace
     * all the search bars across pos ui.
     *
     * @prop {{
     *  config: {
     *      searchFields: Map<string, string>,
     *      filter: { show: boolean, options: Map<string, { text: string, indented: boolean? }> }
     *  },
     *  placeholder: string,
     * }}
     * @emits search @payload { fieldName: string, searchTerm: '' }
     * @emits filter-selected @payload { filter: string }
     *
     * NOTE: The payload of the emitted event is accessible via the `detail`
     * field of the event.
     */
    class SearchBar extends PosComponent {
        setup() {
            super.setup();
            useAutofocus();
            useExternalListener(window, 'click', this._hideOptions);
            useListener('click-search-field', this._onClickSearchField);
            useListener('select-filter', this._onSelectFilter);
            this.filterOptionsList = [...this.props.config.filter.options.keys()];
            this.searchFieldsList = [...this.props.config.searchFields.keys()];
            const defaultSearchFieldId = this.searchFieldsList.indexOf(
                this.props.config.defaultSearchDetails.fieldName
            );
            this.state = useState({
                searchInput: this.props.config.defaultSearchDetails.searchTerm || '',
                selectedSearchFieldId: defaultSearchFieldId == -1 ? 0 : defaultSearchFieldId,
                showSearchFields: false,
                showFilterOptions: false,
                selectedFilter: this.props.config.defaultFilter || this.filterOptionsList[0],
            });
        }
        _onSelectFilter({ detail: key }) {
            this.state.selectedFilter = key;
            this.trigger('filter-selected', { filter: this.state.selectedFilter });
        }
        /**
         * When pressing vertical arrow keys, do not move the input cursor.
         */
        onSearchInputKeydown(event) {
            if (['ArrowUp', 'ArrowDown'].includes(event.key)) {
                event.preventDefault();
            }
        }
        /**
         * When vertical arrow keys are pressed, select fields for searching.
         * When enter key is pressed, trigger search event if there is searchInput.
         */
        onSearchInputKeyup(event) {
            if (['ArrowUp', 'ArrowDown'].includes(event.key)) {
                this.state.selectedSearchFieldId = this._fieldIdToSelect(event.key);
            } else if (event.key === 'Enter' || this.state.searchInput == '') {
                this._onClickSearchField({ detail: this.searchFieldsList[this.state.selectedSearchFieldId] });
            } else {
                if (this.state.selectedSearchFieldId === -1 && this.searchFieldsList.length) {
                    this.state.selectedSearchFieldId = 0;
                }
                this.state.showSearchFields = true;
            }
        }
        /**
         * Called when a search field is clicked.
         */
        _onClickSearchField({ detail: fieldName }) {
            this.state.showSearchFields = false;
            this.trigger('search', { fieldName, searchTerm: this.state.searchInput });
        }
        /**
         * Given an arrow key, return the next selectedSearchFieldId.
         * E.g. If the selectedSearchFieldId is 1 and ArrowDown is pressed, return 2.
         *
         * @param {string} key vertical arrow key
         */
        _fieldIdToSelect(key) {
            const length = this.searchFieldsList.length;
            if (!length) return null;
            if (this.state.selectedSearchFieldId === -1) return 0;
            const current = this.state.selectedSearchFieldId || length;
            return (current + (key === 'ArrowDown' ? 1 : -1)) % length;
        }
        _hideOptions() {
            this.state.showFilterOptions = false;
            this.state.showSearchFields = false;
        }
    }
    SearchBar.template = 'point_of_sale.SearchBar';
    Registries.Component.add(SearchBar);

    return SearchBar;
});
;

/***********************************************************
*  Filepath: /point_of_sale/static/src/js/Notification.js  *
*  Lines: 27                                               *
***********************************************************/
odoo.define('point_of_sale.Notification', function (require) {
    'use strict';

    const { useListener } = require("@web/core/utils/hooks");
    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    const { onMounted } = owl;

    class Notification extends PosComponent {
        setup() {
            super.setup();
            useListener('click', this.closeNotification);

            onMounted(() => {
                setTimeout(() => {
                    this.closeNotification();
                }, this.props.duration)
            });
        }
    }
    Notification.template = 'Notification';

    Registries.Component.add(Notification);

    return Notification;
});
;

/****************************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/AbstractAwaitablePopup.js  *
*  Lines: 64                                                                *
****************************************************************************/
odoo.define('point_of_sale.AbstractAwaitablePopup', function (require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const { useBus } = require('@web/core/utils/hooks');

    /**
     * Implement this abstract class by extending it like so:
     * ```js
     * class ConcretePopup extends AbstractAwaitablePopup {
     *   async getPayload() {
     *     return 'result';
     *   }
     * }
     * ConcretePopup.template = xml`
     *   <div>
     *     <button t-on-click="confirm">Okay</button>
     *     <button t-on-click="cancel">Cancel</button>
     *   </div>
     * `
     * ```
     *
     * The concrete popup can now be instantiated and be awaited for
     * the user's response like so:
     * ```js
     * const { confirmed, payload } = await this.showPopup('ConcretePopup');
     * // based on the implementation above,
     * // if confirmed, payload = 'result'
     * //    otherwise, payload = null
     * ```
     */
    class AbstractAwaitablePopup extends PosComponent {
        setup() {
            super.setup();
            if (this.props.confirmKey) {
                useBus(this.env.posbus, `confirm-popup-${this.props.id}`, this.confirm);
            }
            if (this.props.cancelKey) {
                useBus(this.env.posbus, `cancel-popup-${this.props.id}`, this.cancel);
            }
        }
        async confirm() {
            this.env.posbus.trigger('close-popup', {
                popupId: this.props.id,
                response: { confirmed: true, payload: await this.getPayload() },
            });
        }
        cancel() {
            this.env.posbus.trigger('close-popup', {
                popupId: this.props.id,
                response: { confirmed: false, payload: null },
            });
        }
        /**
         * Override this in the concrete popup implementation to set the
         * payload when the popup is confirmed.
         */
        async getPayload() {
            return null;
        }
    }

    return AbstractAwaitablePopup;
});
;

/*******************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/CashMovePopup.js  *
*  Lines: 96                                                       *
*******************************************************************/
odoo.define('point_of_sale.CashMovePopup', function (require) {
    'use strict';

    const AbstractAwaitablePopup = require('point_of_sale.AbstractAwaitablePopup');
    const Registries = require('point_of_sale.Registries');
    const { _lt } = require('@web/core/l10n/translation');
    const { parse } = require('web.field_utils');
    const { useValidateCashInput } = require('point_of_sale.custom_hooks');

    const { useRef, useState } = owl;

    class CashMovePopup extends AbstractAwaitablePopup {
        setup() {
            super.setup();
            this.state = useState({
                inputType: '', // '' | 'in' | 'out'
                inputAmount: '',
                inputReason: '',
                inputHasError: false,
                parsedAmount: 0,
            });
            this.inputAmountRef = useRef('input-amount-ref');
            useValidateCashInput('input-amount-ref');
        }
        confirm() {
            try {
                parse.float(this.state.inputAmount);
            } catch (_error) {
                this.state.inputHasError = true;
                this.errorMessage = this.env._t('Invalid amount');
                return;
            }
            if (this.state.inputType == '') {
                this.state.inputHasError = true;
                this.errorMessage = this.env._t('Select either Cash In or Cash Out before confirming.');
                return;
            }
            if (this.state.inputType === 'out' && this.state.inputAmount > 0) {
                this.state.inputHasError = true;
                this.errorMessage = this.env._t('Insert a negative amount with the Cash Out option.');
                return;
            }
            if (this.state.inputType === 'in' && this.state.inputAmount < 0) {
                this.state.inputHasError = true;
                this.errorMessage = this.env._t('Insert a positive amount with the Cash In option.');
                return;
            }
            if (parse.float(this.state.inputAmount) < 0) {
                this.state.inputAmount = this.state.inputAmount.substring(1);
            }
            return super.confirm();
        }
        _onAmountKeypress(event) {
            if (event.key === '-') {
                event.preventDefault();
                this.state.inputAmount = this.state.inputType === 'out' ? this.state.inputAmount.substring(1) : `-${this.state.inputAmount}`;
                this.state.inputType = this.state.inputType === 'out' ? 'in' : 'out';
                this.handleInputChange();
            }
        }
        onClickButton(type) {
            let amount = this.state.inputAmount;
            if (type === 'in') {
                this.state.inputAmount = amount.charAt(0) === '-' ? amount.substring(1) : amount;
            } else {
                this.state.inputAmount = amount.charAt(0) === '-' ? amount : `-${amount}`;
            }
            this.state.inputType = type;
            this.state.inputHasError = false;
            this.inputAmountRef.el && this.inputAmountRef.el.focus();
            if (amount && amount !== '-') {
                this.handleInputChange();
            }
        }
        getPayload() {
            return {
                amount: parse.float(this.state.inputAmount),
                reason: this.state.inputReason.trim(),
                type: this.state.inputType,
            };
        }
        handleInputChange() {
            if (this.inputAmountRef.el.classList.contains('invalid-cash-input')) return;
            this.state.parsedAmount = parse.float(this.state.inputAmount);
        }
    }
    CashMovePopup.template = 'point_of_sale.CashMovePopup';
    CashMovePopup.defaultProps = {
        cancelText: _lt('Cancel'),
        title: _lt('Cash In/Out'),
    };

    Registries.Component.add(CashMovePopup);

    return CashMovePopup;
});
;

/**********************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/CashOpeningPopup.js  *
*  Lines: 61                                                          *
**********************************************************************/
odoo.define('point_of_sale.CashOpeningPopup', function(require) {
    'use strict';

    const { useValidateCashInput } = require('point_of_sale.custom_hooks');
    const AbstractAwaitablePopup = require('point_of_sale.AbstractAwaitablePopup');
    const Registries = require('point_of_sale.Registries');
    const { parse } = require('web.field_utils');

    const { useState } = owl;

    class CashOpeningPopup extends AbstractAwaitablePopup {
        setup() {
            super.setup();
            this.manualInputCashCount = null;
            this.state = useState({
                notes: "",
                openingCash: this.env.pos.pos_session.cash_register_balance_start || 0,
                displayMoneyDetailsPopup: false,
            });
            useValidateCashInput("openingCashInput", this.env.pos.pos_session.cash_register_balance_start);
        }
        //@override
        async confirm() {
            this.env.pos.pos_session.cash_register_balance_start = this.state.openingCash;
            this.env.pos.pos_session.state = 'opened';
            this.rpc({
                   model: 'pos.session',
                    method: 'set_cashbox_pos',
                    args: [this.env.pos.pos_session.id, this.state.openingCash, this.state.notes],
            });
            super.confirm();
        }
        openDetailsPopup() {
            this.state.openingCash = 0;
            this.state.notes = "";
            this.state.displayMoneyDetailsPopup = true;
        }
        closeDetailsPopup() {
            this.state.displayMoneyDetailsPopup = false;
        }
        updateCashOpening({ total, moneyDetailsNotes }) {
            this.state.openingCash = total;
            if (moneyDetailsNotes) {
                this.state.notes = moneyDetailsNotes;
            }
            this.manualInputCashCount = false;
            this.closeDetailsPopup();
        }
        handleInputChange(event) {
            if (event.target.classList.contains('invalid-cash-input')) return;
            this.manualInputCashCount = true;
            this.state.openingCash = parse.float(event.target.value);
        }
    }

    CashOpeningPopup.template = 'CashOpeningPopup';
    CashOpeningPopup.defaultProps = { cancelKey: false };
    Registries.Component.add(CashOpeningPopup);

    return CashOpeningPopup;
});
;

/*******************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/ClosePosPopup.js  *
*  Lines: 188                                                      *
*******************************************************************/
odoo.define('point_of_sale.ClosePosPopup', function(require) {
    'use strict';

    const AbstractAwaitablePopup = require('point_of_sale.AbstractAwaitablePopup');
    const Registries = require('point_of_sale.Registries');
    const { identifyError } = require('point_of_sale.utils');
    const { ConnectionLostError, ConnectionAbortedError} = require('@web/core/network/rpc_service')
    const { useState } = owl;
    const { useValidateCashInput } = require('point_of_sale.custom_hooks');
    const { parse } = require('web.field_utils');

    class ClosePosPopup extends AbstractAwaitablePopup {
        setup() {
            super.setup();
            this.manualInputCashCount = false;
            this.cashControl = this.env.pos.config.cash_control;
            this.closeSessionClicked = false;
            this.moneyDetails = null;
            Object.assign(this, this.props.info);
            this.state = useState({
                displayMoneyDetailsPopup: false,
            });
            Object.assign(this.state, this.props.info.state);
            useValidateCashInput("closingCashInput");
            if (this.otherPaymentMethods && this.otherPaymentMethods.length > 0) {
                this.otherPaymentMethods.forEach(pm => {
                    if (this._getShowDiff(pm)) {
                        useValidateCashInput("closingCashInput_" + pm.id, this.state.payments[pm.id].counted);
                    }
                })
            }
        }
        //@override
        async confirm() {
            if (!this.cashControl || !this.hasDifference()) {
                this.closeSession();
            } else if (this.hasUserAuthority()) {
                const { confirmed } = await this.showPopup('ConfirmPopup', {
                    title: this.env._t('Payments Difference'),
                    body: this.env._t('Do you want to accept payments difference and post a profit/loss journal entry?'),
                });
                if (confirmed) {
                    this.closeSession();
                }
            } else {
                await this.showPopup('ConfirmPopup', {
                    title: this.env._t('Payments Difference'),
                    body: _.str.sprintf(
                        this.env._t('The maximum difference allowed is %s.\n\
                        Please contact your manager to accept the closing difference.'),
                        this.env.pos.format_currency(this.amountAuthorizedDiff)
                    ),
                    confirmText: this.env._t('OK'),
                })
            }
        }
        //@override
        async cancel() {
            if (this.canCancel()) {
                super.cancel();
            }
        }
        openDetailsPopup() {
            this.state.payments[this.defaultCashDetails.id].counted = 0;
            this.state.payments[this.defaultCashDetails.id].difference = -this.defaultCashDetails.amount;
            this.state.notes = "";
            this.state.displayMoneyDetailsPopup = true;
        }
        closeDetailsPopup() {
            this.state.displayMoneyDetailsPopup = false;
        }
        async downloadSalesReport() {
            await this.env.legacyActionManager.do_action('point_of_sale.sale_details_report', {
                additional_context: {
                    active_ids: [this.env.pos.pos_session.id],
                },
            });
        }
        handleInputChange(paymentId, event) {
            if (event.target.classList.contains('invalid-cash-input')) return;
            let expectedAmount;
            if (paymentId === this.defaultCashDetails.id) {
                this.manualInputCashCount = true;
                this.state.notes = '';
                expectedAmount = this.defaultCashDetails.amount;
            } else {
                expectedAmount = this.otherPaymentMethods.find(pm => paymentId === pm.id).amount;
            }
            this.state.payments[paymentId].counted = parse.float(event.target.value);
            this.state.payments[paymentId].difference =
                this.env.pos.round_decimals_currency(this.state.payments[paymentId].counted - expectedAmount);
        }
        updateCountedCash({ total, moneyDetailsNotes, moneyDetails }) {
            this.state.payments[this.defaultCashDetails.id].counted = total;
            this.state.payments[this.defaultCashDetails.id].difference =
                this.env.pos.round_decimals_currency(this.state.payments[[this.defaultCashDetails.id]].counted - this.defaultCashDetails.amount);
            if (moneyDetailsNotes) {
                this.state.notes = moneyDetailsNotes;
            }
            this.manualInputCashCount = false;
            this.moneyDetails = moneyDetails;
            this.closeDetailsPopup();
        }
        hasDifference() {
            return Object.entries(this.state.payments).find(pm => pm[1].difference != 0);
        }
        hasUserAuthority() {
            const absDifferences = Object.entries(this.state.payments).map(pm => Math.abs(pm[1].difference));
            return this.isManager || this.amountAuthorizedDiff == null || Math.max(...absDifferences) <= this.amountAuthorizedDiff;
        }
        canCancel() {
            return true;
        }
        closePos() {
            this.trigger('close-pos');
        }
        async closeSession() {
            if (!this.closeSessionClicked) {
                this.closeSessionClicked = true;
                let response;
                if (this.cashControl) {
                     response = await this.rpc({
                        model: 'pos.session',
                        method: 'post_closing_cash_details',
                        args: [this.env.pos.pos_session.id],
                        kwargs: {
                            counted_cash: this.state.payments[this.defaultCashDetails.id].counted,
                        }
                    })
                    if (!response.successful) {
                        return this.handleClosingError(response);
                    }
                }
                await this.rpc({
                    model: 'pos.session',
                    method: 'update_closing_control_state_session',
                    args: [this.env.pos.pos_session.id, this.state.notes]
                })
                try {
                    const bankPaymentMethodDiffPairs = this.otherPaymentMethods
                        .filter((pm) => pm.type == 'bank')
                        .map((pm) => [pm.id, this.state.payments[pm.id].difference]);
                    response = await this.rpc({
                        model: 'pos.session',
                        method: 'close_session_from_ui',
                        args: [this.env.pos.pos_session.id, bankPaymentMethodDiffPairs],
                        context: this.env.session.user_context,
                    });
                    if (!response.successful) {
                        return this.handleClosingError(response);
                    }
                    window.location = '/web#action=point_of_sale.action_client_pos_menu';
                } catch (error) {
                    const iError = identifyError(error);
                    if (iError instanceof ConnectionLostError || iError instanceof ConnectionAbortedError) {
                        await this.showPopup('ErrorPopup', {
                            title: this.env._t('Network Error'),
                            body: this.env._t('Cannot close the session when offline.'),
                        });
                    } else {
                        await this.showPopup('ErrorPopup', {
                            title: this.env._t('Closing session error'),
                            body: this.env._t(
                                'An error has occurred when trying to close the session.\n' +
                                'You will be redirected to the back-end to manually close the session.')
                        })
                        window.location = '/web#action=point_of_sale.action_client_pos_menu';
                    }
                }
                this.closeSessionClicked = false;
            }
        }
        async handleClosingError(response) {
            await this.showPopup('ErrorPopup', {title: 'Error', body: response.message});
            if (response.redirect) {
                window.location = '/web#action=point_of_sale.action_client_pos_menu';
            }
        }
        _getShowDiff(pm) {
            return pm.type == 'bank' && pm.number !== 0;
        }
    }

    ClosePosPopup.template = 'ClosePosPopup';
    Registries.Component.add(ClosePosPopup);

    return ClosePosPopup;
});
;

/******************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/ConfirmPopup.js  *
*  Lines: 21                                                      *
******************************************************************/
odoo.define('point_of_sale.ConfirmPopup', function(require) {
    'use strict';

    const AbstractAwaitablePopup = require('point_of_sale.AbstractAwaitablePopup');
    const Registries = require('point_of_sale.Registries');
    const { _lt } = require('@web/core/l10n/translation');

    // formerly ConfirmPopupWidget
    class ConfirmPopup extends AbstractAwaitablePopup {}
    ConfirmPopup.template = 'ConfirmPopup';
    ConfirmPopup.defaultProps = {
        confirmText: _lt('Ok'),
        cancelText: _lt('Cancel'),
        title: _lt('Confirm ?'),
        body: '',
    };

    Registries.Component.add(ConfirmPopup);

    return ConfirmPopup;
});
;

/************************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/ControlButtonPopup.js  *
*  Lines: 28                                                            *
************************************************************************/
odoo.define('point_of_sale.ControlButtonPopup', function(require) {
    'use strict';

    const AbstractAwaitablePopup = require('point_of_sale.AbstractAwaitablePopup');
    const Registries = require('point_of_sale.Registries');
    const { _lt } = require('@web/core/l10n/translation');

    class ControlButtonPopup extends AbstractAwaitablePopup {
        /**
         * @param {Object} props
         * @param {string} props.startingValue
         */
        setup() {
            super.setup();
            this.controlButtons = this.props.controlButtons;
        }
    }
    ControlButtonPopup.template = 'ControlButtonPopup';
    ControlButtonPopup.defaultProps = {
        cancelText: _lt('Back'),
        controlButtons: [],
        confirmKey: false,
    };

    Registries.Component.add(ControlButtonPopup);

    return ControlButtonPopup;
});
;

/*******************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/EditListInput.js  *
*  Lines: 19                                                       *
*******************************************************************/
odoo.define('point_of_sale.EditListInput', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    class EditListInput extends PosComponent {
        onKeyup(event) {
            if (event.key === "Enter" && event.target.value.trim() !== '') {
                this.trigger('create-new-item');
            }
        }
    }
    EditListInput.template = 'EditListInput';

    Registries.Component.add(EditListInput);

    return EditListInput;
});
;

/*******************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/EditListPopup.js  *
*  Lines: 107                                                      *
*******************************************************************/
odoo.define('point_of_sale.EditListPopup', function(require) {
    'use strict';

    const AbstractAwaitablePopup = require('point_of_sale.AbstractAwaitablePopup');
    const Registries = require('point_of_sale.Registries');
    const { useAutoFocusToLast } = require('point_of_sale.custom_hooks');
    const { _lt } = require('@web/core/l10n/translation');

    const { useState } = owl;

    /**
     * Given a array of { id, text }, we show the user this popup to be able to modify this given array.
     * (used to replace PackLotLinePopupWidget)
     *
     * The expected return of showPopup when this popup is used is an array of { _id, [id], text }.
     *   - _id is the assigned unique identifier for each item.
     *   - id is the original id. if not provided, then it means that the item is new.
     *   - text is the modified/unmodified text.
     *
     * Example:
     *
     * ```
     *   -- perhaps inside a click handler --
     *   // gather the items to edit
     *   const names = [{ id: 1, text: 'Joseph'}, { id: 2, text: 'Kaykay' }];
     *
     *   // supply the items to the popup and wait for user's response
     *   // when user pressed `confirm` in the popup, the changes he made will be returned by the showPopup function.
     *   const { confirmed, payload: newNames } = await this.showPopup('EditListPopup', {
     *     title: "Can you confirm this item?",
     *     array: names })
     *
     *   // we then consume the new data. In this example, it is only logged.
     *   if (confirmed) {
     *     console.log(newNames);
     *     // the above might log the following:
     *     // [{ _id: 1, id: 1, text: 'Joseph Caburnay' }, { _id: 2, id: 2, 'Kaykay' }, { _id: 3, 'James' }]
     *     // The result showed that the original item with id=1 was changed to have text 'Joseph Caburnay' from 'Joseph'
     *     // The one with id=2 did not change. And a new item with text='James' is added.
     *   }
     * ```
     */
    class EditListPopup extends AbstractAwaitablePopup {
        /**
         * @param {String} title required title of popup
         * @param {Array} [props.array=[]] the array of { id, text } to be edited or an array of strings
         * @param {Boolean} [props.isSingleItem=false] true if only allowed to edit single item (the first item)
         */
        setup() {
            super.setup();
            this._id = 0;
            this.state = useState({ array: this._initialize(this.props.array) });
            useAutoFocusToLast();
        }
        _nextId() {
            return this._id++;
        }
        _emptyItem() {
            return {
                text: '',
                _id: this._nextId(),
            };
        }
        _initialize(array) {
            // If no array is provided, we initialize with one empty item.
            if (array.length === 0) return [this._emptyItem()];
            // Put _id for each item. It will serve as unique identifier of each item.
            return array.map((item) => Object.assign({}, { _id: this._nextId() }, typeof item === 'object'? item: { 'text': item}));
        }
        removeItem(event) {
            const itemToRemove = event.detail;
            this.state.array.splice(
                this.state.array.findIndex(item => item._id == itemToRemove._id),
                1
            );
            // We keep a minimum of one empty item in the popup.
            if (this.state.array.length === 0) {
                this.state.array.push(this._emptyItem());
            }
        }
        createNewItem() {
            if (this.props.isSingleItem) return;
            this.state.array.push(this._emptyItem());
        }
        /**
         * @override
         */
        getPayload() {
            return {
                newArray: this.state.array
                    .filter((item) => item.text.trim() !== '')
                    .map((item) => Object.assign({}, item)),
            };
        }
    }
    EditListPopup.template = 'EditListPopup';
    EditListPopup.defaultProps = {
        confirmText: _lt('Ok'),
        cancelText: _lt('Cancel'),
        array: [],
        isSingleItem: false,
    };

    Registries.Component.add(EditListPopup);

    return EditListPopup;
});
;

/***********************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/ErrorBarcodePopup.js  *
*  Lines: 27                                                           *
***********************************************************************/
odoo.define('point_of_sale.ErrorBarcodePopup', function(require) {
    'use strict';

    const ErrorPopup = require('point_of_sale.ErrorPopup');
    const Registries = require('point_of_sale.Registries');
    const { _lt } = require('@web/core/l10n/translation');

    // formerly ErrorBarcodePopupWidget
    class ErrorBarcodePopup extends ErrorPopup {
        get translatedMessage() {
            return this.env._t(this.props.message);
        }
    }
    ErrorBarcodePopup.template = 'ErrorBarcodePopup';
    ErrorBarcodePopup.defaultProps = {
        confirmText: _lt('Ok'),
        cancelText: _lt('Cancel'),
        title: _lt('Error'),
        body: '',
        message:
            _lt('The Point of Sale could not find any product, customer, employee or action associated with the scanned barcode.'),
    };

    Registries.Component.add(ErrorBarcodePopup);

    return ErrorBarcodePopup;
});
;

/****************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/ErrorPopup.js  *
*  Lines: 29                                                    *
****************************************************************/
odoo.define('point_of_sale.ErrorPopup', function(require) {
    'use strict';

    const AbstractAwaitablePopup = require('point_of_sale.AbstractAwaitablePopup');
    const Registries = require('point_of_sale.Registries');
    const { _lt } = require('@web/core/l10n/translation');

    // formerly ErrorPopupWidget
    class ErrorPopup extends AbstractAwaitablePopup {
        setup() {
            super.setup();
            owl.onMounted(this.onMounted);
        }
        onMounted() {
            this.playSound('error');
        }
    }
    ErrorPopup.template = 'ErrorPopup';
    ErrorPopup.defaultProps = {
        confirmText: _lt('Ok'),
        title: _lt('Error'),
        body: '',
        cancelKey: false,
    };

    Registries.Component.add(ErrorPopup);

    return ErrorPopup;
});
;

/*************************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/ErrorTracebackPopup.js  *
*  Lines: 46                                                             *
*************************************************************************/
odoo.define('point_of_sale.ErrorTracebackPopup', function(require) {
    'use strict';

    const ErrorPopup = require('point_of_sale.ErrorPopup');
    const Registries = require('point_of_sale.Registries');
    const { _lt } = require('@web/core/l10n/translation');

    // formerly ErrorTracebackPopupWidget
    class ErrorTracebackPopup extends ErrorPopup {
        get tracebackUrl() {
            const blob = new Blob([this.props.body]);
            const URL = window.URL || window.webkitURL;
            return URL.createObjectURL(blob);
        }
        get tracebackFilename() {
            return `${this.env._t('error')} ${moment().format('YYYY-MM-DD-HH-mm-ss')}.txt`;
        }
        emailTraceback() {
            const address = this.env.pos.company.email;
            const subject = this.env._t('IMPORTANT: Bug Report From Odoo Point Of Sale');
            window.open(
                'mailto:' +
                    address +
                    '?subject=' +
                    (subject ? window.encodeURIComponent(subject) : '') +
                    '&body=' +
                    (this.props.body ? window.encodeURIComponent(this.props.body) : '')
            );
        }
    }
    ErrorTracebackPopup.template = 'ErrorTracebackPopup';
    ErrorTracebackPopup.defaultProps = {
        confirmText: _lt('Ok'),
        cancelText: _lt('Cancel'),
        confirmKey: false,
        title: _lt('Error with Traceback'),
        body: '',
        exitButtonIsShown: false,
        exitButtonText: _lt('Exit Pos'),
        exitButtonTrigger: 'close-pos'
    };

    Registries.Component.add(ErrorTracebackPopup);

    return ErrorTracebackPopup;
});
;

/***********************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/MoneyDetailsPopup.js  *
*  Lines: 63                                                           *
***********************************************************************/
odoo.define('point_of_sale.MoneyDetailsPopup', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    const { useState } = owl;

    /**
     * Even if this component has a "confirm and cancel"-like buttons, this should not be an AbstractAwaitablePopup.
     * We currently cannot show two popups at the same time, what we do is mount this component with its parent
     * and hide it with some css. The confirm button will just trigger an event to the parent.
     */
    class MoneyDetailsPopup extends PosComponent {
        setup() {
            super.setup();
            this.currency = this.env.pos.currency;
            this.state = useState({
                moneyDetails: Object.fromEntries(this.env.pos.bills.map(bill => ([bill.value, 0]))),
                total: 0,
            });
            if (this.props.manualInputCashCount) {
                this.reset();
            }
        }
        get firstHalfMoneyDetails() {
            const moneyDetailsKeys = Object.keys(this.state.moneyDetails).sort((a, b) => a - b);
            return moneyDetailsKeys.slice(0, Math.ceil(moneyDetailsKeys.length/2));
        }
        get lastHalfMoneyDetails() {
            const moneyDetailsKeys = Object.keys(this.state.moneyDetails).sort((a, b) => a - b);
            return moneyDetailsKeys.slice(Math.ceil(moneyDetailsKeys.length/2), moneyDetailsKeys.length);
        }
        updateMoneyDetailsAmount() {
            let total = Object.entries(this.state.moneyDetails).reduce((total, money) => total + money[0] * money[1], 0);
            this.state.total = this.env.pos.round_decimals_currency(total);
        }
        confirm() {
            let moneyDetailsNotes = this.state.total  ? 'Money details: \n' : null;
            this.env.pos.bills.forEach(bill => {
                if (this.state.moneyDetails[bill.value]) {
                    moneyDetailsNotes += `  - ${this.state.moneyDetails[bill.value]} x ${this.env.pos.format_currency(bill.value)}\n`;
                }
            })
            const payload = { total: this.state.total, moneyDetailsNotes, moneyDetails: { ...this.state.moneyDetails } };
            this.props.onConfirm(payload);
        }
        reset() {
            for (let key in this.state.moneyDetails) { this.state.moneyDetails[key] = 0 }
            this.state.total = 0;
        }
        discard() {
            this.reset();
            this.props.onDiscard();
        }
    }

    MoneyDetailsPopup.template = 'MoneyDetailsPopup';
    Registries.Component.add(MoneyDetailsPopup);

    return MoneyDetailsPopup;

});
;

/*****************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/NumberPopup.js  *
*  Lines: 80                                                     *
*****************************************************************/
odoo.define('point_of_sale.NumberPopup', function(require) {
    'use strict';
    var core = require('web.core');
    var _t = core._t;

    const AbstractAwaitablePopup = require('point_of_sale.AbstractAwaitablePopup');
    const NumberBuffer = require('point_of_sale.NumberBuffer');
    const { useListener } = require("@web/core/utils/hooks");
    const Registries = require('point_of_sale.Registries');

    const { useState } = owl;

    // formerly NumberPopupWidget
    class NumberPopup extends AbstractAwaitablePopup {
        /**
         * @param {Object} props
         * @param {Boolean} props.isPassword Show password popup.
         * @param {number|null} props.startingValue Starting value of the popup.
         * @param {Boolean} props.isInputSelected Input is highlighted and will reset upon a change.
         *
         * Resolve to { confirmed, payload } when used with showPopup method.
         * @confirmed {Boolean}
         * @payload {String}
         */
        setup() {
            super.setup();
            useListener('accept-input', this.confirm);
            useListener('close-this-popup', this.cancel);
            let startingBuffer = '';
            if (typeof this.props.startingValue === 'number' && this.props.startingValue > 0) {
                startingBuffer = this.props.startingValue.toString().replace('.', this.decimalSeparator);
            }
            this.state = useState({ buffer: startingBuffer, toStartOver: this.props.isInputSelected });
            NumberBuffer.use({
                nonKeyboardInputEvent: 'numpad-click-input',
                triggerAtEnter: 'accept-input',
                triggerAtEscape: 'close-this-popup',
                state: this.state,
            });
        }
        get decimalSeparator() {
            return this.env._t.database.parameters.decimal_point;
        }
        get inputBuffer() {
            if (this.state.buffer === null) {
                return '';
            }
            if (this.props.isPassword) {
                return this.state.buffer.replace(/./g, '•');
            } else {
                return this.state.buffer;
            }
        }
        confirm(event) {
            if (NumberBuffer.get()) {
                super.confirm();
            }
        }
        sendInput(key) {
            this.trigger('numpad-click-input', { key });
        }
        getPayload() {
            return NumberBuffer.get();
        }
    }
    NumberPopup.template = 'NumberPopup';
    NumberPopup.defaultProps = {
        confirmText: _t('Ok'),
        cancelText: _t('Cancel'),
        title: _t('Confirm ?'),
        body: '',
        cheap: false,
        startingValue: null,
        isPassword: false,
    };

    Registries.Component.add(NumberPopup);

    return NumberPopup;
});
;

/***********************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/OfflineErrorPopup.js  *
*  Lines: 30                                                           *
***********************************************************************/
odoo.define('point_of_sale.OfflineErrorPopup', function(require) {
    'use strict';

    const ErrorPopup = require('point_of_sale.ErrorPopup');
    const Registries = require('point_of_sale.Registries');
    const { _lt } = require('@web/core/l10n/translation');

    /**
     * This is a special kind of error popup as it introduces
     * an option to not show it again.
     */
    class OfflineErrorPopup extends ErrorPopup {
        dontShowAgain() {
            this.constructor.dontShow = true;
            this.cancel();
        }
    }
    OfflineErrorPopup.template = 'OfflineErrorPopup';
    OfflineErrorPopup.dontShow = false;
    OfflineErrorPopup.defaultProps = {
        confirmText: _lt('Ok'),
        cancelText: _lt('Cancel'),
        title: _lt('Offline Error'),
        body: _lt('Either the server is inaccessible or browser is not connected online.'),
    };

    Registries.Component.add(OfflineErrorPopup);

    return OfflineErrorPopup;
});
;

/**********************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/OrderImportPopup.js  *
*  Lines: 28                                                          *
**********************************************************************/
odoo.define('point_of_sale.OrderImportPopup', function(require) {
    'use strict';

    const AbstractAwaitablePopup = require('point_of_sale.AbstractAwaitablePopup');
    const Registries = require('point_of_sale.Registries');
    const { _lt } = require('@web/core/l10n/translation');

    // formerly OrderImportPopupWidget
    class OrderImportPopup extends AbstractAwaitablePopup {
        get unpaidSkipped() {
            return (
                (this.props.report.unpaid_skipped_existing || 0) +
                (this.props.report.unpaid_skipped_session || 0)
            );
        }
        getPayload() {}
    }
    OrderImportPopup.template = 'OrderImportPopup';
    OrderImportPopup.defaultProps = {
        confirmText: _lt('Ok'),
        cancelKey: false,
        body: '',
    };

    Registries.Component.add(OrderImportPopup);

    return OrderImportPopup;
});
;

/************************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/PosPopupController.js  *
*  Lines: 123                                                           *
************************************************************************/
odoo.define('point_of_sale.PosPopupController', function(require) {
    'use strict';

    const Registries = require('point_of_sale.Registries');
    const PosComponent = require('point_of_sale.PosComponent');
    const { useBus } = require('@web/core/utils/hooks');

    /**
     * This component is responsible in controlling the popups. It does so
     * by coordinating with them thru the `env.posbus`. The basic steps follow:
     * 1. `showPopup` method triggers `show-popup` event resulting to the
     *    mounting of the requested popup.
     * 2. When the popup is shown, the `confirm`/`cancel` method of the popup
     *    will be called after the popup is used. `confirming`/`cancelling`
     *    will trigger the `close-popup`, which this component also listens to,
     *    resulting to closing of the popup.
     *
     * Furthermore, Pressing `confirmKey`/`cancelKey` which defaults to
     * 'Enter'/'Escape', will automatically `confirm`/`cancel` the `topPopup`.
     * This behavior is accomplished by listening to `keyup` event of the window.
     * When the `confirmKey`/`cancelKey` of the `topPopup` is pressed,
     * 'cancel-popup-{top-popup-id}'/'confirm-popup-{top-popup-id}' will be triggered
     * and since the popup is listening to that event (@see AbstractAwaitablePopup),
     * it will result to the call of `confirm`/`cancel` method.
     *
     * @typedef {{ id: number, resolve: Function, keepBehind?: boolean, cancelKey?: string, confirmKey?: string }} BasePopupProps
     * @typedef {{ name: string, component: AbstractAwaitablePopup, props: BasePopupProps, key: string }} Popup
     */
    class PosPopupController extends PosComponent {
        setup() {
            super.setup();
            useBus(this.env.posbus, 'show-popup', this._showPopup);
            useBus(this.env.posbus, 'close-popup', this._closePopup);
            owl.useExternalListener(window, 'keyup', this._onWindowKeyup);
            this.popups = owl.useState([]);
        }
        _showPopup(event) {
            let { id, name, props, resolve } = event.detail;
            props = Object.assign(props || {}, { id, resolve });
            const component = this.constructor.components[name];
            if (!component) {
                throw new Error(`'${name}' is not found. Make sure the file is loaded and the component is properly registered using 'Registries.Component.add'.`);
            }
            if (component.dontShow) {
                resolve();
                return;
            }
            this.popups.push({
                name,
                component,
                props: this._constructPopupProps(component, props),
                key: `${name}-${id}`,
            });
        }
        _closePopup(event) {
            const { popupId, response } = event.detail;
            const index = this.popups.findIndex((popup) => popup.props.id == popupId);
            if (index != -1) {
                const popup = this.popups[index];
                popup.props.resolve(response);
                this.popups.splice(index, 1);
            }
        }
        _onWindowKeyup(event) {
            const eventIsFromInputField = event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA';
            const shouldHandleKey = this.topPopup && !eventIsFromInputField;
            if (!shouldHandleKey) return;

            if (event.key === this.topPopup.props.cancelKey) {
                this.env.posbus.trigger(`cancel-popup-${this.topPopup.props.id}`);
            } else if (event.key === this.topPopup.props.confirmKey) {
                this.env.posbus.trigger(`confirm-popup-${this.topPopup.props.id}`);
            }
        }
        /**
         * A popup can be cancelled/confirmed with 'Escape'/'Enter' key by default.
         * Also, if it's not the top popup, it is hidden from the view.
         * This can be overridden by the default props of the popop component
         * and the props used in requesting to show the popup.
         *
         * @param {AbstractAwaitablePopup} popupComponent
         * @param {Object} props
         * @returns {BasePopupProps}
         */
        _constructPopupProps(popupComponent, props) {
            const defaultProps = popupComponent.defaultProps || {};
            return Object.assign(
                {
                    keepBehind: false,
                    cancelKey: 'Escape',
                    confirmKey: 'Enter',
                },
                defaultProps,
                props
            );
        }
        /**
         * @returns {boolean} Hide the element of this component when this returns false.
         */
        isShown() {
            return this.popups.length > 0;
        }
        get topPopup() {
            return this.popups[this.popups.length - 1];
        }
        /**
         * By default, only show the top popup. But always show a popup if
         * `keepBehind` props is true. Meaning, if you have 2 popups, and
         * the bottom popup has `keepBehind = true`, then the bottom popup
         * will be visible if it's not blocked in the view by the top popup.
         *
         * @param {Popup} popup
         * @returns {boolean}
         */
        shouldShow(popup) {
            return this.topPopup === popup || popup.props.keepBehind;
        }
    }
    PosPopupController.template = 'point_of_sale.PosPopupController';
    Registries.Component.add(PosPopupController);

    return PosPopupController;
});
;

/******************************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/ProductConfiguratorPopup.js  *
*  Lines: 93                                                                  *
******************************************************************************/
odoo.define('point_of_sale.ProductConfiguratorPopup', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const AbstractAwaitablePopup = require('point_of_sale.AbstractAwaitablePopup');
    const Registries = require('point_of_sale.Registries');

    const { useState, useSubEnv } = owl;

    class ProductConfiguratorPopup extends AbstractAwaitablePopup {
        setup() {
            super.setup();
            useSubEnv({ attribute_components: [] });
        }

        getPayload() {
            var selected_attributes = [];
            var price_extra = 0.0;

            this.env.attribute_components.forEach((attribute_component) => {
                let { value, extra } = attribute_component.getValue();
                selected_attributes.push(value);
                price_extra += extra;
            });

            return {
                selected_attributes,
                price_extra,
            };
        }
    }
    ProductConfiguratorPopup.template = 'ProductConfiguratorPopup';
    Registries.Component.add(ProductConfiguratorPopup);

    class BaseProductAttribute extends PosComponent {
        setup() {
            super.setup();
            this.env.attribute_components.push(this);

            this.attribute = this.props.attribute;
            this.values = this.attribute.values;
            this.state = useState({
                selected_value: parseFloat(this.values[0].id),
                custom_value: '',
            });
        }

        getValue() {
            let selected_value = this.values.find((val) => val.id === parseFloat(this.state.selected_value));
            let value = selected_value.name;
            if (selected_value.is_custom && this.state.custom_value) {
                value += `: ${this.state.custom_value}`;
            }

            return {
                value,
                extra: selected_value.price_extra
            };
        }
    }

    class RadioProductAttribute extends BaseProductAttribute {
        setup() {
            super.setup();
            owl.onMounted(this.onMounted);
        }
        onMounted() {
            // With radio buttons `t-model` selects the default input by searching for inputs with
            // a matching `value` attribute. In our case, we use `t-att-value` so `value` is
            // not found yet and no radio is selected by default.
            // We then manually select the first input of each radio attribute.
            $(this.el).find('input[type="radio"]:first').prop('checked', true);
        }
    }
    RadioProductAttribute.template = 'RadioProductAttribute';
    Registries.Component.add(RadioProductAttribute);

    class SelectProductAttribute extends BaseProductAttribute { }
    SelectProductAttribute.template = 'SelectProductAttribute';
    Registries.Component.add(SelectProductAttribute);

    class ColorProductAttribute extends BaseProductAttribute {}
    ColorProductAttribute.template = 'ColorProductAttribute';
    Registries.Component.add(ColorProductAttribute);

    return {
        ProductConfiguratorPopup,
        BaseProductAttribute,
        RadioProductAttribute,
        SelectProductAttribute,
        ColorProductAttribute,
    };
});
;

/**********************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/ProductInfoPopup.js  *
*  Lines: 32                                                          *
**********************************************************************/
odoo.define('point_of_sale.ProductInfoPopup', function(require) {
    'use strict';

    const AbstractAwaitablePopup = require('point_of_sale.AbstractAwaitablePopup');
    const Registries = require('point_of_sale.Registries');

    /**
     * Props:
     *  {
     *      info: {object of data}
     *  }
     */
    class ProductInfoPopup extends AbstractAwaitablePopup {
        setup() {
            super.setup();
            Object.assign(this, this.props.info);
        }
        searchProduct(productName) {
            this.env.posbus.trigger('search-product-from-info-popup', productName);
            this.cancel()
        }
        _hasMarginsCostsAccessRights() {
            const isAccessibleToEveryUser = this.env.pos.config.is_margins_costs_accessible_to_every_user;
            const isCashierManager = this.env.pos.get_cashier().role === 'manager';
            return isAccessibleToEveryUser || isCashierManager;
        }
    }

    ProductInfoPopup.template = 'ProductInfoPopup';
    ProductInfoPopup.defaultProps= { confirmKey: false };
    Registries.Component.add(ProductInfoPopup);
});
;

/********************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/SelectionPopup.js  *
*  Lines: 59                                                        *
********************************************************************/
odoo.define('point_of_sale.SelectionPopup', function (require) {
    'use strict';

    const AbstractAwaitablePopup = require('point_of_sale.AbstractAwaitablePopup');
    const Registries = require('point_of_sale.Registries');
    const { _lt } = require('@web/core/l10n/translation');

    const { useState } = owl;

    // formerly SelectionPopupWidget
    class SelectionPopup extends AbstractAwaitablePopup {
        /**
         * Value of the `item` key of the selected element in the Selection
         * Array is the payload of this popup.
         *
         * @param {Object} props
         * @param {String} [props.confirmText='Confirm']
         * @param {String} [props.cancelText='Cancel']
         * @param {String} [props.title='Select']
         * @param {String} [props.body='']
         * @param {Array<Selection>} [props.list=[]]
         *      Selection {
         *          id: integer,
         *          label: string,
         *          isSelected: boolean,
         *          item: any,
         *      }
         */
        setup() {
            super.setup();
            this.state = useState({ selectedId: this.props.list.find((item) => item.isSelected) });
        }
        selectItem(itemId) {
            this.state.selectedId = itemId;
            this.confirm();
        }
        /**
         * We send as payload of the response the selected item.
         *
         * @override
         */
        getPayload() {
            const selected = this.props.list.find((item) => this.state.selectedId === item.id);
            return selected && selected.item;
        }
    }
    SelectionPopup.template = 'SelectionPopup';
    SelectionPopup.defaultProps = {
        cancelText: _lt('Cancel'),
        title: _lt('Select'),
        body: '',
        list: [],
        confirmKey: false,
    };

    Registries.Component.add(SelectionPopup);

    return SelectionPopup;
});
;

/*******************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/TextAreaPopup.js  *
*  Lines: 42                                                       *
*******************************************************************/
odoo.define('point_of_sale.TextAreaPopup', function(require) {
    'use strict';

    const AbstractAwaitablePopup = require('point_of_sale.AbstractAwaitablePopup');
    const Registries = require('point_of_sale.Registries');
    const { _lt } = require('@web/core/l10n/translation');

    const { onMounted, useRef, useState } = owl;

    // formerly TextAreaPopupWidget
    // IMPROVEMENT: This code is very similar to TextInputPopup.
    //      Combining them would reduce the code.
    class TextAreaPopup extends AbstractAwaitablePopup {
        /**
         * @param {Object} props
         * @param {string} props.startingValue
         */
        setup() {
            super.setup();
            this.state = useState({ inputValue: this.props.startingValue });
            this.inputRef = useRef('input');
            onMounted(this.onMounted);
        }
        onMounted() {
            this.inputRef.el.focus();
        }
        getPayload() {
            return this.state.inputValue;
        }
    }
    TextAreaPopup.template = 'TextAreaPopup';
    TextAreaPopup.defaultProps = {
        confirmText: _lt('Ok'),
        cancelText: _lt('Cancel'),
        title: '',
        body: '',
    };

    Registries.Component.add(TextAreaPopup);

    return TextAreaPopup;
});
;

/********************************************************************
*  Filepath: /point_of_sale/static/src/js/Popups/TextInputPopup.js  *
*  Lines: 38                                                        *
********************************************************************/
odoo.define('point_of_sale.TextInputPopup', function(require) {
    'use strict';

    const AbstractAwaitablePopup = require('point_of_sale.AbstractAwaitablePopup');
    const Registries = require('point_of_sale.Registries');
    const { _lt } = require('@web/core/l10n/translation');

    const { onMounted, useRef, useState } = owl;

    // formerly TextInputPopupWidget
    class TextInputPopup extends AbstractAwaitablePopup {
        setup() {
            super.setup();
            this.state = useState({ inputValue: this.props.startingValue });
            this.inputRef = useRef('input');
            onMounted(this.onMounted);
        }
        onMounted() {
            this.inputRef.el.focus();
        }
        getPayload() {
            return this.state.inputValue;
        }
    }
    TextInputPopup.template = 'TextInputPopup';
    TextInputPopup.defaultProps = {
        confirmText: _lt('Ok'),
        cancelText: _lt('Cancel'),
        title: '',
        body: '',
        startingValue: '',
        placeholder: '',
    };

    Registries.Component.add(TextInputPopup);

    return TextInputPopup;
});
;

/***********************************************************
*  Filepath: /point_of_sale/static/src/js/PosComponent.js  *
*  Lines: 75                                               *
***********************************************************/
odoo.define('point_of_sale.PosComponent', function (require) {
    'use strict';

    const { LegacyComponent } = require("@web/legacy/legacy_component");
    const { onRendered } = owl;

    let nextId = 0;

    class PosComponent extends LegacyComponent {
        setup() {
            onRendered(() => {
                if (this.env.isDebug()) {
                    console.log('Rendered:', this.constructor.name);
                }
            });
        }
        /**
         * This function is available to all Components that inherit this class.
         * The goal of this function is to show an awaitable dialog (popup) that
         * returns a response after user interaction. See the following for quick
         * demonstration:
         *
         * ```
         * async getUserName() {
         *   const userResponse = await this.showPopup(
         *     'TextInputPopup',
         *     { title: 'What is your name?' }
         *   );
         *   // at this point, the TextInputPopup is displayed. Depending on how the popup is defined,
         *   // say the input contains the name, the result of the interaction with the user is
         *   // saved in `userResponse`.
         *   console.log(userResponse); // logs { confirmed: true, payload: <name> }
         * }
         * ```
         *
         * @param {String} name Name of the popup component
         * @param {Object} props Object that will be used to render to popup
         */
        showPopup(name, props) {
            return new Promise((resolve) => {
                this.env.posbus.trigger('show-popup', { name, props, resolve, id: nextId++ });
            });
        }
        showTempScreen(name, props) {
            return new Promise((resolve) => {
                this.trigger('show-temp-screen', { name, props, resolve });
            });
        }
        showScreen(name, props) {
            this.trigger('show-main-screen', { name, props });
        }
        /**
         * @param {String} name 'bell' | 'error'
         */
        playSound(name) {
            this.trigger('play-sound', name);
        }
        /**
         * Control the SyncNotification component.
         * @param {String} status 'connected' | 'connecting' | 'disconnected' | 'error'
         * @param {String} pending number of pending orders to sync
         */
        setSyncStatus(status, pending) {
            this.trigger('set-sync-status', { status, pending });
        }
        showNotification(message, duration = 2000) {
            this.trigger('show-notification', { message, duration });
        }
        closeNotification() {
            this.trigger('close-notification');
        }
    }

    return PosComponent;
});
;

/*********************************************************
*  Filepath: /point_of_sale/static/src/js/PosContext.js  *
*  Lines: 10                                             *
*********************************************************/
odoo.define('point_of_sale.PosContext', function (require) {
    'use strict';
    const { reactive } = owl;

    // Create global context objects
    // e.g. component.env.device = new Context({ isMobile: false });
    return {
        orderManagement: reactive({ searchString: '', selectedOrder: null }),
    };
});
;

/*********************************************************
*  Filepath: /point_of_sale/static/src/js/Registries.js  *
*  Lines: 27                                             *
*********************************************************/
odoo.define('point_of_sale.Registries', function(require) {
    'use strict';

    /**
     * This definition contains all the instances of ClassRegistry.
     */

    const ComponentRegistry = require('point_of_sale.ComponentRegistry');
    const ClassRegistry = require('point_of_sale.ClassRegistry');

    class ModelRegistry extends ClassRegistry {
        add(baseClass) {
            super.add(baseClass);
            /**
             * Introduce a static method (`create`) to each base class that can be
             * conveniently use to create an instance of the extended version
             * of the class.
             */
            baseClass.create = (...args) => {
                const ExtendedClass = this.get(baseClass);
                return new ExtendedClass(...args);
            }
        }
    }

    return { Component: new ComponentRegistry(), Model: new ModelRegistry() };
});
;

/*******************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/PartnerListScreen/PartnerDetailsEdit.js  *
*  Lines: 156                                                                              *
*******************************************************************************************/
odoo.define("point_of_sale.PartnerDetailsEdit", function (require) {
    "use strict";

    const { _t } = require("web.core");
    const { getDataURLFromFile } = require("web.utils");
    const PosComponent = require("point_of_sale.PosComponent");
    const Registries = require("point_of_sale.Registries");

    const { onMounted, useState, onWillUnmount } = owl;

    class PartnerDetailsEdit extends PosComponent {
        setup() {
            super.setup();
            this.intFields = ["country_id", "state_id", "property_product_pricelist"];
            const partner = this.props.partner;
            this.changes = useState({
                name: partner.name || "",
                street: partner.street || "",
                city: partner.city || "",
                zip: partner.zip || "",
                state_id: partner.state_id && partner.state_id[0],
                country_id: partner.country_id && partner.country_id[0],
                lang: partner.lang || "",
                email: partner.email || "",
                phone: partner.phone || "",
                mobile: partner.mobile || "",
                barcode: partner.barcode || "",
                vat: partner.vat || "",
                property_product_pricelist: this.getDefaultPricelist(partner),
            });

            onMounted(() => {
                this.env.bus.on("save-partner", this, this.saveChanges);
            });

            onWillUnmount(() => {
                this.env.bus.off("save-partner", this);
            });
        }
        get partnerImageUrl() {
            // We prioritize image_1920 in the `changes` field because we want
            // to show the uploaded image without fetching new data from the server.
            const partner = this.props.partner;
            if (this.changes.image_1920) {
                return this.changes.image_1920;
            } else if (partner.id) {
                return `/web/image?model=res.partner&id=${partner.id}&field=avatar_128&unique=${partner.write_date}`;
            } else {
                return false;
            }
        }
        getDefaultPricelist(partner) {
            if (partner.property_product_pricelist) {
                return partner.property_product_pricelist[0];
            }
            return this.env.pos.default_pricelist ? this.env.pos.default_pricelist.id : false;
        }
        // NOTE: this functions was kept for compatibility with stable
        captureChange(event) {}
        saveChanges() {
            const processedChanges = {};
            for (const [key, value] of Object.entries(this.changes)) {
                if (this.intFields.includes(key)) {
                    processedChanges[key] = parseInt(value) || false;
                } else {
                    processedChanges[key] = value;
                }
            }
            if (
                processedChanges.state_id &&
                this.env.pos.states.find((state) => state.id === processedChanges.state_id)
                    .country_id[0] !== processedChanges.country_id
            ) {
                processedChanges.state_id = false;
            }

            if (
                (!this.props.partner.name && !processedChanges.name) ||
                processedChanges.name === ""
            ) {
                return this.showPopup("ErrorPopup", {
                    title: _t("A Customer Name Is Required"),
                });
            }
            processedChanges.id = this.props.partner.id || false;
            this.trigger("save-changes", { processedChanges });
        }
        async uploadImage(event) {
            const file = event.target.files[0];
            if (!file.type.match(/image.*/)) {
                await this.showPopup("ErrorPopup", {
                    title: this.env._t("Unsupported File Format"),
                    body: this.env._t(
                        "Only web-compatible Image formats such as .png or .jpeg are supported."
                    ),
                });
            } else {
                const imageUrl = await getDataURLFromFile(file);
                const loadedImage = await this._loadImage(imageUrl);
                if (loadedImage) {
                    const resizedImage = await this._resizeImage(loadedImage, 800, 600);
                    this.changes.image_1920 = resizedImage.toDataURL();
                    // Rerender to reflect the changes in the screen
                    this.render(true);
                }
            }
        }
        _resizeImage(img, maxwidth, maxheight) {
            var canvas = document.createElement("canvas");
            var ctx = canvas.getContext("2d");
            var ratio = 1;

            if (img.width > maxwidth) {
                ratio = maxwidth / img.width;
            }
            if (img.height * ratio > maxheight) {
                ratio = maxheight / img.height;
            }
            var width = Math.floor(img.width * ratio);
            var height = Math.floor(img.height * ratio);

            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);
            return canvas;
        }
        /**
         * Loading image is converted to a Promise to allow await when
         * loading an image. It resolves to the loaded image if succesful,
         * else, resolves to false.
         *
         * [Source](https://stackoverflow.com/questions/45788934/how-to-turn-this-callback-into-a-promise-using-async-await)
         */
        _loadImage(url) {
            return new Promise((resolve) => {
                const img = new Image();
                img.addEventListener("load", () => resolve(img));
                img.addEventListener("error", () => {
                    this.showPopup("ErrorPopup", {
                        title: this.env._t("Loading Image Error"),
                        body: this.env._t(
                            "Encountered error when loading image. Please try again."
                        ),
                    });
                    resolve(false);
                });
                img.src = url;
            });
        }
    }
    PartnerDetailsEdit.template = "PartnerDetailsEdit";

    Registries.Component.add(PartnerDetailsEdit);

    return PartnerDetailsEdit;
});
;

/************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/PartnerListScreen/PartnerLine.js  *
*  Lines: 24                                                                        *
************************************************************************************/
odoo.define('point_of_sale.PartnerLine', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    class PartnerLine extends PosComponent {
        get highlight() {
            return this._isPartnerSelected ? 'highlight' : '';
        }
        get shortAddress() {
            const { partner } = this.props;
            return partner.address;
        }
        get _isPartnerSelected() {
            return this.props.partner === this.props.selectedPartner;
        }
    }
    PartnerLine.template = 'PartnerLine';

    Registries.Component.add(PartnerLine);

    return PartnerLine;
});
;

/******************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/PartnerListScreen/PartnerListScreen.js  *
*  Lines: 230                                                                             *
******************************************************************************************/
odoo.define('point_of_sale.PartnerListScreen', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');
    const { isConnectionError } = require('point_of_sale.utils');

    const { debounce } = require("@web/core/utils/timing");
    const { useListener } = require("@web/core/utils/hooks");

    const { onWillUnmount, useRef } = owl;

    /**
     * Render this screen using `showTempScreen` to select partner.
     * When the shown screen is confirmed ('Set Customer' or 'Deselect Customer'
     * button is clicked), the call to `showTempScreen` resolves to the
     * selected partner. E.g.
     *
     * ```js
     * const { confirmed, payload: selectedPartner } = await showTempScreen('PartnerListScreen');
     * if (confirmed) {
     *   // do something with the selectedPartner
     * }
     * ```
     *
     * @props partner - originally selected partner
     */
    class PartnerListScreen extends PosComponent {
        setup() {
            super.setup();
            useListener('click-save', () => this.env.bus.trigger('save-partner'));
            useListener('save-changes', this.saveChanges);
            this.searchWordInputRef = useRef('search-word-input-partner');

            // We are not using useState here because the object
            // passed to useState converts the object and its contents
            // to Observer proxy. Not sure of the side-effects of making
            // a persistent object, such as pos, into Observer. But it
            // is better to be safe.
            this.state = {
                query: null,
                selectedPartner: this.props.partner,
                detailIsShown: false,
                editModeProps: {
                    partner: null,
                },
                previousQuery: "",
                currentOffset: 0,
            };
            this.updatePartnerList = debounce(this.updatePartnerList, 70);
            onWillUnmount(this.updatePartnerList.cancel);
        }
        // Lifecycle hooks
        back() {
            if(this.state.detailIsShown) {
                this.state.detailIsShown = false;
                this.render(true);
            } else {
                this.props.resolve({ confirmed: false, payload: false });
                this.trigger('close-temp-screen');
            }
        }
        confirm() {
            this.props.resolve({ confirmed: true, payload: this.state.selectedPartner });
            this.trigger('close-temp-screen');
        }
        activateEditMode() {
            this.state.detailIsShown = true;
            this.render(true);
        }
        // Getters

        get currentOrder() {
            return this.env.pos.get_order();
        }

        get partners() {
            let res;
            if (this.state.query && this.state.query.trim() !== '') {
                res = this.env.pos.db.search_partner(this.state.query.trim());
            } else {
                res = this.env.pos.db.get_partners_sorted(1000);
            }
            res.sort(function (a, b) { return (a.name || '').localeCompare(b.name || '') });
            // the selected partner (if any) is displayed at the top of the list
            if (this.state.selectedPartner) {
                let indexOfSelectedPartner = res.findIndex( partner => 
                    partner.id === this.state.selectedPartner.id
                );
                if (indexOfSelectedPartner !== -1) {
                    res.splice(indexOfSelectedPartner, 1);
                    res.unshift(this.state.selectedPartner);
                }
            }
            return res
        }
        get isBalanceDisplayed() {
            return false;
        }
        get partnerLink() {
            return `/web#model=res.partner&id=${this.state.editModeProps.partner.id}`;
        }

        // Methods

        async _onPressEnterKey() {
            if (!this.state.query) return;
            const result = await this.searchPartner();
            if (result.length > 0) {
                this.showNotification(
                    _.str.sprintf(
                        this.env._t('%s customer(s) found for "%s".'),
                        result.length,
                        this.state.query
                    ),
                    3000
                );
            } else {
                this.showNotification(
                    _.str.sprintf(
                        this.env._t('No more customer found for "%s".'),
                        this.state.query
                    ),
                    3000
                );
            }
            
        }
        _clearSearch() {
            this.searchWordInputRef.el.value = '';
            this.state.query = '';
            this.render(true);
        }
        // We declare this event handler as a debounce function in
        // order to lower its trigger rate.
        async updatePartnerList(event) {
            this.state.query = event.target.value;
            this.render(true);
        }
        clickPartner(partner) {
            if (this.state.selectedPartner && this.state.selectedPartner.id === partner.id) {
                this.state.selectedPartner = null;
            } else {
                this.state.selectedPartner = partner;
            }
            this.confirm();
        }
        editPartner(partner) {
            this.state.editModeProps.partner = partner;
            this.activateEditMode();
        }
        createPartner() {
            // initialize the edit screen with default details about country & state
            this.state.editModeProps.partner = {
                country_id: this.env.pos.company.country_id,
                state_id: this.env.pos.company.state_id,
            }
            this.activateEditMode();
        }
        async saveChanges(event) {
            try {
                let partnerId = await this.rpc({
                    model: 'res.partner',
                    method: 'create_from_ui',
                    args: [event.detail.processedChanges],
                });
                await this.env.pos.load_new_partners();
                this.state.selectedPartner = this.env.pos.db.get_partner_by_id(partnerId);
                this.confirm();
            } catch (error) {
                if (isConnectionError(error)) {
                    await this.showPopup('OfflineErrorPopup', {
                        title: this.env._t('Offline'),
                        body: this.env._t('Unable to save changes.'),
                    });
                } else {
                    throw error;
                }
            }
        }
        async searchPartner() {
            if (this.state.previousQuery != this.state.query) {
                this.state.currentOffset = 0;
            }
            let result = await this.getNewPartners();
            this.env.pos.addPartners(result);
            this.render(true);
            if (this.state.previousQuery == this.state.query) {
                this.state.currentOffset += result.length;
            } else {
                this.state.previousQuery = this.state.query;
                this.state.currentOffset = result.length;
            }
            return result;
        }
        async getNewPartners() {
            let domain = [];
            const limit = 30;
            if(this.state.query) {
                domain = ['|', ["name", "ilike", this.state.query + "%"],
                               ["parent_name", "ilike", this.state.query + "%"]];
            }
            const result = await this.env.services.rpc(
                {
                    model: 'pos.session',
                    method: 'get_pos_ui_res_partner_by_params',
                    args: [
                        [odoo.pos_session_id],
                        {
                            domain,
                            limit: limit,
                            offset: this.state.currentOffset,
                        },
                    ],
                    context: this.env.session.user_context,
                },
                {
                    timeout: 3000,
                    shadow: true,
                }
            );
            return result;
        }
    }
    PartnerListScreen.template = 'PartnerListScreen';

    Registries.Component.add(PartnerListScreen);

    return PartnerListScreen;
});
;

/****************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/PaymentScreen/PSNumpadInputButton.js  *
*  Lines: 17                                                                            *
****************************************************************************************/
odoo.define('point_of_sale.PSNumpadInputButton', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    class PSNumpadInputButton extends PosComponent {
        get _class() {
            return this.props.changeClassTo || 'input-button number-char';
        }
    }
    PSNumpadInputButton.template = 'PSNumpadInputButton';

    Registries.Component.add(PSNumpadInputButton);

    return PSNumpadInputButton;
});
;

/**********************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/PaymentScreen/PaymentScreen.js  *
*  Lines: 467                                                                     *
**********************************************************************************/
odoo.define('point_of_sale.PaymentScreen', function (require) {
    'use strict';

    const { parse } = require('web.field_utils');
    const PosComponent = require('point_of_sale.PosComponent');
    const { useErrorHandlers } = require('point_of_sale.custom_hooks');
    const NumberBuffer = require('point_of_sale.NumberBuffer');
    const { useListener } = require("@web/core/utils/hooks");
    const Registries = require('point_of_sale.Registries');
    const { isConnectionError } = require('point_of_sale.utils');
    const utils = require('web.utils');

    class PaymentScreen extends PosComponent {
        setup() {
            super.setup();
            useListener('delete-payment-line', this.deletePaymentLine);
            useListener('select-payment-line', this.selectPaymentLine);
            useListener('new-payment-line', this.addNewPaymentLine);
            useListener('update-selected-paymentline', this._updateSelectedPaymentline);
            useListener('send-payment-request', this._sendPaymentRequest);
            useListener('send-payment-cancel', this._sendPaymentCancel);
            useListener('send-payment-reverse', this._sendPaymentReverse);
            useListener('send-force-done', this._sendForceDone);
            useListener('validate-order', () => this.validateOrder(false));
            this.payment_methods_from_config = this.env.pos.payment_methods.filter(method => this.env.pos.config.payment_method_ids.includes(method.id));
            NumberBuffer.use(this._getNumberBufferConfig);
            useErrorHandlers();
            this.payment_interface = null;
            this.error = false;
        }

        showMaxValueError() {
            this.showPopup('ErrorPopup', {
                title: this.env._t('Maximum value reached'),
                body: this.env._t('The amount cannot be higher than the due amount if you don\'t have a cash payment method configured.')
            });
        }
        get _getNumberBufferConfig() {
            let config = {
                // The numberBuffer listens to this event to update its state.
                // Basically means 'update the buffer when this event is triggered'
                nonKeyboardInputEvent: 'input-from-numpad',
                // When the buffer is updated, trigger this event.
                // Note that the component listens to it.
                triggerAtInput: 'update-selected-paymentline',
            };
            // Check if pos has a cash payment method
            const hasCashPaymentMethod = this.payment_methods_from_config.some(
                (method) => method.type === 'cash'
            );

            if (!hasCashPaymentMethod) {
                config['maxValue'] = this.currentOrder.get_due();
                config['maxValueReached'] = this.showMaxValueError.bind(this);
            }

            return config;
        }
        get currentOrder() {
            return this.env.pos.get_order();
        }
        get paymentLines() {
            return this.currentOrder.get_paymentlines();
        }
        get selectedPaymentLine() {
            return this.currentOrder.selected_paymentline;
        }
        async selectPartner() {
            // IMPROVEMENT: This code snippet is repeated multiple times.
            // Maybe it's better to create a function for it.
            const currentPartner = this.currentOrder.get_partner();
            const { confirmed, payload: newPartner } = await this.showTempScreen(
                'PartnerListScreen',
                { partner: currentPartner }
            );
            if (confirmed) {
                this.currentOrder.set_partner(newPartner);
                this.currentOrder.updatePricelist(newPartner);
            }
        }
        addNewPaymentLine({ detail: paymentMethod }) {
            // original function: click_paymentmethods
            let result = this.currentOrder.add_paymentline(paymentMethod);
            if (result){
                NumberBuffer.reset();
                return true;
            }
            else{
                this.showPopup('ErrorPopup', {
                    title: this.env._t('Error'),
                    body: this.env._t('There is already an electronic payment in progress.'),
                });
                return false;
            }
        }
        _updateSelectedPaymentline() {
            if (this.paymentLines.every((line) => line.paid)) {
                this.currentOrder.add_paymentline(this.payment_methods_from_config[0]);
            }
            if (!this.selectedPaymentLine) return; // do nothing if no selected payment line
            // disable changing amount on paymentlines with running or done payments on a payment terminal
            const payment_terminal = this.selectedPaymentLine.payment_method.payment_terminal;
            if (
                payment_terminal &&
                !['pending', 'retry'].includes(this.selectedPaymentLine.get_payment_status())
            ) {
                return;
            }
            if (NumberBuffer.get() === null) {
                this.deletePaymentLine({ detail: { cid: this.selectedPaymentLine.cid } });
            } else {
                this.selectedPaymentLine.set_amount(NumberBuffer.getFloat());
            }
        }
        toggleIsToInvoice() {
            // click_invoice
            this.currentOrder.set_to_invoice(!this.currentOrder.is_to_invoice());
            this.render(true);
        }
        openCashbox() {
            this.env.proxy.printer.open_cashbox();
        }
        async addTip() {
            // click_tip
            const tip = this.currentOrder.get_tip();
            const change = this.currentOrder.get_change();
            let value = tip === 0 && change > 0 ? change : tip;

            const { confirmed, payload } = await this.showPopup('NumberPopup', {
                title: tip ? this.env._t('Change Tip') : this.env._t('Add Tip'),
                startingValue: value,
                isInputSelected: true,
            });

            if (confirmed) {
                this.currentOrder.set_tip(parse.float(payload));
            }
        }
        toggleIsToShip() {
            // click_ship
            this.currentOrder.set_to_ship(!this.currentOrder.is_to_ship());
            this.render(true);
        }
        deletePaymentLine(event) {
            var self = this;
            const { cid } = event.detail;
            const line = this.paymentLines.find((line) => line.cid === cid);

            // If a paymentline with a payment terminal linked to
            // it is removed, the terminal should get a cancel
            // request.
            if (['waiting', 'waitingCard', 'timeout'].includes(line.get_payment_status())) {
                line.set_payment_status('waitingCancel');
                line.payment_method.payment_terminal.send_payment_cancel(this.currentOrder, cid).then(function() {
                    self.currentOrder.remove_paymentline(line);
                    NumberBuffer.reset();
                    self.render(true);
                })
            }
            else if (line.get_payment_status() !== 'waitingCancel') {
                this.currentOrder.remove_paymentline(line);
                NumberBuffer.reset();
                this.render(true);
            }
        }
        selectPaymentLine(event) {
            const { cid } = event.detail;
            const line = this.paymentLines.find((line) => line.cid === cid);
            this.currentOrder.select_paymentline(line);
            NumberBuffer.reset();
            this.render(true);
        }
        async validateOrder(isForceValidate) {
            if(this.env.pos.config.cash_rounding) {
                if(!this.env.pos.get_order().check_paymentlines_rounding()) {
                    this.showPopup('ErrorPopup', {
                        title: this.env._t('Rounding error in payment lines'),
                        body: this.env._t("The amount of your payment lines must be rounded to validate the transaction."),
                    });
                    return;
                }
            }
            if (await this._isOrderValid(isForceValidate)) {
                // remove pending payments before finalizing the validation
                for (let line of this.paymentLines) {
                    if (!line.is_done()) this.currentOrder.remove_paymentline(line);
                }
                await this._finalizeValidation();
            }
        }
        async _finalizeValidation() {
            if ((this.currentOrder.is_paid_with_cash() || this.currentOrder.get_change()) && this.env.pos.config.iface_cashdrawer && this.env.pos.config.use_proxy) {
                this.env.proxy.printer.open_cashbox();
            }

            this.currentOrder.initialize_validation_date();
            this.currentOrder.finalized = true;

            let syncOrderResult, hasError;

            try {
                // 1. Save order to server.
                syncOrderResult = await this.env.pos.push_single_order(this.currentOrder);

                // 2. Invoice.
                if (this.currentOrder.is_to_invoice()) {
                    if (syncOrderResult.length) {
                        await this.env.legacyActionManager.do_action('account.account_invoices', {
                            additional_context: {
                                active_ids: [syncOrderResult[0].account_move],
                            },
                        });
                    } else {
                        throw { code: 401, message: 'Backend Invoice', data: { order: this.currentOrder } };
                    }
                }

                // 3. Post process.
                if (syncOrderResult.length && this.currentOrder.wait_for_push_order()) {
                    const postPushResult = await this._postPushOrderResolve(
                        this.currentOrder,
                        syncOrderResult.map((res) => res.id)
                    );
                    if (!postPushResult) {
                        this.showPopup('ErrorPopup', {
                            title: this.env._t('Error: no internet connection.'),
                            body: this.env._t('Some, if not all, post-processing after syncing order failed.'),
                        });
                    }
                }
            } catch (error) {
                if (error.code == 700 || error.code == 701)
                    this.error = true;

                if ('code' in error) {
                    // We started putting `code` in the rejected object for invoicing error.
                    // We can continue with that convention such that when the error has `code`,
                    // then it is an error when invoicing. Besides, _handlePushOrderError was
                    // introduce to handle invoicing error logic.
                    await this._handlePushOrderError(error);
                } else {
                    // We don't block for connection error. But we rethrow for any other errors.
                    if (isConnectionError(error)) {
                        this.showPopup('OfflineErrorPopup', {
                            title: this.env._t('Connection Error'),
                            body: this.env._t('Order is not synced. Check your internet connection'),
                        });
                    } else {
                        throw error;
                    }
                }
            } finally {
                // Always show the next screen regardless of error since pos has to
                // continue working even offline.
                this.showScreen(this.nextScreen);
                // Remove the order from the local storage so that when we refresh the page, the order
                // won't be there
                this.env.pos.db.remove_unpaid_order(this.currentOrder);

                // Ask the user to sync the remaining unsynced orders.
                if (!hasError && syncOrderResult && this.env.pos.db.get_orders().length) {
                    const { confirmed } = await this.showPopup('ConfirmPopup', {
                        title: this.env._t('Remaining unsynced orders'),
                        body: this.env._t(
                            'There are unsynced orders. Do you want to sync these orders?'
                        ),
                    });
                    if (confirmed) {
                        // NOTE: Not yet sure if this should be awaited or not.
                        // If awaited, some operations like changing screen
                        // might not work.
                        this.env.pos.push_orders();
                    }
                }
            }
        }
        get nextScreen() {
            return !this.error? 'ReceiptScreen' : 'ProductScreen';
        }
        async _isOrderValid(isForceValidate) {
            if (this.currentOrder.get_orderlines().length === 0 && this.currentOrder.is_to_invoice()) {
                this.showPopup('ErrorPopup', {
                    title: this.env._t('Empty Order'),
                    body: this.env._t(
                        'There must be at least one product in your order before it can be validated and invoiced.'
                    ),
                });
                return false;
            }

            if (this.currentOrder.electronic_payment_in_progress()) {
                this.showPopup('ErrorPopup', {
                    title: this.env._t('Pending Electronic Payments'),
                    body: this.env._t(
                        'There is at least one pending electronic payment.\n' +
                        'Please finish the payment with the terminal or ' +
                        'cancel it then remove the payment line.'
                    ),
                });
                return false;
            }

            const splitPayments = this.paymentLines.filter(payment => payment.payment_method.split_transactions)
            if (splitPayments.length && !this.currentOrder.get_partner()) {
                const paymentMethod = splitPayments[0].payment_method
                const { confirmed } = await this.showPopup('ConfirmPopup', {
                    title: this.env._t('Customer Required'),
                    body: _.str.sprintf(this.env._t('Customer is required for %s payment method.'), paymentMethod.name),
                });
                if (confirmed) {
                    this.selectPartner();
                }
                return false;
            }

            if ((this.currentOrder.is_to_invoice() || this.currentOrder.is_to_ship()) && !this.currentOrder.get_partner()) {
                const { confirmed } = await this.showPopup('ConfirmPopup', {
                    title: this.env._t('Please select the Customer'),
                    body: this.env._t(
                        'You need to select the customer before you can invoice or ship an order.'
                    ),
                });
                if (confirmed) {
                    this.selectPartner();
                }
                return false;
            }

            let partner = this.currentOrder.get_partner()
            if (this.currentOrder.is_to_ship() && !(partner.name && partner.street && partner.city && partner.country_id)) {
                this.showPopup('ErrorPopup', {
                    title: this.env._t('Incorrect address for shipping'),
                    body: this.env._t('The selected customer needs an address.'),
                });
                return false;
            }

            if (this.currentOrder.get_total_with_tax() != 0 && this.currentOrder.get_paymentlines().length === 0) {
                this.showNotification(this.env._t('Select a payment method to validate the order.'));
                return false;
            }

            if (!this.currentOrder.is_paid() || this.invoicing) {
                return false;
            }

            if (this.currentOrder.has_not_valid_rounding()) {
                var line = this.currentOrder.has_not_valid_rounding();
                this.showPopup('ErrorPopup', {
                    title: this.env._t('Incorrect rounding'),
                    body: this.env._t(
                        'You have to round your payments lines.' + line.amount + ' is not rounded.'
                    ),
                });
                return false;
            }

            // The exact amount must be paid if there is no cash payment method defined.
            if (
                Math.abs(
                    this.currentOrder.get_total_with_tax() - this.currentOrder.get_total_paid()  + this.currentOrder.get_rounding_applied()
                ) > 0.00001
            ) {
                var cash = false;
                for (var i = 0; i < this.env.pos.payment_methods.length; i++) {
                    cash = cash || this.env.pos.payment_methods[i].is_cash_count;
                }
                if (!cash) {
                    this.showPopup('ErrorPopup', {
                        title: this.env._t('Cannot return change without a cash payment method'),
                        body: this.env._t(
                            'There is no cash payment method available in this point of sale to handle the change.\n\n Please pay the exact amount or add a cash payment method in the point of sale configuration'
                        ),
                    });
                    return false;
                }
            }

            // if the change is too large, it's probably an input error, make the user confirm.
            if (
                !isForceValidate &&
                this.currentOrder.get_total_with_tax() > 0 &&
                this.currentOrder.get_total_with_tax() * 1000 < this.currentOrder.get_total_paid()
            ) {
                this.showPopup('ConfirmPopup', {
                    title: this.env._t('Please Confirm Large Amount'),
                    body:
                        this.env._t('Are you sure that the customer wants to  pay') +
                        ' ' +
                        this.env.pos.format_currency(this.currentOrder.get_total_paid()) +
                        ' ' +
                        this.env._t('for an order of') +
                        ' ' +
                        this.env.pos.format_currency(this.currentOrder.get_total_with_tax()) +
                        ' ' +
                        this.env._t('? Clicking "Confirm" will validate the payment.'),
                }).then(({ confirmed }) => {
                    if (confirmed) this.validateOrder(true);
                });
                return false;
            }

            if (!this.currentOrder._isValidEmptyOrder()) return false;

            return true;
        }
        async _postPushOrderResolve(order, order_server_ids) {
            return true;
        }
        async _sendPaymentRequest({ detail: line }) {
            // Other payment lines can not be reversed anymore
            this.paymentLines.forEach(function (line) {
                line.can_be_reversed = false;
            });

            const payment_terminal = line.payment_method.payment_terminal;
            line.set_payment_status('waiting');

            const isPaymentSuccessful = await payment_terminal.send_payment_request(line.cid);
            if (isPaymentSuccessful) {
                line.set_payment_status('done');
                line.can_be_reversed = payment_terminal.supports_reversals;
                // Automatically validate the order when after an electronic payment,
                // the current order is fully paid and due is zero.
                if (
                    this.currentOrder.is_paid() &&
                    utils.float_is_zero(this.currentOrder.get_due(), this.env.pos.currency.decimal_places)
                ) {
                    this.trigger('validate-order');
                }
            } else {
                line.set_payment_status('retry');
            }
        }
        async _sendPaymentCancel({ detail: line }) {
            const payment_terminal = line.payment_method.payment_terminal;
            line.set_payment_status('waitingCancel');
            const isCancelSuccessful = await payment_terminal.send_payment_cancel(this.currentOrder, line.cid);
            if (isCancelSuccessful) {
                line.set_payment_status('retry');
            } else {
                line.set_payment_status('waitingCard');
            }
        }
        async _sendPaymentReverse({ detail: line }) {
            const payment_terminal = line.payment_method.payment_terminal;
            line.set_payment_status('reversing');

            const isReversalSuccessful = await payment_terminal.send_payment_reversal(line.cid);
            if (isReversalSuccessful) {
                line.set_amount(0);
                line.set_payment_status('reversed');
            } else {
                line.can_be_reversed = false;
                line.set_payment_status('done');
            }
        }
        async _sendForceDone({ detail: line }) {
            line.set_payment_status('done');
        }
    }
    PaymentScreen.template = 'PaymentScreen';

    Registries.Component.add(PaymentScreen);

    return PaymentScreen;
});
;

/****************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/PaymentScreen/PaymentScreenNumpad.js  *
*  Lines: 18                                                                            *
****************************************************************************************/
odoo.define('point_of_sale.PaymentScreenNumpad', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    class PaymentScreenNumpad extends PosComponent {
        setup() {
            super.setup();
            this.decimalPoint = this.env._t.database.parameters.decimal_point;
        }
    }
    PaymentScreenNumpad.template = 'PaymentScreenNumpad';

    Registries.Component.add(PaymentScreenNumpad);

    return PaymentScreenNumpad;
});
;

/**********************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/PaymentScreen/PaymentScreenPaymentLines.js  *
*  Lines: 23                                                                                  *
**********************************************************************************************/
odoo.define('point_of_sale.PaymentScreenPaymentLines', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    class PaymentScreenPaymentLines extends PosComponent {
        formatLineAmount(paymentline) {
            return this.env.pos.format_currency_no_symbol(paymentline.get_amount());
        }
        selectedLineClass(line) {
            return { 'payment-terminal': line.get_payment_status() };
        }
        unselectedLineClass(line) {
            return {};
        }
    }
    PaymentScreenPaymentLines.template = 'PaymentScreenPaymentLines';

    Registries.Component.add(PaymentScreenPaymentLines);

    return PaymentScreenPaymentLines;
});
;

/****************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/PaymentScreen/PaymentScreenStatus.js  *
*  Lines: 27                                                                            *
****************************************************************************************/
odoo.define('point_of_sale.PaymentScreenStatus', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    class PaymentScreenStatus extends PosComponent {
        get changeText() {
            return this.env.pos.format_currency(this.props.order.get_change());
        }
        get totalDueText() {
            return this.env.pos.format_currency(
                this.props.order.get_total_with_tax() + this.props.order.get_rounding_applied()
            );
        }
        get remainingText() {
            return this.env.pos.format_currency(
                this.props.order.get_due() > 0 ? this.props.order.get_due() : 0
            );
        }
    }
    PaymentScreenStatus.template = 'PaymentScreenStatus';

    Registries.Component.add(PaymentScreenStatus);

    return PaymentScreenStatus;
});
;

/************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ProductScreen/ActionpadWidget.js  *
*  Lines: 25                                                                        *
************************************************************************************/
odoo.define('point_of_sale.ActionpadWidget', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    /**
     * @props partner
     * @emits click-partner
     * @emits click-pay
     */
    class ActionpadWidget extends PosComponent {
        get isLongName() {
            return this.props.partner && this.props.partner.name.length > 10;
        }
    }
    ActionpadWidget.template = 'ActionpadWidget';
    ActionpadWidget.defaultProps = {
        isActionButtonHighlighted: false,
    }

    Registries.Component.add(ActionpadWidget);

    return ActionpadWidget;
});
;

/***********************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ProductScreen/CategoryButton.js  *
*  Lines: 18                                                                       *
***********************************************************************************/
odoo.define('point_of_sale.CategoryButton', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    class CategoryButton extends PosComponent {
        get imageUrl() {
            const category = this.props.category
            return `/web/image?model=pos.category&field=image_128&id=${category.id}&unique=${category.write_date}`;
        }
    }
    CategoryButton.template = 'CategoryButton';

    Registries.Component.add(CategoryButton);

    return CategoryButton;
});
;

/***************************************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ProductScreen/ControlButtons/OrderlineCustomerNoteButton.js  *
*  Lines: 37                                                                                                   *
***************************************************************************************************************/
odoo.define('point_of_sale.OrderlineCustomerNoteButton', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const ProductScreen = require('point_of_sale.ProductScreen');
    const { useListener } = require("@web/core/utils/hooks");
    const Registries = require('point_of_sale.Registries');

    class OrderlineCustomerNoteButton extends PosComponent {
        setup() {
            super.setup();
            useListener('click', this.onClick);
        }
        async onClick() {
            const selectedOrderline = this.env.pos.get_order().get_selected_orderline();
            if (!selectedOrderline) return;

            const { confirmed, payload: inputNote } = await this.showPopup('TextAreaPopup', {
                startingValue: selectedOrderline.get_customer_note(),
                title: this.env._t('Add Customer Note'),
            });

            if (confirmed) {
                selectedOrderline.set_customer_note(inputNote);
            }
        }
    }
    OrderlineCustomerNoteButton.template = 'OrderlineCustomerNoteButton';

    ProductScreen.addControlButton({
        component: OrderlineCustomerNoteButton,
    });

    Registries.Component.add(OrderlineCustomerNoteButton);

    return OrderlineCustomerNoteButton;
});
;

/*****************************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ProductScreen/ControlButtons/ProductInfoButton.js  *
*  Lines: 50                                                                                         *
*****************************************************************************************************/
odoo.define('point_of_sale.ProductInfoButton', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const ProductScreen = require('point_of_sale.ProductScreen');
    const { useListener } = require("@web/core/utils/hooks");
    const Registries = require('point_of_sale.Registries');
    const { ConnectionLostError, ConnectionAbortedError } = require('@web/core/network/rpc_service')
    const { identifyError } = require('point_of_sale.utils');

    class ProductInfoButton extends PosComponent {
        setup() {
            super.setup();
            useListener('click', this.onClick);
        }
        async onClick() {
            const orderline = this.env.pos.get_order().get_selected_orderline();
            if (orderline) {
                const product = orderline.get_product();
                const quantity = orderline.get_quantity();
                try {
                    const info = await this.env.pos.getProductInfo(product, quantity);
                    this.showPopup('ProductInfoPopup', { info: info , product: product });
                } catch (e) {
                    if (identifyError(e) instanceof ConnectionLostError||ConnectionAbortedError) {
                        this.showPopup('OfflineErrorPopup', {
                            title: this.env._t('Network Error'),
                            body: this.env._t('Cannot access product information screen if offline.'),
                        });
                    } else {
                        this.showPopup('ErrorPopup', {
                            title: this.env._t('Unknown error'),
                            body: this.env._t('An unknown error prevents us from loading product information.'),
                        });
                    }
                }
            }
        }
    }
    ProductInfoButton.template = 'ProductInfoButton';

    ProductScreen.addControlButton({
        component: ProductInfoButton,
        position: ['before', 'SetFiscalPositionButton'],
    });

    Registries.Component.add(ProductInfoButton);

    return ProductInfoButton;
});
;

/************************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ProductScreen/ControlButtons/RefundButton.js  *
*  Lines: 35                                                                                    *
************************************************************************************************/
odoo.define('point_of_sale.RefundButton', function (require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const ProductScreen = require('point_of_sale.ProductScreen');
    const Registries = require('point_of_sale.Registries');
    const { useListener } = require("@web/core/utils/hooks");

    class RefundButton extends PosComponent {
        setup() {
            super.setup();
            useListener('click', this._onClick);
        }
        _onClick() {
            const partner = this.env.pos.get_order().get_partner();
            const searchDetails = partner ? { fieldName: 'PARTNER', searchTerm: partner.name } : {};
            this.showScreen('TicketScreen', {
                ui: { filter: 'SYNCED', searchDetails },
                destinationOrder: this.env.pos.get_order(),
            });
        }
    }
    RefundButton.template = 'point_of_sale.RefundButton';

    ProductScreen.addControlButton({
        component: RefundButton,
        condition: function () {
            return true;
        },
    });

    Registries.Component.add(RefundButton);

    return RefundButton;
});
;

/***********************************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ProductScreen/ControlButtons/SetFiscalPositionButton.js  *
*  Lines: 71                                                                                               *
***********************************************************************************************************/
odoo.define('point_of_sale.SetFiscalPositionButton', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const ProductScreen = require('point_of_sale.ProductScreen');
    const { useListener } = require("@web/core/utils/hooks");
    const Registries = require('point_of_sale.Registries');

    class SetFiscalPositionButton extends PosComponent {
        setup() {
            super.setup();
            useListener('click', this.onClick);
        }
        get currentOrder() {
            return this.env.pos.get_order();
        }
        get currentFiscalPositionName() {
            return this.currentOrder && this.currentOrder.fiscal_position
                ? this.currentOrder.fiscal_position.display_name
                : this.env._t('Tax');
        }
        async onClick() {
            const currentFiscalPosition = this.currentOrder.fiscal_position;
            const fiscalPosList = [
                {
                    id: -1,
                    label: this.env._t('None'),
                    isSelected: !currentFiscalPosition,
                },
            ];
            for (let fiscalPos of this.env.pos.fiscal_positions) {
                fiscalPosList.push({
                    id: fiscalPos.id,
                    label: fiscalPos.name,
                    isSelected: currentFiscalPosition
                        ? fiscalPos.id === currentFiscalPosition.id
                        : false,
                    item: fiscalPos,
                });
            }
            const { confirmed, payload: selectedFiscalPosition } = await this.showPopup(
                'SelectionPopup',
                {
                    title: this.env._t('Select Fiscal Position'),
                    list: fiscalPosList,
                }
            );
            if (confirmed) {
                this.currentOrder.set_fiscal_position(selectedFiscalPosition);
                // IMPROVEMENT: The following is the old implementation and I believe
                // there could be a better way of doing it.
                for (let line of this.currentOrder.orderlines) {
                    line.set_quantity(line.quantity);
                }
            }
        }
    }
    SetFiscalPositionButton.template = 'SetFiscalPositionButton';

    ProductScreen.addControlButton({
        component: SetFiscalPositionButton,
        condition: function() {
            return this.env.pos.fiscal_positions.length > 0;
        },
        position: ['before', 'SetPricelistButton'],
    });

    Registries.Component.add(SetFiscalPositionButton);

    return SetFiscalPositionButton;
});
;

/******************************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ProductScreen/ControlButtons/SetPricelistButton.js  *
*  Lines: 59                                                                                          *
******************************************************************************************************/
odoo.define('point_of_sale.SetPricelistButton', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const ProductScreen = require('point_of_sale.ProductScreen');
    const { useListener } = require("@web/core/utils/hooks");
    const Registries = require('point_of_sale.Registries');

    class SetPricelistButton extends PosComponent {
        setup() {
            super.setup();
            useListener('click', this.onClick);
        }
        get currentOrder() {
            return this.env.pos.get_order();
        }
        get currentPricelistName() {
            const order = this.currentOrder;
            return order && order.pricelist
                ? order.pricelist.display_name
                : this.env._t('Pricelist');
        }
        async onClick() {
            // Create the list to be passed to the SelectionPopup.
            // Pricelist object is passed as item in the list because it
            // is the object that will be returned when the popup is confirmed.
            const selectionList = this.env.pos.pricelists.map(pricelist => ({
                id: pricelist.id,
                label: pricelist.name,
                isSelected: pricelist.id === this.currentOrder.pricelist.id,
                item: pricelist,
            }));

            const { confirmed, payload: selectedPricelist } = await this.showPopup(
                'SelectionPopup',
                {
                    title: this.env._t('Select the pricelist'),
                    list: selectionList,
                }
            );

            if (confirmed) {
                this.currentOrder.set_pricelist(selectedPricelist);
            }
        }
    }
    SetPricelistButton.template = 'SetPricelistButton';

    ProductScreen.addControlButton({
        component: SetPricelistButton,
        condition: function() {
            return this.env.pos.config.use_pricelist && this.env.pos.pricelists.length > 1;
        },
    });

    Registries.Component.add(SetPricelistButton);

    return SetPricelistButton;
});
;

/*********************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ProductScreen/NumpadWidget.js  *
*  Lines: 49                                                                     *
*********************************************************************************/
odoo.define('point_of_sale.NumpadWidget', function (require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    /**
     * @prop {'quantity' | 'price' | 'discount'} activeMode
     * @prop {Array<'quantity' | 'price' | 'discount'>} disabledModes
     * @prop {boolean} disableSign
     * @event set-numpad-mode - triggered when mode button is clicked
     * @event numpad-click-input - triggered when numpad button is clicked
     */
    class NumpadWidget extends PosComponent {
        get hasPriceControlRights() {
            return (
                this.env.pos.cashierHasPriceControlRights() &&
                !this.props.disabledModes.includes('price')
            );
        }
        get hasManualDiscount() {
            return this.env.pos.config.manual_discount && !this.props.disabledModes.includes('discount');
        }
        changeMode(mode) {
            if (!this.hasPriceControlRights && mode === 'price') {
                return;
            }
            if (!this.hasManualDiscount && mode === 'discount') {
                return;
            }
            this.trigger('set-numpad-mode', { mode });
        }
        sendInput(key) {
            this.trigger('numpad-click-input', { key });
        }
        get decimalSeparator() {
            return this.env._t.database.parameters.decimal_point;
        }
    }
    NumpadWidget.template = 'NumpadWidget';
    NumpadWidget.defaultProps = {
        disabledModes: [],
        disableSign: false,
    }

    Registries.Component.add(NumpadWidget);

    return NumpadWidget;
});
;

/*********************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ProductScreen/OrderSummary.js  *
*  Lines: 27                                                                     *
*********************************************************************************/
odoo.define('point_of_sale.OrderSummary', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');
    const { float_is_zero } = require('web.utils');

    class OrderSummary extends PosComponent {
        getTotal() {
            return this.env.pos.format_currency(this.props.order.get_total_with_tax());
        }
        getTax() {
            const total = this.props.order.get_total_with_tax();
            const totalWithoutTax = this.props.order.get_total_without_tax();
            const taxAmount = total - totalWithoutTax;
            return {
                hasTax: !float_is_zero(taxAmount, this.env.pos.currency.decimal_places),
                displayAmount: this.env.pos.format_currency(taxAmount),
            };
        }
    }
    OrderSummary.template = 'OrderSummary';

    Registries.Component.add(OrderSummary);

    return OrderSummary;
});
;

/********************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ProductScreen/OrderWidget.js  *
*  Lines: 70                                                                    *
********************************************************************************/
odoo.define('point_of_sale.OrderWidget', function(require) {
    'use strict';

    const { useListener } = require("@web/core/utils/hooks");
    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    const { useRef, useEffect } = owl;

    class OrderWidget extends PosComponent {
        setup() {
            super.setup();
            useListener('select-line', this._selectLine);
            useListener('edit-pack-lot-lines', this._editPackLotLines);
            this.scrollableRef = useRef('scrollable');
            useEffect(
                () => {
                    const selectedLineEl = this.scrollableRef.el && this.scrollableRef.el.querySelector(".orderline.selected");
                    if(selectedLineEl) {
                        selectedLineEl.scrollIntoView({ behavior: "smooth", block: "start" });
                    }
                },
                () => [this.order.selected_orderline]
            );
        }
        get order() {
            return this.env.pos.get_order();
        }
        get orderlinesArray() {
            return this.order ? this.order.get_orderlines() : [];
        }
        _selectLine(event) {
            this.order.select_orderline(event.detail.orderline);
        }
        // IMPROVEMENT: Might be better to lift this to ProductScreen
        // because there is similar operation when clicking a product.
        //
        // Furthermore, what if a number different from 1 (or -1) is specified
        // to an orderline that has product tracked by lot. Lot tracking (based
        // on the current implementation) requires that 1 item per orderline is
        // allowed.
        async _editPackLotLines(event) {
            const orderline = event.detail.orderline;
            const isAllowOnlyOneLot = orderline.product.isAllowOnlyOneLot();
            const packLotLinesToEdit = orderline.getPackLotLinesToEdit(isAllowOnlyOneLot);
            const { confirmed, payload } = await this.showPopup('EditListPopup', {
                title: this.env._t('Lot/Serial Number(s) Required'),
                isSingleItem: isAllowOnlyOneLot,
                array: packLotLinesToEdit,
            });
            if (confirmed) {
                // Segregate the old and new packlot lines
                const modifiedPackLotLines = Object.fromEntries(
                    payload.newArray.filter(item => item.id).map(item => [item.id, item.text])
                );
                const newPackLotLines = payload.newArray
                    .filter(item => !item.id)
                    .map(item => ({ lot_name: item.text }));

                orderline.setPackLotLines({ modifiedPackLotLines, newPackLotLines });
            }
            this.order.select_orderline(event.detail.orderline);
        }
    }
    OrderWidget.template = 'OrderWidget';

    Registries.Component.add(OrderWidget);

    return OrderWidget;
});
;

/******************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ProductScreen/Orderline.js  *
*  Lines: 28                                                                  *
******************************************************************************/
odoo.define('point_of_sale.Orderline', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    class Orderline extends PosComponent {
        selectLine() {
            this.trigger('select-line', { orderline: this.props.line });
        }
        lotIconClicked() {
            this.trigger('edit-pack-lot-lines', { orderline: this.props.line });
        }
        get addedClasses() {
            return {
                selected: this.props.line.selected,
            };
        }
        get customerNote() {
            return this.props.line.get_customer_note();
        }
    }
    Orderline.template = 'Orderline';

    Registries.Component.add(Orderline);

    return Orderline;
});
;

/********************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ProductScreen/ProductItem.js  *
*  Lines: 69                                                                    *
********************************************************************************/
odoo.define('point_of_sale.ProductItem', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');
    const { ConnectionLostError, ConnectionAbortedError } = require('@web/core/network/rpc_service')
    const { identifyError } = require('point_of_sale.utils');

    class ProductItem extends PosComponent {
        /**
         * For accessibility, pressing <space> should be like clicking the product.
         * <enter> is not considered because it conflicts with the barcode.
         *
         * @param {KeyPressEvent} event
         */
        spaceClickProduct(event) {
            if (event.which === 32) {
                this.trigger('click-product', this.props.product);
            }
        }
        get imageUrl() {
            const product = this.props.product;
            return `/web/image?model=product.product&field=image_128&id=${product.id}&unique=${product.__last_update}`;
        }
        get pricelist() {
            const current_order = this.env.pos.get_order();
            if (current_order) {
                return current_order.pricelist;
            }
            return this.env.pos.default_pricelist;
        }
        get price() {
            const formattedUnitPrice = this.env.pos.format_currency(
                this.props.product.get_display_price(this.pricelist, 1),
                'Product Price'
            );
            if (this.props.product.to_weight) {
                return `${formattedUnitPrice}/${
                    this.env.pos.units_by_id[this.props.product.uom_id[0]].name
                }`;
            } else {
                return formattedUnitPrice;
            }
        }
        async onProductInfoClick() {
            try {
                const info = await this.env.pos.getProductInfo(this.props.product, 1);
                this.showPopup('ProductInfoPopup', { info: info , product: this.props.product });
            } catch (e) {
                if (identifyError(e) instanceof ConnectionLostError||ConnectionAbortedError) {
                    this.showPopup('ErrorPopup', {
                        title: this.env._t('OfflineErrorPopup'),
                        body: this.env._t('Cannot access product information screen if offline.'),
                    });
                } else {
                    this.showPopup('ErrorPopup', {
                        title: this.env._t('Unknown error'),
                        body: this.env._t('An unknown error prevents us from loading product information.'),
                    });
                }
            }
        }
    }
    ProductItem.template = 'ProductItem';

    Registries.Component.add(ProductItem);

    return ProductItem;
});
;

/**********************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ProductScreen/ProductScreen.js  *
*  Lines: 429                                                                     *
**********************************************************************************/
odoo.define('point_of_sale.ProductScreen', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const ControlButtonsMixin = require('point_of_sale.ControlButtonsMixin');
    const NumberBuffer = require('point_of_sale.NumberBuffer');
    const { useListener } = require("@web/core/utils/hooks");
    const Registries = require('point_of_sale.Registries');
    const { useBarcodeReader } = require('point_of_sale.custom_hooks');
    const { isConnectionError } = require('point_of_sale.utils');
    const { parse } = require('web.field_utils');
    const { _lt } = require('@web/core/l10n/translation');

    const { onMounted, useState } = owl;

    class ProductScreen extends ControlButtonsMixin(PosComponent) {
        setup() {
            super.setup();
            useListener('update-selected-orderline', this._updateSelectedOrderline);
            useListener('select-line', this._selectLine);
            useListener('set-numpad-mode', this._setNumpadMode);
            useListener('click-product', this._clickProduct);
            useListener('click-partner', this.onClickPartner);
            useListener('click-pay', this._onClickPay);
            useBarcodeReader({
                product: this._barcodeProductAction,
                quantity: this._barcodeProductAction,
                weight: this._barcodeProductAction,
                price: this._barcodeProductAction,
                client: this._barcodePartnerAction,
                discount: this._barcodeDiscountAction,
                error: this._barcodeErrorAction,
                gs1: this._barcodeGS1Action,
            });
            NumberBuffer.use({
                nonKeyboardInputEvent: 'numpad-click-input',
                triggerAtInput: 'update-selected-orderline',
                useWithBarcode: true,
            });
            onMounted(this.onMounted);
            // Call `reset` when the `onMounted` callback in `NumberBuffer.use` is done.
            // We don't do this in the `mounted` lifecycle method because it is called before
            // the callbacks in `onMounted` hook.
            onMounted(() => NumberBuffer.reset());
            this.state = useState({
                mobile_pane: this.props.mobile_pane || 'right',
            });
        }
        onMounted() {
            this.env.posbus.trigger('start-cash-control');
        }
        /**
         * To be overridden by modules that checks availability of
         * connected scale.
         * @see _onScaleNotAvailable
         */
        get isScaleAvailable() {
            return true;
        }
        get partner() {
            return this.currentOrder ? this.currentOrder.get_partner() : null;
        }
        get currentOrder() {
            return this.env.pos.get_order();
        }
        async _getAddProductOptions(product, code) {
            let price_extra = 0.0;
            let draftPackLotLines, weight, description, packLotLinesToEdit;

            if (_.some(product.attribute_line_ids, (id) => id in this.env.pos.attributes_by_ptal_id)) {
                let attributes = _.map(product.attribute_line_ids, (id) => this.env.pos.attributes_by_ptal_id[id])
                                  .filter((attr) => attr !== undefined);
                let { confirmed, payload } = await this.showPopup('ProductConfiguratorPopup', {
                    product: product,
                    attributes: attributes,
                });

                if (confirmed) {
                    description = payload.selected_attributes.join(', ');
                    price_extra += payload.price_extra;
                } else {
                    return;
                }
            }

            // Gather lot information if required.
            if (['serial', 'lot'].includes(product.tracking) && (this.env.pos.picking_type.use_create_lots || this.env.pos.picking_type.use_existing_lots)) {
                const isAllowOnlyOneLot = product.isAllowOnlyOneLot();
                if (isAllowOnlyOneLot) {
                    packLotLinesToEdit = [];
                } else {
                    const orderline = this.currentOrder
                        .get_orderlines()
                        .filter(line => !line.get_discount())
                        .find(line => line.product.id === product.id);
                    if (orderline) {
                        packLotLinesToEdit = orderline.getPackLotLinesToEdit();
                    } else {
                        packLotLinesToEdit = [];
                    }
                }
                // if the lot information exists in the barcode, we don't need to ask it from the user.
                if (code && code.type === 'lot') {
                    // consider the old and new packlot lines
                    const modifiedPackLotLines = Object.fromEntries(
                        packLotLinesToEdit.filter(item => item.id).map(item => [item.id, item.text])
                    );
                    const newPackLotLines = [
                        { lot_name: code.code },
                    ];
                    draftPackLotLines = { modifiedPackLotLines, newPackLotLines };
                } else {
                    const { confirmed, payload } = await this.showPopup('EditListPopup', {
                        title: this.env._t('Lot/Serial Number(s) Required'),
                        isSingleItem: isAllowOnlyOneLot,
                        array: packLotLinesToEdit,
                    });
                    if (confirmed) {
                        // Segregate the old and new packlot lines
                        const modifiedPackLotLines = Object.fromEntries(
                            payload.newArray.filter(item => item.id).map(item => [item.id, item.text])
                        );
                        const newPackLotLines = payload.newArray
                            .filter(item => !item.id)
                            .map(item => ({ lot_name: item.text }));

                        draftPackLotLines = { modifiedPackLotLines, newPackLotLines };
                    } else {
                        // We don't proceed on adding product.
                        return;
                    }
                }
            }

            // Take the weight if necessary.
            if (product.to_weight && this.env.pos.config.iface_electronic_scale) {
                // Show the ScaleScreen to weigh the product.
                if (this.isScaleAvailable) {
                    const { confirmed, payload } = await this.showTempScreen('ScaleScreen', {
                        product,
                    });
                    if (confirmed) {
                        weight = payload.weight;
                    } else {
                        // do not add the product;
                        return;
                    }
                } else {
                    await this._onScaleNotAvailable();
                }
            }

            if (code && this.env.pos.db.product_packaging_by_barcode[code.code]) {
                weight = this.env.pos.db.product_packaging_by_barcode[code.code].qty;
            }

            return { draftPackLotLines, quantity: weight, description, price_extra };
        }
        async _addProduct(product, options) {
            this.currentOrder.add_product(product, options);
        }
        async _clickProduct(event) {
            if (!this.currentOrder) {
                this.env.pos.add_new_order();
            }
            const product = event.detail;
            const options = await this._getAddProductOptions(product);
            // Do not add product if options is undefined.
            if (!options) return;
            // Add the product after having the extra information.
            await this._addProduct(product, options);
            NumberBuffer.reset();
        }
        _setNumpadMode(event) {
            const { mode } = event.detail;
            NumberBuffer.capture();
            NumberBuffer.reset();
            this.env.pos.numpadMode = mode;
        }
        _selectLine() {
            NumberBuffer.reset();
        }
        async _updateSelectedOrderline(event) {
            if (this.env.pos.numpadMode === 'quantity' && this.env.pos.disallowLineQuantityChange()) {
                let order = this.env.pos.get_order();
                if(!order.orderlines.length)
                    return;
                let selectedLine = order.get_selected_orderline();
                let orderlines = order.orderlines;
                let lastId = orderlines.length !== 0 && orderlines.at(orderlines.length - 1).cid;
                let currentQuantity = this.env.pos.get_order().get_selected_orderline().get_quantity();

                if(selectedLine.noDecrease) {
                    this.showPopup('ErrorPopup', {
                        title: this.env._t('Invalid action'),
                        body: this.env._t('You are not allowed to change this quantity'),
                    });
                    return;
                }
                const parsedInput = event.detail.buffer && parse.float(event.detail.buffer) || 0;
                if(lastId != selectedLine.cid)
                    this._showDecreaseQuantityPopup();
                else if(currentQuantity < parsedInput)
                    this._setValue(event.detail.buffer);
                else if(parsedInput < currentQuantity)
                    this._showDecreaseQuantityPopup();
            } else {
                let { buffer } = event.detail;
                let val = buffer === null ? 'remove' : buffer;
                this._setValue(val);
                if (val == 'remove') {
                    NumberBuffer.reset();
                    this.env.pos.numpadMode = 'quantity';
                }
            }
        }
        _setValue(val) {
            if (this.currentOrder.get_selected_orderline()) {
                if (this.env.pos.numpadMode === 'quantity') {
                    const result = this.currentOrder.get_selected_orderline().set_quantity(val);
                    if (!result) NumberBuffer.reset();
                } else if (this.env.pos.numpadMode === 'discount') {
                    this.currentOrder.get_selected_orderline().set_discount(val);
                } else if (this.env.pos.numpadMode === 'price') {
                    var selected_orderline = this.currentOrder.get_selected_orderline();
                    selected_orderline.price_manually_set = true;
                    selected_orderline.set_unit_price(val);
                }
            }
        }
        async _getProductByBarcode(code) {
            let product = this.env.pos.db.get_product_by_barcode(code.base_code);
            if (!product) {
                // find the barcode in the backend
                let foundProductIds = [];
                try {
                    foundProductIds = await this.rpc({
                        model: 'product.product',
                        method: 'search',
                        args: [[['barcode', '=', code.base_code], ['sale_ok', '=', true]]],
                        context: this.env.session.user_context,
                    });
                } catch (error) {
                    if (isConnectionError(error)) {
                        return this.showPopup('OfflineErrorPopup', {
                            title: this.env._t('Network Error'),
                            body: this.env._t("Product is not loaded. Tried loading the product from the server but there is a network error."),
                        });
                    } else {
                        throw error;
                    }
                }
                if (foundProductIds.length) {
                    await this.env.pos._addProducts(foundProductIds);
                    // assume that the result is unique.
                    product = this.env.pos.db.get_product_by_id(foundProductIds[0]);
                } else {
                    return this._barcodeErrorAction(code);
                }
            }
            return product
        }
        async _barcodeProductAction(code) {
            const product = await this._getProductByBarcode(code);
            if (!product) {
                return;
            }
            const options = await this._getAddProductOptions(product, code);
            // Do not proceed on adding the product when no options is returned.
            // This is consistent with _clickProduct.
            if (!options) return;

            // update the options depending on the type of the scanned code
            if (code.type === 'price') {
                Object.assign(options, {
                    price: code.value,
                    extras: {
                        price_manually_set: true,
                    },
                });
            } else if (code.type === 'weight' || code.type === 'quantity') {
                Object.assign(options, {
                    quantity: code.value,
                    merge: false,
                });
            } else if (code.type === 'discount') {
                Object.assign(options, {
                    discount: code.value,
                    merge: false,
                });
            }
            this.currentOrder.add_product(product,  options);
            NumberBuffer.reset();
        }
        _barcodePartnerAction(code) {
            const partner = this.env.pos.db.get_partner_by_barcode(code.code);
            if (partner) {
                if (this.currentOrder.get_partner() !== partner) {
                    this.currentOrder.set_partner(partner);
                    this.currentOrder.updatePricelist(partner);
                }
                return true;
            }
            this._barcodeErrorAction(code);
            return false;
        }
        _barcodeDiscountAction(code) {
            var last_orderline = this.currentOrder.get_last_orderline();
            if (last_orderline) {
                last_orderline.set_discount(code.value);
            }
        }
        async _parseElementsFromGS1(parsed_results) {
            const productBarcode = parsed_results.find(element => element.type === 'product');
            const lotBarcode = parsed_results.find(element => element.type === 'lot');
            const product = await this._getProductByBarcode(productBarcode);
            return { product, lotBarcode, customProductOptions: {} }
        }
        /**
         * Add a product to the current order using the product identifier and lot number from parsed results.
         * This function retrieves the product identifier and lot number from the `parsed_results` parameter.
         * It then uses these values to retrieve the product and add it to the current order.
         */
        async _barcodeGS1Action(parsed_results) {
            const { product, lotBarcode, customProductOptions } = await this._parseElementsFromGS1(parsed_results)
            if (!product) {
                return;
            }
            const options = await this._getAddProductOptions(product, lotBarcode);
            await this.currentOrder.add_product(product, { ...options, ...customProductOptions });
            NumberBuffer.reset();
        }
        // IMPROVEMENT: The following two methods should be in PosScreenComponent?
        // Why? Because once we start declaring barcode actions in different
        // screens, these methods will also be declared over and over.
        _barcodeErrorAction(code) {
            this.showPopup('ErrorBarcodePopup', { code: this._codeRepr(code) });
        }
        _codeRepr(code) {
            if (code.code.length > 32) {
                return code.code.substring(0, 29) + '...';
            } else {
                return code.code;
            }
        }
        async _displayAllControlPopup() {
            await this.showPopup('ControlButtonPopup', {
                controlButtons: this.controlButtons
            });
        }
        /**
         * override this method to perform procedure if the scale is not available.
         * @see isScaleAvailable
         */
        async _onScaleNotAvailable() {}
        async _showDecreaseQuantityPopup() {
            const { confirmed, payload: inputNumber } = await this.showPopup('NumberPopup', {
                startingValue: 0,
                title: this.env._t('Set the new quantity'),
            });
            let newQuantity = inputNumber && inputNumber !== "" ? parse.float(inputNumber) : null;
            if (confirmed && newQuantity !== null) {
                let order = this.env.pos.get_order();
                let selectedLine = this.env.pos.get_order().get_selected_orderline();
                let currentQuantity = selectedLine.get_quantity()
                if(selectedLine.is_last_line() && currentQuantity === 1 && newQuantity < currentQuantity)
                    selectedLine.set_quantity(newQuantity);
                else if(newQuantity >= currentQuantity)
                    selectedLine.set_quantity(newQuantity);
                else {
                    let newLine = selectedLine.clone();
                    let decreasedQuantity = currentQuantity - newQuantity
                    newLine.order = order;

                    newLine.set_quantity( - decreasedQuantity, true);
                    order.add_orderline(newLine);
                }
            }
        }
        async onClickPartner() {
            // IMPROVEMENT: This code snippet is very similar to selectPartner of PaymentScreen.
            const currentPartner = this.currentOrder.get_partner();
            if (currentPartner && this.currentOrder.getHasRefundLines()) {
                this.showPopup('ErrorPopup', {
                    title: this.env._t("Can't change customer"),
                    body: _.str.sprintf(
                        this.env._t(
                            "This order already has refund lines for %s. We can't change the customer associated to it. Create a new order for the new customer."
                        ),
                        currentPartner.name
                    ),
                });
                return;
            }
            const { confirmed, payload: newPartner } = await this.showTempScreen(
                'PartnerListScreen',
                { partner: currentPartner }
            );
            if (confirmed) {
                this.currentOrder.set_partner(newPartner);
                this.currentOrder.updatePricelist(newPartner);
            }
        }
        async _onClickPay() {
            if (this.env.pos.get_order().orderlines.some(line => line.get_product().tracking !== 'none' && !line.has_valid_product_lot()) && (this.env.pos.picking_type.use_create_lots || this.env.pos.picking_type.use_existing_lots)) {
                const { confirmed } = await this.showPopup('ConfirmPopup', {
                    title: this.env._t('Some Serial/Lot Numbers are missing'),
                    body: this.env._t('You are trying to sell products with serial/lot numbers, but some of them are not set.\nWould you like to proceed anyway?'),
                    confirmText: this.env._t('Yes'),
                    cancelText: this.env._t('No')
                });
                if (confirmed) {
                    this.showScreen('PaymentScreen');
                }
            } else {
                this.showScreen('PaymentScreen');
            }
        }
        switchPane() {
            this.state.mobile_pane = this.state.mobile_pane === "left" ? "right" : "left";
        }
    }
    ProductScreen.template = 'ProductScreen';
    ProductScreen.numpadActionName = _lt('Payment');

    Registries.Component.add(ProductScreen);

    return ProductScreen;
});
;

/***********************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ProductScreen/ProductsWidget.js  *
*  Lines: 153                                                                      *
***********************************************************************************/
odoo.define('point_of_sale.ProductsWidget', function(require) {
    'use strict';

    const { identifyError } = require('point_of_sale.utils');
    const { ConnectionLostError, ConnectionAbortedError } = require('@web/core/network/rpc_service');
    const PosComponent = require('point_of_sale.PosComponent');
    const { useListener } = require("@web/core/utils/hooks");
    const Registries = require('point_of_sale.Registries');

    const { onWillUnmount, useState } = owl;

    class ProductsWidget extends PosComponent {
        /**
         * @param {Object} props
         * @param {number?} props.startCategoryId
         */
        setup() {
            super.setup();
            useListener('switch-category', this._switchCategory);
            useListener('update-search', this._updateSearch);
            useListener('clear-search', this._clearSearch);
            useListener('load-products-from-server', this._onPressEnterKey);
            this.state = useState({ searchWord: '', previousSearchWord: "", currentOffset: 0 });
            onWillUnmount(this.onWillUnmount);
        }
        onWillUnmount() {
            this.trigger('toggle-mobile-searchbar', false);
        }
        get selectedCategoryId() {
            return this.env.pos.selectedCategoryId;
        }
        get searchWord() {
            return this.state.searchWord.trim();
        }
        get productsToDisplay() {
            let list = [];
            if (this.searchWord !== '') {
                list = this.env.pos.db.search_product_in_category(
                    this.selectedCategoryId,
                    this.searchWord
                );
            } else {
                list = this.env.pos.db.get_product_by_category(this.selectedCategoryId);
            }
            return list.sort(function (a, b) { return a.display_name.localeCompare(b.display_name) });
        }
        get subcategories() {
            return this.env.pos.db
                .get_category_childs_ids(this.selectedCategoryId)
                .map(id => this.env.pos.db.get_category_by_id(id));
        }
        get breadcrumbs() {
            if (this.selectedCategoryId === this.env.pos.db.root_category_id) return [];
            return [
                ...this.env.pos.db
                    .get_category_ancestors_ids(this.selectedCategoryId)
                    .slice(1),
                this.selectedCategoryId,
            ].map(id => this.env.pos.db.get_category_by_id(id));
        }
        get hasNoCategories() {
            return this.env.pos.db.get_category_childs_ids(0).length === 0;
        }
        get shouldShowButton() {
            return this.productsToDisplay.length === 0 && this.searchWord;
        }
        _switchCategory(event) {
            this.env.pos.setSelectedCategoryId(event.detail);
        }
        _updateSearch(event) {
            this.state.searchWord = event.detail;
        }
        _clearSearch() {
            this.state.searchWord = '';
        }
        _updateProductList(event) {
            this.render(true);
            this.trigger('switch-category', 0);
        }
        async _onPressEnterKey() {
            if (!this.state.searchWord) return;
            if (this.state.previousSearchWord != this.state.searchWord) {
                this.state.currentOffset = 0;
            }
            const result = await this.loadProductFromDB();
            if (result.length > 0) {
                this.showNotification(
                    _.str.sprintf(
                        this.env._t('%s product(s) found for "%s".'),
                        result.length,
                        this.state.searchWord
                    ),
                    3000
                );
            } else {
                this.showNotification(
                    _.str.sprintf(
                        this.env._t('No more product found for "%s".'),
                        this.state.searchWord
                    ),
                    3000
                );
            }
            if (this.state.previousSearchWord == this.state.searchWord) {
                this.state.currentOffset += result.length;
            } else {
                this.state.previousSearchWord = this.state.searchWord;
                this.state.currentOffset = result.length;
            }
        }
        async loadProductFromDB() {
            if(!this.state.searchWord)
                return;

            try {
                const limit = 30;
                let ProductIds = await this.rpc({
                    model: 'product.product',
                    method: 'search',
                    args: [['&',['available_in_pos', '=', true], '|','|',
                     ['name', 'ilike', this.state.searchWord],
                     ['default_code', 'ilike', this.state.searchWord],
                     ['barcode', 'ilike', this.state.searchWord]]],
                    context: this.env.session.user_context,
                    kwargs: {
                        offset: this.state.currentOffset,
                        limit: limit,
                    }
                });
                if(ProductIds.length) {
                    await this.env.pos._addProducts(ProductIds, false);
                }
                this._updateProductList();
                return ProductIds;
            } catch (error) {
                const identifiedError = identifyError(error)
                if (identifiedError instanceof ConnectionLostError || identifiedError instanceof ConnectionAbortedError) {
                    return this.showPopup('OfflineErrorPopup', {
                        title: this.env._t('Network Error'),
                        body: this.env._t("Product is not loaded. Tried loading the product from the server but there is a network error."),
                    });
                } else {
                    throw error;
                }
            }
        }
    }
    ProductsWidget.template = 'ProductsWidget';

    Registries.Component.add(ProductsWidget);

    return ProductsWidget;
});
;

/***********************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ProductScreen/ProductsWidgetControlPanel.js  *
*  Lines: 52                                                                                   *
***********************************************************************************************/
odoo.define('point_of_sale.ProductsWidgetControlPanel', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');
    const { debounce } = require("@web/core/utils/timing");

    const { onMounted, onWillUnmount, useRef } = owl;

    class ProductsWidgetControlPanel extends PosComponent {
        setup() {
            super.setup();
            this.searchWordInput = useRef('search-word-input-product');
            this.updateSearch = debounce(this.updateSearch, 100);

            onMounted(() => {
                this.env.posbus.on('search-product-from-info-popup', this, this.searchProductFromInfo)
            });

            onWillUnmount(() => {
                this.env.posbus.off('search-product-from-info-popup', this);
            });
        }
        _clearSearch() {
            this.searchWordInput.el.value = '';
            this.trigger('clear-search');
        }
        get displayCategImages() {
            return Object.values(this.env.pos.db.category_by_id).some(categ => categ.has_image) && !this.env.isMobile;
        }
        updateSearch(event) {
            this.trigger('update-search', event.target.value);
        }
        async _onPressEnterKey() {
            if (!this.searchWordInput.el.value) return;
            this.trigger('load-products-from-server');
        }
        searchProductFromInfo(productName) {
            this.searchWordInput.el.value = productName;
            this.trigger('switch-category', 0);
            this.trigger('update-search', productName);
        }
        _toggleMobileSearchbar() {
            this.trigger('toggle-mobile-searchbar');
        }
    }
    ProductsWidgetControlPanel.template = 'ProductsWidgetControlPanel';

    Registries.Component.add(ProductsWidgetControlPanel);

    return ProductsWidgetControlPanel;
});
;

/*********************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ReceiptScreen/OrderReceipt.js  *
*  Lines: 50                                                                     *
*********************************************************************************/
odoo.define('point_of_sale.OrderReceipt', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    const { onWillUpdateProps } = owl;

    class OrderReceipt extends PosComponent {
        setup() {
            super.setup();
            this._receiptEnv = this.props.order.getOrderReceiptEnv();

            onWillUpdateProps((nextProps) => {
                this._receiptEnv = nextProps.order.getOrderReceiptEnv();
            });
        }
        get receipt() {
            return this.receiptEnv.receipt;
        }
        get orderlines() {
            return this.receiptEnv.orderlines;
        }
        get paymentlines() {
            return this.receiptEnv.paymentlines;
        }
        get isTaxIncluded() {
            return Math.abs(this.receipt.subtotal - this.receipt.total_with_tax) <= 0.000001;
        }
        get receiptEnv () {
          return this._receiptEnv;
        }
        isSimple(line) {
            return (
                line.discount === 0 &&
                line.is_in_unit &&
                line.quantity === 1 &&
                !(
                    line.display_discount_policy == 'without_discount' &&
                    line.price < line.price_lst
                )
            );
        }
    }
    OrderReceipt.template = 'OrderReceipt';

    Registries.Component.add(OrderReceipt);

    return OrderReceipt;
});
;

/**********************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ReceiptScreen/ReceiptScreen.js  *
*  Lines: 148                                                                     *
**********************************************************************************/
odoo.define('point_of_sale.ReceiptScreen', function (require) {
    'use strict';

    const { Printer } = require('point_of_sale.Printer');
    const { is_email } = require('web.utils');
    const { useErrorHandlers } = require('point_of_sale.custom_hooks');
    const Registries = require('point_of_sale.Registries');
    const AbstractReceiptScreen = require('point_of_sale.AbstractReceiptScreen');

    const { onMounted, useRef, status } = owl;

    const ReceiptScreen = (AbstractReceiptScreen) => {
        class ReceiptScreen extends AbstractReceiptScreen {
            setup() {
                super.setup();
                useErrorHandlers();
                this.orderReceipt = useRef('order-receipt');
                const order = this.currentOrder;
                const partner = order.get_partner();
                this.orderUiState = order.uiState.ReceiptScreen;
                this.orderUiState.inputEmail = this.orderUiState.inputEmail || (partner && partner.email) || '';
                this.is_email = is_email;

                onMounted(() => {
                    // Here, we send a task to the event loop that handles
                    // the printing of the receipt when the component is mounted.
                    // We are doing this because we want the receipt screen to be
                    // displayed regardless of what happen to the handleAutoPrint
                    // call.
                    setTimeout(async () => {
                        if (status(this) === "mounted") {
                            let images = this.orderReceipt.el.getElementsByTagName('img');
                            for (let image of images) {
                                await image.decode();
                            }
                            await this.handleAutoPrint();
                        }
                    }, 0);
                });
            }
            _addNewOrder() {
                this.env.pos.add_new_order();
            }
            async onSendEmail() {
                if (!is_email(this.orderUiState.inputEmail)) {
                    this.orderUiState.emailSuccessful = false;
                    this.orderUiState.emailNotice = this.env._t('Invalid email.');
                    return;
                }
                try {
                    await this._sendReceiptToCustomer();
                    this.orderUiState.emailSuccessful = true;
                    this.orderUiState.emailNotice = this.env._t('Email sent.');
                } catch (_error) {
                    this.orderUiState.emailSuccessful = false;
                    this.orderUiState.emailNotice = this.env._t('Sending email failed. Please try again.');
                }
            }
            get orderAmountPlusTip() {
                const order = this.currentOrder;
                const orderTotalAmount = order.get_total_with_tax();
                const tip_product_id = this.env.pos.config.tip_product_id && this.env.pos.config.tip_product_id[0];
                const tipLine = order
                    .get_orderlines()
                    .find((line) => tip_product_id && line.product.id === tip_product_id);
                const tipAmount = tipLine ? tipLine.get_all_prices().priceWithTax : 0;
                const orderAmountStr = this.env.pos.format_currency(orderTotalAmount - tipAmount);
                if (!tipAmount) return orderAmountStr;
                const tipAmountStr = this.env.pos.format_currency(tipAmount);
                return `${orderAmountStr} + ${tipAmountStr} tip`;
            }
            get currentOrder() {
                return this.env.pos.get_order();
            }
            get nextScreen() {
                return { name: 'ProductScreen' };
            }
            whenClosing() {
                this.orderDone();
            }
            /**
             * This function is called outside the rendering call stack. This way,
             * we don't block the displaying of ReceiptScreen when it is mounted; additionally,
             * any error that can happen during the printing does not affect the rendering.
             */
            async handleAutoPrint() {
                if (this._shouldAutoPrint()) {
                    const currentOrder = this.currentOrder;
                    await this.printReceipt();
                    if (this.currentOrder && this.currentOrder === currentOrder && currentOrder._printed && this._shouldCloseImmediately()) {
                        this.whenClosing();
                    }
                }
            }
            orderDone() {
                this.env.pos.removeOrder(this.currentOrder);
                this._addNewOrder();
                const { name, props } = this.nextScreen;
                this.showScreen(name, props);
                if (this.env.pos.config.iface_customer_facing_display) {
                    this.env.pos.send_current_order_to_customer_facing_display();
                }
            }
            async printReceipt() {
                const currentOrder = this.currentOrder;
                const isPrinted = await this._printReceipt();
                if (isPrinted) {
                    currentOrder._printed = true;
                }
            }
            _shouldAutoPrint() {
                return this.env.pos.config.iface_print_auto && !this.currentOrder._printed;
            }
            _shouldCloseImmediately() {
                var invoiced_finalized = this.currentOrder.is_to_invoice() ? this.currentOrder.finalized : true;
                return this.env.proxy.printer && this.env.pos.config.iface_print_skip_screen && invoiced_finalized;
            }
            async _sendReceiptToCustomer() {
                const printer = new Printer(null, this.env.pos);
                const receiptString = this.orderReceipt.el.innerHTML;
                const ticketImage = await printer.htmlToImg(receiptString);
                const order = this.currentOrder;
                const partner = order.get_partner();
                const orderName = order.get_name();
                const orderPartner = { email: this.orderUiState.inputEmail, name: partner ? partner.name : this.orderUiState.inputEmail };
                const order_server_id = this.env.pos.validated_orders_name_server_id_map[orderName];
                if (!order_server_id) {
                    this.showPopup('ErrorPopup', {
                        title: this.env._t('Unsynced order'),
                        body: this.env._t('This order is not yet synced to server. Make sure it is synced then try again.'),
                    });
                    return Promise.reject();
                }
                await this.rpc({
                    model: 'pos.order',
                    method: 'action_receipt_to_customer',
                    args: [[order_server_id], orderName, orderPartner, ticketImage],
                });
            }
        }
        ReceiptScreen.template = 'ReceiptScreen';
        return ReceiptScreen;
    };

    Registries.Component.addByExtending(ReceiptScreen, AbstractReceiptScreen);

    return ReceiptScreen;
});
;

/********************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ReceiptScreen/WrappedProductNameLines.js  *
*  Lines: 13                                                                                *
********************************************************************************************/
odoo.define('point_of_sale.WrappedProductNameLines', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    class WrappedProductNameLines extends PosComponent {}
    WrappedProductNameLines.template = 'WrappedProductNameLines';

    Registries.Component.add(WrappedProductNameLines);

    return WrappedProductNameLines;
});
;

/******************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/ScaleScreen/ScaleScreen.js  *
*  Lines: 105                                                                 *
******************************************************************************/
odoo.define('point_of_sale.ScaleScreen', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const { round_precision: round_pr } = require('web.utils');
    const Registries = require('point_of_sale.Registries');

    const { onMounted, onWillUnmount, useExternalListener, useState } = owl;

    class ScaleScreen extends PosComponent {
        /**
         * @param {Object} props
         * @param {Object} props.product The product to weight.
         */
        setup() {
            super.setup();
            useExternalListener(document, 'keyup', this._onHotkeys);
            this.state = useState({ weight: 0 });
            onMounted(this.onMounted);
            onWillUnmount(this.onWillUnmount);
        }
        onMounted() {
            // start the scale reading
            this._readScale();
        }
        onWillUnmount() {
            // stop the scale reading
            this.env.proxy_queue.clear();
        }
        back() {
            this.props.resolve({ confirmed: false, payload: null });
            this.trigger('close-temp-screen');
        }
        confirm() {
            this.props.resolve({
                confirmed: true,
                payload: { weight: this.state.weight },
            });
            this.trigger('close-temp-screen');
        }
        _onHotkeys(event) {
            if (event.key === 'Escape') {
                this.back();
            } else if (event.key === 'Enter') {
                this.confirm();
            }
        }
        _readScale() {
            this.env.proxy_queue.schedule(this._setWeight.bind(this), {
                duration: 500,
                repeat: true,
            });
        }
        async _setWeight() {
            const reading = await this.env.proxy.scale_read();
            this.state.weight = reading.weight;
        }
        get _activePricelist() {
            const current_order = this.env.pos.get_order();
            let current_pricelist = this.env.pos.default_pricelist;
            if (current_order) {
                current_pricelist = current_order.pricelist;
            }
            return current_pricelist;
        }
        get productWeightString() {
            const defaultstr = (this.state.weight || 0).toFixed(3) + ' Kg';
            if (!this.props.product || !this.env.pos) {
                return defaultstr;
            }
            const unit_id = this.props.product.uom_id;
            if (!unit_id) {
                return defaultstr;
            }
            const unit = this.env.pos.units_by_id[unit_id[0]];
            const weight = round_pr(this.state.weight || 0, unit.rounding);
            let weightstr = weight.toFixed(Math.ceil(Math.log(1.0 / unit.rounding) / Math.log(10)));
            weightstr += ' ' + unit.name;
            return weightstr;
        }
        get computedPriceString() {
            return this.env.pos.format_currency(this.productPrice * this.state.weight);
        }
        get productPrice() {
            const product = this.props.product;
            return (product ? product.get_price(this._activePricelist, this.state.weight) : 0) || 0;
        }
        get productName() {
            return (
                (this.props.product ? this.props.product.display_name : undefined) ||
                'Unnamed Product'
            );
        }
        get productUom() {
            return this.props.product
                ? this.env.pos.units_by_id[this.props.product.uom_id[0]].name
                : '';
        }
    }
    ScaleScreen.template = 'ScaleScreen';

    Registries.Component.add(ScaleScreen);

    return ScaleScreen;
});
;

/************************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/TicketScreen/ControlButtons/InvoiceButton.js  *
*  Lines: 128                                                                                   *
************************************************************************************************/
odoo.define('point_of_sale.InvoiceButton', function (require) {
    'use strict';

    const { useListener } = require("@web/core/utils/hooks");
    const { isConnectionError } = require('point_of_sale.utils');
    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    class InvoiceButton extends PosComponent {
        setup() {
            super.setup();
            useListener('click', this._onClick);
        }
        get isAlreadyInvoiced() {
            if (!this.props.order) return false;
            return Boolean(this.props.order.account_move);
        }
        get commandName() {
            if (!this.props.order) {
                return this.env._t('Invoice');
            } else {
                return this.isAlreadyInvoiced
                    ? this.env._t('Reprint Invoice')
                    : this.env._t('Invoice');
            }
        }
        async _downloadInvoice(orderId) {
            try {
                const [orderWithInvoice] = await this.rpc({
                    method: 'read',
                    model: 'pos.order',
                    args: [orderId, ['account_move']],
                    kwargs: { load: false },
                });
                if (orderWithInvoice && orderWithInvoice.account_move) {
                    await this.env.legacyActionManager.do_action('account.account_invoices', {
                        additional_context: {
                            active_ids: [orderWithInvoice.account_move],
                        },
                    });
                }
            } catch (error) {
                if (error instanceof Error) {
                    throw error;
                } else {
                    // NOTE: error here is most probably undefined
                    this.showPopup('ErrorPopup', {
                        title: this.env._t('Network Error'),
                        body: this.env._t('Unable to download invoice.'),
                    });
                }
            }
        }
        async _invoiceOrder() {
            const order = this.props.order;
            if (!order) return;

            const orderId = order.backendId;

            // Part 0. If already invoiced, print the invoice.
            if (this.isAlreadyInvoiced) {
                await this._downloadInvoice(orderId);
                return;
            }

            // Part 1: Handle missing partner.
            // Write to pos.order the selected partner.
            if (!order.get_partner()) {
                const { confirmed: confirmedPopup } = await this.showPopup('ConfirmPopup', {
                    title: this.env._t('Need customer to invoice'),
                    body: this.env._t('Do you want to open the customer list to select customer?'),
                });
                if (!confirmedPopup) return;

                const { confirmed: confirmedTempScreen, payload: newPartner } = await this.showTempScreen(
                    'PartnerListScreen'
                );
                if (!confirmedTempScreen) return;

                await this.rpc({
                    model: 'pos.order',
                    method: 'write',
                    args: [[orderId], { partner_id: newPartner.id }],
                    kwargs: { context: this.env.session.user_context },
                });
            }

            // Part 2: Invoice the order.
            await this.rpc(
                {
                    model: 'pos.order',
                    method: 'action_pos_order_invoice',
                    args: [orderId],
                    kwargs: { context: this.env.session.user_context },
                },
                {
                    timeout: 30000,
                    shadow: true,
                }
            );

            // Part 3: Download invoice.
            await this._downloadInvoice(orderId);
            this.trigger('order-invoiced', orderId);
        }
        async _onClick() {
            try {
                this.el.style.pointerEvents = 'none';
                await this._invoiceOrder();
            } catch (error) {
                if (isConnectionError(error)) {
                    this.showPopup('ErrorPopup', {
                        title: this.env._t('Network Error'),
                        body: this.env._t('Unable to invoice order.'),
                    });
                } else {
                    throw error;
                }
            } finally {
                this.el.style.pointerEvents = 'auto';
            }
        }
    }
    InvoiceButton.template = 'InvoiceButton';
    Registries.Component.add(InvoiceButton);

    return InvoiceButton;
});
;

/*******************************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/TicketScreen/ControlButtons/ReprintReceiptButton.js  *
*  Lines: 22                                                                                           *
*******************************************************************************************************/
odoo.define('point_of_sale.ReprintReceiptButton', function (require) {
    'use strict';

    const { useListener } = require("@web/core/utils/hooks");
    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    class ReprintReceiptButton extends PosComponent {
        setup() {
            super.setup();
            useListener('click', this._onClick);
        }
        async _onClick() {
            if (!this.props.order) return;
            this.showScreen('ReprintReceiptScreen', { order: this.props.order });
        }
    }
    ReprintReceiptButton.template = 'ReprintReceiptButton';
    Registries.Component.add(ReprintReceiptButton);

    return ReprintReceiptButton;
});
;

/********************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/TicketScreen/OrderDetails.js  *
*  Lines: 29                                                                    *
********************************************************************************/
odoo.define('point_of_sale.OrderDetails', function (require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    /**
     * @props {models.Order} order
     */
    class OrderDetails extends PosComponent {
        get order() {
            return this.props.order;
        }
        get orderlines() {
            return this.order ? this.order.orderlines : [];
        }
        get total() {
            return this.env.pos.format_currency(this.order ? this.order.get_total_with_tax() : 0);
        }
        get tax() {
            return this.env.pos.format_currency(this.order ? this.order.get_total_tax() : 0)
        }
    }
    OrderDetails.template = 'OrderDetails';

    Registries.Component.add(OrderDetails);

    return OrderDetails;
});
;

/************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/TicketScreen/OrderlineDetails.js  *
*  Lines: 81                                                                        *
************************************************************************************/
odoo.define('point_of_sale.OrderlineDetails', function (require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');
    const { format } = require('web.field_utils');
    const { round_precision: round_pr } = require('web.utils');

    /**
     * @props {pos.order.line} line
     */
    class OrderlineDetails extends PosComponent {
        get line() {
            const line = this.props.line;
            const formatQty = (line) => {
                const quantity = line.get_quantity();
                const unit = line.get_unit();
                const decimals = this.env.pos.dp['Product Unit of Measure'];
                const rounding = Math.max(unit.rounding, Math.pow(10, -decimals));
                const roundedQuantity = round_pr(quantity, rounding);
                return format.float(roundedQuantity, { digits: [69, decimals] });
            };
            return {
                productName: line.get_full_product_name(),
                totalPrice: line.get_price_with_tax(),
                quantity: formatQty(line),
                unit: line.get_unit().name,
                unitPrice: line.get_unit_price(),
            };
        }
        get productName() {
            return this.line.productName;
        }
        get totalPrice() {
            return this.env.pos.format_currency(this.line.totalPrice);
        }
        get quantity() {
            return this.line.quantity;
        }
        get unitPrice() {
            return this.env.pos.format_currency(this.line.unitPrice);
        }
        get unit() {
            return this.line.unit;
        }
        get pricePerUnit() {
            return ` ${this.unit} at ${this.unitPrice} / ${this.unit}`;
        }
        get customerNote() {
            return this.props.line.get_customer_note();
        }
        getToRefundDetail() {
            return this.env.pos.toRefundLines[this.props.line.id];
        }
        hasRefundedQty() {
            return !this.env.pos.isProductQtyZero(this.props.line.refunded_qty);
        }
        getFormattedRefundedQty() {
            return this.env.pos.formatProductQty(this.props.line.refunded_qty);
        }
        hasToRefundQty() {
            const toRefundDetail = this.getToRefundDetail();
            return !this.env.pos.isProductQtyZero(toRefundDetail && toRefundDetail.qty);
        }
        getFormattedToRefundQty() {
            const toRefundDetail = this.getToRefundDetail();
            return this.env.pos.formatProductQty(toRefundDetail && toRefundDetail.qty);
        }
        getRefundingMessage() {
            return _.str.sprintf(this.env._t('Refunding %s in '), this.getFormattedToRefundQty());
        }
        getToRefundMessage() {
            return _.str.sprintf(this.env._t('To Refund: %s'), this.getFormattedToRefundQty());
        }
    }
    OrderlineDetails.template = 'OrderlineDetails';

    Registries.Component.add(OrderlineDetails);

    return OrderlineDetails;
});
;

/****************************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/TicketScreen/ReprintReceiptScreen.js  *
*  Lines: 36                                                                            *
****************************************************************************************/
odoo.define('point_of_sale.ReprintReceiptScreen', function (require) {
    'use strict';

    const AbstractReceiptScreen = require('point_of_sale.AbstractReceiptScreen');
    const Registries = require('point_of_sale.Registries');

    const ReprintReceiptScreen = (AbstractReceiptScreen) => {
        class ReprintReceiptScreen extends AbstractReceiptScreen {
            setup() {
                super.setup();
                owl.onMounted(this.onMounted);
            }
            onMounted() {
                this.printReceipt();
            }
            confirm() {
                this.showScreen('TicketScreen', { reuseSavedUIState: true });
            }
            async printReceipt() {
                if(this.env.proxy.printer && this.env.pos.config.iface_print_skip_screen) {
                    let result = await this._printReceipt();
                    if(result)
                        this.showScreen('TicketScreen', { reuseSavedUIState: true });
                }
            }
            async tryReprint() {
                await this._printReceipt();
            }
        }
        ReprintReceiptScreen.template = 'ReprintReceiptScreen';
        return ReprintReceiptScreen;
    };
    Registries.Component.addByExtending(ReprintReceiptScreen, AbstractReceiptScreen);

    return ReprintReceiptScreen;
});
;

/********************************************************************************
*  Filepath: /point_of_sale/static/src/js/Screens/TicketScreen/TicketScreen.js  *
*  Lines: 663                                                                   *
********************************************************************************/
odoo.define('point_of_sale.TicketScreen', function (require) {
    'use strict';

    const { Order } = require('point_of_sale.models');
    const Registries = require('point_of_sale.Registries');
    const IndependentToOrderScreen = require('point_of_sale.IndependentToOrderScreen');
    const NumberBuffer = require('point_of_sale.NumberBuffer');
    const { useListener } = require("@web/core/utils/hooks");
    const { parse } = require('web.field_utils');
    const { _lt } = require('@web/core/l10n/translation');

    const { onMounted, onWillUnmount, useState } = owl;

    class TicketScreen extends IndependentToOrderScreen {
        setup() {
            super.setup();
            useListener('close-screen', this._onCloseScreen);
            useListener('filter-selected', this._onFilterSelected);
            useListener('search', this._onSearch);
            useListener('click-order', this._onClickOrder);
            useListener('create-new-order', this._onCreateNewOrder);
            useListener('delete-order', this._onDeleteOrder);
            useListener('next-page', this._onNextPage);
            useListener('prev-page', this._onPrevPage);
            useListener('order-invoiced', this._onInvoiceOrder);
            useListener('click-order-line', this._onClickOrderline);
            useListener('click-refund-order-uid', this._onClickRefundOrderUid);
            useListener('update-selected-orderline', this._onUpdateSelectedOrderline);
            useListener('do-refund', this._onDoRefund);
            NumberBuffer.use({
                nonKeyboardInputEvent: 'numpad-click-input',
                triggerAtInput: 'update-selected-orderline',
            });
            this._state = this.env.pos.TICKET_SCREEN_STATE;
            this.state = useState({
                showSearchBar: !this.env.isMobile,
            });
            const defaultUIState = this.props.reuseSavedUIState
                ? this._state.ui
                : {
                      selectedSyncedOrderId: null,
                      searchDetails: this.env.pos.getDefaultSearchDetails(),
                      filter: null,
                      selectedOrderlineIds: {},
                  };
            Object.assign(this._state.ui, defaultUIState, this.props.ui || {});

            onMounted(this.onMounted);
            onWillUnmount(this.onWillUnmount);
        }
        //#region LIFECYCLE METHODS
        onMounted() {
            this.env.posbus.on('ticket-button-clicked', this, this.close);
            setTimeout(() => {
                // Show updated list of synced orders when going back to the screen.
                this._onFilterSelected({ detail: { filter: this._state.ui.filter } });
            });
        }
        onWillUnmount() {
            this.env.posbus.off('ticket-button-clicked', this);
        }
        //#endregion
        //#region EVENT HANDLERS
        _onCloseScreen() {
            this.close();
        }
        async _onFilterSelected(event) {
            this._state.ui.filter = event.detail.filter;
            if (this._state.ui.filter == 'SYNCED') {
                await this._fetchSyncedOrders();
            }
        }
        async _onSearch(event) {
            Object.assign(this._state.ui.searchDetails, event.detail);
            if (this._state.ui.filter == 'SYNCED') {
                this._state.syncedOrders.currentPage = 1;
                await this._fetchSyncedOrders();
            }
        }
        _onClickOrder({ detail: clickedOrder }) {
            if (!clickedOrder || clickedOrder.locked) {
                if (this._state.ui.selectedSyncedOrderId == clickedOrder.backendId) {
                    this._state.ui.selectedSyncedOrderId = null;
                } else {
                    this._state.ui.selectedSyncedOrderId = clickedOrder.backendId;
                }
                if (!this.getSelectedOrderlineId()) {
                    // Automatically select the first orderline of the selected order.
                    const firstLine = clickedOrder.get_orderlines()[0];
                    if (firstLine) {
                        this._state.ui.selectedOrderlineIds[clickedOrder.backendId] = firstLine.id;
                    }
                }
                NumberBuffer.reset();
            } else {
                this._setOrder(clickedOrder);
            }
        }
        _onCreateNewOrder() {
            this.env.pos.add_new_order();
            this.showScreen('ProductScreen');
        }
        _selectNextOrder(currentOrder) {
            const currentOrderIndex = this._getOrderList().indexOf(currentOrder);
            const orderList = this._getOrderList();
            this.env.pos.set_order(orderList[currentOrderIndex+1] || orderList[currentOrderIndex-1]);
        }
        async _onDeleteOrder({ detail: order }) {
            const screen = order.get_screen_data();
            if (['ProductScreen', 'PaymentScreen'].includes(screen.name) && order.get_orderlines().length > 0) {
                const { confirmed } = await this.showPopup('ConfirmPopup', {
                    title: this.env._t('Existing orderlines'),
                    body: _.str.sprintf(
                      this.env._t('%s has a total amount of %s, are you sure you want to delete this order ?'),
                      order.name, this.getTotal(order)
                    ),
                });
                if (!confirmed) return;
            }
            if (order && (await this._onBeforeDeleteOrder(order))) {
                if (order === this.env.pos.get_order()) {
                    this._selectNextOrder(order);
                }
                this.env.pos.removeOrder(order);
            }
        }
        async _onNextPage() {
            if (this._state.syncedOrders.currentPage < this._getLastPage()) {
                this._state.syncedOrders.currentPage += 1;
                await this._fetchSyncedOrders();
            }
        }
        async _onPrevPage() {
            if (this._state.syncedOrders.currentPage > 1) {
                this._state.syncedOrders.currentPage -= 1;
                await this._fetchSyncedOrders();
            }
        }
        async _onInvoiceOrder({ detail: orderId }) {
            this.env.pos._invalidateSyncedOrdersCache([orderId]);
            await this._fetchSyncedOrders();
        }
        _onClickOrderline({ detail: orderline }) {
            const order = this.getSelectedSyncedOrder();
            this._state.ui.selectedOrderlineIds[order.backendId] = orderline.id;
            NumberBuffer.reset();
        }
        _onClickRefundOrderUid({ detail: orderUid }) {
            // Open the refund order.
            const refundOrder = this.env.pos.orders.find((order) => order.uid == orderUid);
            if (refundOrder) {
                this._setOrder(refundOrder);
            }
        }
        _onUpdateSelectedOrderline({ detail }) {
            const buffer = detail.buffer;
            const order = this.getSelectedSyncedOrder();
            if (!order) return NumberBuffer.reset();

            const selectedOrderlineId = this.getSelectedOrderlineId();
            const orderline = order.orderlines.find((line) => line.id == selectedOrderlineId);
            if (!orderline) return NumberBuffer.reset();

            const toRefundDetail = this._getToRefundDetail(orderline);
            // When already linked to an order, do not modify the to refund quantity.
            if (toRefundDetail.destinationOrderUid) return NumberBuffer.reset();

            const refundableQty = toRefundDetail.orderline.qty - toRefundDetail.orderline.refundedQty;
            if (refundableQty <= 0) return NumberBuffer.reset();

            if (buffer == null || buffer == '') {
                toRefundDetail.qty = 0;
            } else {
                const quantity = Math.abs(parse.float(buffer));
                if (quantity > refundableQty) {
                    NumberBuffer.reset();
                    this.showPopup('ErrorPopup', {
                        title: this.env._t('Maximum Exceeded'),
                        body: _.str.sprintf(
                            this.env._t(
                                'The requested quantity to be refunded is higher than the ordered quantity. %s is requested while only %s can be refunded.'
                            ),
                            quantity,
                            refundableQty
                        ),
                    });
                } else {
                    toRefundDetail.qty = quantity;
                }
            }
        }
        async _onDoRefund() {
            const order = this.getSelectedSyncedOrder();

            if (!order) {
                this._state.ui.highlightHeaderNote = !this._state.ui.highlightHeaderNote;
                return;
            }
            
            if (this._doesOrderHaveSoleItem(order)) {
                if (!this._prepareAutoRefundOnOrder(order)) {
                    // Don't proceed on refund if preparation returned false.
                    return;
                }
            }

            const partner = order.get_partner();

            const allToRefundDetails = this._getRefundableDetails(partner);
            if (allToRefundDetails.length == 0) {
                this._state.ui.highlightHeaderNote = !this._state.ui.highlightHeaderNote;
                return;
            }

            // The order that will contain the refund orderlines.
            // Use the destinationOrder from props if the order to refund has the same
            // partner as the destinationOrder.
            const destinationOrder =
                this.props.destinationOrder &&
                partner === this.props.destinationOrder.get_partner() &&
                !this.env.pos.doNotAllowRefundAndSales()
                    ? this.props.destinationOrder
                    : this._getEmptyOrder(partner);

            // Add orderline for each toRefundDetail to the destinationOrder.
            for (const refundDetail of allToRefundDetails) {
                const product = this.env.pos.db.get_product_by_id(refundDetail.orderline.productId);
                const options = this._prepareRefundOrderlineOptions(refundDetail);
                await destinationOrder.add_product(product, options);
                refundDetail.destinationOrderUid = destinationOrder.uid;
            }

            // Set the partner to the destinationOrder.
            if (partner && !destinationOrder.get_partner()) {
                destinationOrder.set_partner(partner);
                destinationOrder.updatePricelist(partner);
            }

            if (this.env.pos.get_order().cid !== destinationOrder.cid) {
                this.env.pos.set_order(destinationOrder);
            }

            this._onCloseScreen();
        }
        //#endregion
        //#region PUBLIC METHODS
        close() {
            /**
             * Automatically create new order when there is no currently active order.
             * Important in fiscal modules to keep the sequence of the orders.
             */
            if (this.env.pos.orders.length == 0) {
                this.env.pos.add_new_order();
            }
            super.close();
        }
        getSelectedSyncedOrder() {
            if (this._state.ui.filter == 'SYNCED') {
                return this._state.syncedOrders.cache[this._state.ui.selectedSyncedOrderId];
            } else {
                return null;
            }
        }
        getSelectedOrderlineId() {
            return this._state.ui.selectedOrderlineIds[this._state.ui.selectedSyncedOrderId];
        }
        /**
         * Override to conditionally show the new ticket button.
         */
        shouldShowNewOrderButton() {
            return true;
        }
        getFilteredOrderList() {
            if (this._state.ui.filter == 'SYNCED') return this._state.syncedOrders.toShow;
            const filterCheck = (order) => {
                if (this._state.ui.filter && this._state.ui.filter !== 'ACTIVE_ORDERS') {
                    const screen = order.get_screen_data();
                    return this._state.ui.filter === this._getScreenToStatusMap()[screen.name];
                }
                return true;
            };
            const { fieldName, searchTerm } = this._state.ui.searchDetails;
            const searchField = this._getSearchFields()[fieldName];
            const searchCheck = (order) => {
                if (!searchField) return true;
                const repr = searchField.repr(order);
                if (repr === null) return true;
                if (!searchTerm) return true;
                return repr && repr.toString().toLowerCase().includes(searchTerm.toLowerCase());
            };
            const predicate = (order) => {
                return filterCheck(order) && searchCheck(order);
            };
            return this._getOrderList().filter(predicate);
        }
        getDate(order) {
            return moment(order.validation_date).format('YYYY-MM-DD hh:mm A');
        }
        getTotal(order) {
            return this.env.pos.format_currency(order.get_total_with_tax());
        }
        getPartner(order) {
            return order.get_partner_name();
        }
        getCardholderName(order) {
            return order.get_cardholder_name();
        }
        getCashier(order) {
            return order.cashier ? order.cashier.name : '';
        }
        getStatus(order) {
            if (order.locked) {
                return this.env._t('Paid');
            } else {
                const screen = order.get_screen_data();
                return this._getOrderStates().get(this._getScreenToStatusMap()[screen.name]).text;
            }
        }
        /**
         * If the order is the only order and is empty
         */
        isDefaultOrderEmpty(order) {
            let status = this._getScreenToStatusMap()[order.get_screen_data().name];
            let productScreenStatus = this._getScreenToStatusMap().ProductScreen;
            return order.get_orderlines().length === 0 && this.env.pos.get_order_list().length === 1 &&
                status === productScreenStatus && order.get_paymentlines().length === 0;
        }
        /**
         * Hide the delete button if one of the payments is a 'done' electronic payment.
         */
        shouldHideDeleteButton(order) {
            return (
                this.isDefaultOrderEmpty(order)||
                order.locked ||
                order
                    .get_paymentlines()
                    .some((payment) => payment.is_electronic() && payment.get_payment_status() === 'done')
            );
        }
        isHighlighted(order) {
            if (this._state.ui.filter == 'SYNCED') {
                const selectedOrder = this.getSelectedSyncedOrder();
                return selectedOrder ? order.backendId == selectedOrder.backendId : false;
            } else {
                const activeOrder = this.env.pos.get_order();
                return activeOrder ? activeOrder.uid == order.uid : false;
            }
        }
        showCardholderName() {
            return this.env.pos.payment_methods.some((method) => method.use_payment_terminal);
        }
        getSearchBarConfig() {
            return {
                searchFields: new Map(
                    Object.entries(this._getSearchFields()).map(([key, val]) => [key, val.displayName])
                ),
                filter: { show: true, options: this._getFilterOptions() },
                defaultSearchDetails: this._state.ui.searchDetails,
                defaultFilter: this._state.ui.filter,
            };
        }
        shouldShowPageControls() {
            return this._state.ui.filter == 'SYNCED' && this._getLastPage() > 1;
        }
        getPageNumber() {
            if (!this._state.syncedOrders.totalCount) {
                return `1/1`;
            } else {
                return `${this._state.syncedOrders.currentPage}/${this._getLastPage()}`;
            }
        }
        getSelectedPartner() {
            const order = this.getSelectedSyncedOrder();
            return order ? order.get_partner() : null;
        }
        getHasItemsToRefund() {
            const order = this.getSelectedSyncedOrder();
            if (!order) return false;
            if (this._doesOrderHaveSoleItem(order)) return true;
            const total = Object.values(this.env.pos.toRefundLines)
                .filter(
                    (toRefundDetail) =>
                        toRefundDetail.orderline.orderUid === order.uid && !toRefundDetail.destinationOrderUid
                )
                .map((toRefundDetail) => toRefundDetail.qty)
                .reduce((acc, val) => acc + val, 0);
            return !this.env.pos.isProductQtyZero(total);
        }
        //#endregion
        //#region PRIVATE METHODS
        /**
         * Find the empty order with the following priority:
         * - The empty order with the same parter as the provided.
         * - The first empty order without a partner.
         * - If no empty order, create a new one.
         * @param {Object | null} partner
         * @returns {boolean}
         */
        _getEmptyOrder(partner) {
            let emptyOrderForPartner = null;
            let emptyOrder = null;
            for (const order of this.env.pos.orders) {
                if (order.get_orderlines().length === 0 && order.get_paymentlines().length === 0) {
                    if (order.get_partner() === partner) {
                        emptyOrderForPartner = order;
                        break;
                    } else if (!order.get_partner() && emptyOrder === null) {
                        // If emptyOrderForPartner is not found, we will use the first empty order.
                        emptyOrder = order;
                    }
                }
            }
            return emptyOrderForPartner || emptyOrder || this.env.pos.add_new_order();
        }
        _doesOrderHaveSoleItem(order) {
            const orderlines = order.get_orderlines();
            if (orderlines.length !== 1) return false;
            const theOrderline = orderlines[0];
            const refundableQty = theOrderline.get_quantity() - theOrderline.refunded_qty;
            return this.env.pos.isProductQtyZero(refundableQty - 1);
        }
        _prepareAutoRefundOnOrder(order) {
            const selectedOrderlineId = this.getSelectedOrderlineId();
            const orderline = order.orderlines.find((line) => line.id == selectedOrderlineId);
            if (!orderline) return false;

            const toRefundDetail = this._getToRefundDetail(orderline);
            const refundableQty = orderline.get_quantity() - orderline.refunded_qty;
            if (this.env.pos.isProductQtyZero(refundableQty - 1) && toRefundDetail.qty === 0) {
                toRefundDetail.qty = 1;
            }
            return true;
        }
        /**
         * Returns the corresponding toRefundDetail of the given orderline.
         * SIDE-EFFECT: Automatically creates a toRefundDetail object for
         * the given orderline if it doesn't exist and returns it.
         * @param {models.Orderline} orderline
         * @returns
         */
        _getToRefundDetail(orderline) {
            if (orderline.id in this.env.pos.toRefundLines) {
                return this.env.pos.toRefundLines[orderline.id];
            } else {
                const partner = orderline.order.get_partner();
                const orderPartnerId = partner ? partner.id : false;
                const newToRefundDetail = {
                    qty: 0,
                    orderline: {
                        id: orderline.id,
                        productId: orderline.product.id,
                        price: orderline.price,
                        qty: orderline.quantity,
                        refundedQty: orderline.refunded_qty,
                        orderUid: orderline.order.uid,
                        orderBackendId: orderline.order.backendId,
                        orderPartnerId,
                        tax_ids: orderline.get_taxes().map(tax => tax.id),
                        discount: orderline.discount,
                    },
                    destinationOrderUid: false,
                };
                this.env.pos.toRefundLines[orderline.id] = newToRefundDetail;
                return newToRefundDetail;
            }
        }
        /**
         * Select the lines from toRefundLines, as they can come from different orders.
         * Returns only details that:
         * - The quantity to refund is not zero
         * - Filtered by partner (optional)
         * - It's not yet linked to an active order (no destinationOrderUid)
         *
         * @param {Object} partner (optional)
         * @returns {Array} refundableDetails
         */
        _getRefundableDetails(partner) {
            return Object.values(this.env.pos.toRefundLines).filter(
                ({ qty, orderline, destinationOrderUid }) =>
                    !this.env.pos.isProductQtyZero(qty) &&
                    (partner ? orderline.orderPartnerId == partner.id : true) &&
                    !destinationOrderUid
            );
        }
        /**
         * Prepares the options to add a refund orderline.
         *
         * @param {Object} toRefundDetail
         * @returns {Object}
         */
        _prepareRefundOrderlineOptions(toRefundDetail) {
            const { qty, orderline } = toRefundDetail;
            return {
                quantity: -qty,
                price: orderline.price,
                extras: { price_automatically_set: true },
                merge: false,
                refunded_orderline_id: orderline.id,
                tax_ids: orderline.tax_ids,
                discount: orderline.discount,
            }
        }
        _setOrder(order) {
            this.env.pos.set_order(order);
            this.close();
        }
        _getOrderList() {
            return this.env.pos.get_order_list();
        }
        _getFilterOptions() {
            const orderStates = this._getOrderStates();
            orderStates.set('SYNCED', { text: this.env._t('Paid') });
            return orderStates;
        }
        /**
         * @returns {Record<string, { repr: (order: models.Order) => string, displayName: string, modelField: string }>}
         */
        _getSearchFields() {
            const fields = {
                RECEIPT_NUMBER: {
                    repr: (order) => order.name,
                    displayName: this.env._t('Receipt Number'),
                    modelField: 'pos_reference',
                },
                DATE: {
                    repr: (order) => moment(order.creation_date).format('YYYY-MM-DD hh:mm A'),
                    displayName: this.env._t('Date'),
                    modelField: 'date_order',
                },
                PARTNER: {
                    repr: (order) => order.get_partner_name(),
                    displayName: this.env._t('Customer'),
                    modelField: 'partner_id.display_name',
                },
            };

            if (this.showCardholderName()) {
                fields.CARDHOLDER_NAME = {
                    repr: (order) => order.get_cardholder_name(),
                    displayName: this.env._t('Cardholder Name'),
                    modelField: 'payment_ids.cardholder_name',
                };
            }

            return fields;
        }
        /**
         * Maps the order screen params to order status.
         */
        _getScreenToStatusMap() {
            return {
                ProductScreen: 'ONGOING',
                PaymentScreen: 'PAYMENT',
                ReceiptScreen: 'RECEIPT',
            };
        }
        /**
         * Override to do something before deleting the order.
         * Make sure to return true to proceed on deleting the order.
         * @param {*} order
         * @returns {boolean}
         */
        async _onBeforeDeleteOrder(order) {
            return true;
        }
        _getOrderStates() {
            // We need the items to be ordered, therefore, Map is used instead of normal object.
            const states = new Map();
            states.set('ACTIVE_ORDERS', {
                text: this.env._t('All active orders'),
            });
            // The spaces are important to make sure the following states
            // are under the category of `All active orders`.
            states.set('ONGOING', {
                text: this.env._t('Ongoing'),
                indented: true,
            });
            states.set('PAYMENT', {
                text: this.env._t('Payment'),
                indented: true,
            });
            states.set('RECEIPT', {
                text: this.env._t('Receipt'),
                indented: true,
            });
            return states;
        }
        //#region SEARCH SYNCED ORDERS
        _computeSyncedOrdersDomain() {
            const { fieldName, searchTerm } = this._state.ui.searchDetails;
            if (!searchTerm) return [];
            const modelField = this._getSearchFields()[fieldName].modelField;
            if (modelField) {
                return [[modelField, 'ilike', `%${searchTerm}%`]];
            } else {
                return [];
            }
        }
        /**
         * Fetches the done orders from the backend that needs to be shown.
         * If the order is already in cache, the full information about that
         * order is not fetched anymore, instead, we use info from cache.
         */
        async _fetchSyncedOrders() {
            const domain = this._computeSyncedOrdersDomain();
            const limit = this._state.syncedOrders.nPerPage;
            const offset = (this._state.syncedOrders.currentPage - 1) * this._state.syncedOrders.nPerPage;
            const { ids, totalCount } = await this.rpc({
                model: 'pos.order',
                method: 'search_paid_order_ids',
                kwargs: { config_id: this.env.pos.config.id, domain, limit, offset },
                context: this.env.session.user_context,
            });
            const idsNotInCache = ids.filter((id) => !(id in this._state.syncedOrders.cache));
            if (idsNotInCache.length > 0) {
                const fetchedOrders = await this.rpc({
                    model: 'pos.order',
                    method: 'export_for_ui',
                    args: [idsNotInCache],
                    context: this.env.session.user_context,
                });
                // Check for missing products and partners and load them in the PoS
                await this.env.pos._loadMissingProducts(fetchedOrders);
                await this.env.pos._loadMissingPartners(fetchedOrders);
                // Cache these fetched orders so that next time, no need to fetch
                // them again, unless invalidated. See `_onInvoiceOrder`.
                fetchedOrders.forEach((order) => {
                    this._state.syncedOrders.cache[order.id] = Order.create({}, { pos: this.env.pos, json: order });
                });
            }
            this._state.syncedOrders.totalCount = totalCount;
            this._state.syncedOrders.toShow = ids.map((id) => this._state.syncedOrders.cache[id]);
        }
        _getLastPage() {
            const totalCount = this._state.syncedOrders.totalCount;
            const nPerPage = this._state.syncedOrders.nPerPage;
            const remainder = totalCount % nPerPage;
            if (remainder == 0) {
                return totalCount / nPerPage;
            } else {
                return Math.ceil(totalCount / nPerPage);
            }
        }
        //#endregion
        //#endregion
    }
    TicketScreen.template = 'TicketScreen';
    TicketScreen.defaultProps = {
        destinationOrder: null,
        // When passed as true, it will use the saved _state.ui as default
        // value when this component is reinstantiated.
        // After setting the default value, the _state.ui will be overridden
        // by the passed props.ui if there is any.
        reuseSavedUIState: false,
        ui: {},
    };

    Registries.Component.add(TicketScreen);
    TicketScreen.numpadActionName = _lt('Refund');
    TicketScreen.searchPlaceholder = _lt('Search Orders...');

    return TicketScreen;
});
;

/*************************************************************
*  Filepath: /point_of_sale/static/src/js/barcode_reader.js  *
*  Lines: 181                                                *
*************************************************************/
odoo.define('point_of_sale.BarcodeReader', function (require) {
"use strict";

var concurrency = require('web.concurrency');
var core = require('web.core');
var Mutex = concurrency.Mutex;
const { GS1BarcodeError } = require('barcodes_gs1_nomenclature/static/src/js/barcode_parser.js');

// this module interfaces with the barcode reader. It assumes the barcode reader
// is set-up to act like  a keyboard. Use connect() and disconnect() to activate
// and deactivate the barcode reader. Use set_action_callbacks to tell it
// what to do when it reads a barcode.
var BarcodeReader = core.Class.extend({
    actions:[
        'product',
        'cashier',
        'client',
    ],

    init: function (attributes) {
        this.mutex = new Mutex();
        this.action_callbacks = {};
        this.exclusive_callbacks = {};
        this.proxy = attributes.proxy;
        this.env = attributes.env;
        this.remote_scanning = false;
        this.remote_active = 0;

        this.barcode_parser = attributes.barcode_parser;

        this.action_callback_stack = [];

        core.bus.on('barcode_scanned', this, function (barcode) {
            // use mutex to make sure scans are done one after the other
            this.mutex.exec(async () => {
                await this.scan(barcode);
            });
        });
    },

    set_barcode_parser: function (barcode_parser) {
        this.barcode_parser = barcode_parser;
    },
    setFallbackBarcodeParser: function (fallbackBarcodeParser) {
        this.fallbackBarcodeParser = fallbackBarcodeParser;
    },

    // when a barcode is scanned and parsed, the callback corresponding
    // to its type is called with the parsed_barcode as a parameter.
    // (parsed_barcode is the result of parse_barcode(barcode))
    //
    // callbacks is a Map of 'actions' : callback(parsed_barcode)
    // that sets the callback for each action. if a callback for the
    // specified action already exists, it is replaced.
    //
    // possible actions include :
    // 'product' | 'cashier' | 'client' | 'discount'
    set_action_callback: function (name, callback) {
        if (this.action_callbacks[name]) {
            this.action_callbacks[name].add(callback);
        } else {
            this.action_callbacks[name] = new Set([callback]);
        }
    },

    remove_action_callback: function(name, callback) {
        if (!callback) {
            delete this.action_callbacks[name];
            return;
        }
        const callbacks = this.action_callbacks[name];
        if (callbacks) {
            callbacks.delete(callback);
            if (callbacks.size === 0) {
                delete this.action_callbacks[name];
            }
        }
    },

    /**
     * Allow setting of exclusive callbacks. If there are exclusive callbacks,
     * these callbacks are called neglecting the regular callbacks. This is
     * useful for rendered Components that wants to take exclusive access
     * to the barcode reader.
     *
     * @param {String} name
     * @param {Function} callback function that takes parsed barcode
     */
    set_exclusive_callback: function (name, callback) {
        if (this.exclusive_callbacks[name]) {
            this.exclusive_callbacks[name].add(callback);
        } else {
            this.exclusive_callbacks[name] = new Set([callback]);
        }
    },

    remove_exclusive_callback: function (name, callback) {
        if (!callback) {
            delete this.exclusive_callbacks[name];
            return;
        }
        const callbacks = this.exclusive_callbacks[name];
        if (callbacks) {
            callbacks.delete(callback);
            if (callbacks.size === 0) {
                delete this.exclusive_callbacks[name];
            }
        }
    },

    scan: async function (code) {
        if (!code) return;

        const callbacks = Object.keys(this.exclusive_callbacks).length
            ? this.exclusive_callbacks
            : this.action_callbacks;
        let parsed_result;
        try {
            parsed_result = this.barcode_parser.parse_barcode(code);
        } catch (error) {
            if (this.fallbackBarcodeParser && error instanceof GS1BarcodeError) {
                parsed_result = this.fallbackBarcodeParser.parse_barcode(code);
            } else {
                throw error;
            }
        }
        if (Array.isArray(parsed_result)) {
            [...callbacks.gs1].map(cb => cb(parsed_result));
        } else {
            if (callbacks[parsed_result.type]) {
                for (const cb of callbacks[parsed_result.type]) {
                    await cb(parsed_result);
                }
            } else if (callbacks.error) {
                [...callbacks.error].map(cb => cb(parsed_result));
            } else {
                console.warn('Ignored Barcode Scan:', parsed_result);
            }
        }
    },

    // the barcode scanner will listen on the hw_proxy/scanner interface for
    // scan events until disconnect_from_proxy is called
    connect_to_proxy: function () {
        var self = this;
        this.remote_scanning = true;
        if (this.remote_active >= 1) {
            return;
        }
        this.remote_active = 1;

        function waitforbarcode(){
            return self.proxy.connection.rpc('/hw_proxy/scanner',{},{shadow: true, timeout:7500})
                .then(function (barcode) {
                    if (!self.remote_scanning) {
                        self.remote_active = 0;
                        return;
                    }
                    self.scan(barcode);
                    waitforbarcode();
                },
                function () {
                    if (!self.remote_scanning) {
                        self.remote_active = 0;
                        return;
                    }
                    waitforbarcode();
                });
        }
        waitforbarcode();
    },

    // the barcode scanner will stop listening on the hw_proxy/scanner remote interface
    disconnect_from_proxy: function () {
        this.remote_scanning = false;
    },
});

return BarcodeReader;

});
;

/***********************************************************
*  Filepath: /point_of_sale/static/src/js/custom_hooks.js  *
*  Lines: 162                                              *
***********************************************************/
odoo.define('point_of_sale.custom_hooks', function (require) {
    'use strict';

    const { onMounted, onPatched, onWillUnmount, useComponent, useRef } = owl;
    const { escapeRegExp } = require('@web/core/utils/strings');

    /**
     * Introduce error handlers in the component.
     *
     * IMPROVEMENT: This is a terrible hook. There could be a better way to handle
     * the error when the order failed to sync.
     */
    function useErrorHandlers() {
        const component = useComponent();

        component._handlePushOrderError = async function (error) {
            // This error handler receives `error` equivalent to `error.message` of the rpc error.
            if (error.message === 'Backend Invoice') {
                await this.showPopup('ConfirmPopup', {
                    title: this.env._t('Please print the invoice from the backend'),
                    body:
                        this.env._t(
                            'The order has been synchronized earlier. Please make the invoice from the backend for the order: '
                        ) + error.data.order.name,
                });
            } else if (error.code < 0) {
                // XmlHttpRequest Errors
                const title = this.env._t('Unable to sync order');
                const body = this.env._t(
                    'Check the internet connection then try to sync again by clicking on the red wifi button (upper right of the screen).'
                );
                await this.showPopup('OfflineErrorPopup', { title, body });
            } else if (error.code === 200) {
                // OpenERP Server Errors
                await this.showPopup('ErrorTracebackPopup', {
                    title: error.data.message || this.env._t('Server Error'),
                    body:
                        error.data.debug ||
                        this.env._t('The server encountered an error while receiving your order.'),
                });
            } else if (error.code === 700) {
                // Sweden Fiscal module errors
                await this.showPopup('ErrorPopup', {
                    title: this.env._t('Fiscal data module error'),
                    body:
                        error.data.error.status ||
                        this.env._t('The fiscal data module encountered an error while receiving your order.'),
                });
            } else if (error.code === 701) {
                // Belgian Fiscal module errors
                let bodyMessage = "";
                if(error.error.errorCode)
                    bodyMessage = "'" + error.error.errorCode + "': " + error.error.errorMessage;
                else
                    bodyMessage = "Fiscal data module is not on.";
                await this.showPopup('ErrorPopup', {
                    title: this.env._t('Fiscal data module error'),
                    body: bodyMessage
                });
            } else {
                // ???
                await this.showPopup('ErrorPopup', {
                    title: this.env._t('Unknown Error'),
                    body: this.env._t(
                        'The order could not be sent to the server due to an unknown error'
                    ),
                });
            }
        };
    }

    function useAutoFocusToLast() {
        const current = useComponent();
        let target = null;
        function autofocus() {
            const prevTarget = target;
            const allInputs = current.el.querySelectorAll('input');
            target = allInputs[allInputs.length - 1];
            if (target && target !== prevTarget) {
                target.focus();
                target.selectionStart = target.selectionEnd = target.value.length;
            }
        }
        onMounted(autofocus);
        onPatched(autofocus);
    }

    function useBarcodeReader(callbackMap, exclusive = false) {
        const current = useComponent();
        const barcodeReader = current.env.barcode_reader;
        for (let [key, callback] of Object.entries(callbackMap)) {
            callbackMap[key] = callback.bind(current);
        }
        onMounted(() => {
            if (barcodeReader) {
                for (let key in callbackMap) {
                    if (exclusive) {
                        barcodeReader.set_exclusive_callback(key, callbackMap[key]);
                    } else {
                        barcodeReader.set_action_callback(key, callbackMap[key]);
                    }
                }
            }
        });
        onWillUnmount(() => {
            if (barcodeReader) {
                for (let key in callbackMap) {
                    if (exclusive) {
                        barcodeReader.remove_exclusive_callback(key, callbackMap[key]);
                    } else {
                        barcodeReader.remove_action_callback(key, callbackMap[key]);
                    }
                }
            }
        });
    }

    function useValidateCashInput(inputRef, startingValue) {
        const cashInput = useRef(inputRef);
        const current = useComponent();
        const decimalPoint = current.env._t.database.parameters.decimal_point;
        const thousandsSep = current.env._t.database.parameters.thousands_sep;
        // Replace the thousands separator and decimal point with regex-escaped versions
        const escapedDecimalPoint = escapeRegExp(decimalPoint);
        let floatRegex;
        if (thousandsSep) {
            const escapedThousandsSep = escapeRegExp(thousandsSep);
            floatRegex = new RegExp(`^-?(?:\\d+(${escapedThousandsSep}\\d+)*)?(?:${escapedDecimalPoint}\\d*)?$`);
        } else {
            floatRegex = new RegExp(`^-?(?:\\d+)?(?:${escapedDecimalPoint}\\d*)?$`);
        }
        function isValidFloat(inputValue) {
            return ![decimalPoint, '-'].includes(inputValue) && floatRegex.test(inputValue);
        }
        function handleCashInputChange(event) {
            let inputValue = (event.target.value || "").trim();

            // Check if the current input value is a valid float
            if (!isValidFloat(inputValue)) {
                event.target.classList.add('invalid-cash-input');
            } else {
                event.target.classList.remove('invalid-cash-input');
            }
        }
        

        onMounted(() => {
            if (cashInput.el) {
                cashInput.el.value = (startingValue || 0).toString().replace('.', decimalPoint);
                cashInput.el.addEventListener("input", handleCashInputChange);
            }
        });

        onWillUnmount(() => {
            if (cashInput.el) {
                cashInput.el.removeEventListener("input", handleCashInputChange);
            }
        })
    }

    return { useErrorHandlers, useAutoFocusToLast, useBarcodeReader, useValidateCashInput };
});
;

/*************************************************
*  Filepath: /point_of_sale/static/src/js/db.js  *
*  Lines: 582                                    *
*************************************************/
odoo.define('point_of_sale.DB', function (require) {
"use strict";

var core = require('web.core');
var utils = require('web.utils');
/* The PosDB holds reference to data that is either
 * - static: does not change between pos reloads
 * - persistent : must stay between reloads ( orders )
 */


/**
 * cache the data in memory to avoid roundtrips to the localstorage
 *
 * NOTE/TODO: Originally, this is a prop of PosDB. However, if we keep it that way,
 * caching will result to infinite loop to calling the reactive callbacks.
 * Another way to solve the infinite loop is to move the instance of PosDB to env.
 * But I'm not sure if there is anything inside the object that needs to be observed,
 * so I guess this strategy is good enough for the moment.
 */
const CACHE = {};

var PosDB = core.Class.extend({
    name: 'openerp_pos_db', //the prefix of the localstorage data
    limit: 100,  // the maximum number of results returned by a search
    init: function(options){
        options = options || {};
        this.name = options.name || this.name;
        this.limit = options.limit || this.limit;

        if (options.uuid) {
            this.name = this.name + '_' + options.uuid;
        }

        this.product_by_id = {};
        this.product_by_barcode = {};
        this.product_by_category_id = {};
        this.product_packaging_by_barcode = {};

        this.partner_sorted = [];
        this.partner_by_id = {};
        this.partner_by_barcode = {};
        // FIXME before master: partner_search_string is no longer used but is kept for partial
        // compatibility with customizations. The string is no longer useful but we don't want
        // a custo to crash when calling a method (eg .split()) on it.
        this.partner_search_string = "";
        this.partner_search_strings = {};
        this.partner_write_date = null;

        this.category_by_id = {};
        this.root_category_id  = 0;
        this.category_products = {};
        this.category_ancestors = {};
        this.category_childs = {};
        this.category_parent    = {};
        this.category_search_string = {};
    },

    /**
     * sets an uuid to prevent conflict in locally stored data between multiple PoS Configs. By
     * using the uuid of the config the local storage from other configs will not get effected nor
     * loaded in sessions that don't belong to them.
     *
     * @param {string} uuid Unique identifier of the PoS Config linked to the current session.
     */
    set_uuid: function(uuid){
        this.name = this.name + '_' + uuid;
    },

    /* returns the category object from its id. If you pass a list of id as parameters, you get
     * a list of category objects.
     */
    get_category_by_id: function(categ_id){
        if(categ_id instanceof Array){
            var list = [];
            for(var i = 0, len = categ_id.length; i < len; i++){
                var cat = this.category_by_id[categ_id[i]];
                if(cat){
                    list.push(cat);
                }else{
                    console.error("get_category_by_id: no category has id:",categ_id[i]);
                }
            }
            return list;
        }else{
            return this.category_by_id[categ_id];
        }
    },
    /* returns a list of the category's child categories ids, or an empty list
     * if a category has no childs */
    get_category_childs_ids: function(categ_id){
        return this.category_childs[categ_id] || [];
    },
    /* returns a list of all ancestors (parent, grand-parent, etc) categories ids
     * starting from the root category to the direct parent */
    get_category_ancestors_ids: function(categ_id){
        return this.category_ancestors[categ_id] || [];
    },
    /* returns the parent category's id of a category, or the root_category_id if no parent.
     * the root category is parent of itself. */
    get_category_parent_id: function(categ_id){
        return this.category_parent[categ_id] || this.root_category_id;
    },
    /* adds categories definitions to the database. categories is a list of categories objects as
     * returned by the openerp server. Categories must be inserted before the products or the
     * product/ categories association may (will) not work properly */
    add_categories: function(categories){
        var self = this;
        if(!this.category_by_id[this.root_category_id]){
            this.category_by_id[this.root_category_id] = {
                id : this.root_category_id,
                name : 'Root',
            };
        }
        categories.forEach(function(cat){
            self.category_by_id[cat.id] = cat;
        });
        categories.forEach(function(cat){
            var parent_id = cat.parent_id[0];
            if(!(parent_id && self.category_by_id[parent_id])){
                parent_id = self.root_category_id;
            }
            self.category_parent[cat.id] = parent_id;
            if(!self.category_childs[parent_id]){
                self.category_childs[parent_id] = [];
            }
            self.category_childs[parent_id].push(cat.id);
        });
        function make_ancestors(cat_id, ancestors){
            self.category_ancestors[cat_id] = ancestors;

            ancestors = ancestors.slice(0);
            ancestors.push(cat_id);

            var childs = self.category_childs[cat_id] || [];
            for(var i=0, len = childs.length; i < len; i++){
                make_ancestors(childs[i], ancestors);
            }
        }
        make_ancestors(this.root_category_id, []);
    },
    category_contains: function(categ_id, product_id) {
        var product = this.product_by_id[product_id];
        if (product) {
            var cid = product.pos_categ_id[0];
            while (cid && cid !== categ_id){
                cid = this.category_parent[cid];
            }
            return !!cid;
        }
        return false;
    },
    /* loads a record store from the database. returns default if nothing is found */
    load: function(store,deft){
        if(CACHE[store] !== undefined){
            return CACHE[store];
        }
        var data = localStorage[this.name + '_' + store];
        if(data !== undefined && data !== ""){
            data = JSON.parse(data);
            CACHE[store] = data;
            return data;
        }else{
            return deft;
        }
    },
    /* saves a record store to the database */
    save: function(store,data){
        localStorage[this.name + '_' + store] = JSON.stringify(data);
        CACHE[store] = data;
    },
    _product_search_string: function(product){
        var str = product.display_name;
        if (product.barcode) {
            str += '|' + product.barcode;
        }
        if (product.default_code) {
            str += '|' + product.default_code;
        }
        if (product.description) {
            str += '|' + product.description;
        }
        if (product.description_sale) {
            str += '|' + product.description_sale;
        }
        str  = product.id + ':' + str.replace(/[\n:]/g,'') + '\n';
        return str;
    },
    add_products: function(products){
        var stored_categories = this.product_by_category_id;

        if(!(products instanceof Array)){
            products = [products];
        }
        for(var i = 0, len = products.length; i < len; i++){
            var product = products[i];
            if (product.id in this.product_by_id) continue;
            if (product.available_in_pos){
                var search_string = utils.unaccent(this._product_search_string(product));
                var categ_id = product.pos_categ_id ? product.pos_categ_id[0] : this.root_category_id;
                product.product_tmpl_id = product.product_tmpl_id[0];
                if(!stored_categories[categ_id]){
                    stored_categories[categ_id] = [];
                }
                stored_categories[categ_id].push(product.id);

                if(this.category_search_string[categ_id] === undefined){
                    this.category_search_string[categ_id] = '';
                }
                this.category_search_string[categ_id] += search_string;

                var ancestors = this.get_category_ancestors_ids(categ_id) || [];

                for(var j = 0, jlen = ancestors.length; j < jlen; j++){
                    var ancestor = ancestors[j];
                    if(! stored_categories[ancestor]){
                        stored_categories[ancestor] = [];
                    }
                    stored_categories[ancestor].push(product.id);

                    if( this.category_search_string[ancestor] === undefined){
                        this.category_search_string[ancestor] = '';
                    }
                    this.category_search_string[ancestor] += search_string;
                }
            }
            this.product_by_id[product.id] = product;
            if(product.barcode){
                this.product_by_barcode[product.barcode] = product;
            }
        }
    },
    add_packagings: function(product_packagings){
        var self = this;
        _.map(product_packagings, function (product_packaging) {
            if (_.find(self.product_by_id, {'id': product_packaging.product_id[0]})) {
                self.product_packaging_by_barcode[product_packaging.barcode] = product_packaging;
            }
        });
    },
    _partner_search_string: function(partner){
        var str =  partner.name || '';
        if(partner.barcode){
            str += '|' + partner.barcode;
        }
        if(partner.address){
            str += '|' + partner.address;
        }
        if(partner.phone){
            str += '|' + partner.phone.split(' ').join('');
        }
        if(partner.mobile){
            str += '|' + partner.mobile.split(' ').join('');
        }
        if(partner.email){
            str += '|' + partner.email;
        }
        if(partner.vat){
            str += '|' + partner.vat;
        }
        if(partner.parent_name){
            str += '|' + partner.parent_name;
        }
        str = '' + partner.id + ':' + str.replace(':', '').replace(/\n/g, ' ') + '\n';
        return str;
    },
    add_partners: function(partners){
        var updated = {};
        var new_write_date = '';
        var partner;
        for(var i = 0, len = partners.length; i < len; i++){
            partner = partners[i];

            var local_partner_date = (this.partner_write_date || '').replace(/^(\d{4}-\d{2}-\d{2}) ((\d{2}:?){3})$/, '$1T$2Z');
            var dist_partner_date = (partner.write_date || '').replace(/^(\d{4}-\d{2}-\d{2}) ((\d{2}:?){3})$/, '$1T$2Z');
            if (    this.partner_write_date &&
                    this.partner_by_id[partner.id] &&
                    new Date(local_partner_date).getTime() + 1000 >=
                    new Date(dist_partner_date).getTime() ) {
                // FIXME: The write_date is stored with milisec precision in the database
                // but the dates we get back are only precise to the second. This means when
                // you read partners modified strictly after time X, you get back partners that were
                // modified X - 1 sec ago.
                continue;
            } else if ( new_write_date < partner.write_date ) {
                new_write_date  = partner.write_date;
            }
            if (!this.partner_by_id[partner.id]) {
                this.partner_sorted.push(partner.id);
            } else {
                const oldPartner = this.partner_by_id[partner.id];
                if (oldPartner.barcode) {
                    delete this.partner_by_barcode[oldPartner.barcode];
                }
            }
            if (partner.barcode) {
                this.partner_by_barcode[partner.barcode] = partner;
            }
            updated[partner.id] = partner;
            this.partner_by_id[partner.id] = partner;
        }

        this.partner_write_date = new_write_date || this.partner_write_date;

        const updatedChunks = new Set();
        const CHUNK_SIZE = 100;
        for (const id in updated) {
            const chunkId = Math.floor(id / CHUNK_SIZE);
            if (updatedChunks.has(chunkId)) {
                // another partner in this chunk was updated and we already rebuild the chunk
                continue;
            }
            updatedChunks.add(chunkId);
            // If there were updates, we need to rebuild the search string for this chunk
            let searchString = "";

            for (let id = chunkId * CHUNK_SIZE; id < (chunkId + 1) * CHUNK_SIZE; id++) {
                if (!(id in this.partner_by_id)) {
                    continue;
                }
                const partner = this.partner_by_id[id];
                partner.address = (partner.street ? partner.street + ', ': '') +
                                  (partner.zip ? partner.zip + ', ': '') +
                                  (partner.city ? partner.city + ', ': '') +
                                  (partner.state_id ? partner.state_id[1] + ', ': '') +
                                  (partner.country_id ? partner.country_id[1]: '');
                searchString += this._partner_search_string(partner);
            }

            this.partner_search_strings[chunkId] = utils.unaccent(searchString);
        }
        return Object.keys(updated).length;
    },
    get_partner_write_date: function(){
        return this.partner_write_date || "1970-01-01 00:00:00";
    },
    get_partner_by_id: function(id){
        return this.partner_by_id[id];
    },
    get_partner_by_barcode: function(barcode){
        return this.partner_by_barcode[barcode];
    },
    get_partners_sorted: function(max_count){
        max_count = max_count ? Math.min(this.partner_sorted.length, max_count) : this.partner_sorted.length;
        var partners = [];
        for (var i = 0; i < max_count; i++) {
            partners.push(this.partner_by_id[this.partner_sorted[i]]);
        }
        return partners;
    },
    search_partner: function(query){
        try {
            query = query.replace(/[\[\]\(\)\+\*\?\.\-\!\&\^\$\|\~\_\{\}\:\,\\\/]/g,'.');
            query = query.replace(/ /g,'.+');
            var re = RegExp("([0-9]+):.*?"+utils.unaccent(query),"gi");
        }catch(_e){
            return [];
        }
        var results = [];
        const searchStrings = Object.values(this.partner_search_strings).reverse();
        let searchString = searchStrings.pop();
        while (searchString && results.length < this.limit) {
            var r = re.exec(searchString);
            if(r){
                var id = Number(r[1]);
                results.push(this.get_partner_by_id(id));
            } else {
                searchString = searchStrings.pop();
            }
        }
        return results;
    },
    /* removes all the data from the database. TODO : being able to selectively remove data */
    clear: function(){
        for(var i = 0, len = arguments.length; i < len; i++){
            localStorage.removeItem(this.name + '_' + arguments[i]);
        }
    },
    /* this internal methods returns the count of properties in an object. */
    _count_props : function(obj){
        var count = 0;
        for(var prop in obj){
            if(obj.hasOwnProperty(prop)){
                count++;
            }
        }
        return count;
    },
    get_product_by_id: function(id){
        return this.product_by_id[id];
    },
    get_product_by_barcode: function(barcode){
        if(this.product_by_barcode[barcode]){
            return this.product_by_barcode[barcode];
        } else if (this.product_packaging_by_barcode[barcode]) {
            return this.product_by_id[this.product_packaging_by_barcode[barcode].product_id[0]];
        }
        return undefined;
    },
    get_product_by_category: function(category_id){
        var product_ids  = this.product_by_category_id[category_id];
        var list = [];
        if (product_ids) {
            for (var i = 0, len = Math.min(product_ids.length, this.limit); i < len; i++) {
                const product = this.product_by_id[product_ids[i]];
                if (!(product.active && product.available_in_pos)) continue;
                list.push(product);
            }
        }
        return list;
    },
    /* returns a list of products with :
     * - a category that is or is a child of category_id,
     * - a name, package or barcode containing the query (case insensitive)
     */
    search_product_in_category: function(category_id, query){
        try {
            query = query.replace(/[\[\]\(\)\+\*\?\.\-\!\&\^\$\|\~\_\{\}\:\,\\\/]/g,'.');
            query = query.replace(/ /g,'.+');
            var re = RegExp("([0-9]+):.*?"+utils.unaccent(query),"gi");
        }catch(_e){
            return [];
        }
        var results = [];
        for(var i = 0; i < this.limit; i++){
            var r = re.exec(this.category_search_string[category_id]);
            if(r){
                var id = Number(r[1]);
                const product = this.get_product_by_id(id);
                if (!(product.active && product.available_in_pos)) continue;
                results.push(product);
            }else{
                break;
            }
        }
        return results;
    },
    /* from a product id, and a list of category ids, returns
     * true if the product belongs to one of the provided category
     * or one of its child categories.
     */
    is_product_in_category: function(category_ids, product_id) {
        let cat = this.get_product_by_id(product_id).pos_categ_id[0];
        while (cat) {
            for (let cat_id of category_ids) {
                if (cat == cat_id) {   // The == is important, ids may be strings
                    return true;
                }
            }
            cat = this.get_category_parent_id(cat);
        }
        return false;
    },

    /* paid orders */
    add_order: function(order){
        var order_id = order.uid;
        var orders  = this.load('orders',[]);

        // if the order was already stored, we overwrite its data
        for(var i = 0, len = orders.length; i < len; i++){
            if(orders[i].id === order_id){
                orders[i].data = order;
                this.save('orders',orders);
                return order_id;
            }
        }

        // Only necessary when we store a new, validated order. Orders
        // that where already stored should already have been removed.
        this.remove_unpaid_order(order);

        orders.push({id: order_id, data: order});
        this.save('orders',orders);
        return order_id;
    },
    remove_order: function(order_id){
        var orders = this.load('orders',[]);
        orders = _.filter(orders, function(order){
            return order.id !== order_id;
        });
        this.save('orders',orders);
    },
    remove_all_orders: function(){
        this.save('orders',[]);
    },
    get_orders: function(){
        return this.load('orders',[]);
    },
    get_order: function(order_id){
        var orders = this.get_orders();
        for(var i = 0, len = orders.length; i < len; i++){
            if(orders[i].id === order_id){
                return orders[i];
            }
        }
        return undefined;
    },

    /* working orders */
    save_unpaid_order: function(order){
        var order_id = order.uid;
        var orders = this.load('unpaid_orders',[]);
        var serialized = order.export_as_JSON();

        for (var i = 0; i < orders.length; i++) {
            if (orders[i].id === order_id){
                orders[i].data = serialized;
                this.save('unpaid_orders',orders);
                return order_id;
            }
        }

        orders.push({id: order_id, data: serialized});
        this.save('unpaid_orders',orders);
        return order_id;
    },
    remove_unpaid_order: function(order){
        var orders = this.load('unpaid_orders',[]);
        orders = _.filter(orders, function(o){
            return o.id !== order.uid;
        });
        this.save('unpaid_orders',orders);
    },
    remove_all_unpaid_orders: function(){
        this.save('unpaid_orders',[]);
    },
    get_unpaid_orders: function(){
        var saved = this.load('unpaid_orders',[]);
        var orders = [];
        for (var i = 0; i < saved.length; i++) {
            orders.push(saved[i].data);
        }
        return orders;
    },
    /**
     * Return the orders with requested ids if they are unpaid.
     * @param {array<number>} ids order_ids.
     * @return {array<object>} list of orders.
     */
    get_unpaid_orders_to_sync: function(ids){
        const savedOrders = this.load('unpaid_orders',[]);
        return savedOrders.filter(order => ids.includes(order.id) && (order.data.server_id || order.data.lines.length || order.data.statement_ids.length));
    },
    /**
     * Add a given order to the orders to be removed from the server.
     *
     * If an order is removed from a table it also has to be removed from the server to prevent it from reapearing
     * after syncing. This function will add the server_id of the order to a list of orders still to be removed.
     * @param {object} order object.
     */
    set_order_to_remove_from_server: function(order){
        if (order.server_id !== undefined) {
            var to_remove = this.load('unpaid_orders_to_remove',[]);
            to_remove.push(order.server_id);
            this.save('unpaid_orders_to_remove', to_remove);
        }
    },
    /**
     * Get a list of server_ids of orders to be removed.
     * @return {array<number>} list of server_ids.
     */
    get_ids_to_remove_from_server: function(){
        return this.load('unpaid_orders_to_remove',[]);
    },
    /**
     * Remove server_ids from the list of orders to be removed.
     * @param {array<number>} ids
     */
    set_ids_removed_from_server: function(ids){
        var to_remove = this.load('unpaid_orders_to_remove',[]);

        to_remove = _.filter(to_remove, function(id){
            return !ids.includes(id);
        });
        this.save('unpaid_orders_to_remove', to_remove);
    },
});

return PosDB;

});
;

/******************************************************
*  Filepath: /point_of_sale/static/src/js/devices.js  *
*  Lines: 487                                         *
******************************************************/
odoo.define('point_of_sale.devices', function (require) {
"use strict";

var core = require('web.core');
var mixins = require('web.mixins');
var Session = require('web.Session');
var Printer = require('point_of_sale.Printer').Printer;

// the JobQueue schedules a sequence of 'jobs'. each job is
// a function returning a promise. The queue waits for each job to finish
// before launching the next. Each job can also be scheduled with a delay.
// the  is used to prevent parallel requests to the proxy.

var JobQueue = function(){
    var queue = [];
    var running = false;
    var scheduled_end_time = 0;
    var end_of_queue = Promise.resolve();
    var stoprepeat = false;

    var run = function () {
        var runNextJob = function () {
            if (queue.length === 0) {
                running = false;
                scheduled_end_time = 0;
                return Promise.resolve();
            }
            running = true;
            var job = queue[0];
            if (!job.opts.repeat || stoprepeat) {
                queue.shift();
                stoprepeat = false;
            }

            // the time scheduled for this job
            scheduled_end_time = (new Date()).getTime() + (job.opts.duration || 0);

            // we run the job and put in prom when it finishes
            var prom = job.fun() || Promise.resolve();

            var always = function () {
                // we run the next job after the scheduled_end_time, even if it finishes before
                return new Promise(function (resolve, reject) {
                    setTimeout(
                        resolve,
                        Math.max(0, scheduled_end_time - (new Date()).getTime())
                    );
                });
            };
            // we don't care if a job fails ...
            return prom.then(always, always).then(runNextJob);
        };

        if (!running) {
            end_of_queue = runNextJob();
        }
    };

    /**
     * Adds a job to the schedule.
     *
     * @param {function} fun must return a promise
     * @param {object} [opts]
     * @param {number} [opts.duration] the job is guaranteed to finish no quicker than this (milisec)
     * @param {boolean} [opts.repeat] if true, the job will be endlessly repeated
     * @param {boolean} [opts.important] if true, the scheduled job cannot be canceled by a queue.clear()
     */
    this.schedule  = function (fun, opts) {
        queue.push({fun:fun, opts:opts || {}});
        if(!running){
            run();
        }
    };

    // remove all jobs from the schedule (except the ones marked as important)
    this.clear = function(){
        queue = _.filter(queue,function(job){return job.opts.important === true;});
    };

    // end the repetition of the current job
    this.stoprepeat = function(){
        stoprepeat = true;
    };

    /**
     * Returns a promise that resolves when all scheduled jobs have been run.
     * (jobs added after the call to this method are considered as well)
     *
     * @returns {Promise}
     */
    this.finished = function () {
        return end_of_queue;
    };

};


// this object interfaces with the local proxy to communicate to the various hardware devices
// connected to the Point of Sale. As the communication only goes from the POS to the proxy,
// methods are used both to signal an event, and to fetch information.

var ProxyDevice  = core.Class.extend(mixins.PropertiesMixin,{
    init: function(options){
        mixins.PropertiesMixin.init.call(this);
        var self = this;
        options = options || {};

        this.env = options.env;

        this.weighing = false;
        this.debug_weight = 0;
        this.use_debug_weight = false;

        this.paying = false;

        this.notifications = {};
        this.bypass_proxy = false;

        this.connection = null;
        this.host       = '';
        this.keptalive  = false;

        this.set('status',{});

        this.set_connection_status('disconnected');

        this.on('change:status',this,function(eh,status){
            status = status.newValue;
            if(status.status === 'connected' && self.printer) {
                self.printer.print_receipt();
            }
        });

        this.posbox_supports_display = true;

        window.hw_proxy = this;
    },
    set_pos: function(pos) {
        this.setParent(pos);
        this.pos = pos;
    },
    set_connection_status: function(status, drivers, msg=''){
        var oldstatus = this.get('status');
        var newstatus = {};
        newstatus.status = status;
        newstatus.drivers = status === 'disconnected' ? {} : oldstatus.drivers;
        newstatus.drivers = drivers ? drivers : newstatus.drivers;
        newstatus.msg = msg;
        this.set('status',newstatus);
    },
    disconnect: function(){
        if(this.get('status').status !== 'disconnected'){
            this.connection.destroy();
            this.set_connection_status('disconnected');
        }
    },

    /**
     * Connects to the specified url.
     *
     * @param {string} url
     * @returns {Promise}
     */
    connect: function(url){
        var self = this;
        this.connection = new Session(undefined,url, { use_cors: true});
        this.host = url;
        if (this.pos.config.iface_print_via_proxy) {
            this.connect_to_printer();
        }
        this.set_connection_status('connecting',{});

        return this.message('handshake').then(function(response){
                if(response){
                    self.set_connection_status('connected');
                    localStorage.hw_proxy_url = url;
                    self.keepalive();
                }else{
                    self.set_connection_status('disconnected');
                    console.error('Connection refused by the Proxy');
                }
            },function(){
                self.set_connection_status('disconnected');
                console.error('Could not connect to the Proxy');
            });
    },

    connect_to_printer: function () {
        this.printer = new Printer(this.host, this.pos);
    },

    /**
     * Find a proxy and connects to it.
     *
     * @param {Object} [options]
     * @param {string} [options.force_ip] only try to connect to the specified ip.
     * @param {string} [options.port] @see find_proxy
     * @param {function} [options.progress] @see find_proxy
     * @returns {Promise}
     */
    autoconnect: function (options) {
        var self = this;
        this.set_connection_status('connecting',{});
        if (this.pos.config.iface_print_via_proxy) {
            this.connect_to_printer();
        }
        var found_url = new Promise(function () {});

        if (options.force_ip) {
            // if the ip is forced by server config, bailout on fail
            found_url = this.try_hard_to_connect(options.force_ip, options);
        } else if (localStorage.hw_proxy_url) {
            // try harder when we remember a good proxy url
            found_url = this.try_hard_to_connect(localStorage.hw_proxy_url, options)
                .catch(function () {
                    if (window.location.protocol != 'https:') {
                        return self.find_proxy(options);
                    }
                });
        } else {
            // just find something quick
            if (window.location.protocol != 'https:'){
                found_url = this.find_proxy(options);
            }
        }

        var successProm = found_url.then(function (url) {
            return self.connect(url);
        });

        successProm.catch(function () {
            self.set_connection_status('disconnected');
        });

        return successProm;
    },

    // starts a loop that updates the connection status
    keepalive: function () {
        var self = this;

        function status(){
            var always = function () {
                setTimeout(status, 5000);
            };
            self.connection.rpc('/hw_proxy/status_json',{},{shadow: true, timeout:2500})
                .then(function (driver_status) {
                    self.set_connection_status('connected',driver_status);
                }, function () {
                    if(self.get('status').status !== 'connecting'){
                        self.set_connection_status('disconnected');
                    }
                }).then(always, always);
        }

        if (!this.keptalive) {
            this.keptalive = true;
            status();
        }
    },

    /**
     * @param {string} name
     * @param {Object} [params]
     * @returns {Promise}
     */
    message : function (name, params) {
        var callbacks = this.notifications[name] || [];
        for (var i = 0; i < callbacks.length; i++) {
            callbacks[i](params);
        }
        if (this.get('status').status !== 'disconnected') {
            return this.connection.rpc('/hw_proxy/' + name, params || {}, {shadow: true});
        } else {
            return Promise.reject();
        }
    },

    /**
     * Tries several time to connect to a known proxy url.
     *
     * @param {*} url
     * @param {Object} [options]
     * @param {string} [options.port=8069] what port to listen to
     * @returns {Promise<string|Array>}
     */
    try_hard_to_connect: function (url, options) {
        options   = options || {};
        var protocol = window.location.protocol;
        var port = ( !options.port && protocol == "https:") ? ':443' : ':' + (options.port || '8069');

        this.set_connection_status('connecting');

        if(url.indexOf('//') < 0){
            url = protocol + '//' + url;
        }

        if(url.indexOf(':',5) < 0){
            url = url + port;
        }

        // try real hard to connect to url, with a 1sec timeout and up to 'retries' retries
        function try_real_hard_to_connect(url, retries) {
            return Promise.resolve(
                $.ajax({
                    url: url + '/hw_proxy/hello',
                    method: 'GET',
                    timeout: 1000,
                })
                .then(function () {
                    return Promise.resolve(url);
                }, function (resp) {
                    if (retries > 0) {
                        return try_real_hard_to_connect(url, retries-1);
                    } else {
                        return Promise.reject([resp.statusText, url]);
                    }
                })
            );
        }

        return try_real_hard_to_connect(url, 3);
    },

    /**
     * Returns as a promise a valid host url that can be used as proxy.
     *
     * @param {Object} [options]
     * @param {string} [options.port] what port to listen to (default 8069)
     * @param {function} [options.progress] callback for search progress ( fac in [0,1] )
     * @returns {Promise<string>} will be resolved with the proxy valid url
     */
    find_proxy: function(options){
        options = options || {};
        var self  = this;
        var port  = ':' + (options.port || '8069');
        var urls  = [];
        var found = false;
        var parallel = 8;
        var threads  = [];
        var progress = 0;


        urls.push('http://localhost'+port);
        for(var i = 0; i < 256; i++){
            urls.push('http://192.168.0.'+i+port);
            urls.push('http://192.168.1.'+i+port);
            urls.push('http://10.0.0.'+i+port);
        }

        var prog_inc = 1/urls.length;

        function update_progress(){
            progress = found ? 1 : progress + prog_inc;
            if(options.progress){
                options.progress(progress);
            }
        }

        function thread () {
            var url = urls.shift();

            if (!url || found || !self.searching_for_proxy) {
                return Promise.resolve();
            }

            return Promise.resolve(
                $.ajax({
                    url: url + '/hw_proxy/hello',
                    method: 'GET',
                    timeout: 400,
                }).then(function () {
                    found = true;
                    update_progress();
                    return Promise.resolve(url);
                }, function () {
                    update_progress();
                    return thread();
                })
            );
        }

        this.searching_for_proxy = true;

        var len  = Math.min(parallel, urls.length);
        for(i = 0; i < len; i++){
            threads.push(thread());
        }

        return new Promise(function (resolve, reject) {
            Promise.all(threads).then(function(results){
                var urls = [];
                for(var i = 0; i < results.length; i++){
                    if(results[i]){
                        urls.push(results[i]);
                    }
                }
                resolve(urls[0]);
            });
        });
    },

    stop_searching: function(){
        this.searching_for_proxy = false;
        this.set_connection_status('disconnected');
    },

    // this allows the client to be notified when a proxy call is made. The notification
    // callback will be executed with the same arguments as the proxy call
    add_notification: function(name, callback){
        if(!this.notifications[name]){
            this.notifications[name] = [];
        }
        this.notifications[name].push(callback);
    },

    /**
     * Returns the weight on the scale.
     *
     * @returns {Promise<Object>}
     */
    scale_read: function () {
        var self = this;
        if (self.use_debug_weight) {
            return Promise.resolve({weight:this.debug_weight, unit:'Kg', info:'ok'});
        }
        return new Promise(function (resolve, reject) {
            self.message('scale_read',{})
            .then(function (weight) {
                resolve(weight);
            }, function () { //failed to read weight
                resolve({weight:0.0, unit:'Kg', info:'ok'});
            });
        });
    },

    // sets a custom weight, ignoring the proxy returned value.
    debug_set_weight: function(kg){
        this.use_debug_weight = true;
        this.debug_weight = kg;
    },

    // resets the custom weight and re-enable listening to the proxy for weight values
    debug_reset_weight: function(){
        this.use_debug_weight = false;
        this.debug_weight = 0;
    },

    update_customer_facing_display: function(html) {
        if (this.posbox_supports_display && this.get('status').status == 'connected') {
            return this.message('customer_facing_display',
                { html: html },
                { timeout: 5000 });
        }
    },

    /**
     * @param {string} html
     * @returns {Promise}
     */
    take_ownership_over_customer_screen: function(html) {
        return this.message("take_control", { html: html });
    },

    /**
     * @returns {Promise}
     */
    test_ownership_of_customer_screen: function() {
        if (this.connection) {
            return this.message("test_ownership", {});
        }
        return Promise.reject({abort: true});
    },

    // asks the proxy to log some information, as with the debug.log you can provide several arguments.
    log: function(){
        return this.message('log',{'arguments': _.toArray(arguments)});
    },

});

return {
    JobQueue: JobQueue,
    ProxyDevice: ProxyDevice,
};

});
;

/*****************************************************
*  Filepath: /point_of_sale/static/src/js/models.js  *
*  Lines: 3381                                       *
*****************************************************/
/* global waitForWebfonts */
odoo.define('point_of_sale.models', function (require) {
"use strict";

var PosDB = require('point_of_sale.DB');
var config = require('web.config');
var core = require('web.core');
var field_utils = require('web.field_utils');
var time = require('web.time');
var utils = require('web.utils');
var { Gui } = require('point_of_sale.Gui');
const { batched, uuidv4 } = require("point_of_sale.utils");
const { escape } = require("@web/core/utils/strings");

var QWeb = core.qweb;
var _t = core._t;
var round_di = utils.round_decimals;
var round_pr = utils.round_precision;
const Markup = utils.Markup

const Registries = require('point_of_sale.Registries');
const { markRaw, reactive } = owl;

// Container of the product images fetched during rendering
// of customer display. There is no need to observe it, thus,
// we are putting it outside of PosGlobalState.
const PRODUCT_ID_TO_IMAGE_CACHE = {};

/**
 * If optimization is needed, then we should implement this
 * using a Balanced Binary Tree to behave like an Object and an Array.
 * But behaving like Object (indexed by cid) might not be
 * needed. Let's see how it turns out.
 */
class PosCollection extends Array {
    getByCID(cid) {
        return this.find(item => item.cid == cid);
    }
    add(item) {
        this.push(item);
    }
    remove(item) {
        const index = this.findIndex(_item => item.cid == _item.cid);
        if (index < 0) return index;
        this.splice(index, 1);
        return index;
    }
    reset() {
        this.length = 0;
    }
    at(index) {
        return this[index];
    }
}

let nextId = 0;
class PosModel {
    /**
     * Create an object with cid. If no cid is in the defaultObj,
     * cid is computed based on its id. Override _getCID if you
     * don't want this default calculation of cid.
     * @param {Object?} defaultObj its props copied to this instance.
     */
    constructor(defaultObj) {
        defaultObj = defaultObj || {};
        if (!defaultObj.cid) {
            defaultObj.cid = this._getCID(defaultObj);
        }
        Object.assign(this, defaultObj);
    }
    /**
     * Default cid getter. Used as local identity of this object.
     * @param {Object} obj
     */
    _getCID(obj) {
        if (obj.id) {
            if (typeof obj.id == 'string') {
                return obj.id;
            } else if (typeof obj.id == 'number') {
                return `c${obj.id}`;
            }
        }
        return `c${nextId++}`;
    }
}

class PosGlobalState extends PosModel {
    constructor(obj) {
        super(obj);

        this.db = new PosDB();                       // a local database used to search trough products and categories & store pending orders
        this.debug = config.isDebug(); //debug mode
        this.unwatched = markRaw({});

        // Business data; loaded from the server at launch
        this.company_logo = null;
        this.company_logo_base64 = '';
        this.currency = null;
        this.company = null;
        this.user = null;
        this.partners = [];
        this.taxes = [];
        this.pos_session = null;
        this.config = null;
        this.units = [];
        this.units_by_id = {};
        this.uom_unit_id = null;
        this.default_pricelist = null;
        this.order_sequence = 1;

        // Object mapping the order's name (which contains the uid) to it's server_id after
        // validation (order paid then sent to the backend).
        this.validated_orders_name_server_id_map = {};

        this.numpadMode = 'quantity';

        // Record<orderlineId, { 'qty': number, 'orderline': { qty: number, refundedQty: number, orderUid: string }, 'destinationOrderUid': string }>
        this.toRefundLines = {};
        this.TICKET_SCREEN_STATE = {
            syncedOrders: {
                currentPage: 1,
                cache: {},
                toShow: [],
                nPerPage: 80,
                totalCount: null,
            },
            ui: {
                selectedSyncedOrderId: null,
                searchDetails: this.getDefaultSearchDetails(),
                filter: null,
                // maps the order's backendId to it's selected orderline
                selectedOrderlineIds: {},
                highlightHeaderNote: false,
            },
        };

        // these dynamic attributes can be watched for change by other models or widgets
        Object.assign(this, {
            'synch':            { status:'connected', pending:0 },
            'orders':           new PosCollection(),
            'selectedOrder':    null,
            'selectedPartner':   null,
            'selectedCategoryId': null,
        });
    }
    getDefaultSearchDetails() {
        return {
            fieldName: 'RECEIPT_NUMBER',
            searchTerm: '',
        };
    }
    async load_product_uom_unit() {
        const params = {
            model: 'ir.model.data',
            method:'check_object_reference',
            args: ['uom', 'product_uom_unit'],
        };

        const uom_id = await this.env.services.rpc(params);
        this.uom_unit_id = uom_id[1];
    }

    async after_load_server_data(){
        await this.load_product_uom_unit();
        await this.load_orders();
        this.set_start_order();
    }

    async load_server_data(){
        const loadedData = await this.env.services.rpc({
            model: 'pos.session',
            method: 'load_pos_data',
            args: [[odoo.pos_session_id]],
        });
        await this._processData(loadedData);
        return this.after_load_server_data();
    }
   async _processData(loadedData) {
        this.version = loadedData['version'];
        this.company = loadedData['res.company'];
        this.dp = loadedData['decimal.precision'];
        this.units = loadedData['uom.uom'];
        this.units_by_id = loadedData['units_by_id'];
        this.states = loadedData['res.country.state'];
        this.countries = loadedData['res.country'];
        this.langs = loadedData['res.lang'];
        this.taxes = loadedData['account.tax'];
        this.taxes_by_id = loadedData['taxes_by_id'];
        this.pos_session = loadedData['pos.session'];
        this._loadPosSession();
        this.config = loadedData['pos.config'];
        this._loadPoSConfig();
        this.bills = loadedData['pos.bill'];
        this.partners = loadedData['res.partner'];
        this.addPartners(this.partners);
        this.picking_type = loadedData['stock.picking.type'];
        this.user = loadedData['res.users'];
        this.pricelists = loadedData['product.pricelist'];
        this.default_pricelist = loadedData['default_pricelist'];
        this.currency = loadedData['res.currency'];
        this.db.add_categories(loadedData['pos.category']);
        this._loadProductProduct(loadedData['product.product']);
        this.db.add_packagings(loadedData['product.packaging']);
        this.attributes_by_ptal_id = loadedData['attributes_by_ptal_id'];
        this.cash_rounding = loadedData['account.cash.rounding'];
        this.payment_methods = loadedData['pos.payment.method'];
        this._loadPosPaymentMethod();
        this.fiscal_positions = loadedData['account.fiscal.position'];
        this.base_url = loadedData['base_url'];
        await this._loadFonts();
        await this._loadPictures();
    }
    async _getTableOrdersFromServer(tableIds) {
        return await super._getTableOrdersFromServer(tableIds);
    }
    _loadPosSession() {
        // We need to do it here, since only then the local storage has the correct uuid
        this.db.save('pos_session_id', this.pos_session.id);
        let orders = this.db.get_orders();
        let sequences = orders.map(order => order.data.sequence_number + 1)
        this.pos_session.sequence_number = Math.max(this.pos_session.sequence_number, ...sequences);
        this.pos_session.login_number = odoo.login_number;
    }
    _loadPoSConfig() {
        this.db.set_uuid(this.config.uuid);
    }
    addPartners(partners) {
        return this.db.add_partners(partners);
    }
    _assignApplicableItems(pricelist, correspondingProduct, pricelistItem) {
        if (!(pricelist.id in correspondingProduct.applicablePricelistItems)) {
            correspondingProduct.applicablePricelistItems[pricelist.id] = [];
        }
        correspondingProduct.applicablePricelistItems[pricelist.id].push(pricelistItem);
    }
    _loadProductProduct(products) {
        const productMap = {};
        const productTemplateMap = {};

        const modelProducts = products.map(product => {
            product.pos = this;
            product.applicablePricelistItems = {};
            productMap[product.id] = product;
            productTemplateMap[product.product_tmpl_id[0]] = (productTemplateMap[product.product_tmpl_id[0]] || []).concat(product);
            return Product.create(product);
        });

        for (let pricelist of this.pricelists) {
            for (const pricelistItem of pricelist.items) {
                if (pricelistItem.product_id) {
                    let product_id = pricelistItem.product_id[0];
                    let correspondingProduct = productMap[product_id];
                    if (correspondingProduct) {
                        this._assignApplicableItems(pricelist, correspondingProduct, pricelistItem);
                    }
                }
                else if (pricelistItem.product_tmpl_id) {
                    let product_tmpl_id = pricelistItem.product_tmpl_id[0];
                    let correspondingProducts = productTemplateMap[product_tmpl_id];
                    for (let correspondingProduct of (correspondingProducts || [])) {
                        this._assignApplicableItems(pricelist, correspondingProduct, pricelistItem);
                    }
                }
                else {
                    for (const correspondingProduct of products) {
                        this._assignApplicableItems(pricelist, correspondingProduct, pricelistItem);
                    }
                }
            }
        }
        this.db.add_products(modelProducts)
    }
    _loadPosPaymentMethod() {
        // need to do this for pos_iot due to reference, this is a temporary fix
        this.payment_methods_by_id = {}
        for (let pm of this.payment_methods) {
            this.payment_methods_by_id[pm.id] = pm;
            let PaymentInterface = this.electronic_payment_interfaces[pm.use_payment_terminal];
            if (PaymentInterface) {
                pm.payment_terminal = new PaymentInterface(this, pm);
            }
        }
    }
    async _loadFonts() {
        return new Promise(function (resolve, reject) {
            // Waiting for fonts to be loaded to prevent receipt printing
            // from printing empty receipt while loading Inconsolata
            // ( The font used for the receipt )
            waitForWebfonts(['Lato','Inconsolata'], function () {
                resolve();
            });
            // The JS used to detect font loading is not 100% robust, so
            // do not wait more than 5sec
            setTimeout(resolve, 5000);
        });
    }
    async _loadPictures() {
        this.company_logo = new Image();
        return new Promise((resolve, reject) => {
            this.company_logo.onload = () => {
                let img = this.company_logo;
                let ratio = 1;
                let targetwidth = 300;
                let maxheight = 150;
                if (img.width !== targetwidth) {
                    ratio = targetwidth / img.width;
                }
                if (img.height * ratio > maxheight) {
                    ratio = maxheight / img.height;
                }
                let width  = Math.floor(img.width * ratio);
                let height = Math.floor(img.height * ratio);
                let  c = document.createElement('canvas');
                c.width  = width;
                c.height = height;
                let ctx = c.getContext('2d');
                ctx.drawImage(this.company_logo,0,0, width, height);

                this.company_logo_base64 = c.toDataURL();
                resolve();
            };
            this.company_logo.onerror = () => {
                reject();
            };
            this.company_logo.crossOrigin = "anonymous";
            this.company_logo.src = `/web/image?model=res.company&id=${this.company.id}&field=logo`;
        });

    }
    prepare_new_partners_domain(){
        return [['write_date','>', this.db.get_partner_write_date()]];
    }

    // reload the list of partner, returns as a promise that resolves if there were
    // updated partners, and fails if not
    async load_new_partners(){
        let search_params = { domain: this.prepare_new_partners_domain() };
        if (this.env.pos.config.limited_partners_loading) {
            search_params['order'] = 'write_date desc';
            if (this.env.pos.config.partner_load_background) {
                search_params['limit'] = this.env.pos.config.limited_partners_amount || 1;
            }
            else {
                search_params['limit'] = 1;
            }
        }
        let partners = await this.env.services.rpc({
            model: 'pos.session',
            method: 'get_pos_ui_res_partner_by_params',
            args: [[odoo.pos_session_id], search_params],
        }, {
            timeout: 3000,
            shadow: true,
        })
        if (this.env.pos.config.partner_load_background) {
            this.loadPartnersBackground(
                search_params['domain'],
                this.env.pos.config.limited_partners_amount || 1,
                'write_date desc'
            );
        }
        if (this.addPartners(partners)){
            return true
        }
        else{
            return false
        }
    }

    setSelectedCategoryId(categoryId) {
        this.selectedCategoryId = categoryId;
    }

    /**
     * Remove the order passed in params from the list of orders
     * @param order
     */
    removeOrder(order) {
        this.orders.remove(order);
        this.db.remove_unpaid_order(order);
        for (const line of order.get_orderlines()) {
            if (line.refunded_orderline_id) {
                delete this.toRefundLines[line.refunded_orderline_id];
            }
        }
    }

    /**
     * Return the current cashier (in this case, the user)
     * @returns {name: string, id: int, role: string}
     */
    get_cashier() {
        return this.user;
    }
    get_cashier_user_id() {
        return this.user.id;
    }
    cashierHasPriceControlRights() {
        return !this.config.restrict_price_control || this.get_cashier().role == 'manager';
    }
    _onReactiveOrderUpdated(order) {
        order.save_to_db();
    }
    createReactiveOrder(json) {
        const options = {pos:this};
        if (json) {
            options.json = json;
        }
        return this.makeOrderReactive(Order.create({}, options));
    }
    makeOrderReactive(order) {
        const batchedCallback = batched(() => {
            this._onReactiveOrderUpdated(order)
        });
        order = reactive(order, batchedCallback);
        order.save_to_db();
        return order;
    }
    // creates a new empty order and sets it as the current order
    add_new_order(){
        const order = this.createReactiveOrder();
        this.orders.add(order);
        this.selectedOrder = order;
        return order;
    }
    /**
     * Load the locally saved unpaid orders for this PoS Config.
     *
     * First load all orders belonging to the current session.
     * Second load all orders belonging to the same config but from other sessions,
     * Only if tho order has orderlines.
     */
    async load_orders(){
        var jsons = this.db.get_unpaid_orders();
        await this._loadMissingProducts(jsons);
        await this._loadMissingPartners(jsons);
        var orders = [];

        for (var i = 0; i < jsons.length; i++) {
            var json = jsons[i];
            if (json.pos_session_id === this.pos_session.id) {
                orders.push(this.createReactiveOrder(json));
            }
        }
        for (var i = 0; i < jsons.length; i++) {
            var json = jsons[i];
            if (json.pos_session_id !== this.pos_session.id && (json.lines.length > 0 || json.statement_ids.length > 0)) {
                orders.push(this.createReactiveOrder(json));
            } else if (json.pos_session_id !== this.pos_session.id) {
                this.db.remove_unpaid_order(jsons[i]);
            }
        }

        orders = orders.sort(function(a,b){
            return a.sequence_number - b.sequence_number;
        });

        if (orders.length) {
            for (const order of orders) {
                this.orders.add(order);
            }
        }
    }
    async _loadMissingProducts(orders) {
        const missingProductIds = new Set([]);
        for (const order of orders) {
            for (const line of order.lines) {
                const productId = line[2].product_id;
                if (missingProductIds.has(productId)) continue;
                if (!this.db.get_product_by_id(productId)) {
                    missingProductIds.add(productId);
                }
            }
        }
        const products = await this.env.services.rpc({
            model: 'pos.session',
            method: 'get_pos_ui_product_product_by_params',
            args: [odoo.pos_session_id, {domain: [['id', 'in', [...missingProductIds]]]}],
        });
        this._loadProductProduct(products);
    }
    // load the partners based on the ids
    async _loadPartners(partnerIds) {
        if (partnerIds.length > 0) {
            var domain = [['id','in', partnerIds]];
            const fetchedPartners = await this.env.services.rpc({
                model: 'pos.session',
                method: 'get_pos_ui_res_partner_by_params',
                args: [[odoo.pos_session_id], {domain}],
            }, {
                timeout: 3000,
                shadow: true,
            });
            this.addPartners(fetchedPartners);
        }
    }
    async _loadMissingPartners(orders) {
        const missingPartnerIds = new Set([]);
        for (const order of orders) {
            const partnerId = order.partner_id;
            if(missingPartnerIds.has(partnerId)) continue;
            if (partnerId && !this.db.get_partner_by_id(partnerId)) {
                missingPartnerIds.add(partnerId);
            }
        }
        await this._loadPartners([...missingPartnerIds]);
    }
    async loadProductsBackground() {
        let page = 0;
        let products = [];
        do {
            products = await this.env.services.rpc({
                model: 'pos.session',
                method: 'get_pos_ui_product_product_by_params',
                args: [odoo.pos_session_id, {
                    offset: page * this.config.limited_products_amount,
                    limit: this.config.limited_products_amount,
                }],
            }, { shadow: true });
            this._loadProductProduct(products);
            page += 1;
        } while(products.length == this.config.limited_products_amount);
    }
    async loadPartnersBackground(domain=[], offset=0, order=false) {
        // Start at the first page since the first set of loaded partners are not actually in the
        // same order as this background loading procedure.
        let i = 0;
        let partners = [];
        do {
            partners = await this.env.services.rpc({
                model: 'pos.session',
                method: 'get_pos_ui_res_partner_by_params',
                args: [
                    [odoo.pos_session_id],
                    {
                        domain: domain,
                        limit: this.config.limited_partners_amount,
                        offset: offset + this.config.limited_partners_amount * i,
                        order: order,
                    },
                ],
                context: this.env.session.user_context,
            }, { shadow: true });
            this.addPartners(partners);
            i += 1;
        } while(partners.length);
    }
    async getProductInfo(product, quantity) {
        const order = this.get_order();
        // check back-end method `get_product_info_pos` to see what it returns
        // We do this so it's easier to override the value returned and use it in the component template later
        const productInfo = await this.env.services.rpc({
            model: 'product.product',
            method: 'get_product_info_pos',
            args: [[product.id],
                product.get_price(order.pricelist, quantity),
                quantity,
                this.config.id],
            kwargs: {context: this.env.session.user_context},
        });

        const priceWithoutTax = productInfo['all_prices']['price_without_tax'];
        const margin = priceWithoutTax - product.standard_price;
        const orderPriceWithoutTax = order.get_total_without_tax();
        const orderCost = order.get_total_cost();
        const orderMargin = orderPriceWithoutTax - orderCost;

        const costCurrency = this.format_currency(product.standard_price);
        const marginCurrency = this.format_currency(margin);
        const marginPercent = priceWithoutTax ? Math.round(margin/priceWithoutTax * 10000) / 100 : 0;
        const orderPriceWithoutTaxCurrency = this.format_currency(orderPriceWithoutTax);
        const orderCostCurrency = this.format_currency(orderCost);
        const orderMarginCurrency = this.format_currency(orderMargin);
        const orderMarginPercent = orderPriceWithoutTax ? Math.round(orderMargin/orderPriceWithoutTax * 10000) / 100 : 0;
        return {
            costCurrency, marginCurrency, marginPercent, orderPriceWithoutTaxCurrency,
            orderCostCurrency, orderMarginCurrency, orderMarginPercent,productInfo
        }
    }
    async getClosePosInfo() {
        const closingData = await this.env.services.rpc({
            model: 'pos.session',
            method: 'get_closing_control_data',
            args: [[this.pos_session.id]]
        });
        const ordersDetails = closingData.orders_details;
        const paymentsAmount = closingData.payments_amount;
        const payLaterAmount = closingData.pay_later_amount;
        const openingNotes = closingData.opening_notes;
        const defaultCashDetails = closingData.default_cash_details;
        const otherPaymentMethods = closingData.other_payment_methods;
        const isManager = closingData.is_manager;
        const amountAuthorizedDiff = closingData.amount_authorized_diff;
        const cashControl = this.config.cash_control;

        // component state and refs definition
        const state = {notes: '', acceptClosing: false, payments: {}};
        if (cashControl) {
            state.payments[defaultCashDetails.id] = {counted: 0, difference: -defaultCashDetails.amount, number: 0};
        }
        if (otherPaymentMethods.length > 0) {
            otherPaymentMethods.forEach(pm => {
                if (pm.type === 'bank') {
                    state.payments[pm.id] = {counted: this.round_decimals_currency(pm.amount), difference: 0, number: pm.number}
                }
            })
        }
        return {
            ordersDetails, paymentsAmount, payLaterAmount, openingNotes, defaultCashDetails, otherPaymentMethods,
            isManager, amountAuthorizedDiff, state, cashControl
        }
    }
    set_start_order(){
        if (this.orders.length && !this.selectedOrder) {
            this.selectedOrder = this.orders[0]
        } else {
            this.add_new_order();
        }
    }

    // return the current order
    get_order(){
        return this.selectedOrder;
    }

    // change the current order
    set_order(order, options){
        this.selectedOrder = order;
    }

    // return the list of unpaid orders
    get_order_list(){
        return this.orders;
    }

    _convert_product_img_to_base64 (product, url) {
        return new Promise(function (resolve, reject) {
            var img = new Image();

            img.onload = function () {
                var canvas = document.createElement('CANVAS');
                var ctx = canvas.getContext('2d');

                canvas.height = this.height;
                canvas.width = this.width;
                ctx.drawImage(this,0,0);

                var dataURL = canvas.toDataURL('image/jpeg');
                canvas = null;

                resolve([product, dataURL]);
            };
            img.crossOrigin = 'use-credentials';
            img.src = url;
        });
    }

    get customer_display() {
        return this.unwatched.customer_display;
    }

    set customer_display(value) {
        this.unwatched.customer_display = markRaw(value);
    }

    send_current_order_to_customer_facing_display() {
        var self = this;
        if (!this.config.iface_customer_facing_display) return;
        this.render_html_for_customer_facing_display().then((rendered_html) => {
            if (self.env.pos.customer_display) {
                var $renderedHtml = $('<div>').html(rendered_html);
                $(self.env.pos.customer_display.document.body).html($renderedHtml.find('.pos-customer_facing_display'));
                var orderlines = $(self.env.pos.customer_display.document.body).find('.pos_orderlines_list');
                orderlines.scrollTop(orderlines.prop("scrollHeight"));
            } else if (this.config.iface_customer_facing_display_via_proxy && this.env.proxy.posbox_supports_display) {
                this.env.proxy.update_customer_facing_display(rendered_html);
            }
        });
    }

    /**
     * @returns {Promise<string>}
     */
    render_html_for_customer_facing_display () {
        var self = this;
        var order = this.get_order();

        // If we're using an external device like the IoT Box, we
        // cannot get /web/image?model=product.product because the
        // IoT Box is not logged in and thus doesn't have the access
        // rights to access product.product. So instead we'll base64
        // encode it and embed it in the HTML.
        var get_image_promises = [];

        if (order) {
            order.get_orderlines().forEach(function (orderline) {
                var product = orderline.product;
                var image_url = `/web/image?model=product.product&field=image_128&id=${product.id}&unique=${product.__last_update}`;

                // only download and convert image if we haven't done it before
                if (!(product.id in PRODUCT_ID_TO_IMAGE_CACHE)) {
                    get_image_promises.push(self._convert_product_img_to_base64(product, image_url));
                }
            });
        }

        return Promise.all(get_image_promises).then(function (productIdImagePairs) {
            for (let [product, image] of productIdImagePairs) {
                PRODUCT_ID_TO_IMAGE_CACHE[product.id] = image;
            }
            // Collect the product images that will be used in rendering the customer display template.
            const productImages = {};
            if (order) {
                for (const line of order.get_orderlines()) {
                    productImages[line.product.id] = PRODUCT_ID_TO_IMAGE_CACHE[line.product.id];
                }
            }
            return QWeb.render('CustomerFacingDisplayOrder', {
                pos: self,
                origin: window.location.origin,
                order: order,
                productImages
            });
        });
    }

    // saves the order locally and try to send it to the backend.
    // it returns a promise that succeeds after having tried to send the order and all the other pending orders.
    push_orders (order, opts) {
        opts = opts || {};
        var self = this;

        if (order) {
            this.db.add_order(order.export_as_JSON());
        }

        return new Promise((resolve, reject) => {
            this.env.posMutex.exec(async () => {
                try {
                    resolve(await self._flush_orders(self.db.get_orders(), opts));
                } catch (error) {
                    reject(error);
                }
            });
        });
    }

    push_single_order (order, opts) {
        opts = opts || {};
        const self = this;
        const order_id = self.db.add_order(order.export_as_JSON());

        return new Promise((resolve, reject) => {
            this.env.posMutex.exec(async () => {
                const order = self.db.get_order(order_id);
                try {
                    resolve(await self._flush_orders([order], opts));
                } catch (error) {
                    reject(error);
                }
            });
        });
    }

    // Send validated orders to the backend.
    // Resolves to the backend ids of the synced orders.
    _flush_orders(orders, options) {
        var self = this;

        return this._save_to_server(orders, options).then(function (server_ids) {
            for (let i = 0; i < server_ids.length; i++) {
                self.validated_orders_name_server_id_map[server_ids[i].pos_reference] = server_ids[i].id;
            }
            return server_ids;
        }).finally(function() {
            self._after_flush_orders(orders);
        });
    }
    /**
     * Hook method after _flush_orders resolved or rejected.
     * It aims to:
     *   - remove the refund orderlines from toRefundLines
     *   - invalidate cache of refunded synced orders
     */
    _after_flush_orders(orders) {
        const refundedOrderIds = new Set();
        for (const order of orders) {
            for (const line of order.data.lines) {
                const refundDetail = this.toRefundLines[line[2].refunded_orderline_id];
                if (!refundDetail) continue;
                // Collect the backend id of the refunded orders.
                refundedOrderIds.add(refundDetail.orderline.orderBackendId);
                // Reset the refund detail for the orderline.
                delete this.toRefundLines[refundDetail.orderline.id];
            }
        }
        this._invalidateSyncedOrdersCache([...refundedOrderIds]);
    }
    _invalidateSyncedOrdersCache(ids) {
        for (const id of ids) {
            delete this.TICKET_SCREEN_STATE.syncedOrders.cache[id];
        }
    }
    set_synch(status, pending) {
        if (['connected', 'connecting', 'error', 'disconnected'].indexOf(status) === -1) {
            console.error(status, ' is not a known connection state.');
        }
        pending = pending || this.db.get_orders().length + this.db.get_ids_to_remove_from_server().length;
        this.synch = { status, pending };
    }

    // send an array of orders to the server
    // available options:
    // - timeout: timeout for the rpc call in ms
    // returns a promise that resolves with the list of
    // server generated ids for the sent orders
    _save_to_server (orders, options) {
        if (!orders || !orders.length) {
            return Promise.resolve([]);
        }
        this.set_synch('connecting', orders.length);
        options = options || {};

        var self = this;
        var timeout = typeof options.timeout === 'number' ? options.timeout : 30000 * orders.length;

        // Keep the order ids that are about to be sent to the
        // backend. In between create_from_ui and the success callback
        // new orders may have been added to it.
        var order_ids_to_sync = _.pluck(orders, 'id');

        // we try to send the order. shadow prevents a spinner if it takes too long. (unless we are sending an invoice,
        // then we want to notify the user that we are waiting on something )
        var args = [_.map(orders, function (order) {
                order.to_invoice = options.to_invoice || false;
                return order;
            })];
        args.push(options.draft || false);
        return this.env.services.rpc({
                model: 'pos.order',
                method: 'create_from_ui',
                args: args,
                kwargs: {context: this.env.session.user_context},
            }, {
                timeout: timeout,
                shadow: !options.to_invoice
            })
            .then(function (server_ids) {
                _.each(order_ids_to_sync, function (order_id) {
                    self.db.remove_order(order_id);
                });
                self.failed = false;
                self.set_synch('connected');
                return server_ids;
            }).catch(function (error){
                console.warn('Failed to send orders:', orders);
                if(error.code === 200 ){    // Business Logic Error, not a connection problem
                    // Hide error if already shown before ...
                    if ((!self.failed || options.show_error) && !options.to_invoice) {
                        self.failed = error;
                        self.set_synch('error');
                        throw error;
                    }
                }
                self.set_synch('disconnected');
                throw error;
            });
    }

    // Exports the paid orders (the ones waiting for internet connection)
    export_paid_orders() {
        return JSON.stringify({
            'paid_orders':  this.db.get_orders(),
            'session':      this.pos_session.name,
            'session_id':    this.pos_session.id,
            'date':         (new Date()).toUTCString(),
            'version':      this.version.server_version_info,
        },null,2);
    }

    // Exports the unpaid orders (the tabs)
    export_unpaid_orders() {
        return JSON.stringify({
            'unpaid_orders': this.db.get_unpaid_orders(),
            'session':       this.pos_session.name,
            'session_id':    this.pos_session.id,
            'date':          (new Date()).toUTCString(),
            'version':       this.version.server_version_info,
        },null,2);
    }

    // This imports paid or unpaid orders from a json file whose
    // contents are provided as the string str.
    // It returns a report of what could and what could not be
    // imported.
    import_orders(str) {
        var json = JSON.parse(str);
        var report = {
            // Number of paid orders that were imported
            paid: 0,
            // Number of unpaid orders that were imported
            unpaid: 0,
            // Orders that were not imported because they already exist (uid conflict)
            unpaid_skipped_existing: 0,
            // Orders that were not imported because they belong to another session
            unpaid_skipped_session:  0,
            // The list of session ids to which skipped orders belong.
            unpaid_skipped_sessions: [],
        };

        if (json.paid_orders) {
            for (var i = 0; i < json.paid_orders.length; i++) {
                this.db.add_order(json.paid_orders[i].data);
            }
            report.paid = json.paid_orders.length;
            this.push_orders();
        }

        if (json.unpaid_orders) {

            var orders  = [];
            var existing = this.get_order_list();
            var existing_uids = {};
            var skipped_sessions = {};

            for (var i = 0; i < existing.length; i++) {
                existing_uids[existing[i].uid] = true;
            }

            for (var i = 0; i < json.unpaid_orders.length; i++) {
                var order = json.unpaid_orders[i];
                if (order.pos_session_id !== this.pos_session.id) {
                    report.unpaid_skipped_session += 1;
                    skipped_sessions[order.pos_session_id] = true;
                } else if (existing_uids[order.uid]) {
                    report.unpaid_skipped_existing += 1;
                } else {
                    orders.push(this.createReactiveOrder(order));
                }
            }

            orders = orders.sort(function(a,b){
                return a.sequence_number - b.sequence_number;
            });

            if (orders.length) {
                report.unpaid = orders.length;
                this.orders.add(orders);
            }

            report.unpaid_skipped_sessions = _.keys(skipped_sessions);
        }

        return report;
    }

    _load_orders(){
        var jsons = this.db.get_unpaid_orders();
        var orders = [];
        var not_loaded_count = 0;

        for (var i = 0; i < jsons.length; i++) {
            var json = jsons[i];
            if (json.pos_session_id === this.pos_session.id) {
                orders.push(this.createReactiveOrder(json));
            } else {
                not_loaded_count += 1;
            }
        }

        if (not_loaded_count) {
            console.info('There are '+not_loaded_count+' locally saved unpaid orders belonging to another session');
        }

        orders = orders.sort(function(a,b){
            return a.sequence_number - b.sequence_number;
        });

        if (orders.length) {
            this.orders.add(orders);
        }
    }

    /**
     * Mirror JS method of:
     * _compute_amount in addons/account/models/account.py
     */
    _compute_all(tax, base_amount, quantity, price_exclude) {
        if(price_exclude === undefined)
            var price_include = tax.price_include;
        else
            var price_include = !price_exclude;
        if (tax.amount_type === 'fixed') {
            // Use sign on base_amount and abs on quantity to take into account the sign of the base amount,
            // which includes the sign of the quantity and the sign of the price_unit
            // Amount is the fixed price for the tax, it can be negative
            // Base amount included the sign of the quantity and the sign of the unit price and when
            // a product is returned, it can be done either by changing the sign of quantity or by changing the
            // sign of the price unit.
            // When the price unit is equal to 0, the sign of the quantity is absorbed in base_amount then
            // a "else" case is needed.
            if (base_amount)
                return Math.sign(base_amount) * Math.abs(quantity) * tax.amount;
            else
                return quantity * tax.amount;
        }
        if (tax.amount_type === 'percent' && !price_include){
            return base_amount * tax.amount / 100;
        }
        if (tax.amount_type === 'percent' && price_include){
            return base_amount - (base_amount / (1 + tax.amount / 100));
        }
        if (tax.amount_type === 'division' && !price_include) {
            return base_amount / (1 - tax.amount / 100) - base_amount;
        }
        if (tax.amount_type === 'division' && price_include) {
            return base_amount - (base_amount * (tax.amount / 100));
        }
        return false;
    }

    /**
     * Mirror JS method of:
     * compute_all in addons/account/models/account.py
     *
     * Read comments in the python side method for more details about each sub-methods.
     */
    compute_all(taxes, price_unit, quantity, currency_rounding, handle_price_include=true) {
        var self = this;

        // 1) Flatten the taxes.

        var _collect_taxes = function(taxes, all_taxes){
            taxes = [...taxes].sort(function (tax1, tax2) {
                return tax1.sequence - tax2.sequence;
            });
            _(taxes).each(function(tax){
                if(tax.amount_type === 'group')
                    all_taxes = _collect_taxes(tax.children_tax_ids, all_taxes);
                else
                    all_taxes.push(tax);
            });
            return all_taxes;
        }
        var collect_taxes = function(taxes){
            return _collect_taxes(taxes, []);
        }

        taxes = collect_taxes(taxes);

        // 2) Deal with the rounding methods

        var round_tax = this.company.tax_calculation_rounding_method != 'round_globally';

        var initial_currency_rounding = currency_rounding;
        if(!round_tax)
            currency_rounding = currency_rounding * 0.00001;

        // 3) Iterate the taxes in the reversed sequence order to retrieve the initial base of the computation.
        var recompute_base = function(base_amount, fixed_amount, percent_amount, division_amount){
             return (base_amount - fixed_amount) / (1.0 + percent_amount / 100.0) * (100 - division_amount) / 100;
        }

        var base = round_pr(price_unit * quantity, initial_currency_rounding);

        var sign = 1;
        if(base < 0){
            base = -base;
            sign = -1;
        }

        var total_included_checkpoints = {};
        var i = taxes.length - 1;
        var store_included_tax_total = true;

        var incl_fixed_amount = 0.0;
        var incl_percent_amount = 0.0;
        var incl_division_amount = 0.0;

        var cached_tax_amounts = {};
        if (handle_price_include){
            _(taxes.reverse()).each(function(tax){
                if(tax.include_base_amount){
                    base = recompute_base(base, incl_fixed_amount, incl_percent_amount, incl_division_amount);
                    incl_fixed_amount = 0.0;
                    incl_percent_amount = 0.0;
                    incl_division_amount = 0.0;
                    store_included_tax_total = true;
                }
                if(tax.price_include){
                    if(tax.amount_type === 'percent')
                        incl_percent_amount += tax.amount;
                    else if(tax.amount_type === 'division')
                        incl_division_amount += tax.amount;
                    else if(tax.amount_type === 'fixed')
                        incl_fixed_amount += Math.abs(quantity) * tax.amount
                    else{
                        var tax_amount = self._compute_all(tax, base, quantity);
                        incl_fixed_amount += tax_amount;
                        cached_tax_amounts[i] = tax_amount;
                    }
                    if(store_included_tax_total){
                        total_included_checkpoints[i] = base;
                        store_included_tax_total = false;
                    }
                }
                i -= 1;
            });
        }

        var total_excluded = round_pr(recompute_base(base, incl_fixed_amount, incl_percent_amount, incl_division_amount), initial_currency_rounding);
        var total_included = total_excluded;

        // 4) Iterate the taxes in the sequence order to fill missing base/amount values.

        base = total_excluded;

        var skip_checkpoint = false;

        var taxes_vals = [];
        i = 0;
        var cumulated_tax_included_amount = 0;
        _(taxes.reverse()).each(function(tax){
            if(tax.price_include || tax.is_base_affected)
                var tax_base_amount = base;
            else
                var tax_base_amount = total_excluded;

            if(!skip_checkpoint && tax.price_include && total_included_checkpoints[i] !== undefined){
                var tax_amount = total_included_checkpoints[i] - (base + cumulated_tax_included_amount);
                cumulated_tax_included_amount = 0;
            }else
                var tax_amount = self._compute_all(tax, tax_base_amount, quantity, true);

            tax_amount = round_pr(tax_amount, currency_rounding);

            if(tax.price_include && total_included_checkpoints[i] === undefined)
                cumulated_tax_included_amount += tax_amount;

            taxes_vals.push({
                'id': tax.id,
                'name': tax.name,
                'amount': sign * tax_amount,
                'base': sign * round_pr(tax_base_amount, currency_rounding),
            });

            if(tax.include_base_amount){
                base += tax_amount;
                if(!tax.price_include)
                    skip_checkpoint = true;
            }

            total_included += tax_amount;
            i += 1;
        });

        return {
            'taxes': taxes_vals,
            'total_excluded': sign * round_pr(total_excluded, this.currency.rounding),
            'total_included': sign * round_pr(total_included, this.currency.rounding),
        };
    }

    /**
     * Taxes after fiscal position mapping.
     * @param {number[]} taxIds
     * @param {object | falsy} fpos - fiscal position
     * @returns {object[]}
     */
    get_taxes_after_fp(taxIds, fpos){
        if (!fpos) {
            return taxIds.map((taxId) => this.taxes_by_id[taxId]);
        }
        let mappedTaxes = [];
        for (const taxId of taxIds) {
            const tax = this.taxes_by_id[taxId];
            if (tax) {
                const taxMaps = Object.values(fpos.fiscal_position_taxes_by_id).filter(
                    (fposTax) => fposTax.tax_src_id[0] === tax.id
                );
                if (taxMaps.length) {
                    for (const taxMap of taxMaps) {
                        if (taxMap.tax_dest_id) {
                            const mappedTax = this.taxes_by_id[taxMap.tax_dest_id[0]];
                            if (mappedTax) {
                                mappedTaxes.push(mappedTax);
                            }
                        }
                    }
                } else {
                    mappedTaxes.push(tax);
                }
            }
        }
        return _.uniq(mappedTaxes, (tax) => tax.id);
      }

    /**
     * TODO: We can probably remove this here and put it somewhere else.
     * And that somewhere else becomes the parent of the proxy.
     * Directly calls the requested service, instead of triggering a
     * 'call_service' event up, which wouldn't work as services have no parent
     *
     * @param {OdooEvent} ev
     */
    _trigger_up (ev) {
        if (ev.is_stopped()) {
            return;
        }
        const payload = ev.data;
        if (ev.name === 'call_service') {
            let args = payload.args || [];
            if (payload.service === 'ajax' && payload.method === 'rpc') {
                // ajax service uses an extra 'target' argument for rpc
                args = args.concat(ev.target);
            }
            const service = this.env.services[payload.service];
            const result = service[payload.method].apply(service, args);
            payload.callback(result);
        }
    }

    isProductQtyZero(qty) {
        return utils.float_is_zero(qty, this.dp['Product Unit of Measure']);
    }

    formatProductQty(qty) {
        return field_utils.format.float(qty, { digits: [true, this.dp['Product Unit of Measure']] });
    }

    format_currency(amount, precision) {
        amount = this.format_currency_no_symbol(amount, precision, this.currency);

        if (this.currency.position === 'after') {
            return amount + ' ' + (this.currency.symbol || '');
        } else {
            return (this.currency.symbol || '') + ' ' + amount;
        }
    }

    format_currency_no_symbol(amount, precision, currency) {
        if (!currency) {
            currency = this.currency
        }
        var decimals = currency.decimal_places;

        if (precision && this.dp[precision] !== undefined) {
            decimals = this.dp[precision];
        }

        if (typeof amount === 'number') {
            amount = round_di(amount, decimals).toFixed(decimals);
            amount = field_utils.format.float(round_di(amount, decimals), {
                digits: [69, decimals],
            });
        }

        return amount;
    }

    format_pr(value, precision) {
        var decimals =
            precision > 0
                ? Math.max(0, Math.ceil(Math.log(1.0 / precision) / Math.log(10)))
                : 0;
        return value.toFixed(decimals);
    }

    round_decimals_currency(value) {
        const decimals = this.currency.decimal_places;
        return parseFloat(round_di(value, decimals).toFixed(decimals));
    }

    /**
     * (value = 1.0000, decimals = 2) => '1'
     * (value = 1.1234, decimals = 2) => '1.12'
     * @param {number} value amount to format
     */
    formatFixed(value) {
        const currency = this.currency || { decimal_places: 2 };
        return `${Number(value.toFixed(currency.decimal_places || 0))}`;
    }

    disallowLineQuantityChange() {
        return false;
    }

    getCurrencySymbol() {
        return this.currency ? this.currency.symbol : '$';
    }
    /**
     * Make the products corresponding to the given ids to be available_in_pos and
     * fetch them to be added on the loaded products.
     */
    async _addProducts(ids, setAvailable=true){
        if(setAvailable){
            await this.env.services.rpc({
                model: 'product.product',
                method: 'write',
                args: [ids, {'available_in_pos': true}],
                context: this.env.session.user_context,
            });
        }
        let product = await this.env.services.rpc({
            model: 'pos.session',
            method: 'get_pos_ui_product_product_by_params',
            args: [odoo.pos_session_id, {domain: [['id', 'in', ids]]}],
        });
        this._loadProductProduct(product);
    }
    async refreshTotalDueOfPartner(partner) {
        const partnerWithUpdatedTotalDue = await this.env.services.rpc({
            model: 'res.partner',
            method: 'search_read',
            fields: ['total_due'],
            domain: [['id', '=', partner.id]],
        });
        this.db.update_partners(partnerWithUpdatedTotalDue);
        return partnerWithUpdatedTotalDue;
    }
    doNotAllowRefundAndSales() {
        return false;
    }
}
PosGlobalState.prototype.electronic_payment_interfaces = {};
Registries.Model.add(PosGlobalState);

/**
 * Call this function to map your PaymentInterface implementation to
 * the use_payment_terminal field. When the POS loads it will take
 * care of instantiating your interface and setting it on the right
 * payment methods.
 *
 * @param {string} use_payment_terminal - value used in the
 * use_payment_terminal selection field
 *
 * @param {Object} ImplementedPaymentInterface - implemented
 * PaymentInterface
 */
function register_payment_method(use_payment_terminal, ImplementedPaymentInterface) {
    PosGlobalState.prototype.electronic_payment_interfaces[use_payment_terminal] = ImplementedPaymentInterface;
};


class Product extends PosModel {
    constructor(obj) {
        super(obj);
        this.parent_category_ids = [];
        let category = this.categ.parent;
        while (category) {
            this.parent_category_ids.push(category.id);
            category = category.parent;
        }
    }
    isAllowOnlyOneLot() {
        const productUnit = this.get_unit();
        return this.tracking === 'lot' || !productUnit || !productUnit.is_pos_groupable;
    }
    get_unit() {
        var unit_id = this.uom_id;
        if(!unit_id){
            return undefined;
        }
        unit_id = unit_id[0];
        if(!this.pos){
            return undefined;
        }
        return this.pos.units_by_id[unit_id];
    }
    isPricelistItemUsable(item, date) {
        return (
            (!item.categ_id || _.contains(this.parent_category_ids.concat(this.categ.id), item.categ_id[0])) &&
            (!item.date_start || moment.utc(item.date_start).isSameOrBefore(date)) &&
            (!item.date_end || moment.utc(item.date_end).isSameOrAfter(date))
        );
    }
    // Port of _get_product_price on product.pricelist.
    //
    // Anything related to UOM can be ignored, the POS will always use
    // the default UOM set on the product and the user cannot change
    // it.
    //
    // Pricelist items do not have to be sorted. All
    // product.pricelist.item records are loaded with a search_read
    // and were automatically sorted based on their _order by the
    // ORM. After that they are added in this order to the pricelists.
    get_price(pricelist, quantity, price_extra){
        var self = this;
        var date = moment();

        // In case of nested pricelists, it is necessary that all pricelists are made available in
        // the POS. Display a basic alert to the user in this case.
        if (!pricelist) {
            alert(_t(
                'An error occurred when loading product prices. ' +
                'Make sure all pricelists are available in the POS.'
            ));
        }

        var pricelist_items = _.filter(
            self.applicablePricelistItems[pricelist.id],
            function (item) {
                return self.isPricelistItemUsable(item, date);
            }
        );

        var price = self.lst_price;
        if (price_extra){
            price += price_extra;
        }
        _.find(pricelist_items, function (rule) {
            if (rule.min_quantity && quantity < rule.min_quantity) {
                return false;
            }

            if (rule.base === 'pricelist') {
                let base_pricelist = _.find(self.pos.pricelists, function (pricelist) {
                    return pricelist.id === rule.base_pricelist_id[0];});
                if (base_pricelist) {
                    price = self.get_price(base_pricelist, quantity);
                }
            } else if (rule.base === 'standard_price') {
                price = self.standard_price;
            }

            if (rule.compute_price === 'fixed') {
                price = rule.fixed_price;
                return true;
            } else if (rule.compute_price === 'percentage') {
                price = price - (price * (rule.percent_price / 100));
                return true;
            } else {
                var price_limit = price;
                price = price - (price * (rule.price_discount / 100));
                if (rule.price_round) {
                    price = round_pr(price, rule.price_round);
                }
                if (rule.price_surcharge) {
                    price += rule.price_surcharge;
                }
                if (rule.price_min_margin) {
                    price = Math.max(price, price_limit + rule.price_min_margin);
                }
                if (rule.price_max_margin) {
                    price = Math.min(price, price_limit + rule.price_max_margin);
                }
                return true;
            }

            return false;
        });

        // This return value has to be rounded with round_di before
        // being used further. Note that this cannot happen here,
        // because it would cause inconsistencies with the backend for
        // pricelist that have base == 'pricelist'.
        return price;
    }
    get_display_price(pricelist, quantity) {
        if (this.pos.config.iface_tax_included === 'total') {
            const order = this.pos.get_order();
            const taxes = this.pos.get_taxes_after_fp(this.taxes_id, order && order.fiscal_position);
            const allPrices = this.pos.compute_all(taxes, this.get_price(pricelist, quantity), 1, this.pos.currency.rounding);
            return allPrices.total_included;
        } else {
            return this.get_price(pricelist, quantity);
        }
    }
}
Registries.Model.add(Product);

var orderline_id = 1;

// An orderline represent one element of the content of a customer's shopping cart.
// An orderline contains a product, its quantity, its price, discount. etc.
// An Order contains zero or more Orderlines.
class Orderline extends PosModel {
    constructor(obj, options) {
        super(obj);
        this.pos   = options.pos;
        this.order = options.order;
        this.price_manually_set = options.price_manually_set || false;
        this.price_automatically_set = options.price_automatically_set || false;
        if (options.json) {
            try {
                this.init_from_JSON(options.json);
            } catch(_error) {
                console.error('ERROR: attempting to recover product ID', options.json.product_id,
                    'not available in the point of sale. Correct the product or clean the browser cache.');
            }
            return;
        }
        this.product = options.product;
        this.tax_ids = options.tax_ids;
        this.set_product_lot(this.product);
        this.set_quantity(1);
        this.discount = 0;
        this.discountStr = '0';
        this.selected = false;
        this.description = '';
        this.price_extra = 0;
        this.full_product_name = options.description || '';
        this.id = orderline_id++;
        this.customerNote = this.customerNote || '';

        if (options.price) {
            this.set_unit_price(options.price);
        } else {
            this.set_unit_price(this.product.get_price(this.order.pricelist, this.get_quantity()));
        }
    }
    init_from_JSON(json) {
        this.product = this.pos.db.get_product_by_id(json.product_id);
        this.set_product_lot(this.product);
        this.price = json.price_unit;
        this.price_manually_set = json.price_manually_set;
        this.price_automatically_set = json.price_automatically_set;
        this.set_discount(json.discount);
        this.set_quantity(json.qty, 'do not recompute unit price');
        this.set_description(json.description);
        this.set_price_extra(json.price_extra);
        this.set_full_product_name(json.full_product_name);
        this.id = json.id ? json.id : orderline_id++;
        orderline_id = Math.max(this.id+1,orderline_id);
        var pack_lot_lines = json.pack_lot_ids;
        for (var i = 0; i < pack_lot_lines.length; i++) {
            var packlotline = pack_lot_lines[i][2];
            var pack_lot_line = Packlotline.create({}, {'json': _.extend({...packlotline}, {'order_line':this})});
            this.pack_lot_lines.add(pack_lot_line);
        }
        this.tax_ids = json.tax_ids && json.tax_ids.length !== 0 ? json.tax_ids[0][2] : undefined;
        this.set_customer_note(json.customer_note);
        this.refunded_qty = json.refunded_qty;
        this.refunded_orderline_id = json.refunded_orderline_id;
    }
    clone(){
        var orderline = Orderline.create({},{
            pos: this.pos,
            order: this.order,
            product: this.product,
            price: this.price,
        });
        orderline.order = null;
        orderline.quantity = this.quantity;
        orderline.quantityStr = this.quantityStr;
        orderline.discount = this.discount;
        orderline.price = this.price;
        orderline.selected = false;
        orderline.price_manually_set = this.price_manually_set;
        orderline.price_automatically_set = this.price_automatically_set;
        orderline.customerNote = this.customerNote;
        return orderline;
    }
    getPackLotLinesToEdit(isAllowOnlyOneLot) {
        const currentPackLotLines = this.pack_lot_lines;
        let nExtraLines = Math.abs(this.quantity) - currentPackLotLines.length;
        nExtraLines = Math.ceil(nExtraLines);
        nExtraLines = nExtraLines > 0 ? nExtraLines : 1;
        const tempLines = currentPackLotLines
            .map(lotLine => ({
                id: lotLine.cid,
                text: lotLine.lot_name,
            }))
            .concat(
                Array.from(Array(nExtraLines)).map(_ => ({
                    text: '',
                }))
            );
        return isAllowOnlyOneLot ? [tempLines[0]] : tempLines;
    }
    /**
     * @param { modifiedPackLotLines, newPackLotLines }
     *    @param {Object} modifiedPackLotLines key-value pair of String (the cid) & String (the new lot_name)
     *    @param {Array} newPackLotLines array of { lot_name: String }
     */
    setPackLotLines({ modifiedPackLotLines, newPackLotLines }) {
        // Set the new values for modified lot lines.
        let lotLinesToRemove = [];
        for (let lotLine of this.pack_lot_lines) {
            const modifiedLotName = modifiedPackLotLines[lotLine.cid];
            if (modifiedLotName) {
                lotLine.lot_name = modifiedLotName;
            } else {
                // We should not call lotLine.remove() here because
                // we don't want to mutate the array while looping thru it.
                lotLinesToRemove.push(lotLine);
            }
        }

        // Remove those that needed to be removed.
        for (let lotLine of lotLinesToRemove) {
            this.pack_lot_lines.remove(lotLine);
        }

        // Create new pack lot lines.
        let newPackLotLine;
        for (let newLotLine of newPackLotLines) {
            newPackLotLine = Packlotline.create({}, { order_line: this });
            newPackLotLine.lot_name = newLotLine.lot_name;
            this.pack_lot_lines.add(newPackLotLine);
        }

        // Set the quantity of the line based on number of pack lots.
        if(!this.product.to_weight){
            this.set_quantity_by_lot();
        }
    }
    set_product_lot(product){
        this.has_product_lot = product.tracking !== 'none';
        this.pack_lot_lines  = this.has_product_lot && new PosCollection();
    }
    // sets a discount [0,100]%
    set_discount(discount){
        var parsed_discount = typeof(discount) === 'number' ? discount : isNaN(parseFloat(discount)) ? 0 : field_utils.parse.float('' + discount);
        var disc = Math.min(Math.max(parsed_discount || 0, 0),100);
        this.discount = disc;
        this.discountStr = '' + disc;
    }
    // returns the discount [0,100]%
    get_discount(){
        return this.discount;
    }
    get_discount_str(){
        return this.discountStr;
    }
    set_description(description){
        this.description = description || '';
    }
    set_price_extra(price_extra){
        this.price_extra = parseFloat(price_extra) || 0.0;
    }
    set_full_product_name(full_product_name){
        this.full_product_name = full_product_name || '';
    }
    get_price_extra () {
        return this.price_extra;
    }
    // sets the quantity of the product. The quantity will be rounded according to the
    // product's unity of measure properties. Quantities greater than zero will not get
    // rounded to zero
    // Return true if successfully set the quantity, otherwise, return false.
    set_quantity(quantity, keep_price){
        this.order.assert_editable();
        if(quantity === 'remove'){
            if (this.refunded_orderline_id in this.pos.toRefundLines) {
                delete this.pos.toRefundLines[this.refunded_orderline_id];
            }
            this.order.remove_orderline(this);
            return true;
        }else{
            var quant = typeof(quantity) === 'number' ? quantity : (field_utils.parse.float('' + (quantity ? quantity : 0 )));
            if (this.refunded_orderline_id in this.pos.toRefundLines) {
                const toRefundDetail = this.pos.toRefundLines[this.refunded_orderline_id];
                const maxQtyToRefund = toRefundDetail.orderline.qty - toRefundDetail.orderline.refundedQty
                if (quant > 0) {
                    Gui.showPopup('ErrorPopup', {
                        title: _t('Positive quantity not allowed'),
                        body: _t('Only a negative quantity is allowed for this refund line. Click on +/- to modify the quantity to be refunded.')
                    });
                    return false;
                } else if (quant == 0) {
                    toRefundDetail.qty = 0;
                } else if (-quant <= maxQtyToRefund) {
                    toRefundDetail.qty = -quant;
                } else {
                    Gui.showPopup('ErrorPopup', {
                        title: _t('Greater than allowed'),
                        body: _.str.sprintf(
                            _t('The requested quantity to be refunded is higher than the refundable quantity of %s.'),
                            this.pos.formatProductQty(maxQtyToRefund)
                        ),
                    });
                    return false;
                }
            }
            var unit = this.get_unit();
            if(unit){
                if (unit.rounding) {
                    var decimals = this.pos.dp['Product Unit of Measure'];
                    var rounding = Math.max(unit.rounding, Math.pow(10, -decimals));
                    this.quantity    = round_pr(quant, rounding);
                    this.quantityStr = field_utils.format.float(this.quantity, {digits: [69, decimals]});
                } else {
                    this.quantity    = round_pr(quant, 1);
                    this.quantityStr = this.quantity.toFixed(0);
                }
            }else{
                this.quantity    = quant;
                this.quantityStr = '' + this.quantity;
            }
        }

        // just like in sale.order changing the quantity will recompute the unit price
        if(! keep_price && ! (this.price_manually_set || this.price_automatically_set)){
            this.set_unit_price(this.product.get_price(this.order.pricelist, this.get_quantity(), this.get_price_extra()));
            this.order.fix_tax_included_price(this);
        }
        return true;
    }
    // return the quantity of product
    get_quantity(){
        return this.quantity;
    }
    get_quantity_str(){
        return this.quantityStr;
    }
    get_quantity_str_with_unit(){
        var unit = this.get_unit();
        if(unit && !unit.is_pos_groupable){
            return this.quantityStr + ' ' + unit.name;
        }else{
            return this.quantityStr;
        }
    }

    get_lot_lines() {
        return this.pack_lot_lines && this.pack_lot_lines;
    }

    get_required_number_of_lots(){
        var lots_required = 1;

        if (this.product.tracking == 'serial') {
            lots_required = Math.abs(this.quantity);
        }

        return lots_required;
    }

    get_valid_lots(){
        return this.pack_lot_lines.filter((item) => {
            return item.lot_name;
        });
    }

    set_quantity_by_lot() {
        var valid_lots_quantity = this.get_valid_lots().length;
        if (this.quantity < 0){
            valid_lots_quantity = -valid_lots_quantity;
        }
        this.set_quantity(valid_lots_quantity);
    }

    has_valid_product_lot(){
        if(!this.has_product_lot){
            return true;
        }
        var valid_product_lot = this.get_valid_lots();
        return this.get_required_number_of_lots() === valid_product_lot.length;
    }

    // return the unit of measure of the product
    get_unit(){
        return this.product.get_unit();
    }
    // return the product of this orderline
    get_product(){
        return this.product;
    }
    get_full_product_name () {
        if (this.full_product_name) {
            return this.full_product_name
        }
        var full_name = this.product.display_name;
        if (this.description) {
            full_name += ` (${this.description})`;
        }
        return full_name;
    }
    // selects or deselects this orderline
    set_selected(selected){
        this.selected = selected;
        // this trigger also triggers the change event of the collection.
    }
    // returns true if this orderline is selected
    is_selected(){
        return this.selected;
    }
    // when we add an new orderline we want to merge it with the last line to see reduce the number of items
    // in the orderline. This returns true if it makes sense to merge the two
    can_be_merged_with(orderline){
        var price = parseFloat(round_di(this.price || 0, this.pos.dp['Product Price']).toFixed(this.pos.dp['Product Price']));
        var order_line_price = orderline.get_product().get_price(orderline.order.pricelist, this.get_quantity());
        order_line_price = round_di(orderline.compute_fixed_price(order_line_price), this.pos.currency.decimal_places);
        if( this.get_product().id !== orderline.get_product().id){    //only orderline of the same product can be merged
            return false;
        }else if(!this.get_unit() || !this.get_unit().is_pos_groupable){
            return false;
        }else if(this.get_discount() > 0){             // we don't merge discounted orderlines
            return false;
        }else if(!utils.float_is_zero(price - order_line_price - orderline.get_price_extra(),
                    this.pos.currency.decimal_places)){
            return false;
        }else if(this.product.tracking == 'lot' && (this.pos.picking_type.use_create_lots || this.pos.picking_type.use_existing_lots)) {
            return false;
        }else if (this.description !== orderline.description) {
            return false;
        }else if (orderline.get_customer_note() !== this.get_customer_note()) {
            return false;
        } else if (this.refunded_orderline_id) {
            return false;
        }else{
            return true;
        }
    }
    merge(orderline){
        this.order.assert_editable();
        this.set_quantity(this.get_quantity() + orderline.get_quantity());
    }
    export_as_JSON() {
        var pack_lot_ids = [];
        if (this.has_product_lot){
            this.pack_lot_lines.forEach(item => {
                return pack_lot_ids.push([0, 0, item.export_as_JSON()]);
            });
        }
        return {
            qty: this.get_quantity(),
            price_unit: this.get_unit_price(),
            price_subtotal: this.get_price_without_tax(),
            price_subtotal_incl: this.get_price_with_tax(),
            discount: this.get_discount(),
            product_id: this.get_product().id,
            tax_ids: [[6, false, _.map(this.get_applicable_taxes(), function(tax){ return tax.id; })]],
            id: this.id,
            pack_lot_ids: pack_lot_ids,
            description: this.description,
            full_product_name: this.get_full_product_name(),
            price_extra: this.get_price_extra(),
            customer_note: this.get_customer_note(),
            refunded_orderline_id: this.refunded_orderline_id,
            price_manually_set: this.price_manually_set,
            price_automatically_set: this.price_automatically_set,
        };
    }
    //used to create a json of the ticket, to be sent to the printer
    export_for_printing(){
        return {
            id: this.id,
            quantity:           this.get_quantity(),
            unit_name:          this.get_unit().name,
            is_in_unit:         this.get_unit().id == this.pos.uom_unit_id,
            price:              this.get_unit_display_price(),
            discount:           this.get_discount(),
            product_name:       this.get_product().display_name,
            product_name_wrapped: this.generate_wrapped_product_name(),
            price_lst:          this.get_taxed_lst_unit_price(),
            fixed_lst_price:    this.get_fixed_lst_price(),
            price_manually_set: this.price_manually_set,
            price_automatically_set: this.price_automatically_set,
            display_discount_policy:    this.display_discount_policy(),
            price_display_one:  this.get_display_price_one(),
            price_display :     this.get_display_price(),
            price_with_tax :    this.get_price_with_tax(),
            price_without_tax:  this.get_price_without_tax(),
            price_with_tax_before_discount:  this.get_price_with_tax_before_discount(),
            tax:                this.get_tax(),
            tax_percentages:    this.get_tax_percentages(),
            product_description:      this.get_product().description,
            product_description_sale: this.get_product().description_sale,
            pack_lot_lines:      this.get_lot_lines(),
            customer_note:      this.get_customer_note(),
            taxed_lst_unit_price: this.get_taxed_lst_unit_price(),
        };
    }
    generate_wrapped_product_name() {
        var MAX_LENGTH = 24; // 40 * line ratio of .6
        var wrapped = [];
        var name = this.get_full_product_name();
        var current_line = "";

        while (name.length > 0) {
            var space_index = name.indexOf(" ");

            if (space_index === -1) {
                space_index = name.length;
            }

            if (current_line.length + space_index > MAX_LENGTH) {
                if (current_line.length) {
                    wrapped.push(current_line);
                }
                current_line = "";
            }

            current_line += name.slice(0, space_index + 1);
            name = name.slice(space_index + 1);
        }

        if (current_line.length) {
            wrapped.push(current_line);
        }

        return wrapped;
    }
    // changes the base price of the product for this orderline
    set_unit_price(price){
        this.order.assert_editable();
        var parsed_price = !isNaN(price) ?
            price :
            isNaN(parseFloat(price)) ? 0 : field_utils.parse.float('' + price)
        this.price = round_di(parsed_price || 0, this.pos.dp['Product Price']);
    }
    get_unit_price(){
        var digits = this.pos.dp['Product Price'];
        // round and truncate to mimic _symbol_set behavior
        return parseFloat(round_di(this.price || 0, digits).toFixed(digits));
    }
    get_unit_display_price(){
        if (this.pos.config.iface_tax_included === 'total') {
            return this.get_all_prices(1).priceWithTax;
        } else {
            return this.get_unit_price();
        }
    }
    get_base_price(){
        var rounding = this.pos.currency.rounding;
        return round_pr(this.get_unit_price() * this.get_quantity() * (1 - this.get_discount()/100), rounding);
    }
    get_display_price_one(){
        var rounding = this.pos.currency.rounding;
        var price_unit = this.get_unit_price();
        if (this.pos.config.iface_tax_included !== 'total') {
            return round_pr(price_unit * (1.0 - (this.get_discount() / 100.0)), rounding);
        } else {
            var product =  this.get_product();
            var taxes_ids = this.tax_ids || product.taxes_id;
            var product_taxes = this.pos.get_taxes_after_fp(taxes_ids, this.order.fiscal_position);
            var all_taxes = this.compute_all(product_taxes, price_unit, 1, this.pos.currency.rounding);

            return round_pr(all_taxes.total_included * (1 - this.get_discount()/100), rounding);
        }
    }
    get_display_price(){
        if (this.pos.config.iface_tax_included === 'total') {
            return this.get_price_with_tax();
        } else {
            return this.get_base_price();
        }
    }
    get_taxed_lst_unit_price(){
        var lst_price = this.compute_fixed_price(this.get_lst_price());
        if (this.pos.config.iface_tax_included === 'total') {
            var product =  this.get_product();
            var taxes_ids = product.taxes_id;
            var product_taxes = this.pos.get_taxes_after_fp(taxes_ids);
            return this.compute_all(product_taxes, lst_price, 1, this.pos.currency.rounding).total_included;
        }
        var digits = this.pos.dp['Product Price'];
        return lst_price.toFixed(digits)
    }
    get_price_without_tax(){
        return this.get_all_prices().priceWithoutTax;
    }
    get_price_with_tax(){
        return this.get_all_prices().priceWithTax;
    }
    get_price_with_tax_before_discount () {
        return this.get_all_prices().priceWithTaxBeforeDiscount;
    }
    get_tax(){
        return this.get_all_prices().tax;
    }
    get_tax_percentages() {
        return this.get_all_prices().tax_percentages;
    }
    get_applicable_taxes(){
        var i;
        // Shenaningans because we need
        // to keep the taxes ordering.
        var ptaxes_ids = this.tax_ids || this.get_product().taxes_id;
        var ptaxes_set = {};
        for (i = 0; i < ptaxes_ids.length; i++) {
            ptaxes_set[ptaxes_ids[i]] = true;
        }
        var taxes = [];
        for (i = 0; i < this.pos.taxes.length; i++) {
            if (ptaxes_set[this.pos.taxes[i].id]) {
                taxes.push(this.pos.taxes[i]);
            }
        }
        return taxes;
    }
    get_tax_details(){
        return this.get_all_prices().taxDetails;
    }
    get_taxes(){
        var taxes_ids = this.tax_ids || this.get_product().taxes_id;
        var taxes = [];
        for (var i = 0; i < taxes_ids.length; i++) {
            if (this.pos.taxes_by_id[taxes_ids[i]]) {
                taxes.push(this.pos.taxes_by_id[taxes_ids[i]]);
            }
        }
        return taxes;
    }
    /**
     * Calculate the amount of taxes of a specific Orderline, that are included in the price.
     * @returns {Number} the total amount of price included taxes
     */
    get_total_taxes_included_in_price() {
        const productTaxes = this._getProductTaxesAfterFiscalPosition();
        const taxDetails = this.get_tax_details();
        return productTaxes
            .filter(tax => tax.price_include)
            .reduce((sum, tax) => sum + taxDetails[tax.id].amount,
            0
        );
    }
    _mapTaxFiscalPosition(tax, order = false) {
        return this.pos._mapTaxFiscalPosition(tax, order);
    }
    /**
     * Mirror JS method of:
     * _compute_amount in addons/account/models/account.py
     */
    _compute_all(tax, base_amount, quantity, price_exclude) {
        return this.pos._compute_all(tax, base_amount, quantity, price_exclude);
    }
    /**
     * Mirror JS method of:
     * compute_all in addons/account/models/account.py
     *
     * Read comments in the python side method for more details about each sub-methods.
     */
    compute_all(taxes, price_unit, quantity, currency_rounding, handle_price_include=true) {
        return this.pos.compute_all(taxes, price_unit, quantity, currency_rounding, handle_price_include);
    }
    /**
     * Calculates the taxes for a product, and converts the taxes based on the fiscal position of the order.
     *
     * @returns {Object} The calculated product taxes after filtering and fiscal position conversion.
     */
    _getProductTaxesAfterFiscalPosition() {
        const product = this.get_product();
        let taxesIds = this.tax_ids || product.taxes_id;
        taxesIds = _.filter(taxesIds, t => t in this.pos.taxes_by_id);
        return this.pos.get_taxes_after_fp(taxesIds, this.order.fiscal_position);
    }
    get_all_prices(qty = this.get_quantity()){
        var price_unit = this.get_unit_price() * (1.0 - (this.get_discount() / 100.0));
        var taxtotal = 0;

        var product =  this.get_product();
        var taxes_ids = this.tax_ids || product.taxes_id;
        taxes_ids = _.filter(taxes_ids, t => t in this.pos.taxes_by_id);
        var taxdetail = {};
        var product_taxes = this.pos.get_taxes_after_fp(taxes_ids, this.order.fiscal_position);

        var all_taxes = this.compute_all(product_taxes, price_unit, qty, this.pos.currency.rounding);
        var all_taxes_before_discount = this.compute_all(product_taxes, this.get_unit_price(), qty, this.pos.currency.rounding);
        _(all_taxes.taxes).each(function(tax) {
            taxtotal += tax.amount;
            taxdetail[tax.id] = {
                amount: tax.amount,
                base: tax.base,
            };
        });

        return {
            "priceWithTax": all_taxes.total_included,
            "priceWithoutTax": all_taxes.total_excluded,
            "priceWithTaxBeforeDiscount": all_taxes_before_discount.total_included,
            "tax": taxtotal,
            "taxDetails": taxdetail,
            "tax_percentages": product_taxes.map((tax) => tax.amount),
        };
    }
    display_discount_policy(){
        return this.order.pricelist.discount_policy;
    }
    compute_fixed_price (price) {
        var order = this.order;
        if(order.fiscal_position) {
            var taxes = this.get_taxes();
            var mapped_included_taxes = [];
            var new_included_taxes = [];
            var self = this;
            _(taxes).each(function(tax) {
                var line_taxes = self.pos.get_taxes_after_fp([tax.id], order.fiscal_position);
                if (line_taxes.length && line_taxes[0].price_include){
                    new_included_taxes = new_included_taxes.concat(line_taxes);
                }
                if(tax.price_include && !_.contains(line_taxes, tax)){
                    mapped_included_taxes.push(tax);
                }
            });

            if (mapped_included_taxes.length > 0) {
                if (new_included_taxes.length > 0) {
                    var price_without_taxes = this.compute_all(mapped_included_taxes, price, 1, order.pos.currency.rounding, true).total_excluded
                    return this.compute_all(new_included_taxes, price_without_taxes, 1, order.pos.currency.rounding, false).total_included
                }
                else{
                    return this.compute_all(mapped_included_taxes, price, 1, order.pos.currency.rounding, true).total_excluded;
                }
            }
        }
        return price;
    }
    get_fixed_lst_price(){
        return this.compute_fixed_price(this.get_lst_price());
    }
    get_lst_price(){
        return this.product.get_price(this.pos.default_pricelist, 1, 0)
    }
    set_lst_price(price){
      this.order.assert_editable();
      this.product.lst_price = round_di(parseFloat(price) || 0, this.pos.dp['Product Price']);
    }
    is_last_line() {
        var order = this.pos.get_order();
        var orderlines = order.orderlines;
        var last_id = orderlines[orderlines.length - 1].cid;
        var selectedLine = order? order.selected_orderline: null;

        return !selectedLine ? false : last_id === selectedLine.cid;
    }
    set_customer_note(note) {
        this.customerNote = note;
    }
    get_customer_note() {
        return this.customerNote;
    }
    get_total_cost() {
        return this.product.standard_price * this.quantity;
    }
}
Registries.Model.add(Orderline);

class Packlotline extends PosModel {
    constructor(obj, options){
        super(obj);
        this.lot_name = null;
        this.order_line = options.order_line;
        if (options.json) {
            this.init_from_JSON(options.json);
            return;
        }
    }

    init_from_JSON(json) {
        this.order_line = json.order_line;
        this.set_lot_name(json.lot_name);
    }

    set_lot_name(name){
        this.lot_name = _.str.trim(name) || null;
    }

    get_lot_name(){
        return this.lot_name;
    }

    export_as_JSON(){
        return {
            lot_name: this.get_lot_name(),
        };
    }
}
Registries.Model.add(Packlotline);

// Every Paymentline contains a cashregister and an amount of money.
class Payment extends PosModel {
    constructor(obj, options) {
        super(obj);
        this.pos = options.pos;
        this.order = options.order;
        this.amount = 0;
        this.selected = false;
        this.cashier_receipt = '';
        this.ticket = '';
        this.payment_status = '';
        this.card_type = '';
        this.cardholder_name = '';
        this.transaction_id = '';

        if (options.json) {
            this.init_from_JSON(options.json);
            return;
        }
        this.payment_method = options.payment_method;
        if (this.payment_method === undefined) {
            throw new Error(_t('Please configure a payment method in your POS.'));
        }
        this.name = this.payment_method.name;
    }
    init_from_JSON(json){
        this.amount = json.amount;
        this.payment_method = this.pos.payment_methods_by_id[json.payment_method_id];
        this.can_be_reversed = json.can_be_reversed;
        this.name = this.payment_method.name;
        this.payment_status = json.payment_status;
        this.ticket = json.ticket;
        this.card_type = json.card_type;
        this.cardholder_name = json.cardholder_name;
        this.transaction_id = json.transaction_id;
        this.is_change = json.is_change;
    }
    //sets the amount of money on this payment line
    set_amount(value){
        this.order.assert_editable();
        this.amount = round_di(parseFloat(value) || 0, this.pos.currency.decimal_places);
    }
    // returns the amount of money on this paymentline
    get_amount(){
        return this.amount;
    }
    get_amount_str(){
        return field_utils.format.float(this.amount, {digits: [69, this.pos.currency.decimal_places]});
    }
    set_selected(selected){
        if(this.selected !== selected){
            this.selected = selected;
        }
    }
    /**
     * returns {string} payment status.
     */
    get_payment_status() {
        return this.payment_status;
    }

    /**
     * Set the new payment status.
     *
     * @param {string} value - new status.
     */
    set_payment_status(value) {
        this.payment_status = value;
    }

    /**
     * Check if paymentline is done.
     * Paymentline is done if there is no payment status or the payment status is done.
     */
    is_done() {
        return this.get_payment_status() ? this.get_payment_status() === 'done' || this.get_payment_status() === 'reversed': true;
    }

    /**
    * Set info to be printed on the cashier receipt. value should
    * be compatible with both the QWeb and ESC/POS receipts.
    *
    * @param {string} value - receipt info
    */
    set_cashier_receipt (value) {
        this.cashier_receipt = value;
    }

    /**
     * Set additional info to be printed on the receipts. value should
     * be compatible with both the QWeb and ESC/POS receipts.
     *
     * @param {string} value - receipt info
     */
    set_receipt_info(value) {
        this.ticket += value;
    }

    // returns the associated cashregister
    //exports as JSON for server communication
    export_as_JSON(){
        return {
            name: time.datetime_to_str(new Date()),
            payment_method_id: this.payment_method.id,
            amount: this.get_amount(),
            payment_status: this.payment_status,
            can_be_reversed: this.can_be_resersed,
            ticket: this.ticket,
            card_type: this.card_type,
            cardholder_name: this.cardholder_name,
            transaction_id: this.transaction_id,
        };
    }
    //exports as JSON for receipt printing
    export_for_printing(){
        const ticket = escape(this.ticket).replace(/\n/g, "<br />"); // formatting
        return {
            cid: this.cid,
            amount: this.get_amount(),
            name: this.name,
            ticket: Markup(ticket),
        };
    }
    // If payment status is a non-empty string, then it is an electronic payment.
    // TODO: There has to be a less confusing way to distinguish simple payments
    // from electronic transactions. Perhaps use a flag?
    is_electronic() {
        return Boolean(this.get_payment_status());
    }
}
Registries.Model.add(Payment);

// An order more or less represents the content of a customer's shopping cart (the OrderLines)
// plus the associated payment information (the Paymentlines)
// there is always an active ('selected') order in the Pos, a new one is created
// automaticaly once an order is completed and sent to the server.
class Order extends PosModel {
    constructor(obj, options) {
        super(obj);
        var self = this;
        options  = options || {};

        this.locked         = false;
        this.pos            = options.pos;
        this.selected_orderline   = undefined;
        this.selected_paymentline = undefined;
        this.screen_data    = {};  // see Gui
        this.temporary      = options.temporary || false;
        this.creation_date  = new Date();
        this.to_invoice     = false;
        this.orderlines     = new PosCollection();
        this.paymentlines   = new PosCollection();
        this.pos_session_id = this.pos.pos_session.id;
        this.cashier        = this.pos.get_cashier();
        this.finalized      = false; // if true, cannot be modified.

        this.partner = null;

        this.uiState = {
            ReceiptScreen: {
                inputEmail: '',
                // if null: not yet tried to send
                // if false/true: tried sending email
                emailSuccessful: null,
                emailNotice: '',
            },
            // TODO: This should be in pos_restaurant.
            TipScreen: {
                inputTipAmount: '',
            }
        };

        if (options.json) {
            this.init_from_JSON(options.json);
        } else {
            this.set_pricelist(this.pos.default_pricelist);
            this.sequence_number = this.pos.pos_session.sequence_number++;
            this.access_token = uuidv4();  // unique uuid used to identify the authenticity of the request from the QR code.
            this.uid  = this.generate_unique_id();
            this.name = _.str.sprintf(_t("Order %s"), this.uid);
            this.validation_date = undefined;
            this.fiscal_position = _.find(this.pos.fiscal_positions, function(fp) {
                return fp.id === self.pos.config.default_fiscal_position_id[0];
            });
        }
    }
    save_to_db(){
        if (!this.temporary && !this.locked && !this.finalized) {
            this.assert_editable();
            this.pos.db.save_unpaid_order(this);
        }
    }
    /**
     * Initialize PoS order from a JSON string.
     *
     * If the order was created in another session, the sequence number should be changed so it doesn't conflict
     * with orders in the current session.
     * Else, the sequence number of the session should follow on the sequence number of the loaded order.
     *
     * @param {object} json JSON representing one PoS order.
     */
    init_from_JSON(json) {
        let partner;
        if (json.state && ['done', 'invoiced', 'paid'].includes(json.state)) {
            this.sequence_number = json.sequence_number;
        } else if (json.pos_session_id !== this.pos.pos_session.id) {
            this.sequence_number = this.pos.pos_session.sequence_number++;
        } else {
            this.sequence_number = json.sequence_number;
            this.pos.pos_session.sequence_number = Math.max(this.sequence_number+1,this.pos.pos_session.sequence_number);
        }
        this.session_id = this.pos.pos_session.id;
        this.uid = json.uid;
        this.name = _.str.sprintf(_t("Order %s"), this.uid);
        this.validation_date = json.creation_date;
        this.server_id = json.server_id ? json.server_id : false;
        this.user_id = json.user_id;

        if (json.fiscal_position_id) {
            var fiscal_position = _.find(this.pos.fiscal_positions, function (fp) {
                return fp.id === json.fiscal_position_id;
            });

            if (fiscal_position) {
                this.fiscal_position = fiscal_position;
            } else {
                console.error('ERROR: trying to load a fiscal position not available in the pos');
            }
        }

        if (json.pricelist_id) {
            this.pricelist = _.find(this.pos.pricelists, function (pricelist) {
                return pricelist.id === json.pricelist_id;
            });
        } else {
            this.pricelist = this.pos.default_pricelist;
        }

        if (json.partner_id) {
            partner = this.pos.db.get_partner_by_id(json.partner_id);
            if (!partner) {
                console.error('ERROR: trying to load a partner not available in the pos');
            }
        } else {
            partner = null;
        }
        this.partner = partner;

        this.temporary = false;     // FIXME
        this.to_invoice = false;    // FIXME
        this.to_ship = false;

        var orderlines = json.lines;
        for (var i = 0; i < orderlines.length; i++) {
            var orderline = orderlines[i][2];
            if (this.pos.db.get_product_by_id(orderline.product_id)) {
                this.add_orderline(Orderline.create({}, { pos: this.pos, order: this, json: orderline }));
            }
        }

        var paymentlines = json.statement_ids;
        for (var i = 0; i < paymentlines.length; i++) {
            var paymentline = paymentlines[i][2];
            var newpaymentline = Payment.create({},{pos: this.pos, order: this, json: paymentline});
            this.paymentlines.add(newpaymentline);

            if (i === paymentlines.length - 1) {
                this.select_paymentline(newpaymentline);
            }
        }

        // Tag this order as 'locked' if it is already paid.
        this.locked = ['paid', 'done', 'invoiced'].includes(json.state);
        this.state = json.state;
        this.amount_return = json.amount_return;
        this.account_move = json.account_move;
        this.backendId = json.id;
        this.is_tipped = json.is_tipped || false;
        this.tip_amount = json.tip_amount || 0;
        this.access_token = json.access_token || '';
    }
    export_as_JSON() {
        var orderLines, paymentLines;
        orderLines = [];
        this.orderlines.forEach(item => {
            return orderLines.push([0, 0, item.export_as_JSON()]);
        });
        paymentLines = [];
        this.paymentlines.forEach(_.bind( function(item) {
            return paymentLines.push([0, 0, item.export_as_JSON()]);
        }, this));
        var json = {
            name: this.get_name(),
            amount_paid: this.get_total_paid() - this.get_change(),
            amount_total: this.get_total_with_tax(),
            amount_tax: this.get_total_tax(),
            amount_return: this.get_change(),
            lines: orderLines,
            statement_ids: paymentLines,
            pos_session_id: this.pos_session_id,
            pricelist_id: this.pricelist ? this.pricelist.id : false,
            partner_id: this.get_partner() ? this.get_partner().id : false,
            user_id: this.pos.user.id,
            uid: this.uid,
            sequence_number: this.sequence_number,
            creation_date: this.validation_date || this.creation_date, // todo: rename creation_date in master
            fiscal_position_id: this.fiscal_position ? this.fiscal_position.id : false,
            server_id: this.server_id ? this.server_id : false,
            to_invoice: this.to_invoice ? this.to_invoice : false,
            to_ship: this.to_ship ? this.to_ship : false,
            is_tipped: this.is_tipped || false,
            tip_amount: this.tip_amount || 0,
            access_token: this.access_token || '',
        };
        if (!this.is_paid && this.user_id) {
            json.user_id = this.user_id;
        }
        return json;
    }
    export_for_printing(){
        var orderlines = [];
        var self = this;

        this.orderlines.forEach(function(orderline){
            orderlines.push(orderline.export_for_printing());
        });

        // If order is locked (paid), the 'change' is saved as negative payment,
        // and is flagged with is_change = true. A receipt that is printed first
        // time doesn't show this negative payment so we filter it out.
        var paymentlines = this.paymentlines
            .filter(function (paymentline) {
                return !paymentline.is_change;
            })
            .map(function (paymentline) {
                return paymentline.export_for_printing();
            });
        let partner = this.partner;
        let cashier = this.pos.get_cashier();
        let company = this.pos.company;
        let date    = new Date();

        function is_html(subreceipt){
            return subreceipt ? (subreceipt.split('\n')[0].indexOf('<!DOCTYPE QWEB') >= 0) : false;
        }

        function render_html(subreceipt){
            if (!is_html(subreceipt)) {
                return subreceipt;
            } else {
                subreceipt = subreceipt.split('\n').slice(1).join('\n');
                var qweb = new QWeb2.Engine();
                    qweb.debug = config.isDebug();
                    qweb.default_dict = _.clone(QWeb.default_dict);
                    qweb.add_template('<templates><t t-name="subreceipt">'+subreceipt+'</t></templates>');

                return qweb.render('subreceipt',{'pos':self.pos,'order':self, 'receipt': receipt}) ;
            }
        }

        var receipt = {
            orderlines: orderlines,
            paymentlines: paymentlines,
            subtotal: this.get_subtotal(),
            total_with_tax: this.get_total_with_tax(),
            total_rounded: this.get_total_with_tax() + this.get_rounding_applied(),
            total_without_tax: this.get_total_without_tax(),
            total_tax: this.get_total_tax(),
            total_paid: this.get_total_paid(),
            total_discount: this.get_total_discount(),
            rounding_applied: this.get_rounding_applied(),
            tax_details: this.get_tax_details(),
            change: this.locked ? this.amount_return : this.get_change(),
            name : this.get_name(),
            partner: partner ? partner : null ,
            invoice_id: null,   //TODO
            cashier: cashier ? cashier.name : null,
            precision: {
                price: 2,
                money: 2,
                quantity: 3,
            },
            date: {
                year: date.getFullYear(),
                month: date.getMonth(),
                date: date.getDate(),       // day of the month
                day: date.getDay(),         // day of the week
                hour: date.getHours(),
                minute: date.getMinutes() ,
                isostring: date.toISOString(),
                localestring: this.formatted_validation_date,
                validation_date: this.validation_date,
            },
            company:{
                email: company.email,
                website: company.website,
                company_registry: company.company_registry,
                contact_address: company.partner_id[1],
                vat: company.vat,
                vat_label: company.country && company.country.vat_label || _t('Tax ID'),
                name: company.name,
                phone: company.phone,
                logo:  this.pos.company_logo_base64,
            },
            currency: this.pos.currency,
            pos_qr_code: this._get_qr_code_data(),
        };

        if (is_html(this.pos.config.receipt_header)){
            receipt.header = '';
            receipt.header_html = render_html(this.pos.config.receipt_header);
        } else {
            receipt.header = this.pos.config.receipt_header || '';
        }

        if (is_html(this.pos.config.receipt_footer)){
            receipt.footer = '';
            receipt.footer_html = render_html(this.pos.config.receipt_footer);
        } else {
            receipt.footer = this.pos.config.receipt_footer || '';
        }
        if (!receipt.date.localestring && (!this.state || this.state == 'draft')){
            receipt.date.localestring = field_utils.format.datetime(moment(new Date()), {}, {timezone: false});
        }

        return receipt;
    }
    is_empty(){
        return this.orderlines.length === 0;
    }
    generate_unique_id() {
        // Generates a public identification number for the order.
        // The generated number must be unique and sequential. They are made 12 digit long
        // to fit into EAN-13 barcodes, should it be needed

        function zero_pad(num,size){
            var s = ""+num;
            while (s.length < size) {
                s = "0" + s;
            }
            return s;
        }
        return zero_pad(this.pos.pos_session.id,5) +'-'+
               zero_pad(this.pos.pos_session.login_number,3) +'-'+
               zero_pad(this.sequence_number,4);
    }
    get_name() {
        return this.name;
    }
    assert_editable() {
        if (this.finalized) {
            throw new Error('Finalized Order cannot be modified');
        }
    }
    /* ---- Order Lines --- */
    add_orderline(line){
        this.assert_editable();
        if(line.order){
            line.order.remove_orderline(line);
        }
        line.order = this;
        this.orderlines.add(line);
        this.select_orderline(this.get_last_orderline());
    }
    get_orderline(id){
        var orderlines = this.orderlines;
        for(var i = 0; i < orderlines.length; i++){
            if(orderlines[i].id === id){
                return orderlines[i];
            }
        }
        return null;
    }
    get_orderlines(){
        return this.orderlines;
    }
    /**
     * Groups the orderlines of the specific order according to the taxes applied to them. The orderlines that have
     * the exact same combination of taxes are grouped together.
     *
     * @returns {tax_ids: Orderlines[]} contains pairs of tax_ids (in csv format) and arrays of Orderlines
     * with the corresponding tax_ids.
     * e.g. {
     *  '1,2': [Orderline_A, Orderline_B],
     *  '3': [Orderline_C],
     * }
     */
    get_orderlines_grouped_by_tax_ids() {
        let orderlines_by_tax_group = {};
        const lines = this.get_orderlines();
        for (let line of lines) {
            const tax_group = this._get_tax_group_key(line);
            if (!(tax_group in orderlines_by_tax_group)) {
                orderlines_by_tax_group[tax_group] = [];
            }
            orderlines_by_tax_group[tax_group].push(line);
        }
        return orderlines_by_tax_group;
    }
    _get_tax_group_key(line) {
        return line
            ._getProductTaxesAfterFiscalPosition()
            .map(tax => tax.id)
            .join(',');
    }
    /**
     * Calculate the amount that will be used as a base in order to apply a downpayment or discount product in PoS.
     * In our calculation we take into account taxes that are included in the price.
     *
     * @param  {String} tax_ids a string of the tax ids that are applied on the orderlines, in csv format
     * e.g. if taxes with ids 2, 5 and 6 are applied tax_ids will be "2,5,6"
     * @param  {Orderline[]} lines an srray of Orderlines
     * @return {Number} the base amount on which we will apply a percentile reduction
     */
    calculate_base_amount(tax_ids_array, lines) {
        // Consider price_include taxes use case
        let has_taxes_included_in_price = tax_ids_array.filter(tax_id =>
            this.pos.taxes_by_id[tax_id].price_include
        ).length;

        let base_amount = lines.reduce((sum, line) =>
                sum +
                line.get_price_without_tax() +
                (has_taxes_included_in_price ? line.get_total_taxes_included_in_price() : 0),
            0
        );
        return base_amount;
    }
    get_last_orderline(){
        const orderlines = this.orderlines;
        return this.orderlines.at(orderlines.length -1);
    }
    get_tip() {
        var tip_product = this.pos.db.get_product_by_id(this.pos.config.tip_product_id[0]);
        var lines = this.get_orderlines();
        if (!tip_product) {
            return 0;
        } else {
            for (var i = 0; i < lines.length; i++) {
                if (lines[i].get_product() === tip_product) {
                    return lines[i].get_unit_price();
                }
            }
            return 0;
        }
    }

    initialize_validation_date () {
        this.validation_date = new Date();
        this.formatted_validation_date = field_utils.format.datetime(
            moment(this.validation_date), {}, {timezone: false});
    }

    set_tip(tip) {
        var tip_product = this.pos.db.get_product_by_id(this.pos.config.tip_product_id[0]);
        var lines = this.get_orderlines();
        if (tip_product) {
            for (var i = 0; i < lines.length; i++) {
                if (lines[i].get_product() === tip_product) {
                    lines[i].set_unit_price(tip);
                    lines[i].set_lst_price(tip);
                    lines[i].price_automatically_set = true;
                    lines[i].order.tip_amount = tip;
                    return;
                }
            }
            return this.add_product(tip_product, {
              is_tip: true,
              quantity: 1,
              price: tip,
              lst_price: tip,
              extras: {price_automatically_set: true},
            });
        }
    }
    set_fiscal_position(fiscal_position) {
        this.fiscal_position = fiscal_position;
    }
    set_pricelist (pricelist) {
        var self = this;
        this.pricelist = pricelist;

        var lines_to_recompute = _.filter(this.get_orderlines(), function (line) {
            return ! (line.price_manually_set || line.price_automatically_set);
        });
        _.each(lines_to_recompute, function (line) {
            line.set_unit_price(line.product.get_price(self.pricelist, line.get_quantity(), line.get_price_extra()));
            self.fix_tax_included_price(line);
        });
    }
    remove_orderline( line ){
        this.assert_editable();
        this.orderlines.remove(line);
        this.select_orderline(this.get_last_orderline());
    }

    fix_tax_included_price(line){
        line.set_unit_price(line.compute_fixed_price(line.price));
    }

    _isRefundAndSaleOrder() {
        if (this.orderlines.length && this.orderlines[0].refunded_orderline_id) {
            return true;
        }
        return false;
    }

    add_product(product, options){
        if(this.pos.doNotAllowRefundAndSales() &&
        this._isRefundAndSaleOrder() &&
        (!options.quantity || options.quantity > 0)) {
            Gui.showPopup('ErrorPopup', {
                title: _t('Refund and Sales not allowed'),
                body: _t('It is not allowed to mix refunds and sales')
            });
            return;
        }
        if(this._printed){
            // when adding product with a barcode while being in receipt screen
            this.pos.removeOrder(this);
            return this.pos.add_new_order().add_product(product, options);
        }
        this.assert_editable();
        options = options || {};
        var line = Orderline.create({}, {pos: this.pos, order: this, product: product});
        this.fix_tax_included_price(line);

        this.set_orderline_options(line, options);

        var to_merge_orderline;
        for (var i = 0; i < this.orderlines.length; i++) {
            if(this.orderlines.at(i).can_be_merged_with(line) && options.merge !== false){
                to_merge_orderline = this.orderlines.at(i);
            }
        }
        if (to_merge_orderline){
            to_merge_orderline.merge(line);
            this.select_orderline(to_merge_orderline);
        } else {
            this.add_orderline(line);
            this.select_orderline(this.get_last_orderline());
        }

        if (options.draftPackLotLines) {
            this.selected_orderline.setPackLotLines(options.draftPackLotLines);
        }
    }
    set_orderline_options(orderline, options) {
        if(options.quantity !== undefined){
            orderline.set_quantity(options.quantity);
        }

        if (options.price_extra !== undefined){
            orderline.price_extra = options.price_extra;
            orderline.set_unit_price(orderline.product.get_price(this.pricelist, orderline.get_quantity(), options.price_extra));
            this.fix_tax_included_price(orderline);
        }

        if(options.price !== undefined){
            orderline.set_unit_price(options.price);
            this.fix_tax_included_price(orderline);
        }

        if(options.lst_price !== undefined){
            orderline.set_lst_price(options.lst_price);
        }

        if(options.discount !== undefined){
            orderline.set_discount(options.discount);
        }

        if (options.description !== undefined){
            orderline.description += options.description;
        }

        if(options.extras !== undefined){
            for (var prop in options.extras) {
                orderline[prop] = options.extras[prop];
            }
        }
        if (options.is_tip) {
            this.is_tipped = true;
            this.tip_amount = options.price;
        }
        if (options.refunded_orderline_id) {
            orderline.refunded_orderline_id = options.refunded_orderline_id;
        }
        if (options.tax_ids) {
            orderline.tax_ids = options.tax_ids;
        }
    }
    get_selected_orderline(){
        return this.selected_orderline;
    }
    select_orderline(line){
        if(line){
            if(line !== this.selected_orderline){
                // if line (new line to select) is not the same as the old
                // selected_orderline, then we set the old line to false,
                // and set the new line to true. Also, set the new line as
                // the selected_orderline.
                if(this.selected_orderline){
                    this.selected_orderline.set_selected(false);
                }
                this.selected_orderline = line;
                this.selected_orderline.set_selected(true);
            }
        }else{
            this.selected_orderline = undefined;
        }
        this.pos.numpadMode = 'quantity';
    }
    deselect_orderline(){
        if(this.selected_orderline){
            this.selected_orderline.set_selected(false);
            this.selected_orderline = undefined;
        }
    }

    /* ---- Payment Lines --- */
    add_paymentline(payment_method) {
        this.assert_editable();
        if (this.electronic_payment_in_progress()) {
            return false;
        } else {
            var newPaymentline = Payment.create({},{order: this, payment_method:payment_method, pos: this.pos});
            this.paymentlines.add(newPaymentline);
            this.select_paymentline(newPaymentline);
            if(this.pos.config.cash_rounding){
              this.selected_paymentline.set_amount(0);
            }
            newPaymentline.set_amount(this.get_due());

            if (payment_method.payment_terminal) {
                newPaymentline.set_payment_status('pending');
            }
            return newPaymentline;
        }
    }
    get_paymentlines(){
        return this.paymentlines;
    }
    /**
     * Retrieve the paymentline with the specified cid
     *
     * @param {String} cid
     */
    get_paymentline (cid) {
        var lines = this.get_paymentlines();
        return lines.find(function (line) {
            return line.cid === cid;
        });
    }
    remove_paymentline(line){
        this.assert_editable();
        if(this.selected_paymentline === line){
            this.select_paymentline(undefined);
        }
        this.paymentlines.remove(line);
    }
    clean_empty_paymentlines() {
        var lines = this.paymentlines;
        var empty = [];
        for ( var i = 0; i < lines.length; i++) {
            if (!lines[i].get_amount()) {
                empty.push(lines[i]);
            }
        }
        for ( var i = 0; i < empty.length; i++) {
            this.remove_paymentline(empty[i]);
        }
    }
    select_paymentline(line){
        if(line !== this.selected_paymentline){
            if(this.selected_paymentline){
                this.selected_paymentline.set_selected(false);
            }
            this.selected_paymentline = line;
            if(this.selected_paymentline){
                this.selected_paymentline.set_selected(true);
            }
        }
    }
    electronic_payment_in_progress() {
        return this.get_paymentlines()
            .some(function(pl) {
                if (pl.payment_status) {
                    return !['done', 'reversed'].includes(pl.payment_status);
                } else {
                    return false;
                }
            });
    }
    /**
     * Stops a payment on the terminal if one is running
     */
    stop_electronic_payment () {
        var lines = this.get_paymentlines();
        var line = lines.find(function (line) {
            var status = line.get_payment_status();
            return status && !['done', 'reversed', 'reversing', 'pending', 'retry'].includes(status);
        });
        if (line) {
            line.set_payment_status('waitingCancel');
            line.payment_method.payment_terminal.send_payment_cancel(this, line.cid).finally(function () {
                line.set_payment_status('retry');
            });
        }
    }
    /* ---- Payment Status --- */
    get_subtotal(){
        return round_pr(this.orderlines.reduce((function(sum, orderLine){
            return sum + orderLine.get_display_price();
        }), 0), this.pos.currency.rounding);
    }
    get_total_with_tax() {
        return this.get_total_without_tax() + this.get_total_tax();
    }
    get_total_without_tax() {
        return round_pr(this.orderlines.reduce((function(sum, orderLine) {
            return sum + orderLine.get_price_without_tax();
        }), 0), this.pos.currency.rounding);
    }
    _get_ignored_product_ids_total_discount() {
        return [];
    }
    _reduce_total_discount_callback(sum, orderLine) {
        sum += (orderLine.get_unit_price() * (orderLine.get_discount()/100) * orderLine.get_quantity());
        if (orderLine.display_discount_policy() === 'without_discount'){
            sum += ((orderLine.get_taxed_lst_unit_price() - orderLine.get_unit_price()) * orderLine.get_quantity());
        }
        return sum;
    }
    get_total_discount() {
        const ignored_product_ids = this._get_ignored_product_ids_total_discount()
        return round_pr(this.orderlines.reduce((sum, orderLine) => {
            if (!ignored_product_ids.includes(orderLine.product.id)) {
                sum += (orderLine.get_unit_price() * (orderLine.get_discount()/100) * orderLine.get_quantity());
                if (orderLine.display_discount_policy() === 'without_discount'){
                    sum += ((orderLine.get_lst_price() - orderLine.get_unit_price()) * orderLine.get_quantity());
                }
            }
            return sum;
        }, 0), this.pos.currency.rounding);
    }
    get_total_tax() {
        if (this.pos.company.tax_calculation_rounding_method === "round_globally") {
            // As always, we need:
            // 1. For each tax, sum their amount across all order lines
            // 2. Round that result
            // 3. Sum all those rounded amounts
            var groupTaxes = {};
            this.orderlines.forEach(function (line) {
                var taxDetails = line.get_tax_details();
                var taxIds = Object.keys(taxDetails);
                for (var t = 0; t<taxIds.length; t++) {
                    var taxId = taxIds[t];
                    if (!(taxId in groupTaxes)) {
                        groupTaxes[taxId] = 0;
                    }
                    groupTaxes[taxId] += taxDetails[taxId].amount;
                }
            });

            var sum = 0;
            var taxIds = Object.keys(groupTaxes);
            for (var j = 0; j<taxIds.length; j++) {
                var taxAmount = groupTaxes[taxIds[j]];
                sum += round_pr(taxAmount, this.pos.currency.rounding);
            }
            return sum;
        } else {
            return round_pr(this.orderlines.reduce((function(sum, orderLine) {
                return sum + orderLine.get_tax();
            }), 0), this.pos.currency.rounding);
        }
    }
    get_total_paid() {
        return round_pr(this.paymentlines.reduce((function(sum, paymentLine) {
            if (paymentLine.is_done()) {
                sum += paymentLine.get_amount();
            }
            return sum;
        }), 0), this.pos.currency.rounding);
    }
    get_tax_details(){
        var details = {};
        var fulldetails = [];

        this.orderlines.forEach(function(line){
            var ldetails = line.get_tax_details();
            for(var id in ldetails){
                if(ldetails.hasOwnProperty(id)){
                    let amount = (details[id] && details[id].amount) ? details[id].amount : 0;
                    let base = (details[id] && details[id].base) ? details[id].base : 0;
                    details[id] = {
                        amount: amount + ldetails[id].amount,
                        base: base + ldetails[id].base,
                    };
                }
            }
        });

        for(var id in details){
            if(details.hasOwnProperty(id)){
                fulldetails.push({amount: details[id].amount, base: details[id].base, tax: this.pos.taxes_by_id[id], name: this.pos.taxes_by_id[id].name});
            }
        }

        return fulldetails;
    }
    // Returns a total only for the orderlines with products belonging to the category
    get_total_for_category_with_tax(categ_id){
        var total = 0;
        var self = this;

        if (categ_id instanceof Array) {
            for (var i = 0; i < categ_id.length; i++) {
                total += this.get_total_for_category_with_tax(categ_id[i]);
            }
            return total;
        }

        this.orderlines.forEach(function(line){
            if ( self.pos.db.category_contains(categ_id,line.product.id) ) {
                total += line.get_price_with_tax();
            }
        });

        return total;
    }
    get_total_for_taxes(tax_id){
        var total = 0;

        if (!(tax_id instanceof Array)) {
            tax_id = [tax_id];
        }

        var tax_set = {};

        for (var i = 0; i < tax_id.length; i++) {
            tax_set[tax_id[i]] = true;
        }

        this.orderlines.forEach(line => {
            var taxes_ids = this.tax_ids || line.get_product().taxes_id;
            for (var i = 0; i < taxes_ids.length; i++) {
                if (tax_set[taxes_ids[i]]) {
                    total += line.get_price_with_tax();
                    return;
                }
            }
        });

        return total;
    }
    get_change(paymentline) {
        if (!paymentline) {
            var change = this.get_total_paid() - this.get_total_with_tax() - this.get_rounding_applied();
        } else {
            var change = -this.get_total_with_tax();
            var lines  = this.paymentlines;
            for (var i = 0; i < lines.length; i++) {
                change += lines[i].get_amount();
                if (lines[i] === paymentline) {
                    break;
                }
            }
        }
        return round_pr(Math.max(0,change), this.pos.currency.rounding);
    }
    get_due(paymentline) {
        if (!paymentline) {
            var due = this.get_total_with_tax() - this.get_total_paid() + this.get_rounding_applied();
        } else {
            var due = this.get_total_with_tax();
            var lines = this.paymentlines;
            for (var i = 0; i < lines.length; i++) {
                if (lines[i] === paymentline) {
                    break;
                } else {
                    due -= lines[i].get_amount();
                }
            }
        }
        return round_pr(due, this.pos.currency.rounding);
    }
    get_rounding_applied() {
        if(this.pos.config.cash_rounding) {
            const only_cash = this.pos.config.only_round_cash_method;
            const paymentlines = this.get_paymentlines();
            const last_line = paymentlines ? paymentlines[paymentlines.length-1]: false;
            const last_line_is_cash = last_line ? last_line.payment_method.is_cash_count == true: false;
            if (!only_cash || (only_cash && last_line_is_cash)) {
                var rounding_method = this.pos.cash_rounding[0].rounding_method;
                var remaining = this.get_total_with_tax() - this.get_total_paid();
                var sign = this.get_total_with_tax() > 0 ? 1.0 : -1.0;
                if(rounding_method !== "HALF-UP" && (this.get_total_with_tax() < 0 && remaining > 0 || this.get_total_with_tax() > 0 && remaining < 0)) {
                    rounding_method = rounding_method === "UP" ? "DOWN" : "UP";
                }

                remaining *= sign;
                var total = round_pr(remaining, this.pos.cash_rounding[0].rounding);
                var rounding_applied = total - remaining;

                // because floor and ceil doesn't include decimals in calculation, we reuse the value of the half-up and adapt it.
                if (utils.float_is_zero(rounding_applied, this.pos.currency.decimal_places)){
                    // https://xkcd.com/217/
                    return 0;
                } else if(Math.abs(this.get_total_with_tax()) < this.pos.cash_rounding[0].rounding) {
                    return 0;
                } else if(rounding_method === "UP" && rounding_applied < 0 && remaining > 0) {
                    rounding_applied += this.pos.cash_rounding[0].rounding;
                }
                else if(rounding_method === "UP" && rounding_applied > 0 && remaining < 0) {
                    rounding_applied -= this.pos.cash_rounding[0].rounding;
                }
                else if(rounding_method === "DOWN" && rounding_applied > 0 && remaining > 0){
                    rounding_applied -= this.pos.cash_rounding[0].rounding;
                }
                else if(rounding_method === "DOWN" && rounding_applied < 0 && remaining < 0){
                    rounding_applied += this.pos.cash_rounding[0].rounding;
                }
                else if(rounding_method === "HALF-UP" && rounding_applied === this.pos.cash_rounding[0].rounding / -2){
                    rounding_applied += this.pos.cash_rounding[0].rounding;
                }
                return sign * rounding_applied;
            }
            else {
                return 0;
            }
        }
        return 0;
    }
    has_not_valid_rounding() {
        if(!this.pos.config.cash_rounding || this.get_total_with_tax() < this.pos.cash_rounding[0].rounding)
            return false;

        const only_cash = this.pos.config.only_round_cash_method;
        var lines = this.paymentlines;

        for(var i = 0; i < lines.length; i++) {
            var line = lines[i];
            if (only_cash && !line.payment_method.is_cash_count)
                continue;

            if(!utils.float_is_zero(line.amount - round_pr(line.amount, this.pos.cash_rounding[0].rounding), 6))
                return line;
        }
        return false;
    }
    is_paid(){
        return this.get_due() <= 0 && this.check_paymentlines_rounding();
    }
    is_paid_with_cash(){
        return !!this.paymentlines.find( function(pl){
            return pl.payment_method.is_cash_count;
        });
    }
    check_paymentlines_rounding() {
        if(this.pos.config.cash_rounding) {
            var cash_rounding = this.pos.cash_rounding[0].rounding;
            var default_rounding = this.pos.currency.rounding;
            for(var id in this.get_paymentlines()) {
                var line = this.get_paymentlines()[id];
                var diff = round_pr(round_pr(line.amount, cash_rounding) - round_pr(line.amount, default_rounding), default_rounding);
                if(this.get_total_with_tax() < this.pos.cash_rounding[0].rounding)
                    return true;
                if(diff && line.payment_method.is_cash_count) {
                    return false;
                } else if(!this.pos.config.only_round_cash_method && diff) {
                    return false;
                }
            }
            return true;
        }
        return true;
    }
    get_total_cost() {
        return this.orderlines.reduce((function(sum, orderLine) {
            return sum + orderLine.get_total_cost();
        }), 0)
    }
    /* ---- Invoice --- */
    set_to_invoice(to_invoice) {
        this.assert_editable();
        this.to_invoice = to_invoice;
    }
    is_to_invoice(){
        return this.to_invoice;
    }
    /* ---- Partner --- */
    // the partner related to the current order.
    set_partner(partner){
        this.assert_editable();
        this.partner = partner;
    }
    get_partner(){
        return this.partner;
    }
    get_partner_name(){
        let partner = this.partner;
        return partner ? partner.name : "";
    }
    get_cardholder_name(){
        var card_payment_line = this.paymentlines.find(pl => pl.cardholder_name);
        return card_payment_line ? card_payment_line.cardholder_name : "";
    }
    /* ---- Screen Status --- */
    // the order also stores the screen status, as the PoS supports
    // different active screens per order. This method is used to
    // store the screen status.
    set_screen_data(value){
        this.screen_data['value'] = value;
    }
    //see set_screen_data
    get_screen_data(){
        const screen = this.screen_data['value'];
        // If no screen data is saved
        //   no payment line -> product screen
        //   with payment line -> payment screen
        if (!screen) {
            if (this.get_paymentlines().length > 0) return { name: 'PaymentScreen' };
            return { name: 'ProductScreen' };
        }
        if (!this.finalized && this.get_paymentlines().length > 0) {
            return { name: 'PaymentScreen' };
        }
        return screen;
    }
    wait_for_push_order () {
        return false;
    }
    /**
     * @returns {Object} object to use as props for instantiating OrderReceipt.
     */
    getOrderReceiptEnv() {
        // Formerly get_receipt_render_env defined in ScreenWidget.
        return {
            order: this,
            receipt: this.export_for_printing(),
            orderlines: this.get_orderlines(),
            paymentlines: this.get_paymentlines(),
        };
    }
    updatePricelist(newPartner) {
        let newPartnerPricelist, newPartnerFiscalPosition;
        const defaultFiscalPosition = this.pos.fiscal_positions.find(
            (position) => position.id === this.pos.config.default_fiscal_position_id[0]
        );
        if (newPartner) {
            newPartnerFiscalPosition = newPartner.property_account_position_id
                ? this.pos.fiscal_positions.find(
                      (position) => position.id === newPartner.property_account_position_id[0]
                  )
                : defaultFiscalPosition;
            newPartnerPricelist =
                this.pos.pricelists.find(
                    (pricelist) => pricelist.id === newPartner.property_product_pricelist[0]
                ) || this.pos.default_pricelist;
        } else {
            newPartnerFiscalPosition = defaultFiscalPosition;
            newPartnerPricelist = this.pos.default_pricelist;
        }
        this.set_fiscal_position(newPartnerFiscalPosition);
        this.set_pricelist(newPartnerPricelist);
    }
    /* ---- Ship later --- */
    set_to_ship(to_ship) {
        this.assert_editable();
        this.to_ship = to_ship;
    }
    is_to_ship(){
        return this.to_ship;
    }
    getHasRefundLines() {
        for (const line of this.get_orderlines()) {
            if (line.refunded_orderline_id) {
                return true;
            }
        }
        return false;
    }
    /**
     * Returns false if the current order is empty and has no payments.
     * @returns {boolean}
     */
    _isValidEmptyOrder() {
        if (this.get_orderlines().length == 0) {
            return this.get_paymentlines().length != 0;
        } else {
            return true;
        }
    }
    _get_qr_code_data() {
        if (this.pos.company.point_of_sale_use_ticket_qr_code) {
            const codeWriter = new window.ZXing.BrowserQRCodeSvgWriter();
            // Use the unique access token to ensure the authenticity of the request. Use the order reference as a second check just in case.
            const address = `${this.pos.base_url}/pos/ticket/validate?access_token=${this.access_token}`
            let qr_code_svg = new XMLSerializer().serializeToString(codeWriter.write(address, 150, 150));
            return "data:image/svg+xml;base64,"+ window.btoa(qr_code_svg);
        } else {
            return false;
        }
    }
}
Registries.Model.add(Order);

return {
    register_payment_method,
    PosGlobalState,
    Product,
    Orderline,
    Packlotline,
    Payment,
    Order,
};

});
;

/******************************************************
*  Filepath: /point_of_sale/static/src/js/payment.js  *
*  Lines: 95                                          *
******************************************************/
odoo.define('point_of_sale.PaymentInterface', function (require) {
"use strict";

var core = require('web.core');

/**
 * Implement this interface to support a new payment method in the POS:
 *
 * var PaymentInterface = require('point_of_sale.PaymentInterface');
 * var MyPayment = PaymentInterface.extend({
 *     ...
 * })
 *
 * To connect the interface to the right payment methods register it:
 *
 * var models = require('point_of_sale.models');
 * models.register_payment_method('my_payment', MyPayment);
 *
 * my_payment is the technical name of the added selection in
 * use_payment_terminal.
 *
 * If necessary new fields can be loaded on any model:
 * by overriding the loader_params of the models in the back end
 * in the `pos.session` model
 */
var PaymentInterface = core.Class.extend({
    init: function (pos, payment_method) {
        this.pos = pos;
        this.payment_method = payment_method;
        this.supports_reversals = false;
    },

    /**
     * Call this function to enable UI elements that allow a user to
     * reverse a payment. This requires that you implement
     * send_payment_reversal.
     */
    enable_reversals: function () {
        this.supports_reversals = true;
    },

    /**
     * Called when a user clicks the "Send" button in the
     * interface. This should initiate a payment request and return a
     * Promise that resolves when the final status of the payment line
     * is set with set_payment_status.
     *
     * For successful transactions set_receipt_info() should be used
     * to set info that should to be printed on the receipt. You
     * should also set card_type and transaction_id on the line for
     * successful transactions.
     *
     * @param {string} cid - The id of the paymentline
     * @returns {Promise} resolved with a boolean that is false when
     * the payment should be retried. Rejected when the status of the
     * paymentline will be manually updated.
     */
    send_payment_request: function (cid) {},

    /**
     * Called when a user removes a payment line that's still waiting
     * on send_payment_request to complete. Should execute some
     * request to ensure the current payment request is
     * cancelled. This is not to refund payments, only to cancel
     * them. The payment line being cancelled will be deleted
     * automatically after the returned promise resolves.
     *
     * @param {} order - The order of the paymentline
     * @param {string} cid - The id of the paymentline
     * @returns {Promise}
     */
    send_payment_cancel: function (order, cid) {},

    /**
     * This is an optional method. When implementing this make sure to
     * call enable_reversals() in the constructor of your
     * interface. This should reverse a previous payment with status
     * 'done'. The paymentline will be removed based on returned
     * Promise.
     *
     * @param {string} cid - The id of the paymentline
     * @returns {Promise} returns true if the reversal was successful.
     */
    send_payment_reversal: function (cid) {},

    /**
     * Called when the payment screen in the POS is closed (by
     * e.g. clicking the "Back" button). Could be used to cancel in
     * progress payments.
     */
    close: function () {},
});

return PaymentInterface;
});
;

/******************************************************
*  Filepath: /point_of_sale/static/src/js/pos_env.js  *
*  Lines: 31                                          *
******************************************************/
odoo.define('@point_of_sale/js/pos_env', async function (require) {
'use strict';
let __exports = {};
/* @odoo-module alias=point_of_sale.env */

// This module is basically web.env but with added fields
// that are specific to point_of_sale and extensions.

const env = require('web.env');
const concurrency = require('web.concurrency');
const devices = require('point_of_sale.devices');
const BarcodeReader = require('point_of_sale.BarcodeReader');

// Create new env object base on web.env.
// Mutating this new object won't affect the original object.
let pos_env = Object.create(env);

pos_env.proxy_queue = new devices.JobQueue(); // used to prevent parallels communications to the proxy
pos_env.proxy = new devices.ProxyDevice({ env: pos_env }); // used to communicate to the hardware devices via a local proxy
pos_env.barcode_reader = new BarcodeReader({ env: pos_env, proxy: pos_env.proxy });
pos_env.posbus = new owl.EventBus();
pos_env.posMutex = new concurrency.Mutex();

__exports[Symbol.for("default")] = pos_env;

return __exports;
});

odoo.define(`point_of_sale.env`, async function(require) {
                        return require('@point_of_sale/js/pos_env')[Symbol.for("default")];
                        });
;

/*******************************************************
*  Filepath: /point_of_sale/static/src/js/printers.js  *
*  Lines: 175                                          *
*******************************************************/
/* global html2canvas */
odoo.define('point_of_sale.Printer', function (require) {
"use strict";

var Session = require('web.Session');
var core = require('web.core');
const { Gui } = require('point_of_sale.Gui');
var _t = core._t;

// IMPROVEMENT: This is too much. We can get away from this class.
class PrintResult {
    constructor({ successful, message }) {
        this.successful = successful;
        this.message = message;
    }
}

class PrintResultGenerator {
    IoTActionError() {
        return new PrintResult({
            successful: false,
            message: {
                title: _t('Connection to IoT Box failed'),
                body: _t('Please check if the IoT Box is still connected.'),
            },
        });
    }
    IoTResultError() {
        return new PrintResult({
            successful: false,
            message: {
                title: _t('Connection to the printer failed'),
                body: _t('Please check if the printer is still connected. \n' +
                    'Some browsers don\'t allow HTTP calls from websites to devices in the network (for security reasons). ' +
                    'If it is the case, you will need to follow Odoo\'s documentation for ' +
                    '\'Self-signed certificate for ePOS printers\' and \'Secure connection (HTTPS)\' to solve the issue'
                ),
            },
        });
    }
    Successful() {
        return new PrintResult({
            successful: true,
        });
    }
}

var PrinterMixin = {
    init: function (pos) {
        this.receipt_queue = [];
        this.printResultGenerator = new PrintResultGenerator();
        this.pos = pos;
    },

    /**
     * Add the receipt to the queue of receipts to be printed and process it.
     * We clear the print queue if printing is not successful.
     * @param {String} receipt: The receipt to be printed, in HTML
     * @returns {PrintResult}
     */
    print_receipt: async function(receipt) {
        if (receipt) {
            this.receipt_queue.push(receipt);
        }
        let image, sendPrintResult;
        while (this.receipt_queue.length > 0) {
            receipt = this.receipt_queue.shift();
            image = await this.htmlToImg(receipt);
            try {
                sendPrintResult = await this.send_printing_job(image);
            } catch (_error) {
                // Error in communicating to the IoT box.
                this.receipt_queue.length = 0;
                return this.printResultGenerator.IoTActionError();
            }
            // rpc call is okay but printing failed because
            // IoT box can't find a printer.
            if (!sendPrintResult || sendPrintResult.result === false) {
                this.receipt_queue.length = 0;
                return this.printResultGenerator.IoTResultError(sendPrintResult.printerErrorCode);
            }
        }
        return this.printResultGenerator.Successful();
    },

    /**
     * Generate a jpeg image from a canvas
     * @param {DOMElement} canvas
     */
    process_canvas: function (canvas) {
        return canvas.toDataURL('image/jpeg').replace('data:image/jpeg;base64,','');
    },

    /**
     * Renders the html as an image to print it
     * @param {String} receipt: The receipt to be printed, in HTML
     */
    htmlToImg: function (receipt) {
        $('.pos-receipt-print').html(receipt);
        this.receipt = $('.pos-receipt-print>.pos-receipt');
        // Odoo RTL support automatically flip left into right but html2canvas
        // won't work as expected if the receipt is aligned to the right of the
        // screen so we need to flip it back.
        this.receipt.parent().css({ left: 0, right: 'auto' });
        return html2canvas(this.receipt[0], {
            height: Math.ceil(this.receipt.outerHeight() + this.receipt.offset().top),
            width: Math.ceil(this.receipt.outerWidth() + 2 * this.receipt.offset().left),
            scale: 1,
        }).then(canvas => {
            $('.pos-receipt-print').empty();
            return this.process_canvas(canvas);
        });
    },

    _onIoTActionResult: function (data){
        if (this.pos && (data === false || data.result === false)) {
            Gui.showPopup('ErrorPopup',{
                'title': _t('Connection to the printer failed'),
                'body':  _t('Please check if the printer is still connected.'),
            });
        }
    },

    _onIoTActionFail: function () {
        if (this.pos) {
            Gui.showPopup('ErrorPopup',{
                'title': _t('Connection to IoT Box failed'),
                'body':  _t('Please check if the IoT Box is still connected.'),
            });
        }
    },
}

var Printer = core.Class.extend(PrinterMixin, {
    init: function (url, pos) {
        PrinterMixin.init.call(this, pos);
        this.connection = new Session(undefined, url || 'http://localhost:8069', { use_cors: true});
    },

    /**
     * Sends a command to the connected proxy to open the cashbox
     * (the physical box where you store the cash). Updates the status of
     * the printer with the answer from the proxy.
     */
    open_cashbox: function () {
        var self = this;
        return this.connection.rpc('/hw_proxy/default_printer_action', {
            data: {
                action: 'cashbox'
            }
        }).then(self._onIoTActionResult.bind(self))
            .guardedCatch(self._onIoTActionFail.bind(self));
    },

    /**
     * Sends the printing command the connected proxy
     * @param {String} img : The receipt to be printed, as an image
     */
    send_printing_job: function (img) {
        return this.connection.rpc('/hw_proxy/default_printer_action', {
            data: {
                action: 'print_receipt',
                receipt: img,
            }
        });
    },
});

return {
    PrinterMixin: PrinterMixin,
    Printer: Printer,
    PrintResult,
    PrintResultGenerator,
}
});
;

/****************************************************
*  Filepath: /point_of_sale/static/src/js/utils.js  *
*  Lines: 102                                       *
****************************************************/
odoo.define('point_of_sale.utils', function (require) {
    'use strict';

    const { ConnectionAbortedError, ConnectionLostError } = require('@web/core/network/rpc_service');

    function getFileAsText(file) {
        return new Promise((resolve, reject) => {
            if (!file) {
                reject();
            } else {
                const reader = new FileReader();
                reader.addEventListener('load', function () {
                    resolve(reader.result);
                });
                reader.addEventListener('abort', reject);
                reader.addEventListener('error', reject);
                reader.readAsText(file);
            }
        });
    }

    /**
     * This global variable is used by nextFrame to store the timer and
     * be able to cancel it before another request for animation frame.
     */
    let timer = null;

    /**
     * Wait for the next animation frame to finish.
     */
    const nextFrame = () => {
        return new Promise((resolve) => {
            cancelAnimationFrame(timer);
            timer = requestAnimationFrame(() => {
                resolve();
            });
        });
    };

    function isConnectionError(error) {
        const _error = identifyError(error);
        return _error instanceof ConnectionAbortedError || _error instanceof ConnectionLostError;
    }

    function identifyError(error) {
        if (!error) return error;
        let errorToHandle;
        if (error.legacy) {
            // error.message is either RPCError or ConnectionLostError
            errorToHandle = error.message;
        } else if (error.event && error.event.type == 'abort') {
            // Check if there is event and if the event type is abort.
            // If so, then it's supposed to be a ConnectionAbortedError,
            // however, it was stripped in the patch of rpc in `mapLegacyEnvToWowlEnv`.
            // We recreate the error object here so that in the actual handler,
            // ConnectionAbortedError and ConnectionLostError are handled properly.
            errorToHandle = new ConnectionAbortedError(error.message);
        } else if (error instanceof Error) {
            errorToHandle = error;
        }
        return errorToHandle || error;
    }

    /**
     * Creates a batched version of a callback so that all calls to it in the same
     * microtick will only call the original callback once.
     *
     * @param callback the callback to batch
     * @returns a batched version of the original callback
     */
    function batched(callback) {
        let called = false;
        return async () => {
            // This await blocks all calls to the callback here, then releases them sequentially
            // in the next microtick. This line decides the granularity of the batch.
            await Promise.resolve();
            if (!called) {
                called = true;
                // so that only the first call to the batched function calls the original callback.
                // Schedule this before calling the callback so that calls to the batched function
                // within the callback will proceed only after resetting called to false, and have
                // a chance to execute the callback again
                Promise.resolve().then(() => called = false);
                callback();
            }
        };
    }

    /*
     * comes from o_spreadsheet.js
     * https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
     * */
    function uuidv4() {
        // mainly for jest and other browsers that do not have the crypto functionality
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
            let r = (Math.random() * 16) | 0, v = c == "x" ? r : (r & 0x3) | 0x8;
            return v.toString(16);
        });
    };

    return { getFileAsText, nextFrame, identifyError, isConnectionError, batched, uuidv4 };
});
;

/*************************************************************
*  Filepath: /web/static/lib/zxing-library/zxing-library.js  *
*  Lines: 24253                                              *
*************************************************************/
/*!
 * ZXing.js v0.19.2
 * https://github.com/zxing-js/library
 * (c) 2018 ZXing for JS Contributors
 * Released under the MIT License
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
        typeof define === 'function' && define.amd ? define(['exports'], factory) :
            (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ZXing = {}));
}(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    function fixProto(target, prototype) {
        var setPrototypeOf = Object.setPrototypeOf;
        setPrototypeOf ? setPrototypeOf(target, prototype) : (target.__proto__ = prototype);
    }

    function fixStack(target, fn) {
        if (fn === void 0) {
            fn = target.constructor;
        }
        var captureStackTrace = Error.captureStackTrace;
        captureStackTrace && captureStackTrace(target, fn);
    }





    var CustomError = (function (_super) {
        __extends(CustomError, _super);
        function CustomError(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            Object.defineProperty(_this, 'name', {
                value: _newTarget.name,
                enumerable: false
            });
            fixProto(_this, _newTarget.prototype);
            fixStack(_this);
            return _this;
        }

        return CustomError;
    })(Error);

    /**
     * Custom Error class of type Exception.
     */
    class Exception extends CustomError {
        /**
         * Allows Exception to be constructed directly
         * with some message and prototype definition.
         */
        constructor(message = undefined) {
            super(message);
            this.message = message;
        }
        getKind() {
            const ex = this.constructor;
            return ex.kind;
        }
    }
    /**
     * It's typed as string so it can be extended and overriden.
     */
    Exception.kind = 'Exception';

    /**
     * Custom Error class of type Exception.
     */
    class ArgumentException extends Exception {
    }
    ArgumentException.kind = 'ArgumentException';

    /**
     * Custom Error class of type Exception.
     */
    class IllegalArgumentException extends Exception {
    }
    IllegalArgumentException.kind = 'IllegalArgumentException';

    /*
     * Copyright 2009 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    class BinaryBitmap {
        constructor(binarizer) {
            this.binarizer = binarizer;
            if (binarizer === null) {
                throw new IllegalArgumentException('Binarizer must be non-null.');
            }
        }
        /**
         * @return The width of the bitmap.
         */
        getWidth() {
            return this.binarizer.getWidth();
        }
        /**
         * @return The height of the bitmap.
         */
        getHeight() {
            return this.binarizer.getHeight();
        }
        /**
         * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return
         * cached data. Callers should assume this method is expensive and call it as seldom as possible.
         * This method is intended for decoding 1D barcodes and may choose to apply sharpening.
         *
         * @param y The row to fetch, which must be in [0, bitmap height)
         * @param row An optional preallocated array. If null or too small, it will be ignored.
         *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.
         * @return The array of bits for this row (true means black).
         * @throws NotFoundException if row can't be binarized
         */
        getBlackRow(y /*int*/, row) {
            return this.binarizer.getBlackRow(y, row);
        }
        /**
         * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive
         * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or
         * may not apply sharpening. Therefore, a row from this matrix may not be identical to one
         * fetched using getBlackRow(), so don't mix and match between them.
         *
         * @return The 2D array of bits for the image (true means black).
         * @throws NotFoundException if image can't be binarized to make a matrix
         */
        getBlackMatrix() {
            // The matrix is created on demand the first time it is requested, then cached. There are two
            // reasons for this:
            // 1. This work will never be done if the caller only installs 1D Reader objects, or if a
            //    1D Reader finds a barcode before the 2D Readers run.
            // 2. This work will only be done once even if the caller installs multiple 2D Readers.
            if (this.matrix === null || this.matrix === undefined) {
                this.matrix = this.binarizer.getBlackMatrix();
            }
            return this.matrix;
        }
        /**
         * @return Whether this bitmap can be cropped.
         */
        isCropSupported() {
            return this.binarizer.getLuminanceSource().isCropSupported();
        }
        /**
         * Returns a new object with cropped image data. Implementations may keep a reference to the
         * original data rather than a copy. Only callable if isCropSupported() is true.
         *
         * @param left The left coordinate, which must be in [0,getWidth())
         * @param top The top coordinate, which must be in [0,getHeight())
         * @param width The width of the rectangle to crop.
         * @param height The height of the rectangle to crop.
         * @return A cropped version of this object.
         */
        crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
            const newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);
            return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
        }
        /**
         * @return Whether this bitmap supports counter-clockwise rotation.
         */
        isRotateSupported() {
            return this.binarizer.getLuminanceSource().isRotateSupported();
        }
        /**
         * Returns a new object with rotated image data by 90 degrees counterclockwise.
         * Only callable if {@link #isRotateSupported()} is true.
         *
         * @return A rotated version of this object.
         */
        rotateCounterClockwise() {
            const newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();
            return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
        }
        /**
         * Returns a new object with rotated image data by 45 degrees counterclockwise.
         * Only callable if {@link #isRotateSupported()} is true.
         *
         * @return A rotated version of this object.
         */
        rotateCounterClockwise45() {
            const newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();
            return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
        }
        /*@Override*/
        toString() {
            try {
                return this.getBlackMatrix().toString();
            }
            catch (e /*: NotFoundException*/) {
                return '';
            }
        }
    }

    /**
     * Custom Error class of type Exception.
     */
    class ChecksumException extends Exception {
        static getChecksumInstance() {
            return new ChecksumException();
        }
    }
    ChecksumException.kind = 'ChecksumException';

    /*
     * Copyright 2009 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * This class hierarchy provides a set of methods to convert luminance data to 1 bit data.
     * It allows the algorithm to vary polymorphically, for example allowing a very expensive
     * thresholding technique for servers and a fast one for mobile. It also permits the implementation
     * to vary, e.g. a JNI version for Android and a Java fallback version for other platforms.
     *
     * @author dswitkin@google.com (Daniel Switkin)
     */
    class Binarizer {
        constructor(source) {
            this.source = source;
        }
        getLuminanceSource() {
            return this.source;
        }
        getWidth() {
            return this.source.getWidth();
        }
        getHeight() {
            return this.source.getHeight();
        }
    }

    class System {
        // public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
        /**
         * Makes a copy of a array.
         */
        static arraycopy(src, srcPos, dest, destPos, length) {
            // TODO: better use split or set?
            while (length--) {
                dest[destPos++] = src[srcPos++];
            }
        }
        /**
         * Returns the current time in milliseconds.
         */
        static currentTimeMillis() {
            return Date.now();
        }
    }

    /**
     * Custom Error class of type Exception.
     */
    class IndexOutOfBoundsException extends Exception {
    }
    IndexOutOfBoundsException.kind = 'IndexOutOfBoundsException';

    /**
     * Custom Error class of type Exception.
     */
    class ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException {
        constructor(index = undefined, message = undefined) {
            super(message);
            this.index = index;
            this.message = message;
        }
    }
    ArrayIndexOutOfBoundsException.kind = 'ArrayIndexOutOfBoundsException';

    class Arrays {
        /**
         * Assigns the specified int value to each element of the specified array
         * of ints.
         *
         * @param a the array to be filled
         * @param val the value to be stored in all elements of the array
         */
        static fill(a, val) {
            for (let i = 0, len = a.length; i < len; i++)
                a[i] = val;
        }
        /**
         * Assigns the specified int value to each element of the specified
         * range of the specified array of ints.  The range to be filled
         * extends from index {@code fromIndex}, inclusive, to index
         * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
         * range to be filled is empty.)
         *
         * @param a the array to be filled
         * @param fromIndex the index of the first element (inclusive) to be
         *        filled with the specified value
         * @param toIndex the index of the last element (exclusive) to be
         *        filled with the specified value
         * @param val the value to be stored in all elements of the array
         * @throws IllegalArgumentException if {@code fromIndex > toIndex}
         * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or
         *         {@code toIndex > a.length}
         */
        static fillWithin(a, fromIndex, toIndex, val) {
            Arrays.rangeCheck(a.length, fromIndex, toIndex);
            for (let i = fromIndex; i < toIndex; i++)
                a[i] = val;
        }
        /**
         * Checks that {@code fromIndex} and {@code toIndex} are in
         * the range and throws an exception if they aren't.
         */
        static rangeCheck(arrayLength, fromIndex, toIndex) {
            if (fromIndex > toIndex) {
                throw new IllegalArgumentException('fromIndex(' + fromIndex + ') > toIndex(' + toIndex + ')');
            }
            if (fromIndex < 0) {
                throw new ArrayIndexOutOfBoundsException(fromIndex);
            }
            if (toIndex > arrayLength) {
                throw new ArrayIndexOutOfBoundsException(toIndex);
            }
        }
        static asList(...args) {
            return args;
        }
        static create(rows, cols, value) {
            let arr = Array.from({ length: rows });
            return arr.map(x => Array.from({ length: cols }).fill(value));
        }
        static createInt32Array(rows, cols, value) {
            let arr = Array.from({ length: rows });
            return arr.map(x => Int32Array.from({ length: cols }).fill(value));
        }
        static equals(first, second) {
            if (!first) {
                return false;
            }
            if (!second) {
                return false;
            }
            if (!first.length) {
                return false;
            }
            if (!second.length) {
                return false;
            }
            if (first.length !== second.length) {
                return false;
            }
            for (let i = 0, length = first.length; i < length; i++) {
                if (first[i] !== second[i]) {
                    return false;
                }
            }
            return true;
        }
        static hashCode(a) {
            if (a === null) {
                return 0;
            }
            let result = 1;
            for (const element of a) {
                result = 31 * result + element;
            }
            return result;
        }
        static fillUint8Array(a, value) {
            for (let i = 0; i !== a.length; i++) {
                a[i] = value;
            }
        }
        static copyOf(original, newLength) {
            return original.slice(0, newLength);
        }
        static copyOfUint8Array(original, newLength) {
            if (original.length <= newLength) {
                const newArray = new Uint8Array(newLength);
                newArray.set(original);
                return newArray;
            }
            return original.slice(0, newLength);
        }
        static copyOfRange(original, from, to) {
            const newLength = to - from;
            const copy = new Int32Array(newLength);
            System.arraycopy(original, from, copy, 0, newLength);
            return copy;
        }
        /*
        * Returns the index of of the element in a sorted array or (-n-1) where n is the insertion point
        * for the new element.
        * Parameters:
        *     ar - A sorted array
        *     el - An element to search for
        *     comparator - A comparator function. The function takes two arguments: (a, b) and returns:
        *        a negative number  if a is less than b;
        *        0 if a is equal to b;
        *        a positive number of a is greater than b.
        * The array may contain duplicate elements. If there are more than one equal elements in the array,
        * the returned value can be the index of any one of the equal elements.
        *
        * http://jsfiddle.net/aryzhov/pkfst550/
        */
        static binarySearch(ar, el, comparator) {
            if (undefined === comparator) {
                comparator = Arrays.numberComparator;
            }
            let m = 0;
            let n = ar.length - 1;
            while (m <= n) {
                const k = (n + m) >> 1;
                const cmp = comparator(el, ar[k]);
                if (cmp > 0) {
                    m = k + 1;
                }
                else if (cmp < 0) {
                    n = k - 1;
                }
                else {
                    return k;
                }
            }
            return -m - 1;
        }
        static numberComparator(a, b) {
            return a - b;
        }
    }

    /**
     * Ponyfill for Java's Integer class.
     */
    class Integer {
        static numberOfTrailingZeros(i) {
            let y;
            if (i === 0)
                return 32;
            let n = 31;
            y = i << 16;
            if (y !== 0) {
                n -= 16;
                i = y;
            }
            y = i << 8;
            if (y !== 0) {
                n -= 8;
                i = y;
            }
            y = i << 4;
            if (y !== 0) {
                n -= 4;
                i = y;
            }
            y = i << 2;
            if (y !== 0) {
                n -= 2;
                i = y;
            }
            return n - ((i << 1) >>> 31);
        }
        static numberOfLeadingZeros(i) {
            // HD, Figure 5-6
            if (i === 0) {
                return 32;
            }
            let n = 1;
            if (i >>> 16 === 0) {
                n += 16;
                i <<= 16;
            }
            if (i >>> 24 === 0) {
                n += 8;
                i <<= 8;
            }
            if (i >>> 28 === 0) {
                n += 4;
                i <<= 4;
            }
            if (i >>> 30 === 0) {
                n += 2;
                i <<= 2;
            }
            n -= i >>> 31;
            return n;
        }
        static toHexString(i) {
            return i.toString(16);
        }
        static toBinaryString(intNumber) {
            return String(parseInt(String(intNumber), 2));
        }
        // Returns the number of one-bits in the two's complement binary representation of the specified int value. This function is sometimes referred to as the population count.
        // Returns:
        // the number of one-bits in the two's complement binary representation of the specified int value.
        static bitCount(i) {
            // HD, Figure 5-2
            i = i - ((i >>> 1) & 0x55555555);
            i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
            i = (i + (i >>> 4)) & 0x0f0f0f0f;
            i = i + (i >>> 8);
            i = i + (i >>> 16);
            return i & 0x3f;
        }
        static truncDivision(dividend, divisor) {
            return Math.trunc(dividend / divisor);
        }
        /**
         * Converts A string to an integer.
         * @param s A string to convert into a number.
         * @param radix A value between 2 and 36 that specifies the base of the number in numString. If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal. All other strings are considered decimal.
         */
        static parseInt(num, radix = undefined) {
            return parseInt(num, radix);
        }
    }
    Integer.MIN_VALUE_32_BITS = -2147483648;
    Integer.MAX_VALUE = Number.MAX_SAFE_INTEGER;

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>A simple, fast array of bits, represented compactly by an array of ints internally.</p>
     *
     * @author Sean Owen
     */
    class BitArray /*implements Cloneable*/ {
        // public constructor() {
        //   this.size = 0
        //   this.bits = new Int32Array(1)
        // }
        // public constructor(size?: number /*int*/) {
        //   if (undefined === size) {
        //     this.size = 0
        //   } else {
        //     this.size = size
        //   }
        //   this.bits = this.makeArray(size)
        // }
        // For testing only
        constructor(size /*int*/, bits) {
            if (undefined === size) {
                this.size = 0;
                this.bits = new Int32Array(1);
            }
            else {
                this.size = size;
                if (undefined === bits || null === bits) {
                    this.bits = BitArray.makeArray(size);
                }
                else {
                    this.bits = bits;
                }
            }
        }
        getSize() {
            return this.size;
        }
        getSizeInBytes() {
            return Math.floor((this.size + 7) / 8);
        }
        ensureCapacity(size /*int*/) {
            if (size > this.bits.length * 32) {
                const newBits = BitArray.makeArray(size);
                System.arraycopy(this.bits, 0, newBits, 0, this.bits.length);
                this.bits = newBits;
            }
        }
        /**
         * @param i bit to get
         * @return true iff bit i is set
         */
        get(i /*int*/) {
            return (this.bits[Math.floor(i / 32)] & (1 << (i & 0x1F))) !== 0;
        }
        /**
         * Sets bit i.
         *
         * @param i bit to set
         */
        set(i /*int*/) {
            this.bits[Math.floor(i / 32)] |= 1 << (i & 0x1F);
        }
        /**
         * Flips bit i.
         *
         * @param i bit to set
         */
        flip(i /*int*/) {
            this.bits[Math.floor(i / 32)] ^= 1 << (i & 0x1F);
        }
        /**
         * @param from first bit to check
         * @return index of first bit that is set, starting from the given index, or size if none are set
         *  at or beyond this given index
         * @see #getNextUnset(int)
         */
        getNextSet(from /*int*/) {
            const size = this.size;
            if (from >= size) {
                return size;
            }
            const bits = this.bits;
            let bitsOffset = Math.floor(from / 32);
            let currentBits = bits[bitsOffset];
            // mask off lesser bits first
            currentBits &= ~((1 << (from & 0x1F)) - 1);
            const length = bits.length;
            while (currentBits === 0) {
                if (++bitsOffset === length) {
                    return size;
                }
                currentBits = bits[bitsOffset];
            }
            const result = (bitsOffset * 32) + Integer.numberOfTrailingZeros(currentBits);
            return result > size ? size : result;
        }
        /**
         * @param from index to start looking for unset bit
         * @return index of next unset bit, or {@code size} if none are unset until the end
         * @see #getNextSet(int)
         */
        getNextUnset(from /*int*/) {
            const size = this.size;
            if (from >= size) {
                return size;
            }
            const bits = this.bits;
            let bitsOffset = Math.floor(from / 32);
            let currentBits = ~bits[bitsOffset];
            // mask off lesser bits first
            currentBits &= ~((1 << (from & 0x1F)) - 1);
            const length = bits.length;
            while (currentBits === 0) {
                if (++bitsOffset === length) {
                    return size;
                }
                currentBits = ~bits[bitsOffset];
            }
            const result = (bitsOffset * 32) + Integer.numberOfTrailingZeros(currentBits);
            return result > size ? size : result;
        }
        /**
         * Sets a block of 32 bits, starting at bit i.
         *
         * @param i first bit to set
         * @param newBits the new value of the next 32 bits. Note again that the least-significant bit
         * corresponds to bit i, the next-least-significant to i+1, and so on.
         */
        setBulk(i /*int*/, newBits /*int*/) {
            this.bits[Math.floor(i / 32)] = newBits;
        }
        /**
         * Sets a range of bits.
         *
         * @param start start of range, inclusive.
         * @param end end of range, exclusive
         */
        setRange(start /*int*/, end /*int*/) {
            if (end < start || start < 0 || end > this.size) {
                throw new IllegalArgumentException();
            }
            if (end === start) {
                return;
            }
            end--; // will be easier to treat this as the last actually set bit -- inclusive
            const firstInt = Math.floor(start / 32);
            const lastInt = Math.floor(end / 32);
            const bits = this.bits;
            for (let i = firstInt; i <= lastInt; i++) {
                const firstBit = i > firstInt ? 0 : start & 0x1F;
                const lastBit = i < lastInt ? 31 : end & 0x1F;
                // Ones from firstBit to lastBit, inclusive
                const mask = (2 << lastBit) - (1 << firstBit);
                bits[i] |= mask;
            }
        }
        /**
         * Clears all bits (sets to false).
         */
        clear() {
            const max = this.bits.length;
            const bits = this.bits;
            for (let i = 0; i < max; i++) {
                bits[i] = 0;
            }
        }
        /**
         * Efficient method to check if a range of bits is set, or not set.
         *
         * @param start start of range, inclusive.
         * @param end end of range, exclusive
         * @param value if true, checks that bits in range are set, otherwise checks that they are not set
         * @return true iff all bits are set or not set in range, according to value argument
         * @throws IllegalArgumentException if end is less than start or the range is not contained in the array
         */
        isRange(start /*int*/, end /*int*/, value) {
            if (end < start || start < 0 || end > this.size) {
                throw new IllegalArgumentException();
            }
            if (end === start) {
                return true; // empty range matches
            }
            end--; // will be easier to treat this as the last actually set bit -- inclusive
            const firstInt = Math.floor(start / 32);
            const lastInt = Math.floor(end / 32);
            const bits = this.bits;
            for (let i = firstInt; i <= lastInt; i++) {
                const firstBit = i > firstInt ? 0 : start & 0x1F;
                const lastBit = i < lastInt ? 31 : end & 0x1F;
                // Ones from firstBit to lastBit, inclusive
                const mask = (2 << lastBit) - (1 << firstBit) & 0xFFFFFFFF;
                // TYPESCRIPTPORT: & 0xFFFFFFFF added to discard anything after 32 bits, as ES has 53 bits
                // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (is: that,
                // equals the mask, or we're looking for 0s and the masked portion is not all 0s
                if ((bits[i] & mask) !== (value ? mask : 0)) {
                    return false;
                }
            }
            return true;
        }
        appendBit(bit) {
            this.ensureCapacity(this.size + 1);
            if (bit) {
                this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 0x1F);
            }
            this.size++;
        }
        /**
         * Appends the least-significant bits, from value, in order from most-significant to
         * least-significant. For example, appending 6 bits from 0x000001E will append the bits
         * 0, 1, 1, 1, 1, 0 in that order.
         *
         * @param value {@code int} containing bits to append
         * @param numBits bits from value to append
         */
        appendBits(value /*int*/, numBits /*int*/) {
            if (numBits < 0 || numBits > 32) {
                throw new IllegalArgumentException('Num bits must be between 0 and 32');
            }
            this.ensureCapacity(this.size + numBits);
            // const appendBit = this.appendBit;
            for (let numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {
                this.appendBit(((value >> (numBitsLeft - 1)) & 0x01) === 1);
            }
        }
        appendBitArray(other) {
            const otherSize = other.size;
            this.ensureCapacity(this.size + otherSize);
            // const appendBit = this.appendBit;
            for (let i = 0; i < otherSize; i++) {
                this.appendBit(other.get(i));
            }
        }
        xor(other) {
            if (this.size !== other.size) {
                throw new IllegalArgumentException('Sizes don\'t match');
            }
            const bits = this.bits;
            for (let i = 0, length = bits.length; i < length; i++) {
                // The last int could be incomplete (i.e. not have 32 bits in
                // it) but there is no problem since 0 XOR 0 == 0.
                bits[i] ^= other.bits[i];
            }
        }
        /**
         *
         * @param bitOffset first bit to start writing
         * @param array array to write into. Bytes are written most-significant byte first. This is the opposite
         *  of the internal representation, which is exposed by {@link #getBitArray()}
         * @param offset position in array to start writing
         * @param numBytes how many bytes to write
         */
        toBytes(bitOffset /*int*/, array, offset /*int*/, numBytes /*int*/) {
            for (let i = 0; i < numBytes; i++) {
                let theByte = 0;
                for (let j = 0; j < 8; j++) {
                    if (this.get(bitOffset)) {
                        theByte |= 1 << (7 - j);
                    }
                    bitOffset++;
                }
                array[offset + i] = /*(byte)*/ theByte;
            }
        }
        /**
         * @return underlying array of ints. The first element holds the first 32 bits, and the least
         *         significant bit is bit 0.
         */
        getBitArray() {
            return this.bits;
        }
        /**
         * Reverses all bits in the array.
         */
        reverse() {
            const newBits = new Int32Array(this.bits.length);
            // reverse all int's first
            const len = Math.floor((this.size - 1) / 32);
            const oldBitsLen = len + 1;
            const bits = this.bits;
            for (let i = 0; i < oldBitsLen; i++) {
                let x = bits[i];
                x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);
                x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);
                x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);
                x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);
                x = ((x >> 16) & 0x0000ffff) | ((x & 0x0000ffff) << 16);
                newBits[len - i] = /*(int)*/ x;
            }
            // now correct the int's if the bit size isn't a multiple of 32
            if (this.size !== oldBitsLen * 32) {
                const leftOffset = oldBitsLen * 32 - this.size;
                let currentInt = newBits[0] >>> leftOffset;
                for (let i = 1; i < oldBitsLen; i++) {
                    const nextInt = newBits[i];
                    currentInt |= nextInt << (32 - leftOffset);
                    newBits[i - 1] = currentInt;
                    currentInt = nextInt >>> leftOffset;
                }
                newBits[oldBitsLen - 1] = currentInt;
            }
            this.bits = newBits;
        }
        static makeArray(size /*int*/) {
            return new Int32Array(Math.floor((size + 31) / 32));
        }
        /*@Override*/
        equals(o) {
            if (!(o instanceof BitArray)) {
                return false;
            }
            const other = o;
            return this.size === other.size && Arrays.equals(this.bits, other.bits);
        }
        /*@Override*/
        hashCode() {
            return 31 * this.size + Arrays.hashCode(this.bits);
        }
        /*@Override*/
        toString() {
            let result = '';
            for (let i = 0, size = this.size; i < size; i++) {
                if ((i & 0x07) === 0) {
                    result += ' ';
                }
                result += this.get(i) ? 'X' : '.';
            }
            return result;
        }
        /*@Override*/
        clone() {
            return new BitArray(this.size, this.bits.slice());
        }
    }

    /*
     * Copyright 2009 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*namespace com.google.zxing {*/
    /**
     * Encapsulates a type of hint that a caller may pass to a barcode reader to help it
     * more quickly or accurately decode it. It is up to implementations to decide what,
     * if anything, to do with the information that is supplied.
     *
     * @author Sean Owen
     * @author dswitkin@google.com (Daniel Switkin)
     * @see Reader#decode(BinaryBitmap,java.util.Map)
     */
    var DecodeHintType;
    (function (DecodeHintType) {
        /**
         * Unspecified, application-specific hint. Maps to an unspecified {@link Object}.
         */
        DecodeHintType[DecodeHintType["OTHER"] = 0] = "OTHER"; /*(Object.class)*/
        /**
         * Image is a pure monochrome image of a barcode. Doesn't matter what it maps to;
         * use {@link Boolean#TRUE}.
         */
        DecodeHintType[DecodeHintType["PURE_BARCODE"] = 1] = "PURE_BARCODE"; /*(Void.class)*/
        /**
         * Image is known to be of one of a few possible formats.
         * Maps to a {@link List} of {@link BarcodeFormat}s.
         */
        DecodeHintType[DecodeHintType["POSSIBLE_FORMATS"] = 2] = "POSSIBLE_FORMATS"; /*(List.class)*/
        /**
         * Spend more time to try to find a barcode; optimize for accuracy, not speed.
         * Doesn't matter what it maps to; use {@link Boolean#TRUE}.
         */
        DecodeHintType[DecodeHintType["TRY_HARDER"] = 3] = "TRY_HARDER"; /*(Void.class)*/
        /**
         * Specifies what character encoding to use when decoding, where applicable (type String)
         */
        DecodeHintType[DecodeHintType["CHARACTER_SET"] = 4] = "CHARACTER_SET"; /*(String.class)*/
        /**
         * Allowed lengths of encoded data -- reject anything else. Maps to an {@code Int32Array}.
         */
        DecodeHintType[DecodeHintType["ALLOWED_LENGTHS"] = 5] = "ALLOWED_LENGTHS"; /*(Int32Array.class)*/
        /**
         * Assume Code 39 codes employ a check digit. Doesn't matter what it maps to;
         * use {@link Boolean#TRUE}.
         */
        DecodeHintType[DecodeHintType["ASSUME_CODE_39_CHECK_DIGIT"] = 6] = "ASSUME_CODE_39_CHECK_DIGIT"; /*(Void.class)*/
        /**
         * Assume the barcode is being processed as a GS1 barcode, and modify behavior as needed.
         * For example this affects FNC1 handling for Code 128 (aka GS1-128). Doesn't matter what it maps to;
         * use {@link Boolean#TRUE}.
         */
        DecodeHintType[DecodeHintType["ASSUME_GS1"] = 7] = "ASSUME_GS1"; /*(Void.class)*/
        /**
         * If true, return the start and end digits in a Codabar barcode instead of stripping them. They
         * are alpha, whereas the rest are numeric. By default, they are stripped, but this causes them
         * to not be. Doesn't matter what it maps to; use {@link Boolean#TRUE}.
         */
        DecodeHintType[DecodeHintType["RETURN_CODABAR_START_END"] = 8] = "RETURN_CODABAR_START_END"; /*(Void.class)*/
        /**
         * The caller needs to be notified via callback when a possible {@link ResultPoint}
         * is found. Maps to a {@link ResultPointCallback}.
         */
        DecodeHintType[DecodeHintType["NEED_RESULT_POINT_CALLBACK"] = 9] = "NEED_RESULT_POINT_CALLBACK"; /*(ResultPointCallback.class)*/
        /**
         * Allowed extension lengths for EAN or UPC barcodes. Other formats will ignore this.
         * Maps to an {@code Int32Array} of the allowed extension lengths, for example [2], [5], or [2, 5].
         * If it is optional to have an extension, do not set this hint. If this is set,
         * and a UPC or EAN barcode is found but an extension is not, then no result will be returned
         * at all.
         */
        DecodeHintType[DecodeHintType["ALLOWED_EAN_EXTENSIONS"] = 10] = "ALLOWED_EAN_EXTENSIONS"; /*(Int32Array.class)*/
        // End of enumeration values.
        /**
         * Data type the hint is expecting.
         * Among the possible values the {@link Void} stands out as being used for
         * hints that do not expect a value to be supplied (flag hints). Such hints
         * will possibly have their value ignored, or replaced by a
         * {@link Boolean#TRUE}. Hint suppliers should probably use
         * {@link Boolean#TRUE} as directed by the actual hint documentation.
         */
        // private valueType: Class<?>
        // DecodeHintType(valueType: Class<?>) {
        //   this.valueType = valueType
        // }
        // public getValueType(): Class<?> {
        //   return valueType
        // }
    })(DecodeHintType || (DecodeHintType = {}));
    var DecodeHintType$1 = DecodeHintType;

    /**
     * Custom Error class of type Exception.
     */
    class FormatException extends Exception {
        static getFormatInstance() {
            return new FormatException();
        }
    }
    FormatException.kind = 'FormatException';

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*import java.util.HashMap;*/
    /*import java.util.Map;*/
    var CharacterSetValueIdentifiers;
    (function (CharacterSetValueIdentifiers) {
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp437"] = 0] = "Cp437";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_1"] = 1] = "ISO8859_1";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_2"] = 2] = "ISO8859_2";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_3"] = 3] = "ISO8859_3";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_4"] = 4] = "ISO8859_4";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_5"] = 5] = "ISO8859_5";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_6"] = 6] = "ISO8859_6";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_7"] = 7] = "ISO8859_7";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_8"] = 8] = "ISO8859_8";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_9"] = 9] = "ISO8859_9";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_10"] = 10] = "ISO8859_10";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_11"] = 11] = "ISO8859_11";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_13"] = 12] = "ISO8859_13";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_14"] = 13] = "ISO8859_14";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_15"] = 14] = "ISO8859_15";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_16"] = 15] = "ISO8859_16";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["SJIS"] = 16] = "SJIS";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1250"] = 17] = "Cp1250";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1251"] = 18] = "Cp1251";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1252"] = 19] = "Cp1252";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1256"] = 20] = "Cp1256";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["UnicodeBigUnmarked"] = 21] = "UnicodeBigUnmarked";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["UTF8"] = 22] = "UTF8";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ASCII"] = 23] = "ASCII";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Big5"] = 24] = "Big5";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["GB18030"] = 25] = "GB18030";
        CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["EUC_KR"] = 26] = "EUC_KR";
    })(CharacterSetValueIdentifiers || (CharacterSetValueIdentifiers = {}));
    /**
     * Encapsulates a Character Set ECI, according to "Extended Channel Interpretations" 5.3.1.1
     * of ISO 18004.
     *
     * @author Sean Owen
     */
    class CharacterSetECI {
        constructor(valueIdentifier, valuesParam, name, ...otherEncodingNames) {
            this.valueIdentifier = valueIdentifier;
            this.name = name;
            if (typeof valuesParam === 'number') {
                this.values = Int32Array.from([valuesParam]);
            }
            else {
                this.values = valuesParam;
            }
            this.otherEncodingNames = otherEncodingNames;
            CharacterSetECI.VALUE_IDENTIFIER_TO_ECI.set(valueIdentifier, this);
            CharacterSetECI.NAME_TO_ECI.set(name, this);
            const values = this.values;
            for (let i = 0, length = values.length; i !== length; i++) {
                const v = values[i];
                CharacterSetECI.VALUES_TO_ECI.set(v, this);
            }
            for (const otherName of otherEncodingNames) {
                CharacterSetECI.NAME_TO_ECI.set(otherName, this);
            }
        }
        // CharacterSetECI(value: number /*int*/) {
        //   this(new Int32Array {value})
        // }
        // CharacterSetECI(value: number /*int*/, String... otherEncodingNames) {
        //   this.values = new Int32Array {value}
        //   this.otherEncodingNames = otherEncodingNames
        // }
        // CharacterSetECI(values: Int32Array, String... otherEncodingNames) {
        //   this.values = values
        //   this.otherEncodingNames = otherEncodingNames
        // }
        getValueIdentifier() {
            return this.valueIdentifier;
        }
        getName() {
            return this.name;
        }
        getValue() {
            return this.values[0];
        }
        /**
         * @param value character set ECI value
         * @return {@code CharacterSetECI} representing ECI of given value, or null if it is legal but
         *   unsupported
         * @throws FormatException if ECI value is invalid
         */
        static getCharacterSetECIByValue(value /*int*/) {
            if (value < 0 || value >= 900) {
                throw new FormatException('incorect value');
            }
            const characterSet = CharacterSetECI.VALUES_TO_ECI.get(value);
            if (undefined === characterSet) {
                throw new FormatException('incorect value');
            }
            return characterSet;
        }
        /**
         * @param name character set ECI encoding name
         * @return CharacterSetECI representing ECI for character encoding, or null if it is legal
         *   but unsupported
         */
        static getCharacterSetECIByName(name) {
            const characterSet = CharacterSetECI.NAME_TO_ECI.get(name);
            if (undefined === characterSet) {
                throw new FormatException('incorect value');
            }
            return characterSet;
        }
        equals(o) {
            if (!(o instanceof CharacterSetECI)) {
                return false;
            }
            const other = o;
            return this.getName() === other.getName();
        }
    }
    CharacterSetECI.VALUE_IDENTIFIER_TO_ECI = new Map();
    CharacterSetECI.VALUES_TO_ECI = new Map();
    CharacterSetECI.NAME_TO_ECI = new Map();
    // Enum name is a Java encoding valid for java.lang and java.io
    // TYPESCRIPTPORT: changed the main label for ISO as the TextEncoder did not recognized them in the form from java
    // (eg ISO8859_1 must be ISO88591 or ISO8859-1 or ISO-8859-1)
    // later on: well, except 16 wich does not work with ISO885916 so used ISO-8859-1 form for default
    CharacterSetECI.Cp437 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp437, Int32Array.from([0, 2]), 'Cp437');
    CharacterSetECI.ISO8859_1 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_1, Int32Array.from([1, 3]), 'ISO-8859-1', 'ISO88591', 'ISO8859_1');
    CharacterSetECI.ISO8859_2 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_2, 4, 'ISO-8859-2', 'ISO88592', 'ISO8859_2');
    CharacterSetECI.ISO8859_3 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_3, 5, 'ISO-8859-3', 'ISO88593', 'ISO8859_3');
    CharacterSetECI.ISO8859_4 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_4, 6, 'ISO-8859-4', 'ISO88594', 'ISO8859_4');
    CharacterSetECI.ISO8859_5 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_5, 7, 'ISO-8859-5', 'ISO88595', 'ISO8859_5');
    CharacterSetECI.ISO8859_6 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_6, 8, 'ISO-8859-6', 'ISO88596', 'ISO8859_6');
    CharacterSetECI.ISO8859_7 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_7, 9, 'ISO-8859-7', 'ISO88597', 'ISO8859_7');
    CharacterSetECI.ISO8859_8 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_8, 10, 'ISO-8859-8', 'ISO88598', 'ISO8859_8');
    CharacterSetECI.ISO8859_9 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_9, 11, 'ISO-8859-9', 'ISO88599', 'ISO8859_9');
    CharacterSetECI.ISO8859_10 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_10, 12, 'ISO-8859-10', 'ISO885910', 'ISO8859_10');
    CharacterSetECI.ISO8859_11 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_11, 13, 'ISO-8859-11', 'ISO885911', 'ISO8859_11');
    CharacterSetECI.ISO8859_13 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_13, 15, 'ISO-8859-13', 'ISO885913', 'ISO8859_13');
    CharacterSetECI.ISO8859_14 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_14, 16, 'ISO-8859-14', 'ISO885914', 'ISO8859_14');
    CharacterSetECI.ISO8859_15 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_15, 17, 'ISO-8859-15', 'ISO885915', 'ISO8859_15');
    CharacterSetECI.ISO8859_16 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_16, 18, 'ISO-8859-16', 'ISO885916', 'ISO8859_16');
    CharacterSetECI.SJIS = new CharacterSetECI(CharacterSetValueIdentifiers.SJIS, 20, 'SJIS', 'Shift_JIS');
    CharacterSetECI.Cp1250 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1250, 21, 'Cp1250', 'windows-1250');
    CharacterSetECI.Cp1251 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1251, 22, 'Cp1251', 'windows-1251');
    CharacterSetECI.Cp1252 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1252, 23, 'Cp1252', 'windows-1252');
    CharacterSetECI.Cp1256 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1256, 24, 'Cp1256', 'windows-1256');
    CharacterSetECI.UnicodeBigUnmarked = new CharacterSetECI(CharacterSetValueIdentifiers.UnicodeBigUnmarked, 25, 'UnicodeBigUnmarked', 'UTF-16BE', 'UnicodeBig');
    CharacterSetECI.UTF8 = new CharacterSetECI(CharacterSetValueIdentifiers.UTF8, 26, 'UTF8', 'UTF-8');
    CharacterSetECI.ASCII = new CharacterSetECI(CharacterSetValueIdentifiers.ASCII, Int32Array.from([27, 170]), 'ASCII', 'US-ASCII');
    CharacterSetECI.Big5 = new CharacterSetECI(CharacterSetValueIdentifiers.Big5, 28, 'Big5');
    CharacterSetECI.GB18030 = new CharacterSetECI(CharacterSetValueIdentifiers.GB18030, 29, 'GB18030', 'GB2312', 'EUC_CN', 'GBK');
    CharacterSetECI.EUC_KR = new CharacterSetECI(CharacterSetValueIdentifiers.EUC_KR, 30, 'EUC_KR', 'EUC-KR');

    /**
     * Custom Error class of type Exception.
     */
    class UnsupportedOperationException extends Exception {
    }
    UnsupportedOperationException.kind = 'UnsupportedOperationException';

    /**
     * Responsible for en/decoding strings.
     */
    class StringEncoding {
        /**
         * Decodes some Uint8Array to a string format.
         */
        static decode(bytes, encoding) {
            const encodingName = this.encodingName(encoding);
            if (this.customDecoder) {
                return this.customDecoder(bytes, encodingName);
            }
            // Increases browser support.
            if (typeof TextDecoder === 'undefined' || this.shouldDecodeOnFallback(encodingName)) {
                return this.decodeFallback(bytes, encodingName);
            }
            return new TextDecoder(encodingName).decode(bytes);
        }
        /**
         * Checks if the decoding method should use the fallback for decoding
         * once Node TextDecoder doesn't support all encoding formats.
         *
         * @param encodingName
         */
        static shouldDecodeOnFallback(encodingName) {
            return !StringEncoding.isBrowser() && encodingName === 'ISO-8859-1';
        }
        /**
         * Encodes some string into a Uint8Array.
         */
        static encode(s, encoding) {
            const encodingName = this.encodingName(encoding);
            if (this.customEncoder) {
                return this.customEncoder(s, encodingName);
            }
            // Increases browser support.
            if (typeof TextEncoder === 'undefined') {
                return this.encodeFallback(s);
            }
            // TextEncoder only encodes to UTF8 by default as specified by encoding.spec.whatwg.org
            return new TextEncoder().encode(s);
        }
        static isBrowser() {
            return (typeof window !== 'undefined' && {}.toString.call(window) === '[object Window]');
        }
        /**
         * Returns the string value from some encoding character set.
         */
        static encodingName(encoding) {
            return typeof encoding === 'string'
                ? encoding
                : encoding.getName();
        }
        /**
         * Returns character set from some encoding character set.
         */
        static encodingCharacterSet(encoding) {
            if (encoding instanceof CharacterSetECI) {
                return encoding;
            }
            return CharacterSetECI.getCharacterSetECIByName(encoding);
        }
        /**
         * Runs a fallback for the native decoding funcion.
         */
        static decodeFallback(bytes, encoding) {
            const characterSet = this.encodingCharacterSet(encoding);
            if (StringEncoding.isDecodeFallbackSupported(characterSet)) {
                let s = '';
                for (let i = 0, length = bytes.length; i < length; i++) {
                    let h = bytes[i].toString(16);
                    if (h.length < 2) {
                        h = '0' + h;
                    }
                    s += '%' + h;
                }
                return decodeURIComponent(s);
            }
            if (characterSet.equals(CharacterSetECI.UnicodeBigUnmarked)) {
                return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
            }
            throw new UnsupportedOperationException(`Encoding ${this.encodingName(encoding)} not supported by fallback.`);
        }
        static isDecodeFallbackSupported(characterSet) {
            return characterSet.equals(CharacterSetECI.UTF8) ||
                characterSet.equals(CharacterSetECI.ISO8859_1) ||
                characterSet.equals(CharacterSetECI.ASCII);
        }
        /**
         * Runs a fallback for the native encoding funcion.
         *
         * @see https://stackoverflow.com/a/17192845/4367683
         */
        static encodeFallback(s) {
            const encodedURIstring = btoa(unescape(encodeURIComponent(s)));
            const charList = encodedURIstring.split('');
            const uintArray = [];
            for (let i = 0; i < charList.length; i++) {
                uintArray.push(charList[i].charCodeAt(0));
            }
            return new Uint8Array(uintArray);
        }
    }

    /*
     * Copyright (C) 2010 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Common string-related functions.
     *
     * @author Sean Owen
     * @author Alex Dupre
     */
    class StringUtils {
        // SHIFT_JIS.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING) ||
        // EUC_JP.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING);
        static castAsNonUtf8Char(code, encoding = null) {
            // ISO 8859-1 is the Java default as UTF-8 is JavaScripts
            // you can see this method as a Java version of String.fromCharCode
            const e = encoding ? encoding.getName() : this.ISO88591;
            // use passed format (fromCharCode will return UTF8 encoding)
            return StringEncoding.decode(new Uint8Array([code]), e);
        }
        /**
         * @param bytes bytes encoding a string, whose encoding should be guessed
         * @param hints decode hints if applicable
         * @return name of guessed encoding; at the moment will only guess one of:
         *  {@link #SHIFT_JIS}, {@link #UTF8}, {@link #ISO88591}, or the platform
         *  default encoding if none of these can possibly be correct
         */
        static guessEncoding(bytes, hints) {
            if (hints !== null && hints !== undefined && undefined !== hints.get(DecodeHintType$1.CHARACTER_SET)) {
                return hints.get(DecodeHintType$1.CHARACTER_SET).toString();
            }
            // For now, merely tries to distinguish ISO-8859-1, UTF-8 and Shift_JIS,
            // which should be by far the most common encodings.
            const length = bytes.length;
            let canBeISO88591 = true;
            let canBeShiftJIS = true;
            let canBeUTF8 = true;
            let utf8BytesLeft = 0;
            // int utf8LowChars = 0
            let utf2BytesChars = 0;
            let utf3BytesChars = 0;
            let utf4BytesChars = 0;
            let sjisBytesLeft = 0;
            // int sjisLowChars = 0
            let sjisKatakanaChars = 0;
            // int sjisDoubleBytesChars = 0
            let sjisCurKatakanaWordLength = 0;
            let sjisCurDoubleBytesWordLength = 0;
            let sjisMaxKatakanaWordLength = 0;
            let sjisMaxDoubleBytesWordLength = 0;
            // int isoLowChars = 0
            // int isoHighChars = 0
            let isoHighOther = 0;
            const utf8bom = bytes.length > 3 &&
                bytes[0] === /*(byte) */ 0xEF &&
                bytes[1] === /*(byte) */ 0xBB &&
                bytes[2] === /*(byte) */ 0xBF;
            for (let i = 0; i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i++) {
                const value = bytes[i] & 0xFF;
                // UTF-8 stuff
                if (canBeUTF8) {
                    if (utf8BytesLeft > 0) {
                        if ((value & 0x80) === 0) {
                            canBeUTF8 = false;
                        }
                        else {
                            utf8BytesLeft--;
                        }
                    }
                    else if ((value & 0x80) !== 0) {
                        if ((value & 0x40) === 0) {
                            canBeUTF8 = false;
                        }
                        else {
                            utf8BytesLeft++;
                            if ((value & 0x20) === 0) {
                                utf2BytesChars++;
                            }
                            else {
                                utf8BytesLeft++;
                                if ((value & 0x10) === 0) {
                                    utf3BytesChars++;
                                }
                                else {
                                    utf8BytesLeft++;
                                    if ((value & 0x08) === 0) {
                                        utf4BytesChars++;
                                    }
                                    else {
                                        canBeUTF8 = false;
                                    }
                                }
                            }
                        }
                    } // else {
                    // utf8LowChars++
                    // }
                }
                // ISO-8859-1 stuff
                if (canBeISO88591) {
                    if (value > 0x7F && value < 0xA0) {
                        canBeISO88591 = false;
                    }
                    else if (value > 0x9F) {
                        if (value < 0xC0 || value === 0xD7 || value === 0xF7) {
                            isoHighOther++;
                        } // else {
                        // isoHighChars++
                        // }
                    } // else {
                    // isoLowChars++
                    // }
                }
                // Shift_JIS stuff
                if (canBeShiftJIS) {
                    if (sjisBytesLeft > 0) {
                        if (value < 0x40 || value === 0x7F || value > 0xFC) {
                            canBeShiftJIS = false;
                        }
                        else {
                            sjisBytesLeft--;
                        }
                    }
                    else if (value === 0x80 || value === 0xA0 || value > 0xEF) {
                        canBeShiftJIS = false;
                    }
                    else if (value > 0xA0 && value < 0xE0) {
                        sjisKatakanaChars++;
                        sjisCurDoubleBytesWordLength = 0;
                        sjisCurKatakanaWordLength++;
                        if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {
                            sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;
                        }
                    }
                    else if (value > 0x7F) {
                        sjisBytesLeft++;
                        // sjisDoubleBytesChars++
                        sjisCurKatakanaWordLength = 0;
                        sjisCurDoubleBytesWordLength++;
                        if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {
                            sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;
                        }
                    }
                    else {
                        // sjisLowChars++
                        sjisCurKatakanaWordLength = 0;
                        sjisCurDoubleBytesWordLength = 0;
                    }
                }
            }
            if (canBeUTF8 && utf8BytesLeft > 0) {
                canBeUTF8 = false;
            }
            if (canBeShiftJIS && sjisBytesLeft > 0) {
                canBeShiftJIS = false;
            }
            // Easy -- if there is BOM or at least 1 valid not-single byte character (and no evidence it can't be UTF-8), done
            if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {
                return StringUtils.UTF8;
            }
            // Easy -- if assuming Shift_JIS or at least 3 valid consecutive not-ascii characters (and no evidence it can't be), done
            if (canBeShiftJIS && (StringUtils.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {
                return StringUtils.SHIFT_JIS;
            }
            // Distinguishing Shift_JIS and ISO-8859-1 can be a little tough for short words. The crude heuristic is:
            // - If we saw
            //   - only two consecutive katakana chars in the whole text, or
            //   - at least 10% of bytes that could be "upper" not-alphanumeric Latin1,
            // - then we conclude Shift_JIS, else ISO-8859-1
            if (canBeISO88591 && canBeShiftJIS) {
                return (sjisMaxKatakanaWordLength === 2 && sjisKatakanaChars === 2) || isoHighOther * 10 >= length
                    ? StringUtils.SHIFT_JIS : StringUtils.ISO88591;
            }
            // Otherwise, try in order ISO-8859-1, Shift JIS, UTF-8 and fall back to default platform encoding
            if (canBeISO88591) {
                return StringUtils.ISO88591;
            }
            if (canBeShiftJIS) {
                return StringUtils.SHIFT_JIS;
            }
            if (canBeUTF8) {
                return StringUtils.UTF8;
            }
            // Otherwise, we take a wild guess with platform encoding
            return StringUtils.PLATFORM_DEFAULT_ENCODING;
        }
        /**
         *
         * @see https://stackoverflow.com/a/13439711/4367683
         *
         * @param append The new string to append.
         * @param args Argumets values to be formated.
         */
        static format(append, ...args) {
            let i = -1;
            function callback(exp, p0, p1, p2, p3, p4) {
                if (exp === '%%')
                    return '%';
                if (args[++i] === undefined)
                    return undefined;
                exp = p2 ? parseInt(p2.substr(1)) : undefined;
                let base = p3 ? parseInt(p3.substr(1)) : undefined;
                let val;
                switch (p4) {
                    case 's':
                        val = args[i];
                        break;
                    case 'c':
                        val = args[i][0];
                        break;
                    case 'f':
                        val = parseFloat(args[i]).toFixed(exp);
                        break;
                    case 'p':
                        val = parseFloat(args[i]).toPrecision(exp);
                        break;
                    case 'e':
                        val = parseFloat(args[i]).toExponential(exp);
                        break;
                    case 'x':
                        val = parseInt(args[i]).toString(base ? base : 16);
                        break;
                    case 'd':
                        val = parseFloat(parseInt(args[i], base ? base : 10).toPrecision(exp)).toFixed(0);
                        break;
                }
                val = typeof val === 'object' ? JSON.stringify(val) : (+val).toString(base);
                let size = parseInt(p1); /* padding size */
                let ch = p1 && (p1[0] + '') === '0' ? '0' : ' '; /* isnull? */
                while (val.length < size)
                    val = p0 !== undefined ? val + ch : ch + val; /* isminus? */
                return val;
            }
            let regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
            return append.replace(regex, callback);
        }
        /**
         *
         */
        static getBytes(str, encoding) {
            return StringEncoding.encode(str, encoding);
        }
        /**
         * Returns the charcode at the specified index or at index zero.
         */
        static getCharCode(str, index = 0) {
            return str.charCodeAt(index);
        }
        /**
         * Returns char for given charcode
         */
        static getCharAt(charCode) {
            return String.fromCharCode(charCode);
        }
    }
    StringUtils.SHIFT_JIS = CharacterSetECI.SJIS.getName(); // "SJIS"
    StringUtils.GB2312 = 'GB2312';
    StringUtils.ISO88591 = CharacterSetECI.ISO8859_1.getName(); // "ISO8859_1"
    StringUtils.EUC_JP = 'EUC_JP';
    StringUtils.UTF8 = CharacterSetECI.UTF8.getName(); // "UTF8"
    StringUtils.PLATFORM_DEFAULT_ENCODING = StringUtils.UTF8; // "UTF8"//Charset.defaultCharset().name()
    StringUtils.ASSUME_SHIFT_JIS = false;

    class StringBuilder {
        constructor(value = '') {
            this.value = value;
        }
        enableDecoding(encoding) {
            this.encoding = encoding;
            return this;
        }
        append(s) {
            if (typeof s === 'string') {
                this.value += s.toString();
            }
            else if (this.encoding) {
                // use passed format (fromCharCode will return UTF8 encoding)
                this.value += StringUtils.castAsNonUtf8Char(s, this.encoding);
            }
            else {
                // correctly converts from UTF-8, but not other encodings
                this.value += String.fromCharCode(s);
            }
            return this;
        }
        appendChars(str, offset, len) {
            for (let i = offset; offset < offset + len; i++) {
                this.append(str[i]);
            }
            return this;
        }
        length() {
            return this.value.length;
        }
        charAt(n) {
            return this.value.charAt(n);
        }
        deleteCharAt(n) {
            this.value = this.value.substr(0, n) + this.value.substring(n + 1);
        }
        setCharAt(n, c) {
            this.value = this.value.substr(0, n) + c + this.value.substr(n + 1);
        }
        substring(start, end) {
            return this.value.substring(start, end);
        }
        /**
         * @note helper method for RSS Expanded
         */
        setLengthToZero() {
            this.value = '';
        }
        toString() {
            return this.value;
        }
        insert(n, c) {
            this.value = this.value.substr(0, n) + c + this.value.substr(n + c.length);
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Represents a 2D matrix of bits. In function arguments below, and throughout the common
     * module, x is the column position, and y is the row position. The ordering is always x, y.
     * The origin is at the top-left.</p>
     *
     * <p>Internally the bits are represented in a 1-D array of 32-bit ints. However, each row begins
     * with a new int. This is done intentionally so that we can copy out a row into a BitArray very
     * efficiently.</p>
     *
     * <p>The ordering of bits is row-major. Within each int, the least significant bits are used first,
     * meaning they represent lower x values. This is compatible with BitArray's implementation.</p>
     *
     * @author Sean Owen
     * @author dswitkin@google.com (Daniel Switkin)
     */
    class BitMatrix /*implements Cloneable*/ {
        /**
         * Creates an empty square {@link BitMatrix}.
         *
         * @param dimension height and width
         */
        // public constructor(dimension: number /*int*/) {
        //   this(dimension, dimension)
        // }
        /**
         * Creates an empty {@link BitMatrix}.
         *
         * @param width bit matrix width
         * @param height bit matrix height
         */
        // public constructor(width: number /*int*/, height: number /*int*/) {
        //   if (width < 1 || height < 1) {
        //     throw new IllegalArgumentException("Both dimensions must be greater than 0")
        //   }
        //   this.width = width
        //   this.height = height
        //   this.rowSize = (width + 31) / 32
        //   bits = new int[rowSize * height];
        // }
        constructor(width /*int*/, height /*int*/, rowSize /*int*/, bits) {
            this.width = width;
            this.height = height;
            this.rowSize = rowSize;
            this.bits = bits;
            if (undefined === height || null === height) {
                height = width;
            }
            this.height = height;
            if (width < 1 || height < 1) {
                throw new IllegalArgumentException('Both dimensions must be greater than 0');
            }
            if (undefined === rowSize || null === rowSize) {
                rowSize = Math.floor((width + 31) / 32);
            }
            this.rowSize = rowSize;
            if (undefined === bits || null === bits) {
                this.bits = new Int32Array(this.rowSize * this.height);
            }
        }
        /**
         * Interprets a 2D array of booleans as a {@link BitMatrix}, where "true" means an "on" bit.
         *
         * @function parse
         * @param image bits of the image, as a row-major 2D array. Elements are arrays representing rows
         * @return {@link BitMatrix} representation of image
         */
        static parseFromBooleanArray(image) {
            const height = image.length;
            const width = image[0].length;
            const bits = new BitMatrix(width, height);
            for (let i = 0; i < height; i++) {
                const imageI = image[i];
                for (let j = 0; j < width; j++) {
                    if (imageI[j]) {
                        bits.set(j, i);
                    }
                }
            }
            return bits;
        }
        /**
         *
         * @function parse
         * @param stringRepresentation
         * @param setString
         * @param unsetString
         */
        static parseFromString(stringRepresentation, setString, unsetString) {
            if (stringRepresentation === null) {
                throw new IllegalArgumentException('stringRepresentation cannot be null');
            }
            const bits = new Array(stringRepresentation.length);
            let bitsPos = 0;
            let rowStartPos = 0;
            let rowLength = -1;
            let nRows = 0;
            let pos = 0;
            while (pos < stringRepresentation.length) {
                if (stringRepresentation.charAt(pos) === '\n' ||
                    stringRepresentation.charAt(pos) === '\r') {
                    if (bitsPos > rowStartPos) {
                        if (rowLength === -1) {
                            rowLength = bitsPos - rowStartPos;
                        }
                        else if (bitsPos - rowStartPos !== rowLength) {
                            throw new IllegalArgumentException('row lengths do not match');
                        }
                        rowStartPos = bitsPos;
                        nRows++;
                    }
                    pos++;
                }
                else if (stringRepresentation.substring(pos, pos + setString.length) === setString) {
                    pos += setString.length;
                    bits[bitsPos] = true;
                    bitsPos++;
                }
                else if (stringRepresentation.substring(pos, pos + unsetString.length) === unsetString) {
                    pos += unsetString.length;
                    bits[bitsPos] = false;
                    bitsPos++;
                }
                else {
                    throw new IllegalArgumentException('illegal character encountered: ' + stringRepresentation.substring(pos));
                }
            }
            // no EOL at end?
            if (bitsPos > rowStartPos) {
                if (rowLength === -1) {
                    rowLength = bitsPos - rowStartPos;
                }
                else if (bitsPos - rowStartPos !== rowLength) {
                    throw new IllegalArgumentException('row lengths do not match');
                }
                nRows++;
            }
            const matrix = new BitMatrix(rowLength, nRows);
            for (let i = 0; i < bitsPos; i++) {
                if (bits[i]) {
                    matrix.set(Math.floor(i % rowLength), Math.floor(i / rowLength));
                }
            }
            return matrix;
        }
        /**
         * <p>Gets the requested bit, where true means black.</p>
         *
         * @param x The horizontal component (i.e. which column)
         * @param y The vertical component (i.e. which row)
         * @return value of given bit in matrix
         */
        get(x /*int*/, y /*int*/) {
            const offset = y * this.rowSize + Math.floor(x / 32);
            return ((this.bits[offset] >>> (x & 0x1f)) & 1) !== 0;
        }
        /**
         * <p>Sets the given bit to true.</p>
         *
         * @param x The horizontal component (i.e. which column)
         * @param y The vertical component (i.e. which row)
         */
        set(x /*int*/, y /*int*/) {
            const offset = y * this.rowSize + Math.floor(x / 32);
            this.bits[offset] |= (1 << (x & 0x1f)) & 0xFFFFFFFF;
        }
        unset(x /*int*/, y /*int*/) {
            const offset = y * this.rowSize + Math.floor(x / 32);
            this.bits[offset] &= ~((1 << (x & 0x1f)) & 0xFFFFFFFF);
        }
        /**
         * <p>Flips the given bit.</p>
         *
         * @param x The horizontal component (i.e. which column)
         * @param y The vertical component (i.e. which row)
         */
        flip(x /*int*/, y /*int*/) {
            const offset = y * this.rowSize + Math.floor(x / 32);
            this.bits[offset] ^= ((1 << (x & 0x1f)) & 0xFFFFFFFF);
        }
        /**
         * Exclusive-or (XOR): Flip the bit in this {@code BitMatrix} if the corresponding
         * mask bit is set.
         *
         * @param mask XOR mask
         */
        xor(mask) {
            if (this.width !== mask.getWidth() || this.height !== mask.getHeight()
                || this.rowSize !== mask.getRowSize()) {
                throw new IllegalArgumentException('input matrix dimensions do not match');
            }
            const rowArray = new BitArray(Math.floor(this.width / 32) + 1);
            const rowSize = this.rowSize;
            const bits = this.bits;
            for (let y = 0, height = this.height; y < height; y++) {
                const offset = y * rowSize;
                const row = mask.getRow(y, rowArray).getBitArray();
                for (let x = 0; x < rowSize; x++) {
                    bits[offset + x] ^= row[x];
                }
            }
        }
        /**
         * Clears all bits (sets to false).
         */
        clear() {
            const bits = this.bits;
            const max = bits.length;
            for (let i = 0; i < max; i++) {
                bits[i] = 0;
            }
        }
        /**
         * <p>Sets a square region of the bit matrix to true.</p>
         *
         * @param left The horizontal position to begin at (inclusive)
         * @param top The vertical position to begin at (inclusive)
         * @param width The width of the region
         * @param height The height of the region
         */
        setRegion(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
            if (top < 0 || left < 0) {
                throw new IllegalArgumentException('Left and top must be nonnegative');
            }
            if (height < 1 || width < 1) {
                throw new IllegalArgumentException('Height and width must be at least 1');
            }
            const right = left + width;
            const bottom = top + height;
            if (bottom > this.height || right > this.width) {
                throw new IllegalArgumentException('The region must fit inside the matrix');
            }
            const rowSize = this.rowSize;
            const bits = this.bits;
            for (let y = top; y < bottom; y++) {
                const offset = y * rowSize;
                for (let x = left; x < right; x++) {
                    bits[offset + Math.floor(x / 32)] |= ((1 << (x & 0x1f)) & 0xFFFFFFFF);
                }
            }
        }
        /**
         * A fast method to retrieve one row of data from the matrix as a BitArray.
         *
         * @param y The row to retrieve
         * @param row An optional caller-allocated BitArray, will be allocated if null or too small
         * @return The resulting BitArray - this reference should always be used even when passing
         *         your own row
         */
        getRow(y /*int*/, row) {
            if (row === null || row === undefined || row.getSize() < this.width) {
                row = new BitArray(this.width);
            }
            else {
                row.clear();
            }
            const rowSize = this.rowSize;
            const bits = this.bits;
            const offset = y * rowSize;
            for (let x = 0; x < rowSize; x++) {
                row.setBulk(x * 32, bits[offset + x]);
            }
            return row;
        }
        /**
         * @param y row to set
         * @param row {@link BitArray} to copy from
         */
        setRow(y /*int*/, row) {
            System.arraycopy(row.getBitArray(), 0, this.bits, y * this.rowSize, this.rowSize);
        }
        /**
         * Modifies this {@code BitMatrix} to represent the same but rotated 180 degrees
         */
        rotate180() {
            const width = this.getWidth();
            const height = this.getHeight();
            let topRow = new BitArray(width);
            let bottomRow = new BitArray(width);
            for (let i = 0, length = Math.floor((height + 1) / 2); i < length; i++) {
                topRow = this.getRow(i, topRow);
                bottomRow = this.getRow(height - 1 - i, bottomRow);
                topRow.reverse();
                bottomRow.reverse();
                this.setRow(i, bottomRow);
                this.setRow(height - 1 - i, topRow);
            }
        }
        /**
         * This is useful in detecting the enclosing rectangle of a 'pure' barcode.
         *
         * @return {@code left,top,width,height} enclosing rectangle of all 1 bits, or null if it is all white
         */
        getEnclosingRectangle() {
            const width = this.width;
            const height = this.height;
            const rowSize = this.rowSize;
            const bits = this.bits;
            let left = width;
            let top = height;
            let right = -1;
            let bottom = -1;
            for (let y = 0; y < height; y++) {
                for (let x32 = 0; x32 < rowSize; x32++) {
                    const theBits = bits[y * rowSize + x32];
                    if (theBits !== 0) {
                        if (y < top) {
                            top = y;
                        }
                        if (y > bottom) {
                            bottom = y;
                        }
                        if (x32 * 32 < left) {
                            let bit = 0;
                            while (((theBits << (31 - bit)) & 0xFFFFFFFF) === 0) {
                                bit++;
                            }
                            if ((x32 * 32 + bit) < left) {
                                left = x32 * 32 + bit;
                            }
                        }
                        if (x32 * 32 + 31 > right) {
                            let bit = 31;
                            while ((theBits >>> bit) === 0) {
                                bit--;
                            }
                            if ((x32 * 32 + bit) > right) {
                                right = x32 * 32 + bit;
                            }
                        }
                    }
                }
            }
            if (right < left || bottom < top) {
                return null;
            }
            return Int32Array.from([left, top, right - left + 1, bottom - top + 1]);
        }
        /**
         * This is useful in detecting a corner of a 'pure' barcode.
         *
         * @return {@code x,y} coordinate of top-left-most 1 bit, or null if it is all white
         */
        getTopLeftOnBit() {
            const rowSize = this.rowSize;
            const bits = this.bits;
            let bitsOffset = 0;
            while (bitsOffset < bits.length && bits[bitsOffset] === 0) {
                bitsOffset++;
            }
            if (bitsOffset === bits.length) {
                return null;
            }
            const y = bitsOffset / rowSize;
            let x = (bitsOffset % rowSize) * 32;
            const theBits = bits[bitsOffset];
            let bit = 0;
            while (((theBits << (31 - bit)) & 0xFFFFFFFF) === 0) {
                bit++;
            }
            x += bit;
            return Int32Array.from([x, y]);
        }
        getBottomRightOnBit() {
            const rowSize = this.rowSize;
            const bits = this.bits;
            let bitsOffset = bits.length - 1;
            while (bitsOffset >= 0 && bits[bitsOffset] === 0) {
                bitsOffset--;
            }
            if (bitsOffset < 0) {
                return null;
            }
            const y = Math.floor(bitsOffset / rowSize);
            let x = Math.floor(bitsOffset % rowSize) * 32;
            const theBits = bits[bitsOffset];
            let bit = 31;
            while ((theBits >>> bit) === 0) {
                bit--;
            }
            x += bit;
            return Int32Array.from([x, y]);
        }
        /**
         * @return The width of the matrix
         */
        getWidth() {
            return this.width;
        }
        /**
         * @return The height of the matrix
         */
        getHeight() {
            return this.height;
        }
        /**
         * @return The row size of the matrix
         */
        getRowSize() {
            return this.rowSize;
        }
        /*@Override*/
        equals(o) {
            if (!(o instanceof BitMatrix)) {
                return false;
            }
            const other = o;
            return this.width === other.width && this.height === other.height && this.rowSize === other.rowSize &&
                Arrays.equals(this.bits, other.bits);
        }
        /*@Override*/
        hashCode() {
            let hash = this.width;
            hash = 31 * hash + this.width;
            hash = 31 * hash + this.height;
            hash = 31 * hash + this.rowSize;
            hash = 31 * hash + Arrays.hashCode(this.bits);
            return hash;
        }
        /**
         * @return string representation using "X" for set and " " for unset bits
         */
        /*@Override*/
        // public toString(): string {
        //   return toString(": "X, "  ")
        // }
        /**
         * @param setString representation of a set bit
         * @param unsetString representation of an unset bit
         * @return string representation of entire matrix utilizing given strings
         */
        // public toString(setString: string = "X ", unsetString: string = "  "): string {
        //   return this.buildToString(setString, unsetString, "\n")
        // }
        /**
         * @param setString representation of a set bit
         * @param unsetString representation of an unset bit
         * @param lineSeparator newline character in string representation
         * @return string representation of entire matrix utilizing given strings and line separator
         * @deprecated call {@link #toString(String,String)} only, which uses \n line separator always
         */
        // @Deprecated
        toString(setString = 'X ', unsetString = '  ', lineSeparator = '\n') {
            return this.buildToString(setString, unsetString, lineSeparator);
        }
        buildToString(setString, unsetString, lineSeparator) {
            let result = new StringBuilder();
            // result.append(lineSeparator);
            for (let y = 0, height = this.height; y < height; y++) {
                for (let x = 0, width = this.width; x < width; x++) {
                    result.append(this.get(x, y) ? setString : unsetString);
                }
                result.append(lineSeparator);
            }
            return result.toString();
        }
        /*@Override*/
        clone() {
            return new BitMatrix(this.width, this.height, this.rowSize, this.bits.slice());
        }
    }

    /**
     * Custom Error class of type Exception.
     */
    class NotFoundException extends Exception {
        static getNotFoundInstance() {
            return new NotFoundException();
        }
    }
    NotFoundException.kind = 'NotFoundException';

    /*
     * Copyright 2009 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * This Binarizer implementation uses the old ZXing global histogram approach. It is suitable
     * for low-end mobile devices which don't have enough CPU or memory to use a local thresholding
     * algorithm. However, because it picks a global black point, it cannot handle difficult shadows
     * and gradients.
     *
     * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.
     *
     * @author dswitkin@google.com (Daniel Switkin)
     * @author Sean Owen
     */
    class GlobalHistogramBinarizer extends Binarizer {
        constructor(source) {
            super(source);
            this.luminances = GlobalHistogramBinarizer.EMPTY;
            this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);
        }
        // Applies simple sharpening to the row data to improve performance of the 1D Readers.
        /*@Override*/
        getBlackRow(y /*int*/, row) {
            const source = this.getLuminanceSource();
            const width = source.getWidth();
            if (row === undefined || row === null || row.getSize() < width) {
                row = new BitArray(width);
            }
            else {
                row.clear();
            }
            this.initArrays(width);
            const localLuminances = source.getRow(y, this.luminances);
            const localBuckets = this.buckets;
            for (let x = 0; x < width; x++) {
                localBuckets[(localLuminances[x] & 0xff) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
            }
            const blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
            if (width < 3) {
                // Special case for very small images
                for (let x = 0; x < width; x++) {
                    if ((localLuminances[x] & 0xff) < blackPoint) {
                        row.set(x);
                    }
                }
            }
            else {
                let left = localLuminances[0] & 0xff;
                let center = localLuminances[1] & 0xff;
                for (let x = 1; x < width - 1; x++) {
                    const right = localLuminances[x + 1] & 0xff;
                    // A simple -1 4 -1 box filter with a weight of 2.
                    if (((center * 4) - left - right) / 2 < blackPoint) {
                        row.set(x);
                    }
                    left = center;
                    center = right;
                }
            }
            return row;
        }
        // Does not sharpen the data, as this call is intended to only be used by 2D Readers.
        /*@Override*/
        getBlackMatrix() {
            const source = this.getLuminanceSource();
            const width = source.getWidth();
            const height = source.getHeight();
            const matrix = new BitMatrix(width, height);
            // Quickly calculates the histogram by sampling four rows from the image. This proved to be
            // more robust on the blackbox tests than sampling a diagonal as we used to do.
            this.initArrays(width);
            const localBuckets = this.buckets;
            for (let y = 1; y < 5; y++) {
                const row = Math.floor((height * y) / 5);
                const localLuminances = source.getRow(row, this.luminances);
                const right = Math.floor((width * 4) / 5);
                for (let x = Math.floor(width / 5); x < right; x++) {
                    const pixel = localLuminances[x] & 0xff;
                    localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
                }
            }
            const blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
            // We delay reading the entire image luminance until the black point estimation succeeds.
            // Although we end up reading four rows twice, it is consistent with our motto of
            // "fail quickly" which is necessary for continuous scanning.
            const localLuminances = source.getMatrix();
            for (let y = 0; y < height; y++) {
                const offset = y * width;
                for (let x = 0; x < width; x++) {
                    const pixel = localLuminances[offset + x] & 0xff;
                    if (pixel < blackPoint) {
                        matrix.set(x, y);
                    }
                }
            }
            return matrix;
        }
        /*@Override*/
        createBinarizer(source) {
            return new GlobalHistogramBinarizer(source);
        }
        initArrays(luminanceSize /*int*/) {
            if (this.luminances.length < luminanceSize) {
                this.luminances = new Uint8ClampedArray(luminanceSize);
            }
            const buckets = this.buckets;
            for (let x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {
                buckets[x] = 0;
            }
        }
        static estimateBlackPoint(buckets) {
            // Find the tallest peak in the histogram.
            const numBuckets = buckets.length;
            let maxBucketCount = 0;
            let firstPeak = 0;
            let firstPeakSize = 0;
            for (let x = 0; x < numBuckets; x++) {
                if (buckets[x] > firstPeakSize) {
                    firstPeak = x;
                    firstPeakSize = buckets[x];
                }
                if (buckets[x] > maxBucketCount) {
                    maxBucketCount = buckets[x];
                }
            }
            // Find the second-tallest peak which is somewhat far from the tallest peak.
            let secondPeak = 0;
            let secondPeakScore = 0;
            for (let x = 0; x < numBuckets; x++) {
                const distanceToBiggest = x - firstPeak;
                // Encourage more distant second peaks by multiplying by square of distance.
                const score = buckets[x] * distanceToBiggest * distanceToBiggest;
                if (score > secondPeakScore) {
                    secondPeak = x;
                    secondPeakScore = score;
                }
            }
            // Make sure firstPeak corresponds to the black peak.
            if (firstPeak > secondPeak) {
                const temp = firstPeak;
                firstPeak = secondPeak;
                secondPeak = temp;
            }
            // If there is too little contrast in the image to pick a meaningful black point, throw rather
            // than waste time trying to decode the image, and risk false positives.
            if (secondPeak - firstPeak <= numBuckets / 16) {
                throw new NotFoundException();
            }
            // Find a valley between them that is low and closer to the white peak.
            let bestValley = secondPeak - 1;
            let bestValleyScore = -1;
            for (let x = secondPeak - 1; x > firstPeak; x--) {
                const fromFirst = x - firstPeak;
                const score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);
                if (score > bestValleyScore) {
                    bestValley = x;
                    bestValleyScore = score;
                }
            }
            return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;
        }
    }
    GlobalHistogramBinarizer.LUMINANCE_BITS = 5;
    GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;
    GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;
    GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);

    /*
     * Copyright 2009 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * This class implements a local thresholding algorithm, which while slower than the
     * GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for
     * high frequency images of barcodes with black data on white backgrounds. For this application,
     * it does a much better job than a global blackpoint with severe shadows and gradients.
     * However it tends to produce artifacts on lower frequency images and is therefore not
     * a good general purpose binarizer for uses outside ZXing.
     *
     * This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,
     * and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already
     * inherently local, and only fails for horizontal gradients. We can revisit that problem later,
     * but for now it was not a win to use local blocks for 1D.
     *
     * This Binarizer is the default for the unit tests and the recommended class for library users.
     *
     * @author dswitkin@google.com (Daniel Switkin)
     */
    class HybridBinarizer extends GlobalHistogramBinarizer {
        constructor(source) {
            super(source);
            this.matrix = null;
        }
        /**
         * Calculates the final BitMatrix once for all requests. This could be called once from the
         * constructor instead, but there are some advantages to doing it lazily, such as making
         * profiling easier, and not doing heavy lifting when callers don't expect it.
         */
        /*@Override*/
        getBlackMatrix() {
            if (this.matrix !== null) {
                return this.matrix;
            }
            const source = this.getLuminanceSource();
            const width = source.getWidth();
            const height = source.getHeight();
            if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {
                const luminances = source.getMatrix();
                let subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;
                if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {
                    subWidth++;
                }
                let subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;
                if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {
                    subHeight++;
                }
                const blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);
                const newMatrix = new BitMatrix(width, height);
                HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);
                this.matrix = newMatrix;
            }
            else {
                // If the image is too small, fall back to the global histogram approach.
                this.matrix = super.getBlackMatrix();
            }
            return this.matrix;
        }
        /*@Override*/
        createBinarizer(source) {
            return new HybridBinarizer(source);
        }
        /**
         * For each block in the image, calculate the average black point using a 5x5 grid
         * of the blocks around it. Also handles the corner cases (fractional blocks are computed based
         * on the last pixels in the row/column which are also used in the previous block).
         */
        static calculateThresholdForBlock(luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/, blackPoints, matrix) {
            const maxYOffset = height - HybridBinarizer.BLOCK_SIZE;
            const maxXOffset = width - HybridBinarizer.BLOCK_SIZE;
            for (let y = 0; y < subHeight; y++) {
                let yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;
                if (yoffset > maxYOffset) {
                    yoffset = maxYOffset;
                }
                const top = HybridBinarizer.cap(y, 2, subHeight - 3);
                for (let x = 0; x < subWidth; x++) {
                    let xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;
                    if (xoffset > maxXOffset) {
                        xoffset = maxXOffset;
                    }
                    const left = HybridBinarizer.cap(x, 2, subWidth - 3);
                    let sum = 0;
                    for (let z = -2; z <= 2; z++) {
                        const blackRow = blackPoints[top + z];
                        sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];
                    }
                    const average = sum / 25;
                    HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);
                }
            }
        }
        static cap(value /*int*/, min /*int*/, max /*int*/) {
            return value < min ? min : value > max ? max : value;
        }
        /**
         * Applies a single threshold to a block of pixels.
         */
        static thresholdBlock(luminances, xoffset /*int*/, yoffset /*int*/, threshold /*int*/, stride /*int*/, matrix) {
            for (let y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride) {
                for (let x = 0; x < HybridBinarizer.BLOCK_SIZE; x++) {
                    // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0.
                    if ((luminances[offset + x] & 0xFF) <= threshold) {
                        matrix.set(xoffset + x, yoffset + y);
                    }
                }
            }
        }
        /**
         * Calculates a single black point for each block of pixels and saves it away.
         * See the following thread for a discussion of this algorithm:
         *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0
         */
        static calculateBlackPoints(luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/) {
            const maxYOffset = height - HybridBinarizer.BLOCK_SIZE;
            const maxXOffset = width - HybridBinarizer.BLOCK_SIZE;
            // tslint:disable-next-line:whitespace
            const blackPoints = new Array(subHeight); // subWidth
            for (let y = 0; y < subHeight; y++) {
                blackPoints[y] = new Int32Array(subWidth);
                let yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;
                if (yoffset > maxYOffset) {
                    yoffset = maxYOffset;
                }
                for (let x = 0; x < subWidth; x++) {
                    let xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;
                    if (xoffset > maxXOffset) {
                        xoffset = maxXOffset;
                    }
                    let sum = 0;
                    let min = 0xFF;
                    let max = 0;
                    for (let yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {
                        for (let xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {
                            const pixel = luminances[offset + xx] & 0xFF;
                            sum += pixel;
                            // still looking for good contrast
                            if (pixel < min) {
                                min = pixel;
                            }
                            if (pixel > max) {
                                max = pixel;
                            }
                        }
                        // short-circuit min/max tests once dynamic range is met
                        if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {
                            // finish the rest of the rows quickly
                            for (yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {
                                for (let xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {
                                    sum += luminances[offset + xx] & 0xFF;
                                }
                            }
                        }
                    }
                    // The default estimate is the average of the values in the block.
                    let average = sum >> (HybridBinarizer.BLOCK_SIZE_POWER * 2);
                    if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {
                        // If variation within the block is low, assume this is a block with only light or only
                        // dark pixels. In that case we do not want to use the average, as it would divide this
                        // low contrast area into black and white pixels, essentially creating data out of noise.
                        //
                        // The default assumption is that the block is light/background. Since no estimate for
                        // the level of dark pixels exists locally, use half the min for the block.
                        average = min / 2;
                        if (y > 0 && x > 0) {
                            // Correct the "white background" assumption for blocks that have neighbors by comparing
                            // the pixels in this block to the previously calculated black points. This is based on
                            // the fact that dark barcode symbology is always surrounded by some amount of light
                            // background for which reasonable black point estimates were made. The bp estimated at
                            // the boundaries is used for the interior.
                            // The (min < bp) is arbitrary but works better than other heuristics that were tried.
                            const averageNeighborBlackPoint = (blackPoints[y - 1][x] + (2 * blackPoints[y][x - 1]) + blackPoints[y - 1][x - 1]) / 4;
                            if (min < averageNeighborBlackPoint) {
                                average = averageNeighborBlackPoint;
                            }
                        }
                    }
                    blackPoints[y][x] = average;
                }
            }
            return blackPoints;
        }
    }
    // This class uses 5x5 blocks to compute local luminance, where each block is 8x8 pixels.
    // So this is the smallest dimension in each axis we can accept.
    HybridBinarizer.BLOCK_SIZE_POWER = 3;
    HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER; // ...0100...00
    HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1; // ...0011...11
    HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;
    HybridBinarizer.MIN_DYNAMIC_RANGE = 24;

    /*
     * Copyright 2009 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*namespace com.google.zxing {*/
    /**
     * The purpose of this class hierarchy is to abstract different bitmap implementations across
     * platforms into a standard interface for requesting greyscale luminance values. The interface
     * only provides immutable methods; therefore crop and rotation create copies. This is to ensure
     * that one Reader does not modify the original luminance source and leave it in an unknown state
     * for other Readers in the chain.
     *
     * @author dswitkin@google.com (Daniel Switkin)
     */
    class LuminanceSource {
        constructor(width /*int*/, height /*int*/) {
            this.width = width;
            this.height = height;
        }
        /**
         * @return The width of the bitmap.
         */
        getWidth() {
            return this.width;
        }
        /**
         * @return The height of the bitmap.
         */
        getHeight() {
            return this.height;
        }
        /**
         * @return Whether this subclass supports cropping.
         */
        isCropSupported() {
            return false;
        }
        /**
         * Returns a new object with cropped image data. Implementations may keep a reference to the
         * original data rather than a copy. Only callable if isCropSupported() is true.
         *
         * @param left The left coordinate, which must be in [0,getWidth())
         * @param top The top coordinate, which must be in [0,getHeight())
         * @param width The width of the rectangle to crop.
         * @param height The height of the rectangle to crop.
         * @return A cropped version of this object.
         */
        crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
            throw new UnsupportedOperationException('This luminance source does not support cropping.');
        }
        /**
         * @return Whether this subclass supports counter-clockwise rotation.
         */
        isRotateSupported() {
            return false;
        }
        /**
         * Returns a new object with rotated image data by 90 degrees counterclockwise.
         * Only callable if {@link #isRotateSupported()} is true.
         *
         * @return A rotated version of this object.
         */
        rotateCounterClockwise() {
            throw new UnsupportedOperationException('This luminance source does not support rotation by 90 degrees.');
        }
        /**
         * Returns a new object with rotated image data by 45 degrees counterclockwise.
         * Only callable if {@link #isRotateSupported()} is true.
         *
         * @return A rotated version of this object.
         */
        rotateCounterClockwise45() {
            throw new UnsupportedOperationException('This luminance source does not support rotation by 45 degrees.');
        }
        /*@Override*/
        toString() {
            const row = new Uint8ClampedArray(this.width);
            let result = new StringBuilder();
            for (let y = 0; y < this.height; y++) {
                const sourceRow = this.getRow(y, row);
                for (let x = 0; x < this.width; x++) {
                    const luminance = sourceRow[x] & 0xFF;
                    let c;
                    if (luminance < 0x40) {
                        c = '#';
                    }
                    else if (luminance < 0x80) {
                        c = '+';
                    }
                    else if (luminance < 0xC0) {
                        c = '.';
                    }
                    else {
                        c = ' ';
                    }
                    result.append(c);
                }
                result.append('\n');
            }
            return result.toString();
        }
    }

    /*
     * Copyright 2009 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*namespace com.google.zxing {*/
    /**
     * A wrapper implementation of {@link LuminanceSource} which inverts the luminances it returns -- black becomes
     * white and vice versa, and each value becomes (255-value).
     *
     * @author Sean Owen
     */
    class InvertedLuminanceSource extends LuminanceSource {
        constructor(delegate) {
            super(delegate.getWidth(), delegate.getHeight());
            this.delegate = delegate;
        }
        /*@Override*/
        getRow(y /*int*/, row) {
            const sourceRow = this.delegate.getRow(y, row);
            const width = this.getWidth();
            for (let i = 0; i < width; i++) {
                sourceRow[i] = /*(byte)*/ (255 - (sourceRow[i] & 0xFF));
            }
            return sourceRow;
        }
        /*@Override*/
        getMatrix() {
            const matrix = this.delegate.getMatrix();
            const length = this.getWidth() * this.getHeight();
            const invertedMatrix = new Uint8ClampedArray(length);
            for (let i = 0; i < length; i++) {
                invertedMatrix[i] = /*(byte)*/ (255 - (matrix[i] & 0xFF));
            }
            return invertedMatrix;
        }
        /*@Override*/
        isCropSupported() {
            return this.delegate.isCropSupported();
        }
        /*@Override*/
        crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
            return new InvertedLuminanceSource(this.delegate.crop(left, top, width, height));
        }
        /*@Override*/
        isRotateSupported() {
            return this.delegate.isRotateSupported();
        }
        /**
         * @return original delegate {@link LuminanceSource} since invert undoes itself
         */
        /*@Override*/
        invert() {
            return this.delegate;
        }
        /*@Override*/
        rotateCounterClockwise() {
            return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise());
        }
        /*@Override*/
        rotateCounterClockwise45() {
            return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise45());
        }
    }

    /**
     * @deprecated Moving to @zxing/browser
     */
    class HTMLCanvasElementLuminanceSource extends LuminanceSource {
        constructor(canvas) {
            super(canvas.width, canvas.height);
            this.canvas = canvas;
            this.tempCanvasElement = null;
            this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(canvas);
        }
        static makeBufferFromCanvasImageData(canvas) {
            const imageData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
            return HTMLCanvasElementLuminanceSource.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height);
        }
        static toGrayscaleBuffer(imageBuffer, width, height) {
            const grayscaleBuffer = new Uint8ClampedArray(width * height);
            for (let i = 0, j = 0, length = imageBuffer.length; i < length; i += 4, j++) {
                let gray;
                const alpha = imageBuffer[i + 3];
                // The color of fully-transparent pixels is irrelevant. They are often, technically, fully-transparent
                // black (0 alpha, and then 0 RGB). They are often used, of course as the "white" area in a
                // barcode image. Force any such pixel to be white:
                if (alpha === 0) {
                    gray = 0xFF;
                }
                else {
                    const pixelR = imageBuffer[i];
                    const pixelG = imageBuffer[i + 1];
                    const pixelB = imageBuffer[i + 2];
                    // .299R + 0.587G + 0.114B (YUV/YIQ for PAL and NTSC),
                    // (306*R) >> 10 is approximately equal to R*0.299, and so on.
                    // 0x200 >> 10 is 0.5, it implements rounding.
                    gray = (306 * pixelR +
                        601 * pixelG +
                        117 * pixelB +
                        0x200) >> 10;
                }
                grayscaleBuffer[j] = gray;
            }
            return grayscaleBuffer;
        }
        getRow(y /*int*/, row) {
            if (y < 0 || y >= this.getHeight()) {
                throw new IllegalArgumentException('Requested row is outside the image: ' + y);
            }
            const width = this.getWidth();
            const start = y * width;
            if (row === null) {
                row = this.buffer.slice(start, start + width);
            }
            else {
                if (row.length < width) {
                    row = new Uint8ClampedArray(width);
                }
                // The underlying raster of image consists of bytes with the luminance values
                // TODO: can avoid set/slice?
                row.set(this.buffer.slice(start, start + width));
            }
            return row;
        }
        getMatrix() {
            return this.buffer;
        }
        isCropSupported() {
            return true;
        }
        crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
            super.crop(left, top, width, height);
            return this;
        }
        /**
         * This is always true, since the image is a gray-scale image.
         *
         * @return true
         */
        isRotateSupported() {
            return true;
        }
        rotateCounterClockwise() {
            this.rotate(-90);
            return this;
        }
        rotateCounterClockwise45() {
            this.rotate(-45);
            return this;
        }
        getTempCanvasElement() {
            if (null === this.tempCanvasElement) {
                const tempCanvasElement = this.canvas.ownerDocument.createElement('canvas');
                tempCanvasElement.width = this.canvas.width;
                tempCanvasElement.height = this.canvas.height;
                this.tempCanvasElement = tempCanvasElement;
            }
            return this.tempCanvasElement;
        }
        rotate(angle) {
            const tempCanvasElement = this.getTempCanvasElement();
            const tempContext = tempCanvasElement.getContext('2d');
            const angleRadians = angle * HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS;
            // Calculate and set new dimensions for temp canvas
            const width = this.canvas.width;
            const height = this.canvas.height;
            const newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);
            const newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);
            tempCanvasElement.width = newWidth;
            tempCanvasElement.height = newHeight;
            // Draw at center of temp canvas to prevent clipping of image data
            tempContext.translate(newWidth / 2, newHeight / 2);
            tempContext.rotate(angleRadians);
            tempContext.drawImage(this.canvas, width / -2, height / -2);
            this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(tempCanvasElement);
            return this;
        }
        invert() {
            return new InvertedLuminanceSource(this);
        }
    }
    HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS = Math.PI / 180;

    /**
     * @deprecated Moving to @zxing/browser
     *
     * Video input device metadata containing the id and label of the device if available.
     */
    class VideoInputDevice {
        /**
         * Creates an instance of VideoInputDevice.
         *
         * @param {string} deviceId the video input device id
         * @param {string} label the label of the device if available
         */
        constructor(deviceId, label, groupId) {
            this.deviceId = deviceId;
            this.label = label;
            /** @inheritdoc */
            this.kind = 'videoinput';
            this.groupId = groupId || undefined;
        }
        /** @inheritdoc */
        toJSON() {
            return {
                kind: this.kind,
                groupId: this.groupId,
                deviceId: this.deviceId,
                label: this.label,
            };
        }
    }

    var __awaiter = ((globalThis || global || self || window || undefined) && (globalThis || global || self || window || undefined).__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    /**
     * @deprecated Moving to @zxing/browser
     *
     * Base class for browser code reader.
     */
    class BrowserCodeReader {
        /**
         * Creates an instance of BrowserCodeReader.
         * @param {Reader} reader The reader instance to decode the barcode
         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent successful decode tries
         *
         * @memberOf BrowserCodeReader
         */
        constructor(reader, timeBetweenScansMillis = 500, _hints) {
            this.reader = reader;
            this.timeBetweenScansMillis = timeBetweenScansMillis;
            this._hints = _hints;
            /**
             * This will break the loop.
             */
            this._stopContinuousDecode = false;
            /**
             * This will break the loop.
             */
            this._stopAsyncDecode = false;
            /**
             * Delay time between decode attempts made by the scanner.
             */
            this._timeBetweenDecodingAttempts = 0;
        }
        /**
         * If navigator is present.
         */
        get hasNavigator() {
            return typeof navigator !== 'undefined';
        }
        /**
         * If mediaDevices under navigator is supported.
         */
        get isMediaDevicesSuported() {
            return this.hasNavigator && !!navigator.mediaDevices;
        }
        /**
         * If enumerateDevices under navigator is supported.
         */
        get canEnumerateDevices() {
            return !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices);
        }
        /** Time between two decoding tries in milli seconds. */
        get timeBetweenDecodingAttempts() {
            return this._timeBetweenDecodingAttempts;
        }
        /**
         * Change the time span the decoder waits between two decoding tries.
         *
         * @param {number} millis Time between two decoding tries in milli seconds.
         */
        set timeBetweenDecodingAttempts(millis) {
            this._timeBetweenDecodingAttempts = millis < 0 ? 0 : millis;
        }
        /**
         * Sets the hints.
         */
        set hints(hints) {
            this._hints = hints || null;
        }
        /**
         * Sets the hints.
         */
        get hints() {
            return this._hints;
        }
        /**
         * Lists all the available video input devices.
         */
        listVideoInputDevices() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.hasNavigator) {
                    throw new Error('Can\'t enumerate devices, navigator is not present.');
                }
                if (!this.canEnumerateDevices) {
                    throw new Error('Can\'t enumerate devices, method not supported.');
                }
                const devices = yield navigator.mediaDevices.enumerateDevices();
                const videoDevices = [];
                for (const device of devices) {
                    const kind = device.kind === 'video' ? 'videoinput' : device.kind;
                    if (kind !== 'videoinput') {
                        continue;
                    }
                    const deviceId = device.deviceId || device.id;
                    const label = device.label || `Video device ${videoDevices.length + 1}`;
                    const groupId = device.groupId;
                    const videoDevice = { deviceId, label, kind, groupId };
                    videoDevices.push(videoDevice);
                }
                return videoDevices;
            });
        }
        /**
         * Obtain the list of available devices with type 'videoinput'.
         *
         * @returns {Promise<VideoInputDevice[]>} an array of available video input devices
         *
         * @memberOf BrowserCodeReader
         *
         * @deprecated Use `listVideoInputDevices` instead.
         */
        getVideoInputDevices() {
            return __awaiter(this, void 0, void 0, function* () {
                const devices = yield this.listVideoInputDevices();
                return devices.map(d => new VideoInputDevice(d.deviceId, d.label));
            });
        }
        /**
         * Let's you find a device using it's Id.
         */
        findDeviceById(deviceId) {
            return __awaiter(this, void 0, void 0, function* () {
                const devices = yield this.listVideoInputDevices();
                if (!devices) {
                    return null;
                }
                return devices.find(x => x.deviceId === deviceId);
            });
        }
        /**
         * Decodes the barcode from the device specified by deviceId while showing the video in the specified video element.
         *
         * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
         * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
         * @returns The decoding result.
         *
         * @memberOf BrowserCodeReader
         *
         * @deprecated Use `decodeOnceFromVideoDevice` instead.
         */
        decodeFromInputVideoDevice(deviceId, videoSource) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.decodeOnceFromVideoDevice(deviceId, videoSource);
            });
        }
        /**
         * In one attempt, tries to decode the barcode from the device specified by deviceId while showing the video in the specified video element.
         *
         * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
         * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
         * @returns The decoding result.
         *
         * @memberOf BrowserCodeReader
         */
        decodeOnceFromVideoDevice(deviceId, videoSource) {
            return __awaiter(this, void 0, void 0, function* () {
                this.reset();
                let videoConstraints;
                if (!deviceId) {
                    videoConstraints = { facingMode: 'environment' };
                }
                else {
                    videoConstraints = { deviceId: { exact: deviceId } };
                }
                const constraints = { video: videoConstraints };
                return yield this.decodeOnceFromConstraints(constraints, videoSource);
            });
        }
        /**
         * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
         *
         * @param constraints the media stream constraints to get s valid media stream to decode from
         * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
         * @returns The decoding result.
         *
         * @memberOf BrowserCodeReader
         */
        decodeOnceFromConstraints(constraints, videoSource) {
            return __awaiter(this, void 0, void 0, function* () {
                const stream = yield navigator.mediaDevices.getUserMedia(constraints);
                return yield this.decodeOnceFromStream(stream, videoSource);
            });
        }
        /**
         * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
         *
         * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from
         * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
         * @returns {Promise<Result>} The decoding result.
         *
         * @memberOf BrowserCodeReader
         */
        decodeOnceFromStream(stream, videoSource) {
            return __awaiter(this, void 0, void 0, function* () {
                this.reset();
                const video = yield this.attachStreamToVideo(stream, videoSource);
                const result = yield this.decodeOnce(video);
                return result;
            });
        }
        /**
         * Continuously decodes the barcode from the device specified by device while showing the video in the specified video element.
         *
         * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
         * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
         * @returns {Promise<void>}
         *
         * @memberOf BrowserCodeReader
         *
         * @deprecated Use `decodeFromVideoDevice` instead.
         */
        decodeFromInputVideoDeviceContinuously(deviceId, videoSource, callbackFn) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield this.decodeFromVideoDevice(deviceId, videoSource, callbackFn);
            });
        }
        /**
         * Continuously tries to decode the barcode from the device specified by device while showing the video in the specified video element.
         *
         * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
         * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
         * @returns {Promise<void>}
         *
         * @memberOf BrowserCodeReader
         */
        decodeFromVideoDevice(deviceId, videoSource, callbackFn) {
            return __awaiter(this, void 0, void 0, function* () {
                let videoConstraints;
                if (!deviceId) {
                    videoConstraints = { facingMode: 'environment' };
                }
                else {
                    videoConstraints = { deviceId: { exact: deviceId } };
                }
                const constraints = { video: videoConstraints };
                return yield this.decodeFromConstraints(constraints, videoSource, callbackFn);
            });
        }
        /**
         * Continuously tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
         *
         * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from
         * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
         * @returns {Promise<Result>} The decoding result.
         *
         * @memberOf BrowserCodeReader
         */
        decodeFromConstraints(constraints, videoSource, callbackFn) {
            return __awaiter(this, void 0, void 0, function* () {
                const stream = yield navigator.mediaDevices.getUserMedia(constraints);
                return yield this.decodeFromStream(stream, videoSource, callbackFn);
            });
        }
        /**
         * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
         *
         * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from
         * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
         * @returns {Promise<Result>} The decoding result.
         *
         * @memberOf BrowserCodeReader
         */
        decodeFromStream(stream, videoSource, callbackFn) {
            return __awaiter(this, void 0, void 0, function* () {
                this.reset();
                const video = yield this.attachStreamToVideo(stream, videoSource);
                return yield this.decodeContinuously(video, callbackFn);
            });
        }
        /**
         * Breaks the decoding loop.
         */
        stopAsyncDecode() {
            this._stopAsyncDecode = true;
        }
        /**
         * Breaks the decoding loop.
         */
        stopContinuousDecode() {
            this._stopContinuousDecode = true;
        }
        /**
         * Sets the new stream and request a new decoding-with-delay.
         *
         * @param stream The stream to be shown in the video element.
         * @param decodeFn A callback for the decode method.
         */
        attachStreamToVideo(stream, videoSource) {
            return __awaiter(this, void 0, void 0, function* () {
                const videoElement = this.prepareVideoElement(videoSource);
                this.addVideoSource(videoElement, stream);
                this.videoElement = videoElement;
                this.stream = stream;
                yield this.playVideoOnLoadAsync(videoElement);
                return videoElement;
            });
        }
        /**
         *
         * @param videoElement
         */
        playVideoOnLoadAsync(videoElement) {
            return new Promise((resolve, reject) => this.playVideoOnLoad(videoElement, () => resolve()));
        }
        /**
         * Binds listeners and callbacks to the videoElement.
         *
         * @param element
         * @param callbackFn
         */
        playVideoOnLoad(element, callbackFn) {
            this.videoEndedListener = () => this.stopStreams();
            this.videoCanPlayListener = () => this.tryPlayVideo(element);
            element.addEventListener('ended', this.videoEndedListener);
            element.addEventListener('canplay', this.videoCanPlayListener);
            element.addEventListener('playing', callbackFn);
            // if canplay was already fired, we won't know when to play, so just give it a try
            this.tryPlayVideo(element);
        }
        /**
         * Checks if the given video element is currently playing.
         */
        isVideoPlaying(video) {
            return video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2;
        }
        /**
         * Just tries to play the video and logs any errors.
         * The play call is only made is the video is not already playing.
         */
        tryPlayVideo(videoElement) {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.isVideoPlaying(videoElement)) {
                    console.warn('Trying to play video that is already playing.');
                    return;
                }
                try {
                    yield videoElement.play();
                }
                catch (_a) {
                    console.warn('It was not possible to play the video.');
                }
            });
        }
        /**
         * Searches and validates a media element.
         */
        getMediaElement(mediaElementId, type) {
            const mediaElement = document.getElementById(mediaElementId);
            if (!mediaElement) {
                throw new ArgumentException(`element with id '${mediaElementId}' not found`);
            }
            if (mediaElement.nodeName.toLowerCase() !== type.toLowerCase()) {
                throw new ArgumentException(`element with id '${mediaElementId}' must be an ${type} element`);
            }
            return mediaElement;
        }
        /**
         * Decodes the barcode from an image.
         *
         * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.
         * @param {string} [url]
         * @returns {Promise<Result>} The decoding result.
         *
         * @memberOf BrowserCodeReader
         */
        decodeFromImage(source, url) {
            if (!source && !url) {
                throw new ArgumentException('either imageElement with a src set or an url must be provided');
            }
            if (url && !source) {
                return this.decodeFromImageUrl(url);
            }
            return this.decodeFromImageElement(source);
        }
        /**
         * Decodes the barcode from a video.
         *
         * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.
         * @param {string} [url]
         * @returns {Promise<Result>} The decoding result.
         *
         * @memberOf BrowserCodeReader
         */
        decodeFromVideo(source, url) {
            if (!source && !url) {
                throw new ArgumentException('Either an element with a src set or an URL must be provided');
            }
            if (url && !source) {
                return this.decodeFromVideoUrl(url);
            }
            return this.decodeFromVideoElement(source);
        }
        /**
         * Decodes continuously the barcode from a video.
         *
         * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.
         * @param {string} [url]
         * @returns {Promise<Result>} The decoding result.
         *
         * @memberOf BrowserCodeReader
         *
         * @experimental
         */
        decodeFromVideoContinuously(source, url, callbackFn) {
            if (undefined === source && undefined === url) {
                throw new ArgumentException('Either an element with a src set or an URL must be provided');
            }
            if (url && !source) {
                return this.decodeFromVideoUrlContinuously(url, callbackFn);
            }
            return this.decodeFromVideoElementContinuously(source, callbackFn);
        }
        /**
         * Decodes something from an image HTML element.
         */
        decodeFromImageElement(source) {
            if (!source) {
                throw new ArgumentException('An image element must be provided.');
            }
            this.reset();
            const element = this.prepareImageElement(source);
            this.imageElement = element;
            let task;
            if (this.isImageLoaded(element)) {
                task = this.decodeOnce(element, false, true);
            }
            else {
                task = this._decodeOnLoadImage(element);
            }
            return task;
        }
        /**
         * Decodes something from an image HTML element.
         */
        decodeFromVideoElement(source) {
            const element = this._decodeFromVideoElementSetup(source);
            return this._decodeOnLoadVideo(element);
        }
        /**
         * Decodes something from an image HTML element.
         */
        decodeFromVideoElementContinuously(source, callbackFn) {
            const element = this._decodeFromVideoElementSetup(source);
            return this._decodeOnLoadVideoContinuously(element, callbackFn);
        }
        /**
         * Sets up the video source so it can be decoded when loaded.
         *
         * @param source The video source element.
         */
        _decodeFromVideoElementSetup(source) {
            if (!source) {
                throw new ArgumentException('A video element must be provided.');
            }
            this.reset();
            const element = this.prepareVideoElement(source);
            // defines the video element before starts decoding
            this.videoElement = element;
            return element;
        }
        /**
         * Decodes an image from a URL.
         */
        decodeFromImageUrl(url) {
            if (!url) {
                throw new ArgumentException('An URL must be provided.');
            }
            this.reset();
            const element = this.prepareImageElement();
            this.imageElement = element;
            const decodeTask = this._decodeOnLoadImage(element);
            element.src = url;
            return decodeTask;
        }
        /**
         * Decodes an image from a URL.
         */
        decodeFromVideoUrl(url) {
            if (!url) {
                throw new ArgumentException('An URL must be provided.');
            }
            this.reset();
            // creates a new element
            const element = this.prepareVideoElement();
            const decodeTask = this.decodeFromVideoElement(element);
            element.src = url;
            return decodeTask;
        }
        /**
         * Decodes an image from a URL.
         *
         * @experimental
         */
        decodeFromVideoUrlContinuously(url, callbackFn) {
            if (!url) {
                throw new ArgumentException('An URL must be provided.');
            }
            this.reset();
            // creates a new element
            const element = this.prepareVideoElement();
            const decodeTask = this.decodeFromVideoElementContinuously(element, callbackFn);
            element.src = url;
            return decodeTask;
        }
        _decodeOnLoadImage(element) {
            return new Promise((resolve, reject) => {
                this.imageLoadedListener = () => this.decodeOnce(element, false, true).then(resolve, reject);
                element.addEventListener('load', this.imageLoadedListener);
            });
        }
        _decodeOnLoadVideo(videoElement) {
            return __awaiter(this, void 0, void 0, function* () {
                // plays the video
                yield this.playVideoOnLoadAsync(videoElement);
                // starts decoding after played the video
                return yield this.decodeOnce(videoElement);
            });
        }
        _decodeOnLoadVideoContinuously(videoElement, callbackFn) {
            return __awaiter(this, void 0, void 0, function* () {
                // plays the video
                yield this.playVideoOnLoadAsync(videoElement);
                // starts decoding after played the video
                this.decodeContinuously(videoElement, callbackFn);
            });
        }
        isImageLoaded(img) {
            // During the onload event, IE correctly identifies any images that
            // weren’t downloaded as not complete. Others should too. Gecko-based
            // browsers act like NS4 in that they report this incorrectly.
            if (!img.complete) {
                return false;
            }
            // However, they do have two very useful properties: naturalWidth and
            // naturalHeight. These give the true size of the image. If it failed
            // to load, either of these should be zero.
            if (img.naturalWidth === 0) {
                return false;
            }
            // No other way of checking: assume it’s ok.
            return true;
        }
        prepareImageElement(imageSource) {
            let imageElement;
            if (typeof imageSource === 'undefined') {
                imageElement = document.createElement('img');
                imageElement.width = 200;
                imageElement.height = 200;
            }
            if (typeof imageSource === 'string') {
                imageElement = this.getMediaElement(imageSource, 'img');
            }
            if (imageSource instanceof HTMLImageElement) {
                imageElement = imageSource;
            }
            return imageElement;
        }
        /**
         * Sets a HTMLVideoElement for scanning or creates a new one.
         *
         * @param videoSource The HTMLVideoElement to be set.
         */
        prepareVideoElement(videoSource) {
            let videoElement;
            if (!videoSource && typeof document !== 'undefined') {
                videoElement = document.createElement('video');
                videoElement.width = 200;
                videoElement.height = 200;
            }
            if (typeof videoSource === 'string') {
                videoElement = this.getMediaElement(videoSource, 'video');
            }
            if (videoSource instanceof HTMLVideoElement) {
                videoElement = videoSource;
            }
            // Needed for iOS 11
            videoElement.setAttribute('autoplay', 'true');
            videoElement.setAttribute('muted', 'true');
            videoElement.setAttribute('playsinline', 'true');
            return videoElement;
        }
        /**
         * Tries to decode from the video input until it finds some value.
         */
        decodeOnce(element, retryIfNotFound = true, retryIfChecksumOrFormatError = true) {
            this._stopAsyncDecode = false;
            const loop = (resolve, reject) => {
                if (this._stopAsyncDecode) {
                    reject(new NotFoundException('Video stream has ended before any code could be detected.'));
                    this._stopAsyncDecode = undefined;
                    return;
                }
                try {
                    const result = this.decode(element);
                    resolve(result);
                }
                catch (e) {
                    const ifNotFound = retryIfNotFound && e instanceof NotFoundException;
                    const isChecksumOrFormatError = e instanceof ChecksumException || e instanceof FormatException;
                    const ifChecksumOrFormat = isChecksumOrFormatError && retryIfChecksumOrFormatError;
                    if (ifNotFound || ifChecksumOrFormat) {
                        // trying again
                        return setTimeout(loop, this._timeBetweenDecodingAttempts, resolve, reject);
                    }
                    reject(e);
                }
            };
            return new Promise((resolve, reject) => loop(resolve, reject));
        }
        /**
         * Continuously decodes from video input.
         */
        decodeContinuously(element, callbackFn) {
            this._stopContinuousDecode = false;
            const loop = () => {
                if (this._stopContinuousDecode) {
                    this._stopContinuousDecode = undefined;
                    return;
                }
                try {
                    const result = this.decode(element);
                    callbackFn(result, null);
                    setTimeout(loop, this.timeBetweenScansMillis);
                }
                catch (e) {
                    callbackFn(null, e);
                    const isChecksumOrFormatError = e instanceof ChecksumException || e instanceof FormatException;
                    const isNotFound = e instanceof NotFoundException;
                    if (isChecksumOrFormatError || isNotFound) {
                        // trying again
                        setTimeout(loop, this._timeBetweenDecodingAttempts);
                    }
                }
            };
            loop();
        }
        /**
         * Gets the BinaryBitmap for ya! (and decodes it)
         */
        decode(element) {
            // get binary bitmap for decode function
            const binaryBitmap = this.createBinaryBitmap(element);
            return this.decodeBitmap(binaryBitmap);
        }
        _isHTMLVideoElement(mediaElement) {
            const potentialVideo = mediaElement;
            return potentialVideo.videoWidth !== 0;
        }
        /**
         * Creates a binaryBitmap based in some image source.
         *
         * @param mediaElement HTML element containing drawable image source.
         */
        createBinaryBitmap(mediaElement) {
            const ctx = this.getCaptureCanvasContext(mediaElement);
            if (this._isHTMLVideoElement(mediaElement)) {
                this.drawFrameOnCanvas(mediaElement);
            }
            else {
                this.drawImageOnCanvas(mediaElement);
            }
            const canvas = this.getCaptureCanvas(mediaElement);
            const luminanceSource = new HTMLCanvasElementLuminanceSource(canvas);
            const hybridBinarizer = new HybridBinarizer(luminanceSource);
            return new BinaryBitmap(hybridBinarizer);
        }
        /**
         *
         */
        getCaptureCanvasContext(mediaElement) {
            if (!this.captureCanvasContext) {
                const elem = this.getCaptureCanvas(mediaElement);
                const ctx = elem.getContext('2d');
                this.captureCanvasContext = ctx;
            }
            return this.captureCanvasContext;
        }
        /**
         *
         */
        getCaptureCanvas(mediaElement) {
            if (!this.captureCanvas) {
                const elem = this.createCaptureCanvas(mediaElement);
                this.captureCanvas = elem;
            }
            return this.captureCanvas;
        }
        /**
         * Overwriting this allows you to manipulate the next frame in anyway you want before decode.
         */
        drawFrameOnCanvas(srcElement, dimensions = { sx: 0, sy: 0, sWidth: srcElement.videoWidth, sHeight: srcElement.videoHeight, dx: 0, dy: 0, dWidth: srcElement.videoWidth, dHeight: srcElement.videoHeight }, canvasElementContext = this.captureCanvasContext) {
            canvasElementContext.drawImage(srcElement, dimensions.sx, dimensions.sy, dimensions.sWidth, dimensions.sHeight, dimensions.dx, dimensions.dy, dimensions.dWidth, dimensions.dHeight);
        }
        /**
         * Ovewriting this allows you to manipulate the snapshot image in anyway you want before decode.
         */
        drawImageOnCanvas(srcElement, dimensions = { sx: 0, sy: 0, sWidth: srcElement.naturalWidth, sHeight: srcElement.naturalHeight, dx: 0, dy: 0, dWidth: srcElement.naturalWidth, dHeight: srcElement.naturalHeight }, canvasElementContext = this.captureCanvasContext) {
            canvasElementContext.drawImage(srcElement, dimensions.sx, dimensions.sy, dimensions.sWidth, dimensions.sHeight, dimensions.dx, dimensions.dy, dimensions.dWidth, dimensions.dHeight);
        }
        /**
         * Call the encapsulated readers decode
         */
        decodeBitmap(binaryBitmap) {
            return this.reader.decode(binaryBitmap, this._hints);
        }
        /**
         * 🖌 Prepares the canvas for capture and scan frames.
         */
        createCaptureCanvas(mediaElement) {
            if (typeof document === 'undefined') {
                this._destroyCaptureCanvas();
                return null;
            }
            const canvasElement = document.createElement('canvas');
            let width;
            let height;
            if (typeof mediaElement !== 'undefined') {
                if (mediaElement instanceof HTMLVideoElement) {
                    width = mediaElement.videoWidth;
                    height = mediaElement.videoHeight;
                }
                else if (mediaElement instanceof HTMLImageElement) {
                    width = mediaElement.naturalWidth || mediaElement.width;
                    height = mediaElement.naturalHeight || mediaElement.height;
                }
            }
            canvasElement.style.width = width + 'px';
            canvasElement.style.height = height + 'px';
            canvasElement.width = width;
            canvasElement.height = height;
            return canvasElement;
        }
        /**
         * Stops the continuous scan and cleans the stream.
         */
        stopStreams() {
            if (this.stream) {
                this.stream.getVideoTracks().forEach(t => t.stop());
                this.stream = undefined;
            }
            if (this._stopAsyncDecode === false) {
                this.stopAsyncDecode();
            }
            if (this._stopContinuousDecode === false) {
                this.stopContinuousDecode();
            }
        }
        /**
         * Resets the code reader to the initial state. Cancels any ongoing barcode scanning from video or camera.
         *
         * @memberOf BrowserCodeReader
         */
        reset() {
            // stops the camera, preview and scan 🔴
            this.stopStreams();
            // clean and forget about HTML elements
            this._destroyVideoElement();
            this._destroyImageElement();
            this._destroyCaptureCanvas();
        }
        _destroyVideoElement() {
            if (!this.videoElement) {
                return;
            }
            // first gives freedon to the element 🕊
            if (typeof this.videoEndedListener !== 'undefined') {
                this.videoElement.removeEventListener('ended', this.videoEndedListener);
            }
            if (typeof this.videoPlayingEventListener !== 'undefined') {
                this.videoElement.removeEventListener('playing', this.videoPlayingEventListener);
            }
            if (typeof this.videoCanPlayListener !== 'undefined') {
                this.videoElement.removeEventListener('loadedmetadata', this.videoCanPlayListener);
            }
            // then forgets about that element 😢
            this.cleanVideoSource(this.videoElement);
            this.videoElement = undefined;
        }
        _destroyImageElement() {
            if (!this.imageElement) {
                return;
            }
            // first gives freedon to the element 🕊
            if (undefined !== this.imageLoadedListener) {
                this.imageElement.removeEventListener('load', this.imageLoadedListener);
            }
            // then forget about that element 😢
            this.imageElement.src = undefined;
            this.imageElement.removeAttribute('src');
            this.imageElement = undefined;
        }
        /**
         * Cleans canvas references 🖌
         */
        _destroyCaptureCanvas() {
            // then forget about that element 😢
            this.captureCanvasContext = undefined;
            this.captureCanvas = undefined;
        }
        /**
         * Defines what the videoElement src will be.
         *
         * @param videoElement
         * @param stream
         */
        addVideoSource(videoElement, stream) {
            // Older browsers may not have `srcObject`
            try {
                // @note Throws Exception if interrupted by a new loaded request
                videoElement.srcObject = stream;
            }
            catch (err) {
                // @note Avoid using this in new browsers, as it is going away.
                videoElement.src = URL.createObjectURL(stream);
            }
        }
        /**
         * Unbinds a HTML video src property.
         *
         * @param videoElement
         */
        cleanVideoSource(videoElement) {
            try {
                videoElement.srcObject = null;
            }
            catch (err) {
                videoElement.src = '';
            }
            this.videoElement.removeAttribute('src');
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Encapsulates the result of decoding a barcode within an image.</p>
     *
     * @author Sean Owen
     */
    class Result {
        // public constructor(private text: string,
        //               Uint8Array rawBytes,
        //               ResultPoconst resultPoints: Int32Array,
        //               BarcodeFormat format) {
        //   this(text, rawBytes, resultPoints, format, System.currentTimeMillis())
        // }
        // public constructor(text: string,
        //               Uint8Array rawBytes,
        //               ResultPoconst resultPoints: Int32Array,
        //               BarcodeFormat format,
        //               long timestamp) {
        //   this(text, rawBytes, rawBytes == null ? 0 : 8 * rawBytes.length,
        //        resultPoints, format, timestamp)
        // }
        constructor(text, rawBytes, numBits = rawBytes == null ? 0 : 8 * rawBytes.length, resultPoints, format, timestamp = System.currentTimeMillis()) {
            this.text = text;
            this.rawBytes = rawBytes;
            this.numBits = numBits;
            this.resultPoints = resultPoints;
            this.format = format;
            this.timestamp = timestamp;
            this.text = text;
            this.rawBytes = rawBytes;
            if (undefined === numBits || null === numBits) {
                this.numBits = (rawBytes === null || rawBytes === undefined) ? 0 : 8 * rawBytes.length;
            }
            else {
                this.numBits = numBits;
            }
            this.resultPoints = resultPoints;
            this.format = format;
            this.resultMetadata = null;
            if (undefined === timestamp || null === timestamp) {
                this.timestamp = System.currentTimeMillis();
            }
            else {
                this.timestamp = timestamp;
            }
        }
        /**
         * @return raw text encoded by the barcode
         */
        getText() {
            return this.text;
        }
        /**
         * @return raw bytes encoded by the barcode, if applicable, otherwise {@code null}
         */
        getRawBytes() {
            return this.rawBytes;
        }
        /**
         * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length
         * @since 3.3.0
         */
        getNumBits() {
            return this.numBits;
        }
        /**
         * @return points related to the barcode in the image. These are typically points
         *         identifying finder patterns or the corners of the barcode. The exact meaning is
         *         specific to the type of barcode that was decoded.
         */
        getResultPoints() {
            return this.resultPoints;
        }
        /**
         * @return {@link BarcodeFormat} representing the format of the barcode that was decoded
         */
        getBarcodeFormat() {
            return this.format;
        }
        /**
         * @return {@link Map} mapping {@link ResultMetadataType} keys to values. May be
         *   {@code null}. This contains optional metadata about what was detected about the barcode,
         *   like orientation.
         */
        getResultMetadata() {
            return this.resultMetadata;
        }
        putMetadata(type, value) {
            if (this.resultMetadata === null) {
                this.resultMetadata = new Map();
            }
            this.resultMetadata.set(type, value);
        }
        putAllMetadata(metadata) {
            if (metadata !== null) {
                if (this.resultMetadata === null) {
                    this.resultMetadata = metadata;
                }
                else {
                    this.resultMetadata = new Map(metadata);
                }
            }
        }
        addResultPoints(newPoints) {
            const oldPoints = this.resultPoints;
            if (oldPoints === null) {
                this.resultPoints = newPoints;
            }
            else if (newPoints !== null && newPoints.length > 0) {
                const allPoints = new Array(oldPoints.length + newPoints.length);
                System.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);
                System.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);
                this.resultPoints = allPoints;
            }
        }
        getTimestamp() {
            return this.timestamp;
        }
        /*@Override*/
        toString() {
            return this.text;
        }
    }

    /*
     * Direct port to TypeScript of ZXing by Adrian Toșcă
     */
    /*
     * Copyright 2009 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*namespace com.google.zxing {*/
    /**
     * Enumerates barcode formats known to this package. Please keep alphabetized.
     *
     * @author Sean Owen
     */
    var BarcodeFormat;
    (function (BarcodeFormat) {
        /** Aztec 2D barcode format. */
        BarcodeFormat[BarcodeFormat["AZTEC"] = 0] = "AZTEC";
        /** CODABAR 1D format. */
        BarcodeFormat[BarcodeFormat["CODABAR"] = 1] = "CODABAR";
        /** Code 39 1D format. */
        BarcodeFormat[BarcodeFormat["CODE_39"] = 2] = "CODE_39";
        /** Code 93 1D format. */
        BarcodeFormat[BarcodeFormat["CODE_93"] = 3] = "CODE_93";
        /** Code 128 1D format. */
        BarcodeFormat[BarcodeFormat["CODE_128"] = 4] = "CODE_128";
        /** Data Matrix 2D barcode format. */
        BarcodeFormat[BarcodeFormat["DATA_MATRIX"] = 5] = "DATA_MATRIX";
        /** EAN-8 1D format. */
        BarcodeFormat[BarcodeFormat["EAN_8"] = 6] = "EAN_8";
        /** EAN-13 1D format. */
        BarcodeFormat[BarcodeFormat["EAN_13"] = 7] = "EAN_13";
        /** ITF (Interleaved Two of Five) 1D format. */
        BarcodeFormat[BarcodeFormat["ITF"] = 8] = "ITF";
        /** MaxiCode 2D barcode format. */
        BarcodeFormat[BarcodeFormat["MAXICODE"] = 9] = "MAXICODE";
        /** PDF417 format. */
        BarcodeFormat[BarcodeFormat["PDF_417"] = 10] = "PDF_417";
        /** QR Code 2D barcode format. */
        BarcodeFormat[BarcodeFormat["QR_CODE"] = 11] = "QR_CODE";
        /** RSS 14 */
        BarcodeFormat[BarcodeFormat["RSS_14"] = 12] = "RSS_14";
        /** RSS EXPANDED */
        BarcodeFormat[BarcodeFormat["RSS_EXPANDED"] = 13] = "RSS_EXPANDED";
        /** UPC-A 1D format. */
        BarcodeFormat[BarcodeFormat["UPC_A"] = 14] = "UPC_A";
        /** UPC-E 1D format. */
        BarcodeFormat[BarcodeFormat["UPC_E"] = 15] = "UPC_E";
        /** UPC/EAN extension format. Not a stand-alone format. */
        BarcodeFormat[BarcodeFormat["UPC_EAN_EXTENSION"] = 16] = "UPC_EAN_EXTENSION";
    })(BarcodeFormat || (BarcodeFormat = {}));
    var BarcodeFormat$1 = BarcodeFormat;

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*namespace com.google.zxing {*/
    /**
     * Represents some type of metadata about the result of the decoding that the decoder
     * wishes to communicate back to the caller.
     *
     * @author Sean Owen
     */
    var ResultMetadataType;
    (function (ResultMetadataType) {
        /**
         * Unspecified, application-specific metadata. Maps to an unspecified {@link Object}.
         */
        ResultMetadataType[ResultMetadataType["OTHER"] = 0] = "OTHER";
        /**
         * Denotes the likely approximate orientation of the barcode in the image. This value
         * is given as degrees rotated clockwise from the normal, upright orientation.
         * For example a 1D barcode which was found by reading top-to-bottom would be
         * said to have orientation "90". This key maps to an {@link Integer} whose
         * value is in the range [0,360).
         */
        ResultMetadataType[ResultMetadataType["ORIENTATION"] = 1] = "ORIENTATION";
        /**
         * <p>2D barcode formats typically encode text, but allow for a sort of 'byte mode'
         * which is sometimes used to encode binary data. While {@link Result} makes available
         * the complete raw bytes in the barcode for these formats, it does not offer the bytes
         * from the byte segments alone.</p>
         *
         * <p>This maps to a {@link java.util.List} of byte arrays corresponding to the
         * raw bytes in the byte segments in the barcode, in order.</p>
         */
        ResultMetadataType[ResultMetadataType["BYTE_SEGMENTS"] = 2] = "BYTE_SEGMENTS";
        /**
         * Error correction level used, if applicable. The value type depends on the
         * format, but is typically a String.
         */
        ResultMetadataType[ResultMetadataType["ERROR_CORRECTION_LEVEL"] = 3] = "ERROR_CORRECTION_LEVEL";
        /**
         * For some periodicals, indicates the issue number as an {@link Integer}.
         */
        ResultMetadataType[ResultMetadataType["ISSUE_NUMBER"] = 4] = "ISSUE_NUMBER";
        /**
         * For some products, indicates the suggested retail price in the barcode as a
         * formatted {@link String}.
         */
        ResultMetadataType[ResultMetadataType["SUGGESTED_PRICE"] = 5] = "SUGGESTED_PRICE";
        /**
         * For some products, the possible country of manufacture as a {@link String} denoting the
         * ISO country code. Some map to multiple possible countries, like "US/CA".
         */
        ResultMetadataType[ResultMetadataType["POSSIBLE_COUNTRY"] = 6] = "POSSIBLE_COUNTRY";
        /**
         * For some products, the extension text
         */
        ResultMetadataType[ResultMetadataType["UPC_EAN_EXTENSION"] = 7] = "UPC_EAN_EXTENSION";
        /**
         * PDF417-specific metadata
         */
        ResultMetadataType[ResultMetadataType["PDF417_EXTRA_METADATA"] = 8] = "PDF417_EXTRA_METADATA";
        /**
         * If the code format supports structured append and the current scanned code is part of one then the
         * sequence number is given with it.
         */
        ResultMetadataType[ResultMetadataType["STRUCTURED_APPEND_SEQUENCE"] = 9] = "STRUCTURED_APPEND_SEQUENCE";
        /**
         * If the code format supports structured append and the current scanned code is part of one then the
         * parity is given with it.
         */
        ResultMetadataType[ResultMetadataType["STRUCTURED_APPEND_PARITY"] = 10] = "STRUCTURED_APPEND_PARITY";
    })(ResultMetadataType || (ResultMetadataType = {}));
    var ResultMetadataType$1 = ResultMetadataType;

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*namespace com.google.zxing.common {*/
    /*import java.util.List;*/
    /**
     * <p>Encapsulates the result of decoding a matrix of bits. This typically
     * applies to 2D barcode formats. For now it contains the raw bytes obtained,
     * as well as a String interpretation of those bytes, if applicable.</p>
     *
     * @author Sean Owen
     */
    class DecoderResult {
        // public constructor(rawBytes: Uint8Array,
        //                      text: string,
        //                      List<Uint8Array> byteSegments,
        //                      String ecLevel) {
        //   this(rawBytes, text, byteSegments, ecLevel, -1, -1)
        // }
        constructor(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber = -1, structuredAppendParity = -1) {
            this.rawBytes = rawBytes;
            this.text = text;
            this.byteSegments = byteSegments;
            this.ecLevel = ecLevel;
            this.structuredAppendSequenceNumber = structuredAppendSequenceNumber;
            this.structuredAppendParity = structuredAppendParity;
            this.numBits = (rawBytes === undefined || rawBytes === null) ? 0 : 8 * rawBytes.length;
        }
        /**
         * @return raw bytes representing the result, or {@code null} if not applicable
         */
        getRawBytes() {
            return this.rawBytes;
        }
        /**
         * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length
         * @since 3.3.0
         */
        getNumBits() {
            return this.numBits;
        }
        /**
         * @param numBits overrides the number of bits that are valid in {@link #getRawBytes()}
         * @since 3.3.0
         */
        setNumBits(numBits /*int*/) {
            this.numBits = numBits;
        }
        /**
         * @return text representation of the result
         */
        getText() {
            return this.text;
        }
        /**
         * @return list of byte segments in the result, or {@code null} if not applicable
         */
        getByteSegments() {
            return this.byteSegments;
        }
        /**
         * @return name of error correction level used, or {@code null} if not applicable
         */
        getECLevel() {
            return this.ecLevel;
        }
        /**
         * @return number of errors corrected, or {@code null} if not applicable
         */
        getErrorsCorrected() {
            return this.errorsCorrected;
        }
        setErrorsCorrected(errorsCorrected /*Integer*/) {
            this.errorsCorrected = errorsCorrected;
        }
        /**
         * @return number of erasures corrected, or {@code null} if not applicable
         */
        getErasures() {
            return this.erasures;
        }
        setErasures(erasures /*Integer*/) {
            this.erasures = erasures;
        }
        /**
         * @return arbitrary additional metadata
         */
        getOther() {
            return this.other;
        }
        setOther(other) {
            this.other = other;
        }
        hasStructuredAppend() {
            return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;
        }
        getStructuredAppendParity() {
            return this.structuredAppendParity;
        }
        getStructuredAppendSequenceNumber() {
            return this.structuredAppendSequenceNumber;
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>This class contains utility methods for performing mathematical operations over
     * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>
     *
     * <p>Throughout this package, elements of the GF are represented as an {@code int}
     * for convenience and speed (but at the cost of memory).
     * </p>
     *
     * @author Sean Owen
     * @author David Olivier
     */
    class AbstractGenericGF {
        /**
         * @return 2 to the power of a in GF(size)
         */
        exp(a) {
            return this.expTable[a];
        }
        /**
         * @return base 2 log of a in GF(size)
         */
        log(a /*int*/) {
            if (a === 0) {
                throw new IllegalArgumentException();
            }
            return this.logTable[a];
        }
        /**
         * Implements both addition and subtraction -- they are the same in GF(size).
         *
         * @return sum/difference of a and b
         */
        static addOrSubtract(a /*int*/, b /*int*/) {
            return a ^ b;
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Represents a polynomial whose coefficients are elements of a GF.
     * Instances of this class are immutable.</p>
     *
     * <p>Much credit is due to William Rucklidge since portions of this code are an indirect
     * port of his C++ Reed-Solomon implementation.</p>
     *
     * @author Sean Owen
     */
    class GenericGFPoly {
        /**
         * @param field the {@link GenericGF} instance representing the field to use
         * to perform computations
         * @param coefficients coefficients as ints representing elements of GF(size), arranged
         * from most significant (highest-power term) coefficient to least significant
         * @throws IllegalArgumentException if argument is null or empty,
         * or if leading coefficient is 0 and this is not a
         * constant polynomial (that is, it is not the monomial "0")
         */
        constructor(field, coefficients) {
            if (coefficients.length === 0) {
                throw new IllegalArgumentException();
            }
            this.field = field;
            const coefficientsLength = coefficients.length;
            if (coefficientsLength > 1 && coefficients[0] === 0) {
                // Leading term must be non-zero for anything except the constant polynomial "0"
                let firstNonZero = 1;
                while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
                    firstNonZero++;
                }
                if (firstNonZero === coefficientsLength) {
                    this.coefficients = Int32Array.from([0]);
                }
                else {
                    this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
                    System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
                }
            }
            else {
                this.coefficients = coefficients;
            }
        }
        getCoefficients() {
            return this.coefficients;
        }
        /**
         * @return degree of this polynomial
         */
        getDegree() {
            return this.coefficients.length - 1;
        }
        /**
         * @return true iff this polynomial is the monomial "0"
         */
        isZero() {
            return this.coefficients[0] === 0;
        }
        /**
         * @return coefficient of x^degree term in this polynomial
         */
        getCoefficient(degree /*int*/) {
            return this.coefficients[this.coefficients.length - 1 - degree];
        }
        /**
         * @return evaluation of this polynomial at a given point
         */
        evaluateAt(a /*int*/) {
            if (a === 0) {
                // Just return the x^0 coefficient
                return this.getCoefficient(0);
            }
            const coefficients = this.coefficients;
            let result;
            if (a === 1) {
                // Just the sum of the coefficients
                result = 0;
                for (let i = 0, length = coefficients.length; i !== length; i++) {
                    const coefficient = coefficients[i];
                    result = AbstractGenericGF.addOrSubtract(result, coefficient);
                }
                return result;
            }
            result = coefficients[0];
            const size = coefficients.length;
            const field = this.field;
            for (let i = 1; i < size; i++) {
                result = AbstractGenericGF.addOrSubtract(field.multiply(a, result), coefficients[i]);
            }
            return result;
        }
        addOrSubtract(other) {
            if (!this.field.equals(other.field)) {
                throw new IllegalArgumentException('GenericGFPolys do not have same GenericGF field');
            }
            if (this.isZero()) {
                return other;
            }
            if (other.isZero()) {
                return this;
            }
            let smallerCoefficients = this.coefficients;
            let largerCoefficients = other.coefficients;
            if (smallerCoefficients.length > largerCoefficients.length) {
                const temp = smallerCoefficients;
                smallerCoefficients = largerCoefficients;
                largerCoefficients = temp;
            }
            let sumDiff = new Int32Array(largerCoefficients.length);
            const lengthDiff = largerCoefficients.length - smallerCoefficients.length;
            // Copy high-order terms only found in higher-degree polynomial's coefficients
            System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
            for (let i = lengthDiff; i < largerCoefficients.length; i++) {
                sumDiff[i] = AbstractGenericGF.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
            }
            return new GenericGFPoly(this.field, sumDiff);
        }
        multiply(other) {
            if (!this.field.equals(other.field)) {
                throw new IllegalArgumentException('GenericGFPolys do not have same GenericGF field');
            }
            if (this.isZero() || other.isZero()) {
                return this.field.getZero();
            }
            const aCoefficients = this.coefficients;
            const aLength = aCoefficients.length;
            const bCoefficients = other.coefficients;
            const bLength = bCoefficients.length;
            const product = new Int32Array(aLength + bLength - 1);
            const field = this.field;
            for (let i = 0; i < aLength; i++) {
                const aCoeff = aCoefficients[i];
                for (let j = 0; j < bLength; j++) {
                    product[i + j] = AbstractGenericGF.addOrSubtract(product[i + j], field.multiply(aCoeff, bCoefficients[j]));
                }
            }
            return new GenericGFPoly(field, product);
        }
        multiplyScalar(scalar /*int*/) {
            if (scalar === 0) {
                return this.field.getZero();
            }
            if (scalar === 1) {
                return this;
            }
            const size = this.coefficients.length;
            const field = this.field;
            const product = new Int32Array(size);
            const coefficients = this.coefficients;
            for (let i = 0; i < size; i++) {
                product[i] = field.multiply(coefficients[i], scalar);
            }
            return new GenericGFPoly(field, product);
        }
        multiplyByMonomial(degree /*int*/, coefficient /*int*/) {
            if (degree < 0) {
                throw new IllegalArgumentException();
            }
            if (coefficient === 0) {
                return this.field.getZero();
            }
            const coefficients = this.coefficients;
            const size = coefficients.length;
            const product = new Int32Array(size + degree);
            const field = this.field;
            for (let i = 0; i < size; i++) {
                product[i] = field.multiply(coefficients[i], coefficient);
            }
            return new GenericGFPoly(field, product);
        }
        divide(other) {
            if (!this.field.equals(other.field)) {
                throw new IllegalArgumentException('GenericGFPolys do not have same GenericGF field');
            }
            if (other.isZero()) {
                throw new IllegalArgumentException('Divide by 0');
            }
            const field = this.field;
            let quotient = field.getZero();
            let remainder = this;
            const denominatorLeadingTerm = other.getCoefficient(other.getDegree());
            const inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);
            while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {
                const degreeDifference = remainder.getDegree() - other.getDegree();
                const scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);
                const term = other.multiplyByMonomial(degreeDifference, scale);
                const iterationQuotient = field.buildMonomial(degreeDifference, scale);
                quotient = quotient.addOrSubtract(iterationQuotient);
                remainder = remainder.addOrSubtract(term);
            }
            return [quotient, remainder];
        }
        /*@Override*/
        toString() {
            let result = '';
            for (let degree = this.getDegree(); degree >= 0; degree--) {
                let coefficient = this.getCoefficient(degree);
                if (coefficient !== 0) {
                    if (coefficient < 0) {
                        result += ' - ';
                        coefficient = -coefficient;
                    }
                    else {
                        if (result.length > 0) {
                            result += ' + ';
                        }
                    }
                    if (degree === 0 || coefficient !== 1) {
                        const alphaPower = this.field.log(coefficient);
                        if (alphaPower === 0) {
                            result += '1';
                        }
                        else if (alphaPower === 1) {
                            result += 'a';
                        }
                        else {
                            result += 'a^';
                            result += alphaPower;
                        }
                    }
                    if (degree !== 0) {
                        if (degree === 1) {
                            result += 'x';
                        }
                        else {
                            result += 'x^';
                            result += degree;
                        }
                    }
                }
            }
            return result;
        }
    }

    /**
     * Custom Error class of type Exception.
     */
    class ArithmeticException extends Exception {
    }
    ArithmeticException.kind = 'ArithmeticException';

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>This class contains utility methods for performing mathematical operations over
     * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>
     *
     * <p>Throughout this package, elements of the GF are represented as an {@code int}
     * for convenience and speed (but at the cost of memory).
     * </p>
     *
     * @author Sean Owen
     * @author David Olivier
     */
    class GenericGF extends AbstractGenericGF {
        /**
         * Create a representation of GF(size) using the given primitive polynomial.
         *
         * @param primitive irreducible polynomial whose coefficients are represented by
         *  the bits of an int, where the least-significant bit represents the constant
         *  coefficient
         * @param size the size of the field
         * @param b the factor b in the generator polynomial can be 0- or 1-based
         *  (g(x) = (x+a^b)(x+a^(b+1))...(x+a^(b+2t-1))).
         *  In most cases it should be 1, but for QR code it is 0.
         */
        constructor(primitive /*int*/, size /*int*/, generatorBase /*int*/) {
            super();
            this.primitive = primitive;
            this.size = size;
            this.generatorBase = generatorBase;
            const expTable = new Int32Array(size);
            let x = 1;
            for (let i = 0; i < size; i++) {
                expTable[i] = x;
                x *= 2; // we're assuming the generator alpha is 2
                if (x >= size) {
                    x ^= primitive;
                    x &= size - 1;
                }
            }
            this.expTable = expTable;
            const logTable = new Int32Array(size);
            for (let i = 0; i < size - 1; i++) {
                logTable[expTable[i]] = i;
            }
            this.logTable = logTable;
            // logTable[0] == 0 but this should never be used
            this.zero = new GenericGFPoly(this, Int32Array.from([0]));
            this.one = new GenericGFPoly(this, Int32Array.from([1]));
        }
        getZero() {
            return this.zero;
        }
        getOne() {
            return this.one;
        }
        /**
         * @return the monomial representing coefficient * x^degree
         */
        buildMonomial(degree /*int*/, coefficient /*int*/) {
            if (degree < 0) {
                throw new IllegalArgumentException();
            }
            if (coefficient === 0) {
                return this.zero;
            }
            const coefficients = new Int32Array(degree + 1);
            coefficients[0] = coefficient;
            return new GenericGFPoly(this, coefficients);
        }
        /**
         * @return multiplicative inverse of a
         */
        inverse(a /*int*/) {
            if (a === 0) {
                throw new ArithmeticException();
            }
            return this.expTable[this.size - this.logTable[a] - 1];
        }
        /**
         * @return product of a and b in GF(size)
         */
        multiply(a /*int*/, b /*int*/) {
            if (a === 0 || b === 0) {
                return 0;
            }
            return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.size - 1)];
        }
        getSize() {
            return this.size;
        }
        getGeneratorBase() {
            return this.generatorBase;
        }
        /*@Override*/
        toString() {
            return ('GF(0x' + Integer.toHexString(this.primitive) + ',' + this.size + ')');
        }
        equals(o) {
            return o === this;
        }
    }
    GenericGF.AZTEC_DATA_12 = new GenericGF(0x1069, 4096, 1); // x^12 + x^6 + x^5 + x^3 + 1
    GenericGF.AZTEC_DATA_10 = new GenericGF(0x409, 1024, 1); // x^10 + x^3 + 1
    GenericGF.AZTEC_DATA_6 = new GenericGF(0x43, 64, 1); // x^6 + x + 1
    GenericGF.AZTEC_PARAM = new GenericGF(0x13, 16, 1); // x^4 + x + 1
    GenericGF.QR_CODE_FIELD_256 = new GenericGF(0x011d, 256, 0); // x^8 + x^4 + x^3 + x^2 + 1
    GenericGF.DATA_MATRIX_FIELD_256 = new GenericGF(0x012d, 256, 1); // x^8 + x^5 + x^3 + x^2 + 1
    GenericGF.AZTEC_DATA_8 = GenericGF.DATA_MATRIX_FIELD_256;
    GenericGF.MAXICODE_FIELD_64 = GenericGF.AZTEC_DATA_6;

    /**
     * Custom Error class of type Exception.
     */
    class ReedSolomonException extends Exception {
    }
    ReedSolomonException.kind = 'ReedSolomonException';

    /**
     * Custom Error class of type Exception.
     */
    class IllegalStateException extends Exception {
    }
    IllegalStateException.kind = 'IllegalStateException';

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Implements Reed-Solomon decoding, as the name implies.</p>
     *
     * <p>The algorithm will not be explained here, but the following references were helpful
     * in creating this implementation:</p>
     *
     * <ul>
     * <li>Bruce Maggs.
     * <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/pscico-guyb/realworld/www/rs_decode.ps">
     * "Decoding Reed-Solomon Codes"</a> (see discussion of Forney's Formula)</li>
     * <li>J.I. Hall. <a href="www.mth.msu.edu/~jhall/classes/codenotes/GRS.pdf">
     * "Chapter 5. Generalized Reed-Solomon Codes"</a>
     * (see discussion of Euclidean algorithm)</li>
     * </ul>
     *
     * <p>Much credit is due to William Rucklidge since portions of this code are an indirect
     * port of his C++ Reed-Solomon implementation.</p>
     *
     * @author Sean Owen
     * @author William Rucklidge
     * @author sanfordsquires
     */
    class ReedSolomonDecoder {
        constructor(field) {
            this.field = field;
        }
        /**
         * <p>Decodes given set of received codewords, which include both data and error-correction
         * codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,
         * in the input.</p>
         *
         * @param received data and error-correction codewords
         * @param twoS number of error-correction codewords available
         * @throws ReedSolomonException if decoding fails for any reason
         */
        decode(received, twoS /*int*/) {
            const field = this.field;
            const poly = new GenericGFPoly(field, received);
            const syndromeCoefficients = new Int32Array(twoS);
            let noError = true;
            for (let i = 0; i < twoS; i++) {
                const evalResult = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));
                syndromeCoefficients[syndromeCoefficients.length - 1 - i] = evalResult;
                if (evalResult !== 0) {
                    noError = false;
                }
            }
            if (noError) {
                return;
            }
            const syndrome = new GenericGFPoly(field, syndromeCoefficients);
            const sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);
            const sigma = sigmaOmega[0];
            const omega = sigmaOmega[1];
            const errorLocations = this.findErrorLocations(sigma);
            const errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);
            for (let i = 0; i < errorLocations.length; i++) {
                const position = received.length - 1 - field.log(errorLocations[i]);
                if (position < 0) {
                    throw new ReedSolomonException('Bad error location');
                }
                received[position] = GenericGF.addOrSubtract(received[position], errorMagnitudes[i]);
            }
        }
        runEuclideanAlgorithm(a, b, R /*int*/) {
            // Assume a's degree is >= b's
            if (a.getDegree() < b.getDegree()) {
                const temp = a;
                a = b;
                b = temp;
            }
            const field = this.field;
            let rLast = a;
            let r = b;
            let tLast = field.getZero();
            let t = field.getOne();
            // Run Euclidean algorithm until r's degree is less than R/2
            while (r.getDegree() >= (R / 2 | 0)) {
                let rLastLast = rLast;
                let tLastLast = tLast;
                rLast = r;
                tLast = t;
                // Divide rLastLast by rLast, with quotient in q and remainder in r
                if (rLast.isZero()) {
                    // Oops, Euclidean algorithm already terminated?
                    throw new ReedSolomonException('r_{i-1} was zero');
                }
                r = rLastLast;
                let q = field.getZero();
                const denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
                const dltInverse = field.inverse(denominatorLeadingTerm);
                while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {
                    const degreeDiff = r.getDegree() - rLast.getDegree();
                    const scale = field.multiply(r.getCoefficient(r.getDegree()), dltInverse);
                    q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));
                    r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
                }
                t = q.multiply(tLast).addOrSubtract(tLastLast);
                if (r.getDegree() >= rLast.getDegree()) {
                    throw new IllegalStateException('Division algorithm failed to reduce polynomial?');
                }
            }
            const sigmaTildeAtZero = t.getCoefficient(0);
            if (sigmaTildeAtZero === 0) {
                throw new ReedSolomonException('sigmaTilde(0) was zero');
            }
            const inverse = field.inverse(sigmaTildeAtZero);
            const sigma = t.multiplyScalar(inverse);
            const omega = r.multiplyScalar(inverse);
            return [sigma, omega];
        }
        findErrorLocations(errorLocator) {
            // This is a direct application of Chien's search
            const numErrors = errorLocator.getDegree();
            if (numErrors === 1) { // shortcut
                return Int32Array.from([errorLocator.getCoefficient(1)]);
            }
            const result = new Int32Array(numErrors);
            let e = 0;
            const field = this.field;
            for (let i = 1; i < field.getSize() && e < numErrors; i++) {
                if (errorLocator.evaluateAt(i) === 0) {
                    result[e] = field.inverse(i);
                    e++;
                }
            }
            if (e !== numErrors) {
                throw new ReedSolomonException('Error locator degree does not match number of roots');
            }
            return result;
        }
        findErrorMagnitudes(errorEvaluator, errorLocations) {
            // This is directly applying Forney's Formula
            const s = errorLocations.length;
            const result = new Int32Array(s);
            const field = this.field;
            for (let i = 0; i < s; i++) {
                const xiInverse = field.inverse(errorLocations[i]);
                let denominator = 1;
                for (let j = 0; j < s; j++) {
                    if (i !== j) {
                        // denominator = field.multiply(denominator,
                        //    GenericGF.addOrSubtract(1, field.multiply(errorLocations[j], xiInverse)))
                        // Above should work but fails on some Apple and Linux JDKs due to a Hotspot bug.
                        // Below is a funny-looking workaround from Steven Parkes
                        const term = field.multiply(errorLocations[j], xiInverse);
                        const termPlus1 = (term & 0x1) === 0 ? term | 1 : term & ~1;
                        denominator = field.multiply(denominator, termPlus1);
                    }
                }
                result[i] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));
                if (field.getGeneratorBase() !== 0) {
                    result[i] = field.multiply(result[i], xiInverse);
                }
            }
            return result;
        }
    }

    /*
     * Copyright 2010 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // import java.util.Arrays;
    var Table;
    (function (Table) {
        Table[Table["UPPER"] = 0] = "UPPER";
        Table[Table["LOWER"] = 1] = "LOWER";
        Table[Table["MIXED"] = 2] = "MIXED";
        Table[Table["DIGIT"] = 3] = "DIGIT";
        Table[Table["PUNCT"] = 4] = "PUNCT";
        Table[Table["BINARY"] = 5] = "BINARY";
    })(Table || (Table = {}));
    /**
     * <p>The main class which implements Aztec Code decoding -- as opposed to locating and extracting
     * the Aztec Code from an image.</p>
     *
     * @author David Olivier
     */
    class Decoder {
        decode(detectorResult) {
            this.ddata = detectorResult;
            let matrix = detectorResult.getBits();
            let rawbits = this.extractBits(matrix);
            let correctedBits = this.correctBits(rawbits);
            let rawBytes = Decoder.convertBoolArrayToByteArray(correctedBits);
            let result = Decoder.getEncodedData(correctedBits);
            let decoderResult = new DecoderResult(rawBytes, result, null, null);
            decoderResult.setNumBits(correctedBits.length);
            return decoderResult;
        }
        // This method is used for testing the high-level encoder
        static highLevelDecode(correctedBits) {
            return this.getEncodedData(correctedBits);
        }
        /**
         * Gets the string encoded in the aztec code bits
         *
         * @return the decoded string
         */
        static getEncodedData(correctedBits) {
            let endIndex = correctedBits.length;
            let latchTable = Table.UPPER; // table most recently latched to
            let shiftTable = Table.UPPER; // table to use for the next read
            let result = '';
            let index = 0;
            while (index < endIndex) {
                if (shiftTable === Table.BINARY) {
                    if (endIndex - index < 5) {
                        break;
                    }
                    let length = Decoder.readCode(correctedBits, index, 5);
                    index += 5;
                    if (length === 0) {
                        if (endIndex - index < 11) {
                            break;
                        }
                        length = Decoder.readCode(correctedBits, index, 11) + 31;
                        index += 11;
                    }
                    for (let charCount = 0; charCount < length; charCount++) {
                        if (endIndex - index < 8) {
                            index = endIndex; // Force outer loop to exit
                            break;
                        }
                        const code = Decoder.readCode(correctedBits, index, 8);
                        result += /*(char)*/ StringUtils.castAsNonUtf8Char(code);
                        index += 8;
                    }
                    // Go back to whatever mode we had been in
                    shiftTable = latchTable;
                }
                else {
                    let size = shiftTable === Table.DIGIT ? 4 : 5;
                    if (endIndex - index < size) {
                        break;
                    }
                    let code = Decoder.readCode(correctedBits, index, size);
                    index += size;
                    let str = Decoder.getCharacter(shiftTable, code);
                    if (str.startsWith('CTRL_')) {
                        // Table changes
                        // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.
                        // That's including when that mode is a shift.
                        // Our test case dlusbs.png for issue #642 exercises that.
                        latchTable = shiftTable; // Latch the current mode, so as to return to Upper after U/S B/S
                        shiftTable = Decoder.getTable(str.charAt(5));
                        if (str.charAt(6) === 'L') {
                            latchTable = shiftTable;
                        }
                    }
                    else {
                        result += str;
                        // Go back to whatever mode we had been in
                        shiftTable = latchTable;
                    }
                }
            }
            return result;
        }
        /**
         * gets the table corresponding to the char passed
         */
        static getTable(t) {
            switch (t) {
                case 'L':
                    return Table.LOWER;
                case 'P':
                    return Table.PUNCT;
                case 'M':
                    return Table.MIXED;
                case 'D':
                    return Table.DIGIT;
                case 'B':
                    return Table.BINARY;
                case 'U':
                default:
                    return Table.UPPER;
            }
        }
        /**
         * Gets the character (or string) corresponding to the passed code in the given table
         *
         * @param table the table used
         * @param code the code of the character
         */
        static getCharacter(table, code) {
            switch (table) {
                case Table.UPPER:
                    return Decoder.UPPER_TABLE[code];
                case Table.LOWER:
                    return Decoder.LOWER_TABLE[code];
                case Table.MIXED:
                    return Decoder.MIXED_TABLE[code];
                case Table.PUNCT:
                    return Decoder.PUNCT_TABLE[code];
                case Table.DIGIT:
                    return Decoder.DIGIT_TABLE[code];
                default:
                    // Should not reach here.
                    throw new IllegalStateException('Bad table');
            }
        }
        /**
         * <p>Performs RS error correction on an array of bits.</p>
         *
         * @return the corrected array
         * @throws FormatException if the input contains too many errors
         */
        correctBits(rawbits) {
            let gf;
            let codewordSize;
            if (this.ddata.getNbLayers() <= 2) {
                codewordSize = 6;
                gf = GenericGF.AZTEC_DATA_6;
            }
            else if (this.ddata.getNbLayers() <= 8) {
                codewordSize = 8;
                gf = GenericGF.AZTEC_DATA_8;
            }
            else if (this.ddata.getNbLayers() <= 22) {
                codewordSize = 10;
                gf = GenericGF.AZTEC_DATA_10;
            }
            else {
                codewordSize = 12;
                gf = GenericGF.AZTEC_DATA_12;
            }
            let numDataCodewords = this.ddata.getNbDatablocks();
            let numCodewords = rawbits.length / codewordSize;
            if (numCodewords < numDataCodewords) {
                throw new FormatException();
            }
            let offset = rawbits.length % codewordSize;
            let dataWords = new Int32Array(numCodewords);
            for (let i = 0; i < numCodewords; i++, offset += codewordSize) {
                dataWords[i] = Decoder.readCode(rawbits, offset, codewordSize);
            }
            try {
                let rsDecoder = new ReedSolomonDecoder(gf);
                rsDecoder.decode(dataWords, numCodewords - numDataCodewords);
            }
            catch (ex) {
                throw new FormatException(ex);
            }
            // Now perform the unstuffing operation.
            // First, count how many bits are going to be thrown out as stuffing
            let mask = (1 << codewordSize) - 1;
            let stuffedBits = 0;
            for (let i = 0; i < numDataCodewords; i++) {
                let dataWord = dataWords[i];
                if (dataWord === 0 || dataWord === mask) {
                    throw new FormatException();
                }
                else if (dataWord === 1 || dataWord === mask - 1) {
                    stuffedBits++;
                }
            }
            // Now, actually unpack the bits and remove the stuffing
            let correctedBits = new Array(numDataCodewords * codewordSize - stuffedBits);
            let index = 0;
            for (let i = 0; i < numDataCodewords; i++) {
                let dataWord = dataWords[i];
                if (dataWord === 1 || dataWord === mask - 1) {
                    // next codewordSize-1 bits are all zeros or all ones
                    correctedBits.fill(dataWord > 1, index, index + codewordSize - 1);
                    // Arrays.fill(correctedBits, index, index + codewordSize - 1, dataWord > 1);
                    index += codewordSize - 1;
                }
                else {
                    for (let bit = codewordSize - 1; bit >= 0; --bit) {
                        correctedBits[index++] = (dataWord & (1 << bit)) !== 0;
                    }
                }
            }
            return correctedBits;
        }
        /**
         * Gets the array of bits from an Aztec Code matrix
         *
         * @return the array of bits
         */
        extractBits(matrix) {
            let compact = this.ddata.isCompact();
            let layers = this.ddata.getNbLayers();
            let baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines
            let alignmentMap = new Int32Array(baseMatrixSize);
            let rawbits = new Array(this.totalBitsInLayer(layers, compact));
            if (compact) {
                for (let i = 0; i < alignmentMap.length; i++) {
                    alignmentMap[i] = i;
                }
            }
            else {
                let matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision((Integer.truncDivision(baseMatrixSize, 2) - 1), 15);
                let origCenter = baseMatrixSize / 2;
                let center = Integer.truncDivision(matrixSize, 2);
                for (let i = 0; i < origCenter; i++) {
                    let newOffset = i + Integer.truncDivision(i, 15);
                    alignmentMap[origCenter - i - 1] = center - newOffset - 1;
                    alignmentMap[origCenter + i] = center + newOffset + 1;
                }
            }
            for (let i = 0, rowOffset = 0; i < layers; i++) {
                let rowSize = (layers - i) * 4 + (compact ? 9 : 12);
                // The top-left most point of this layer is <low, low> (not including alignment lines)
                let low = i * 2;
                // The bottom-right most point of this layer is <high, high> (not including alignment lines)
                let high = baseMatrixSize - 1 - low;
                // We pull bits from the two 2 x rowSize columns and two rowSize x 2 rows
                for (let j = 0; j < rowSize; j++) {
                    let columnOffset = j * 2;
                    for (let k = 0; k < 2; k++) {
                        // left column
                        rawbits[rowOffset + columnOffset + k] =
                            matrix.get(alignmentMap[low + k], alignmentMap[low + j]);
                        // bottom row
                        rawbits[rowOffset + 2 * rowSize + columnOffset + k] =
                            matrix.get(alignmentMap[low + j], alignmentMap[high - k]);
                        // right column
                        rawbits[rowOffset + 4 * rowSize + columnOffset + k] =
                            matrix.get(alignmentMap[high - k], alignmentMap[high - j]);
                        // top row
                        rawbits[rowOffset + 6 * rowSize + columnOffset + k] =
                            matrix.get(alignmentMap[high - j], alignmentMap[low + k]);
                    }
                }
                rowOffset += rowSize * 8;
            }
            return rawbits;
        }
        /**
         * Reads a code of given length and at given index in an array of bits
         */
        static readCode(rawbits, startIndex, length) {
            let res = 0;
            for (let i = startIndex; i < startIndex + length; i++) {
                res <<= 1;
                if (rawbits[i]) {
                    res |= 0x01;
                }
            }
            return res;
        }
        /**
         * Reads a code of length 8 in an array of bits, padding with zeros
         */
        static readByte(rawbits, startIndex) {
            let n = rawbits.length - startIndex;
            if (n >= 8) {
                return Decoder.readCode(rawbits, startIndex, 8);
            }
            return Decoder.readCode(rawbits, startIndex, n) << (8 - n);
        }
        /**
         * Packs a bit array into bytes, most significant bit first
         */
        static convertBoolArrayToByteArray(boolArr) {
            let byteArr = new Uint8Array((boolArr.length + 7) / 8);
            for (let i = 0; i < byteArr.length; i++) {
                byteArr[i] = Decoder.readByte(boolArr, 8 * i);
            }
            return byteArr;
        }
        totalBitsInLayer(layers, compact) {
            return ((compact ? 88 : 112) + 16 * layers) * layers;
        }
    }
    Decoder.UPPER_TABLE = [
        'CTRL_PS', ' ', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'CTRL_LL', 'CTRL_ML', 'CTRL_DL', 'CTRL_BS'
    ];
    Decoder.LOWER_TABLE = [
        'CTRL_PS', ' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
        'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'CTRL_US', 'CTRL_ML', 'CTRL_DL', 'CTRL_BS'
    ];
    Decoder.MIXED_TABLE = [
        // Module parse failed: Octal literal in strict mode (50:29)
        // so number string were scaped
        'CTRL_PS', ' ', '\\1', '\\2', '\\3', '\\4', '\\5', '\\6', '\\7', '\b', '\t', '\n',
        '\\13', '\f', '\r', '\\33', '\\34', '\\35', '\\36', '\\37', '@', '\\', '^', '_',
        '`', '|', '~', '\\177', 'CTRL_LL', 'CTRL_UL', 'CTRL_PL', 'CTRL_BS'
    ];
    Decoder.PUNCT_TABLE = [
        '', '\r', '\r\n', '. ', ', ', ': ', '!', '"', '#', '$', '%', '&', '\'', '(', ')',
        '*', '+', ',', '-', '.', '/', ':', ';', '<', '=', '>', '?', '[', ']', '{', '}', 'CTRL_UL'
    ];
    Decoder.DIGIT_TABLE = [
        'CTRL_PS', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', '.', 'CTRL_UL', 'CTRL_US'
    ];

    /*
     * Copyright 2012 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*namespace com.google.zxing.common.detector {*/
    /**
     * General math-related and numeric utility functions.
     */
    class MathUtils {
        constructor() { }
        /**
         * Ends up being a bit faster than {@link Math#round(float)}. This merely rounds its
         * argument to the nearest int, where x.5 rounds up to x+1. Semantics of this shortcut
         * differ slightly from {@link Math#round(float)} in that half rounds down for negative
         * values. -2.5 rounds to -3, not -2. For purposes here it makes no difference.
         *
         * @param d real value to round
         * @return nearest {@code int}
         */
        static round(d /*float*/) {
            if (NaN === d)
                return 0;
            if (d <= Number.MIN_SAFE_INTEGER)
                return Number.MIN_SAFE_INTEGER;
            if (d >= Number.MAX_SAFE_INTEGER)
                return Number.MAX_SAFE_INTEGER;
            return /*(int) */ (d + (d < 0.0 ? -0.5 : 0.5)) | 0;
        }
        // TYPESCRIPTPORT: maybe remove round method and call directly Math.round, it looks like it doesn't make sense for js
        /**
         * @param aX point A x coordinate
         * @param aY point A y coordinate
         * @param bX point B x coordinate
         * @param bY point B y coordinate
         * @return Euclidean distance between points A and B
         */
        static distance(aX /*float|int*/, aY /*float|int*/, bX /*float|int*/, bY /*float|int*/) {
            const xDiff = aX - bX;
            const yDiff = aY - bY;
            return /*(float) */ Math.sqrt(xDiff * xDiff + yDiff * yDiff);
        }
        /**
         * @param aX point A x coordinate
         * @param aY point A y coordinate
         * @param bX point B x coordinate
         * @param bY point B y coordinate
         * @return Euclidean distance between points A and B
         */
        // public static distance(aX: number /*int*/, aY: number /*int*/, bX: number /*int*/, bY: number /*int*/): float {
        //   const xDiff = aX - bX
        //   const yDiff = aY - bY
        //   return (float) Math.sqrt(xDiff * xDiff + yDiff * yDiff);
        // }
        /**
         * @param array values to sum
         * @return sum of values in array
         */
        static sum(array) {
            let count = 0;
            for (let i = 0, length = array.length; i !== length; i++) {
                const a = array[i];
                count += a;
            }
            return count;
        }
    }

    /**
     * Ponyfill for Java's Float class.
     */
    class Float {
        /**
         * SincTS has no difference between int and float, there's all numbers,
         * this is used only to polyfill Java code.
         */
        static floatToIntBits(f) {
            return f;
        }
    }
    /**
     * The float max value in JS is the number max value.
     */
    Float.MAX_VALUE = Number.MAX_SAFE_INTEGER;

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Encapsulates a point of interest in an image containing a barcode. Typically, this
     * would be the location of a finder pattern or the corner of the barcode, for example.</p>
     *
     * @author Sean Owen
     */
    class ResultPoint {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
        getX() {
            return this.x;
        }
        getY() {
            return this.y;
        }
        /*@Override*/
        equals(other) {
            if (other instanceof ResultPoint) {
                const otherPoint = other;
                return this.x === otherPoint.x && this.y === otherPoint.y;
            }
            return false;
        }
        /*@Override*/
        hashCode() {
            return 31 * Float.floatToIntBits(this.x) + Float.floatToIntBits(this.y);
        }
        /*@Override*/
        toString() {
            return '(' + this.x + ',' + this.y + ')';
        }
        /**
         * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC
         * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.
         *
         * @param patterns array of three {@code ResultPoint} to order
         */
        static orderBestPatterns(patterns) {
            // Find distances between pattern centers
            const zeroOneDistance = this.distance(patterns[0], patterns[1]);
            const oneTwoDistance = this.distance(patterns[1], patterns[2]);
            const zeroTwoDistance = this.distance(patterns[0], patterns[2]);
            let pointA;
            let pointB;
            let pointC;
            // Assume one closest to other two is B; A and C will just be guesses at first
            if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {
                pointB = patterns[0];
                pointA = patterns[1];
                pointC = patterns[2];
            }
            else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {
                pointB = patterns[1];
                pointA = patterns[0];
                pointC = patterns[2];
            }
            else {
                pointB = patterns[2];
                pointA = patterns[0];
                pointC = patterns[1];
            }
            // Use cross product to figure out whether A and C are correct or flipped.
            // This asks whether BC x BA has a positive z component, which is the arrangement
            // we want for A, B, C. If it's negative, then we've got it flipped around and
            // should swap A and C.
            if (this.crossProductZ(pointA, pointB, pointC) < 0.0) {
                const temp = pointA;
                pointA = pointC;
                pointC = temp;
            }
            patterns[0] = pointA;
            patterns[1] = pointB;
            patterns[2] = pointC;
        }
        /**
         * @param pattern1 first pattern
         * @param pattern2 second pattern
         * @return distance between two points
         */
        static distance(pattern1, pattern2) {
            return MathUtils.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);
        }
        /**
         * Returns the z component of the cross product between vectors BC and BA.
         */
        static crossProductZ(pointA, pointB, pointC) {
            const bX = pointB.x;
            const bY = pointB.y;
            return ((pointC.x - bX) * (pointA.y - bY)) - ((pointC.y - bY) * (pointA.x - bX));
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Encapsulates the result of detecting a barcode in an image. This includes the raw
     * matrix of black/white pixels corresponding to the barcode, and possibly points of interest
     * in the image, like the location of finder patterns or corners of the barcode in the image.</p>
     *
     * @author Sean Owen
     */
    class DetectorResult {
        constructor(bits, points) {
            this.bits = bits;
            this.points = points;
        }
        getBits() {
            return this.bits;
        }
        getPoints() {
            return this.points;
        }
    }

    /*
     * Copyright 2010 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Extends {@link DetectorResult} with more information specific to the Aztec format,
     * like the number of layers and whether it's compact.</p>
     *
     * @author Sean Owen
     */
    class AztecDetectorResult extends DetectorResult {
        constructor(bits, points, compact, nbDatablocks, nbLayers) {
            super(bits, points);
            this.compact = compact;
            this.nbDatablocks = nbDatablocks;
            this.nbLayers = nbLayers;
        }
        getNbLayers() {
            return this.nbLayers;
        }
        getNbDatablocks() {
            return this.nbDatablocks;
        }
        isCompact() {
            return this.compact;
        }
    }

    /*
     * Copyright 2010 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>
     * Detects a candidate barcode-like rectangular region within an image. It
     * starts around the center of the image, increases the size of the candidate
     * region until it finds a white rectangular region. By keeping track of the
     * last black points it encountered, it determines the corners of the barcode.
     * </p>
     *
     * @author David Olivier
     */
    class WhiteRectangleDetector {
        // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {
        //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)
        // }
        /**
         * @param image barcode image to find a rectangle in
         * @param initSize initial size of search area around center
         * @param x x position of search center
         * @param y y position of search center
         * @throws NotFoundException if image is too small to accommodate {@code initSize}
         */
        constructor(image, initSize /*int*/, x /*int*/, y /*int*/) {
            this.image = image;
            this.height = image.getHeight();
            this.width = image.getWidth();
            if (undefined === initSize || null === initSize) {
                initSize = WhiteRectangleDetector.INIT_SIZE;
            }
            if (undefined === x || null === x) {
                x = image.getWidth() / 2 | 0;
            }
            if (undefined === y || null === y) {
                y = image.getHeight() / 2 | 0;
            }
            const halfsize = initSize / 2 | 0;
            this.leftInit = x - halfsize;
            this.rightInit = x + halfsize;
            this.upInit = y - halfsize;
            this.downInit = y + halfsize;
            if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {
                throw new NotFoundException();
            }
        }
        /**
         * <p>
         * Detects a candidate barcode-like rectangular region within an image. It
         * starts around the center of the image, increases the size of the candidate
         * region until it finds a white rectangular region.
         * </p>
         *
         * @return {@link ResultPoint}[] describing the corners of the rectangular
         *         region. The first and last points are opposed on the diagonal, as
         *         are the second and third. The first point will be the topmost
         *         point and the last, the bottommost. The second point will be
         *         leftmost and the third, the rightmost
         * @throws NotFoundException if no Data Matrix Code can be found
         */
        detect() {
            let left = this.leftInit;
            let right = this.rightInit;
            let up = this.upInit;
            let down = this.downInit;
            let sizeExceeded = false;
            let aBlackPointFoundOnBorder = true;
            let atLeastOneBlackPointFoundOnBorder = false;
            let atLeastOneBlackPointFoundOnRight = false;
            let atLeastOneBlackPointFoundOnBottom = false;
            let atLeastOneBlackPointFoundOnLeft = false;
            let atLeastOneBlackPointFoundOnTop = false;
            const width = this.width;
            const height = this.height;
            while (aBlackPointFoundOnBorder) {
                aBlackPointFoundOnBorder = false;
                // .....
                // .   |
                // .....
                let rightBorderNotWhite = true;
                while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {
                    rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);
                    if (rightBorderNotWhite) {
                        right++;
                        aBlackPointFoundOnBorder = true;
                        atLeastOneBlackPointFoundOnRight = true;
                    }
                    else if (!atLeastOneBlackPointFoundOnRight) {
                        right++;
                    }
                }
                if (right >= width) {
                    sizeExceeded = true;
                    break;
                }
                // .....
                // .   .
                // .___.
                let bottomBorderNotWhite = true;
                while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {
                    bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);
                    if (bottomBorderNotWhite) {
                        down++;
                        aBlackPointFoundOnBorder = true;
                        atLeastOneBlackPointFoundOnBottom = true;
                    }
                    else if (!atLeastOneBlackPointFoundOnBottom) {
                        down++;
                    }
                }
                if (down >= height) {
                    sizeExceeded = true;
                    break;
                }
                // .....
                // |   .
                // .....
                let leftBorderNotWhite = true;
                while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {
                    leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);
                    if (leftBorderNotWhite) {
                        left--;
                        aBlackPointFoundOnBorder = true;
                        atLeastOneBlackPointFoundOnLeft = true;
                    }
                    else if (!atLeastOneBlackPointFoundOnLeft) {
                        left--;
                    }
                }
                if (left < 0) {
                    sizeExceeded = true;
                    break;
                }
                // .___.
                // .   .
                // .....
                let topBorderNotWhite = true;
                while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {
                    topBorderNotWhite = this.containsBlackPoint(left, right, up, true);
                    if (topBorderNotWhite) {
                        up--;
                        aBlackPointFoundOnBorder = true;
                        atLeastOneBlackPointFoundOnTop = true;
                    }
                    else if (!atLeastOneBlackPointFoundOnTop) {
                        up--;
                    }
                }
                if (up < 0) {
                    sizeExceeded = true;
                    break;
                }
                if (aBlackPointFoundOnBorder) {
                    atLeastOneBlackPointFoundOnBorder = true;
                }
            }
            if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {
                const maxSize = right - left;
                let z = null;
                for (let i = 1; z === null && i < maxSize; i++) {
                    z = this.getBlackPointOnSegment(left, down - i, left + i, down);
                }
                if (z == null) {
                    throw new NotFoundException();
                }
                let t = null;
                // go down right
                for (let i = 1; t === null && i < maxSize; i++) {
                    t = this.getBlackPointOnSegment(left, up + i, left + i, up);
                }
                if (t == null) {
                    throw new NotFoundException();
                }
                let x = null;
                // go down left
                for (let i = 1; x === null && i < maxSize; i++) {
                    x = this.getBlackPointOnSegment(right, up + i, right - i, up);
                }
                if (x == null) {
                    throw new NotFoundException();
                }
                let y = null;
                // go up left
                for (let i = 1; y === null && i < maxSize; i++) {
                    y = this.getBlackPointOnSegment(right, down - i, right - i, down);
                }
                if (y == null) {
                    throw new NotFoundException();
                }
                return this.centerEdges(y, z, x, t);
            }
            else {
                throw new NotFoundException();
            }
        }
        getBlackPointOnSegment(aX /*float*/, aY /*float*/, bX /*float*/, bY /*float*/) {
            const dist = MathUtils.round(MathUtils.distance(aX, aY, bX, bY));
            const xStep = (bX - aX) / dist;
            const yStep = (bY - aY) / dist;
            const image = this.image;
            for (let i = 0; i < dist; i++) {
                const x = MathUtils.round(aX + i * xStep);
                const y = MathUtils.round(aY + i * yStep);
                if (image.get(x, y)) {
                    return new ResultPoint(x, y);
                }
            }
            return null;
        }
        /**
         * recenters the points of a constant distance towards the center
         *
         * @param y bottom most point
         * @param z left most point
         * @param x right most point
         * @param t top most point
         * @return {@link ResultPoint}[] describing the corners of the rectangular
         *         region. The first and last points are opposed on the diagonal, as
         *         are the second and third. The first point will be the topmost
         *         point and the last, the bottommost. The second point will be
         *         leftmost and the third, the rightmost
         */
        centerEdges(y, z, x, t) {
            //
            //       t            t
            //  z                      x
            //        x    OR    z
            //   y                    y
            //
            const yi = y.getX();
            const yj = y.getY();
            const zi = z.getX();
            const zj = z.getY();
            const xi = x.getX();
            const xj = x.getY();
            const ti = t.getX();
            const tj = t.getY();
            const CORR = WhiteRectangleDetector.CORR;
            if (yi < this.width / 2.0) {
                return [
                    new ResultPoint(ti - CORR, tj + CORR),
                    new ResultPoint(zi + CORR, zj + CORR),
                    new ResultPoint(xi - CORR, xj - CORR),
                    new ResultPoint(yi + CORR, yj - CORR)
                ];
            }
            else {
                return [
                    new ResultPoint(ti + CORR, tj + CORR),
                    new ResultPoint(zi + CORR, zj - CORR),
                    new ResultPoint(xi - CORR, xj + CORR),
                    new ResultPoint(yi - CORR, yj - CORR)
                ];
            }
        }
        /**
         * Determines whether a segment contains a black point
         *
         * @param a          min value of the scanned coordinate
         * @param b          max value of the scanned coordinate
         * @param fixed      value of fixed coordinate
         * @param horizontal set to true if scan must be horizontal, false if vertical
         * @return true if a black point has been found, else false.
         */
        containsBlackPoint(a /*int*/, b /*int*/, fixed /*int*/, horizontal) {
            const image = this.image;
            if (horizontal) {
                for (let x = a; x <= b; x++) {
                    if (image.get(x, fixed)) {
                        return true;
                    }
                }
            }
            else {
                for (let y = a; y <= b; y++) {
                    if (image.get(fixed, y)) {
                        return true;
                    }
                }
            }
            return false;
        }
    }
    WhiteRectangleDetector.INIT_SIZE = 10;
    WhiteRectangleDetector.CORR = 1;

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Implementations of this class can, given locations of finder patterns for a QR code in an
     * image, sample the right points in the image to reconstruct the QR code, accounting for
     * perspective distortion. It is abstracted since it is relatively expensive and should be allowed
     * to take advantage of platform-specific optimized implementations, like Sun's Java Advanced
     * Imaging library, but which may not be available in other environments such as J2ME, and vice
     * versa.
     *
     * The implementation used can be controlled by calling {@link #setGridSampler(GridSampler)}
     * with an instance of a class which implements this interface.
     *
     * @author Sean Owen
     */
    class GridSampler {
        /**
         * <p>Checks a set of points that have been transformed to sample points on an image against
         * the image's dimensions to see if the point are even within the image.</p>
         *
         * <p>This method will actually "nudge" the endpoints back onto the image if they are found to be
         * barely (less than 1 pixel) off the image. This accounts for imperfect detection of finder
         * patterns in an image where the QR Code runs all the way to the image border.</p>
         *
         * <p>For efficiency, the method will check points from either end of the line until one is found
         * to be within the image. Because the set of points are assumed to be linear, this is valid.</p>
         *
         * @param image image into which the points should map
         * @param points actual points in x1,y1,...,xn,yn form
         * @throws NotFoundException if an endpoint is lies outside the image boundaries
         */
        static checkAndNudgePoints(image, points) {
            const width = image.getWidth();
            const height = image.getHeight();
            // Check and nudge points from start until we see some that are OK:
            let nudged = true;
            for (let offset = 0; offset < points.length && nudged; offset += 2) {
                const x = Math.floor(points[offset]);
                const y = Math.floor(points[offset + 1]);
                if (x < -1 || x > width || y < -1 || y > height) {
                    throw new NotFoundException();
                }
                nudged = false;
                if (x === -1) {
                    points[offset] = 0.0;
                    nudged = true;
                }
                else if (x === width) {
                    points[offset] = width - 1;
                    nudged = true;
                }
                if (y === -1) {
                    points[offset + 1] = 0.0;
                    nudged = true;
                }
                else if (y === height) {
                    points[offset + 1] = height - 1;
                    nudged = true;
                }
            }
            // Check and nudge points from end:
            nudged = true;
            for (let offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {
                const x = Math.floor(points[offset]);
                const y = Math.floor(points[offset + 1]);
                if (x < -1 || x > width || y < -1 || y > height) {
                    throw new NotFoundException();
                }
                nudged = false;
                if (x === -1) {
                    points[offset] = 0.0;
                    nudged = true;
                }
                else if (x === width) {
                    points[offset] = width - 1;
                    nudged = true;
                }
                if (y === -1) {
                    points[offset + 1] = 0.0;
                    nudged = true;
                }
                else if (y === height) {
                    points[offset + 1] = height - 1;
                    nudged = true;
                }
            }
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*namespace com.google.zxing.common {*/
    /**
     * <p>This class implements a perspective transform in two dimensions. Given four source and four
     * destination points, it will compute the transformation implied between them. The code is based
     * directly upon section 3.4.2 of George Wolberg's "Digital Image Warping"; see pages 54-56.</p>
     *
     * @author Sean Owen
     */
    class PerspectiveTransform {
        constructor(a11 /*float*/, a21 /*float*/, a31 /*float*/, a12 /*float*/, a22 /*float*/, a32 /*float*/, a13 /*float*/, a23 /*float*/, a33 /*float*/) {
            this.a11 = a11;
            this.a21 = a21;
            this.a31 = a31;
            this.a12 = a12;
            this.a22 = a22;
            this.a32 = a32;
            this.a13 = a13;
            this.a23 = a23;
            this.a33 = a33;
        }
        static quadrilateralToQuadrilateral(x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/, x0p /*float*/, y0p /*float*/, x1p /*float*/, y1p /*float*/, x2p /*float*/, y2p /*float*/, x3p /*float*/, y3p /*float*/) {
            const qToS = PerspectiveTransform.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
            const sToQ = PerspectiveTransform.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
            return sToQ.times(qToS);
        }
        transformPoints(points) {
            const max = points.length;
            const a11 = this.a11;
            const a12 = this.a12;
            const a13 = this.a13;
            const a21 = this.a21;
            const a22 = this.a22;
            const a23 = this.a23;
            const a31 = this.a31;
            const a32 = this.a32;
            const a33 = this.a33;
            for (let i = 0; i < max; i += 2) {
                const x = points[i];
                const y = points[i + 1];
                const denominator = a13 * x + a23 * y + a33;
                points[i] = (a11 * x + a21 * y + a31) / denominator;
                points[i + 1] = (a12 * x + a22 * y + a32) / denominator;
            }
        }
        transformPointsWithValues(xValues, yValues) {
            const a11 = this.a11;
            const a12 = this.a12;
            const a13 = this.a13;
            const a21 = this.a21;
            const a22 = this.a22;
            const a23 = this.a23;
            const a31 = this.a31;
            const a32 = this.a32;
            const a33 = this.a33;
            const n = xValues.length;
            for (let i = 0; i < n; i++) {
                const x = xValues[i];
                const y = yValues[i];
                const denominator = a13 * x + a23 * y + a33;
                xValues[i] = (a11 * x + a21 * y + a31) / denominator;
                yValues[i] = (a12 * x + a22 * y + a32) / denominator;
            }
        }
        static squareToQuadrilateral(x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/) {
            const dx3 = x0 - x1 + x2 - x3;
            const dy3 = y0 - y1 + y2 - y3;
            if (dx3 === 0.0 && dy3 === 0.0) {
                // Affine
                return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0.0, 0.0, 1.0);
            }
            else {
                const dx1 = x1 - x2;
                const dx2 = x3 - x2;
                const dy1 = y1 - y2;
                const dy2 = y3 - y2;
                const denominator = dx1 * dy2 - dx2 * dy1;
                const a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
                const a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
                return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1.0);
            }
        }
        static quadrilateralToSquare(x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/) {
            // Here, the adjoint serves as the inverse:
            return PerspectiveTransform.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();
        }
        buildAdjoint() {
            // Adjoint is the transpose of the cofactor matrix:
            return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);
        }
        times(other) {
            return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * @author Sean Owen
     */
    class DefaultGridSampler extends GridSampler {
        /*@Override*/
        sampleGrid(image, dimensionX /*int*/, dimensionY /*int*/, p1ToX /*float*/, p1ToY /*float*/, p2ToX /*float*/, p2ToY /*float*/, p3ToX /*float*/, p3ToY /*float*/, p4ToX /*float*/, p4ToY /*float*/, p1FromX /*float*/, p1FromY /*float*/, p2FromX /*float*/, p2FromY /*float*/, p3FromX /*float*/, p3FromY /*float*/, p4FromX /*float*/, p4FromY /*float*/) {
            const transform = PerspectiveTransform.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);
            return this.sampleGridWithTransform(image, dimensionX, dimensionY, transform);
        }
        /*@Override*/
        sampleGridWithTransform(image, dimensionX /*int*/, dimensionY /*int*/, transform) {
            if (dimensionX <= 0 || dimensionY <= 0) {
                throw new NotFoundException();
            }
            const bits = new BitMatrix(dimensionX, dimensionY);
            const points = new Float32Array(2 * dimensionX);
            for (let y = 0; y < dimensionY; y++) {
                const max = points.length;
                const iValue = y + 0.5;
                for (let x = 0; x < max; x += 2) {
                    points[x] = (x / 2) + 0.5;
                    points[x + 1] = iValue;
                }
                transform.transformPoints(points);
                // Quick check to see if points transformed to something inside the image
                // sufficient to check the endpoints
                GridSampler.checkAndNudgePoints(image, points);
                try {
                    for (let x = 0; x < max; x += 2) {
                        if (image.get(Math.floor(points[x]), Math.floor(points[x + 1]))) {
                            // Black(-ish) pixel
                            bits.set(x / 2, y);
                        }
                    }
                }
                catch (aioobe /*: ArrayIndexOutOfBoundsException*/) {
                    // This feels wrong, but, sometimes if the finder patterns are misidentified, the resulting
                    // transform gets "twisted" such that it maps a straight line of points to a set of points
                    // whose endpoints are in bounds, but others are not. There is probably some mathematical
                    // way to detect this about the transformation that I don't know yet.
                    // This results in an ugly runtime exception despite our clever checks above -- can't have
                    // that. We could check each point's coordinates but that feels duplicative. We settle for
                    // catching and wrapping ArrayIndexOutOfBoundsException.
                    throw new NotFoundException();
                }
            }
            return bits;
        }
    }

    class GridSamplerInstance {
        /**
         * Sets the implementation of GridSampler used by the library. One global
         * instance is stored, which may sound problematic. But, the implementation provided
         * ought to be appropriate for the entire platform, and all uses of this library
         * in the whole lifetime of the JVM. For instance, an Android activity can swap in
         * an implementation that takes advantage of native platform libraries.
         *
         * @param newGridSampler The platform-specific object to install.
         */
        static setGridSampler(newGridSampler) {
            GridSamplerInstance.gridSampler = newGridSampler;
        }
        /**
         * @return the current implementation of GridSampler
         */
        static getInstance() {
            return GridSamplerInstance.gridSampler;
        }
    }
    GridSamplerInstance.gridSampler = new DefaultGridSampler();

    /*
     * Copyright 2010 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
        toResultPoint() {
            return new ResultPoint(this.getX(), this.getY());
        }
        getX() {
            return this.x;
        }
        getY() {
            return this.y;
        }
    }
    /**
     * Encapsulates logic that can detect an Aztec Code in an image, even if the Aztec Code
     * is rotated or skewed, or partially obscured.
     *
     * @author David Olivier
     * @author Frank Yellin
     */
    class Detector {
        constructor(image) {
            this.EXPECTED_CORNER_BITS = new Int32Array([
                0xee0,
                0x1dc,
                0x83b,
                0x707,
            ]);
            this.image = image;
        }
        detect() {
            return this.detectMirror(false);
        }
        /**
         * Detects an Aztec Code in an image.
         *
         * @param isMirror if true, image is a mirror-image of original
         * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code
         * @throws NotFoundException if no Aztec Code can be found
         */
        detectMirror(isMirror) {
            // 1. Get the center of the aztec matrix
            let pCenter = this.getMatrixCenter();
            // 2. Get the center points of the four diagonal points just outside the bull's eye
            //  [topRight, bottomRight, bottomLeft, topLeft]
            let bullsEyeCorners = this.getBullsEyeCorners(pCenter);
            if (isMirror) {
                let temp = bullsEyeCorners[0];
                bullsEyeCorners[0] = bullsEyeCorners[2];
                bullsEyeCorners[2] = temp;
            }
            // 3. Get the size of the matrix and other parameters from the bull's eye
            this.extractParameters(bullsEyeCorners);
            // 4. Sample the grid
            let bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);
            // 5. Get the corners of the matrix.
            let corners = this.getMatrixCornerPoints(bullsEyeCorners);
            return new AztecDetectorResult(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);
        }
        /**
         * Extracts the number of data layers and data blocks from the layer around the bull's eye.
         *
         * @param bullsEyeCorners the array of bull's eye corners
         * @throws NotFoundException in case of too many errors or invalid parameters
         */
        extractParameters(bullsEyeCorners) {
            if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) ||
                !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {
                throw new NotFoundException();
            }
            let length = 2 * this.nbCenterLayers;
            // Get the bits around the bull's eye
            let sides = new Int32Array([
                this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length),
                this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length),
                this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length),
                this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) // Top
            ]);
            // bullsEyeCorners[shift] is the corner of the bulls'eye that has three
            // orientation marks.
            // sides[shift] is the row/column that goes from the corner with three
            // orientation marks to the corner with two.
            this.shift = this.getRotation(sides, length);
            // Flatten the parameter bits into a single 28- or 40-bit long
            let parameterData = 0;
            for (let i = 0; i < 4; i++) {
                let side = sides[(this.shift + i) % 4];
                if (this.compact) {
                    // Each side of the form ..XXXXXXX. where Xs are parameter data
                    parameterData <<= 7;
                    parameterData += (side >> 1) & 0x7F;
                }
                else {
                    // Each side of the form ..XXXXX.XXXXX. where Xs are parameter data
                    parameterData <<= 10;
                    parameterData += ((side >> 2) & (0x1f << 5)) + ((side >> 1) & 0x1F);
                }
            }
            // Corrects parameter data using RS.  Returns just the data portion
            // without the error correction.
            let correctedData = this.getCorrectedParameterData(parameterData, this.compact);
            if (this.compact) {
                // 8 bits:  2 bits layers and 6 bits data blocks
                this.nbLayers = (correctedData >> 6) + 1;
                this.nbDataBlocks = (correctedData & 0x3F) + 1;
            }
            else {
                // 16 bits:  5 bits layers and 11 bits data blocks
                this.nbLayers = (correctedData >> 11) + 1;
                this.nbDataBlocks = (correctedData & 0x7FF) + 1;
            }
        }
        getRotation(sides, length) {
            // In a normal pattern, we expect to See
            //   **    .*             D       A
            //   *      *
            //
            //   .      *
            //   ..    ..             C       B
            //
            // Grab the 3 bits from each of the sides the form the locator pattern and concatenate
            // into a 12-bit integer.  Start with the bit at A
            let cornerBits = 0;
            sides.forEach((side, idx, arr) => {
                // XX......X where X's are orientation marks
                let t = ((side >> (length - 2)) << 1) + (side & 1);
                cornerBits = (cornerBits << 3) + t;
            });
            // for (var side in sides) {
            //     // XX......X where X's are orientation marks
            //     var t = ((side >> (length - 2)) << 1) + (side & 1);
            //     cornerBits = (cornerBits << 3) + t;
            // }
            // Mov the bottom bit to the top, so that the three bits of the locator pattern at A are
            // together.  cornerBits is now:
            //  3 orientation bits at A || 3 orientation bits at B || ... || 3 orientation bits at D
            cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);
            // The result shift indicates which element of BullsEyeCorners[] goes into the top-left
            // corner. Since the four rotation values have a Hamming distance of 8, we
            // can easily tolerate two errors.
            for (let shift = 0; shift < 4; shift++) {
                if (Integer.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {
                    return shift;
                }
            }
            throw new NotFoundException();
        }
        /**
         * Corrects the parameter bits using Reed-Solomon algorithm.
         *
         * @param parameterData parameter bits
         * @param compact true if this is a compact Aztec code
         * @throws NotFoundException if the array contains too many errors
         */
        getCorrectedParameterData(parameterData, compact) {
            let numCodewords;
            let numDataCodewords;
            if (compact) {
                numCodewords = 7;
                numDataCodewords = 2;
            }
            else {
                numCodewords = 10;
                numDataCodewords = 4;
            }
            let numECCodewords = numCodewords - numDataCodewords;
            let parameterWords = new Int32Array(numCodewords);
            for (let i = numCodewords - 1; i >= 0; --i) {
                parameterWords[i] = parameterData & 0xF;
                parameterData >>= 4;
            }
            try {
                let rsDecoder = new ReedSolomonDecoder(GenericGF.AZTEC_PARAM);
                rsDecoder.decode(parameterWords, numECCodewords);
            }
            catch (ignored) {
                throw new NotFoundException();
            }
            // Toss the error correction.  Just return the data as an integer
            let result = 0;
            for (let i = 0; i < numDataCodewords; i++) {
                result = (result << 4) + parameterWords[i];
            }
            return result;
        }
        /**
         * Finds the corners of a bull-eye centered on the passed point.
         * This returns the centers of the diagonal points just outside the bull's eye
         * Returns [topRight, bottomRight, bottomLeft, topLeft]
         *
         * @param pCenter Center point
         * @return The corners of the bull-eye
         * @throws NotFoundException If no valid bull-eye can be found
         */
        getBullsEyeCorners(pCenter) {
            let pina = pCenter;
            let pinb = pCenter;
            let pinc = pCenter;
            let pind = pCenter;
            let color = true;
            for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {
                let pouta = this.getFirstDifferent(pina, color, 1, -1);
                let poutb = this.getFirstDifferent(pinb, color, 1, 1);
                let poutc = this.getFirstDifferent(pinc, color, -1, 1);
                let poutd = this.getFirstDifferent(pind, color, -1, -1);
                // d      a
                //
                // c      b
                if (this.nbCenterLayers > 2) {
                    let q = (this.distancePoint(poutd, pouta) * this.nbCenterLayers) / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));
                    if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {
                        break;
                    }
                }
                pina = pouta;
                pinb = poutb;
                pinc = poutc;
                pind = poutd;
                color = !color;
            }
            if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {
                throw new NotFoundException();
            }
            this.compact = this.nbCenterLayers === 5;
            // Expand the square by .5 pixel in each direction so that we're on the border
            // between the white square and the black square
            let pinax = new ResultPoint(pina.getX() + 0.5, pina.getY() - 0.5);
            let pinbx = new ResultPoint(pinb.getX() + 0.5, pinb.getY() + 0.5);
            let pincx = new ResultPoint(pinc.getX() - 0.5, pinc.getY() + 0.5);
            let pindx = new ResultPoint(pind.getX() - 0.5, pind.getY() - 0.5);
            // Expand the square so that its corners are the centers of the points
            // just outside the bull's eye.
            return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);
        }
        /**
         * Finds a candidate center point of an Aztec code from an image
         *
         * @return the center point
         */
        getMatrixCenter() {
            let pointA;
            let pointB;
            let pointC;
            let pointD;
            // Get a white rectangle that can be the border of the matrix in center bull's eye or
            try {
                let cornerPoints = new WhiteRectangleDetector(this.image).detect();
                pointA = cornerPoints[0];
                pointB = cornerPoints[1];
                pointC = cornerPoints[2];
                pointD = cornerPoints[3];
            }
            catch (e) {
                // This exception can be in case the initial rectangle is white
                // In that case, surely in the bull's eye, we try to expand the rectangle.
                let cx = this.image.getWidth() / 2;
                let cy = this.image.getHeight() / 2;
                pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();
                pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();
                pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();
                pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();
            }
            // Compute the center of the rectangle
            let cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);
            let cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);
            // Redetermine the white rectangle starting from previously computed center.
            // This will ensure that we end up with a white rectangle in center bull's eye
            // in order to compute a more accurate center.
            try {
                let cornerPoints = new WhiteRectangleDetector(this.image, 15, cx, cy).detect();
                pointA = cornerPoints[0];
                pointB = cornerPoints[1];
                pointC = cornerPoints[2];
                pointD = cornerPoints[3];
            }
            catch (e) {
                // This exception can be in case the initial rectangle is white
                // In that case we try to expand the rectangle.
                pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();
                pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();
                pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();
                pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();
            }
            // Recompute the center of the rectangle
            cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);
            cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);
            return new Point(cx, cy);
        }
        /**
         * Gets the Aztec code corners from the bull's eye corners and the parameters.
         *
         * @param bullsEyeCorners the array of bull's eye corners
         * @return the array of aztec code corners
         */
        getMatrixCornerPoints(bullsEyeCorners) {
            return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());
        }
        /**
         * Creates a BitMatrix by sampling the provided image.
         * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the
         * diagonal just outside the bull's eye.
         */
        sampleGrid(image, topLeft, topRight, bottomRight, bottomLeft) {
            let sampler = GridSamplerInstance.getInstance();
            let dimension = this.getDimension();
            let low = dimension / 2 - this.nbCenterLayers;
            let high = dimension / 2 + this.nbCenterLayers;
            return sampler.sampleGrid(image, dimension, dimension, low, low, // topleft
                high, low, // topright
                high, high, // bottomright
                low, high, // bottomleft
                topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());
        }
        /**
         * Samples a line.
         *
         * @param p1   start point (inclusive)
         * @param p2   end point (exclusive)
         * @param size number of bits
         * @return the array of bits as an int (first bit is high-order bit of result)
         */
        sampleLine(p1, p2, size) {
            let result = 0;
            let d = this.distanceResultPoint(p1, p2);
            let moduleSize = d / size;
            let px = p1.getX();
            let py = p1.getY();
            let dx = moduleSize * (p2.getX() - p1.getX()) / d;
            let dy = moduleSize * (p2.getY() - p1.getY()) / d;
            for (let i = 0; i < size; i++) {
                if (this.image.get(MathUtils.round(px + i * dx), MathUtils.round(py + i * dy))) {
                    result |= 1 << (size - i - 1);
                }
            }
            return result;
        }
        /**
         * @return true if the border of the rectangle passed in parameter is compound of white points only
         *         or black points only
         */
        isWhiteOrBlackRectangle(p1, p2, p3, p4) {
            let corr = 3;
            p1 = new Point(p1.getX() - corr, p1.getY() + corr);
            p2 = new Point(p2.getX() - corr, p2.getY() - corr);
            p3 = new Point(p3.getX() + corr, p3.getY() - corr);
            p4 = new Point(p4.getX() + corr, p4.getY() + corr);
            let cInit = this.getColor(p4, p1);
            if (cInit === 0) {
                return false;
            }
            let c = this.getColor(p1, p2);
            if (c !== cInit) {
                return false;
            }
            c = this.getColor(p2, p3);
            if (c !== cInit) {
                return false;
            }
            c = this.getColor(p3, p4);
            return c === cInit;
        }
        /**
         * Gets the color of a segment
         *
         * @return 1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else
         */
        getColor(p1, p2) {
            let d = this.distancePoint(p1, p2);
            let dx = (p2.getX() - p1.getX()) / d;
            let dy = (p2.getY() - p1.getY()) / d;
            let error = 0;
            let px = p1.getX();
            let py = p1.getY();
            let colorModel = this.image.get(p1.getX(), p1.getY());
            let iMax = Math.ceil(d);
            for (let i = 0; i < iMax; i++) {
                px += dx;
                py += dy;
                if (this.image.get(MathUtils.round(px), MathUtils.round(py)) !== colorModel) {
                    error++;
                }
            }
            let errRatio = error / d;
            if (errRatio > 0.1 && errRatio < 0.9) {
                return 0;
            }
            return (errRatio <= 0.1) === colorModel ? 1 : -1;
        }
        /**
         * Gets the coordinate of the first point with a different color in the given direction
         */
        getFirstDifferent(init, color, dx, dy) {
            let x = init.getX() + dx;
            let y = init.getY() + dy;
            while (this.isValid(x, y) && this.image.get(x, y) === color) {
                x += dx;
                y += dy;
            }
            x -= dx;
            y -= dy;
            while (this.isValid(x, y) && this.image.get(x, y) === color) {
                x += dx;
            }
            x -= dx;
            while (this.isValid(x, y) && this.image.get(x, y) === color) {
                y += dy;
            }
            y -= dy;
            return new Point(x, y);
        }
        /**
         * Expand the square represented by the corner points by pushing out equally in all directions
         *
         * @param cornerPoints the corners of the square, which has the bull's eye at its center
         * @param oldSide the original length of the side of the square in the target bit matrix
         * @param newSide the new length of the size of the square in the target bit matrix
         * @return the corners of the expanded square
         */
        expandSquare(cornerPoints, oldSide, newSide) {
            let ratio = newSide / (2.0 * oldSide);
            let dx = cornerPoints[0].getX() - cornerPoints[2].getX();
            let dy = cornerPoints[0].getY() - cornerPoints[2].getY();
            let centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0;
            let centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0;
            let result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
            let result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);
            dx = cornerPoints[1].getX() - cornerPoints[3].getX();
            dy = cornerPoints[1].getY() - cornerPoints[3].getY();
            centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0;
            centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0;
            let result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
            let result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);
            let results = [result0, result1, result2, result3];
            return results;
        }
        isValid(x, y) {
            return x >= 0 && x < this.image.getWidth() && y > 0 && y < this.image.getHeight();
        }
        isValidPoint(point) {
            let x = MathUtils.round(point.getX());
            let y = MathUtils.round(point.getY());
            return this.isValid(x, y);
        }
        distancePoint(a, b) {
            return MathUtils.distance(a.getX(), a.getY(), b.getX(), b.getY());
        }
        distanceResultPoint(a, b) {
            return MathUtils.distance(a.getX(), a.getY(), b.getX(), b.getY());
        }
        getDimension() {
            if (this.compact) {
                return 4 * this.nbLayers + 11;
            }
            if (this.nbLayers <= 4) {
                return 4 * this.nbLayers + 15;
            }
            return 4 * this.nbLayers + 2 * (Integer.truncDivision((this.nbLayers - 4), 8) + 1) + 15;
        }
    }

    /*
     * Copyright 2010 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // import java.util.List;
    // import java.util.Map;
    /**
     * This implementation can detect and decode Aztec codes in an image.
     *
     * @author David Olivier
     */
    class AztecReader {
        /**
         * Locates and decodes a Data Matrix code in an image.
         *
         * @return a String representing the content encoded by the Data Matrix code
         * @throws NotFoundException if a Data Matrix code cannot be found
         * @throws FormatException if a Data Matrix code cannot be decoded
         */
        decode(image, hints = null) {
            let exception = null;
            let detector = new Detector(image.getBlackMatrix());
            let points = null;
            let decoderResult = null;
            try {
                let detectorResult = detector.detectMirror(false);
                points = detectorResult.getPoints();
                this.reportFoundResultPoints(hints, points);
                decoderResult = new Decoder().decode(detectorResult);
            }
            catch (e) {
                exception = e;
            }
            if (decoderResult == null) {
                try {
                    let detectorResult = detector.detectMirror(true);
                    points = detectorResult.getPoints();
                    this.reportFoundResultPoints(hints, points);
                    decoderResult = new Decoder().decode(detectorResult);
                }
                catch (e) {
                    if (exception != null) {
                        throw exception;
                    }
                    throw e;
                }
            }
            let result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), decoderResult.getNumBits(), points, BarcodeFormat$1.AZTEC, System.currentTimeMillis());
            let byteSegments = decoderResult.getByteSegments();
            if (byteSegments != null) {
                result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);
            }
            let ecLevel = decoderResult.getECLevel();
            if (ecLevel != null) {
                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);
            }
            return result;
        }
        reportFoundResultPoints(hints, points) {
            if (hints != null) {
                let rpcb = hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
                if (rpcb != null) {
                    points.forEach((point, idx, arr) => {
                        rpcb.foundPossibleResultPoint(point);
                    });
                }
            }
        }
        // @Override
        reset() {
            // do nothing
        }
    }

    /**
     * Aztec Code reader to use from browser.
     *
     * @class BrowserAztecCodeReader
     * @extends {BrowserCodeReader}
     */
    class BrowserAztecCodeReader extends BrowserCodeReader {
        /**
         * Creates an instance of BrowserAztecCodeReader.
         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
         *
         * @memberOf BrowserAztecCodeReader
         */
        constructor(timeBetweenScansMillis = 500) {
            super(new AztecReader(), timeBetweenScansMillis);
        }
    }

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Encapsulates functionality and implementation that is common to all families
     * of one-dimensional barcodes.
     *
     * @author dswitkin@google.com (Daniel Switkin)
     * @author Sean Owen
     */
    class OneDReader {
        /*
        @Override
        public Result decode(BinaryBitmap image) throws NotFoundException, FormatException {
          return decode(image, null);
        }
        */
        // Note that we don't try rotation without the try harder flag, even if rotation was supported.
        // @Override
        decode(image, hints) {
            try {
                return this.doDecode(image, hints);
            }
            catch (nfe) {
                const tryHarder = hints && (hints.get(DecodeHintType$1.TRY_HARDER) === true);
                if (tryHarder && image.isRotateSupported()) {
                    const rotatedImage = image.rotateCounterClockwise();
                    const result = this.doDecode(rotatedImage, hints);
                    // Record that we found it rotated 90 degrees CCW / 270 degrees CW
                    const metadata = result.getResultMetadata();
                    let orientation = 270;
                    if (metadata !== null && (metadata.get(ResultMetadataType$1.ORIENTATION) === true)) {
                        // But if we found it reversed in doDecode(), add in that result here:
                        orientation = (orientation + metadata.get(ResultMetadataType$1.ORIENTATION) % 360);
                    }
                    result.putMetadata(ResultMetadataType$1.ORIENTATION, orientation);
                    // Update result points
                    const points = result.getResultPoints();
                    if (points !== null) {
                        const height = rotatedImage.getHeight();
                        for (let i = 0; i < points.length; i++) {
                            points[i] = new ResultPoint(height - points[i].getY() - 1, points[i].getX());
                        }
                    }
                    return result;
                }
                else {
                    throw new NotFoundException();
                }
            }
        }
        // @Override
        reset() {
            // do nothing
        }
        /**
         * We're going to examine rows from the middle outward, searching alternately above and below the
         * middle, and farther out each time. rowStep is the number of rows between each successive
         * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then
         * middle + rowStep, then middle - (2 * rowStep), etc.
         * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily
         * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the
         * image if "trying harder".
         *
         * @param image The image to decode
         * @param hints Any hints that were requested
         * @return The contents of the decoded barcode
         * @throws NotFoundException Any spontaneous errors which occur
         */
        doDecode(image, hints) {
            const width = image.getWidth();
            const height = image.getHeight();
            let row = new BitArray(width);
            const tryHarder = hints && (hints.get(DecodeHintType$1.TRY_HARDER) === true);
            const rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));
            let maxLines;
            if (tryHarder) {
                maxLines = height; // Look at the whole image, not just the center
            }
            else {
                maxLines = 15; // 15 rows spaced 1/32 apart is roughly the middle half of the image
            }
            const middle = Math.trunc(height / 2);
            for (let x = 0; x < maxLines; x++) {
                // Scanning from the middle out. Determine which row we're looking at next:
                const rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);
                const isAbove = (x & 0x01) === 0; // i.e. is x even?
                const rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);
                if (rowNumber < 0 || rowNumber >= height) {
                    // Oops, if we run off the top or bottom, stop
                    break;
                }
                // Estimate black point for this row and load it:
                try {
                    row = image.getBlackRow(rowNumber, row);
                }
                catch (ignored) {
                    continue;
                }
                // While we have the image data in a BitArray, it's fairly cheap to reverse it in place to
                // handle decoding upside down barcodes.
                for (let attempt = 0; attempt < 2; attempt++) {
                    if (attempt === 1) { // trying again?
                        row.reverse(); // reverse the row and continue
                        // This means we will only ever draw result points *once* in the life of this method
                        // since we want to avoid drawing the wrong points after flipping the row, and,
                        // don't want to clutter with noise from every single row scan -- just the scans
                        // that start on the center line.
                        if (hints && (hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK) === true)) {
                            const newHints = new Map();
                            hints.forEach((hint, key) => newHints.set(key, hint));
                            newHints.delete(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
                            hints = newHints;
                        }
                    }
                    try {
                        // Look for a barcode
                        const result = this.decodeRow(rowNumber, row, hints);
                        // We found our barcode
                        if (attempt === 1) {
                            // But it was upside down, so note that
                            result.putMetadata(ResultMetadataType$1.ORIENTATION, 180);
                            // And remember to flip the result points horizontally.
                            const points = result.getResultPoints();
                            if (points !== null) {
                                points[0] = new ResultPoint(width - points[0].getX() - 1, points[0].getY());
                                points[1] = new ResultPoint(width - points[1].getX() - 1, points[1].getY());
                            }
                        }
                        return result;
                    }
                    catch (re) {
                        // continue -- just couldn't decode this row
                    }
                }
            }
            throw new NotFoundException();
        }
        /**
         * Records the size of successive runs of white and black pixels in a row, starting at a given point.
         * The values are recorded in the given array, and the number of runs recorded is equal to the size
         * of the array. If the row starts on a white pixel at the given start point, then the first count
         * recorded is the run of white pixels starting from that point; likewise it is the count of a run
         * of black pixels if the row begin on a black pixels at that point.
         *
         * @param row row to count from
         * @param start offset into row to start at
         * @param counters array into which to record counts
         * @throws NotFoundException if counters cannot be filled entirely from row before running out
         *  of pixels
         */
        static recordPattern(row, start, counters) {
            const numCounters = counters.length;
            for (let index = 0; index < numCounters; index++)
                counters[index] = 0;
            const end = row.getSize();
            if (start >= end) {
                throw new NotFoundException();
            }
            let isWhite = !row.get(start);
            let counterPosition = 0;
            let i = start;
            while (i < end) {
                if (row.get(i) !== isWhite) {
                    counters[counterPosition]++;
                }
                else {
                    if (++counterPosition === numCounters) {
                        break;
                    }
                    else {
                        counters[counterPosition] = 1;
                        isWhite = !isWhite;
                    }
                }
                i++;
            }
            // If we read fully the last section of pixels and filled up our counters -- or filled
            // the last counter but ran off the side of the image, OK. Otherwise, a problem.
            if (!(counterPosition === numCounters || (counterPosition === numCounters - 1 && i === end))) {
                throw new NotFoundException();
            }
        }
        static recordPatternInReverse(row, start, counters) {
            // This could be more efficient I guess
            let numTransitionsLeft = counters.length;
            let last = row.get(start);
            while (start > 0 && numTransitionsLeft >= 0) {
                if (row.get(--start) !== last) {
                    numTransitionsLeft--;
                    last = !last;
                }
            }
            if (numTransitionsLeft >= 0) {
                throw new NotFoundException();
            }
            OneDReader.recordPattern(row, start + 1, counters);
        }
        /**
         * Determines how closely a set of observed counts of runs of black/white values matches a given
         * target pattern. This is reported as the ratio of the total variance from the expected pattern
         * proportions across all pattern elements, to the length of the pattern.
         *
         * @param counters observed counters
         * @param pattern expected pattern
         * @param maxIndividualVariance The most any counter can differ before we give up
         * @return ratio of total variance between counters and pattern compared to total pattern size
         */
        static patternMatchVariance(counters, pattern, maxIndividualVariance) {
            const numCounters = counters.length;
            let total = 0;
            let patternLength = 0;
            for (let i = 0; i < numCounters; i++) {
                total += counters[i];
                patternLength += pattern[i];
            }
            if (total < patternLength) {
                // If we don't even have one pixel per unit of bar width, assume this is too small
                // to reliably match, so fail:
                return Number.POSITIVE_INFINITY;
            }
            const unitBarWidth = total / patternLength;
            maxIndividualVariance *= unitBarWidth;
            let totalVariance = 0.0;
            for (let x = 0; x < numCounters; x++) {
                const counter = counters[x];
                const scaledPattern = pattern[x] * unitBarWidth;
                const variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;
                if (variance > maxIndividualVariance) {
                    return Number.POSITIVE_INFINITY;
                }
                totalVariance += variance;
            }
            return totalVariance / total;
        }
    }

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Decodes Code 128 barcodes.</p>
     *
     * @author Sean Owen
     */
    class Code128Reader extends OneDReader {
        static findStartPattern(row) {
            const width = row.getSize();
            const rowOffset = row.getNextSet(0);
            let counterPosition = 0;
            let counters = Int32Array.from([0, 0, 0, 0, 0, 0]);
            let patternStart = rowOffset;
            let isWhite = false;
            const patternLength = 6;
            for (let i = rowOffset; i < width; i++) {
                if (row.get(i) !== isWhite) {
                    counters[counterPosition]++;
                }
                else {
                    if (counterPosition === (patternLength - 1)) {
                        let bestVariance = Code128Reader.MAX_AVG_VARIANCE;
                        let bestMatch = -1;
                        for (let startCode = Code128Reader.CODE_START_A; startCode <= Code128Reader.CODE_START_C; startCode++) {
                            const variance = OneDReader.patternMatchVariance(counters, Code128Reader.CODE_PATTERNS[startCode], Code128Reader.MAX_INDIVIDUAL_VARIANCE);
                            if (variance < bestVariance) {
                                bestVariance = variance;
                                bestMatch = startCode;
                            }
                        }
                        // Look for whitespace before start pattern, >= 50% of width of start pattern
                        if (bestMatch >= 0 &&
                            row.isRange(Math.max(0, patternStart - (i - patternStart) / 2), patternStart, false)) {
                            return Int32Array.from([patternStart, i, bestMatch]);
                        }
                        patternStart += counters[0] + counters[1];
                        counters = counters.slice(2, counters.length - 1);
                        counters[counterPosition - 1] = 0;
                        counters[counterPosition] = 0;
                        counterPosition--;
                    }
                    else {
                        counterPosition++;
                    }
                    counters[counterPosition] = 1;
                    isWhite = !isWhite;
                }
            }
            throw new NotFoundException();
        }
        static decodeCode(row, counters, rowOffset) {
            OneDReader.recordPattern(row, rowOffset, counters);
            let bestVariance = Code128Reader.MAX_AVG_VARIANCE; // worst variance we'll accept
            let bestMatch = -1;
            for (let d = 0; d < Code128Reader.CODE_PATTERNS.length; d++) {
                const pattern = Code128Reader.CODE_PATTERNS[d];
                const variance = this.patternMatchVariance(counters, pattern, Code128Reader.MAX_INDIVIDUAL_VARIANCE);
                if (variance < bestVariance) {
                    bestVariance = variance;
                    bestMatch = d;
                }
            }
            // TODO We're overlooking the fact that the STOP pattern has 7 values, not 6.
            if (bestMatch >= 0) {
                return bestMatch;
            }
            else {
                throw new NotFoundException();
            }
        }
        decodeRow(rowNumber, row, hints) {
            const convertFNC1 = hints && (hints.get(DecodeHintType$1.ASSUME_GS1) === true);
            const startPatternInfo = Code128Reader.findStartPattern(row);
            const startCode = startPatternInfo[2];
            let currentRawCodesIndex = 0;
            const rawCodes = new Uint8Array(20);
            rawCodes[currentRawCodesIndex++] = startCode;
            let codeSet;
            switch (startCode) {
                case Code128Reader.CODE_START_A:
                    codeSet = Code128Reader.CODE_CODE_A;
                    break;
                case Code128Reader.CODE_START_B:
                    codeSet = Code128Reader.CODE_CODE_B;
                    break;
                case Code128Reader.CODE_START_C:
                    codeSet = Code128Reader.CODE_CODE_C;
                    break;
                default:
                    throw new FormatException();
            }
            let done = false;
            let isNextShifted = false;
            let result = '';
            let lastStart = startPatternInfo[0];
            let nextStart = startPatternInfo[1];
            const counters = Int32Array.from([0, 0, 0, 0, 0, 0]);
            let lastCode = 0;
            let code = 0;
            let checksumTotal = startCode;
            let multiplier = 0;
            let lastCharacterWasPrintable = true;
            let upperMode = false;
            let shiftUpperMode = false;
            while (!done) {
                const unshift = isNextShifted;
                isNextShifted = false;
                // Save off last code
                lastCode = code;
                // Decode another code from image
                code = Code128Reader.decodeCode(row, counters, nextStart);
                rawCodes[currentRawCodesIndex++] = code;
                // Remember whether the last code was printable or not (excluding CODE_STOP)
                if (code !== Code128Reader.CODE_STOP) {
                    lastCharacterWasPrintable = true;
                }
                // Add to checksum computation (if not CODE_STOP of course)
                if (code !== Code128Reader.CODE_STOP) {
                    multiplier++;
                    checksumTotal += multiplier * code;
                }
                // Advance to where the next code will to start
                lastStart = nextStart;
                nextStart += counters.reduce((previous, current) => previous + current, 0);
                // Take care of illegal start codes
                switch (code) {
                    case Code128Reader.CODE_START_A:
                    case Code128Reader.CODE_START_B:
                    case Code128Reader.CODE_START_C:
                        throw new FormatException();
                }
                switch (codeSet) {
                    case Code128Reader.CODE_CODE_A:
                        if (code < 64) {
                            if (shiftUpperMode === upperMode) {
                                result += String.fromCharCode((' '.charCodeAt(0) + code));
                            }
                            else {
                                result += String.fromCharCode((' '.charCodeAt(0) + code + 128));
                            }
                            shiftUpperMode = false;
                        }
                        else if (code < 96) {
                            if (shiftUpperMode === upperMode) {
                                result += String.fromCharCode((code - 64));
                            }
                            else {
                                result += String.fromCharCode((code + 64));
                            }
                            shiftUpperMode = false;
                        }
                        else {
                            // Don't let CODE_STOP, which always appears, affect whether whether we think the last
                            // code was printable or not.
                            if (code !== Code128Reader.CODE_STOP) {
                                lastCharacterWasPrintable = false;
                            }
                            switch (code) {
                                case Code128Reader.CODE_FNC_1:
                                    if (convertFNC1) {
                                        if (result.length === 0) {
                                            // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code
                                            // is FNC1 then this is GS1-128. We add the symbology identifier.
                                            result += ']C1';
                                        }
                                        else {
                                            // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)
                                            result += String.fromCharCode(29);
                                        }
                                    }
                                    break;
                                case Code128Reader.CODE_FNC_2:
                                case Code128Reader.CODE_FNC_3:
                                    // do nothing?
                                    break;
                                case Code128Reader.CODE_FNC_4_A:
                                    if (!upperMode && shiftUpperMode) {
                                        upperMode = true;
                                        shiftUpperMode = false;
                                    }
                                    else if (upperMode && shiftUpperMode) {
                                        upperMode = false;
                                        shiftUpperMode = false;
                                    }
                                    else {
                                        shiftUpperMode = true;
                                    }
                                    break;
                                case Code128Reader.CODE_SHIFT:
                                    isNextShifted = true;
                                    codeSet = Code128Reader.CODE_CODE_B;
                                    break;
                                case Code128Reader.CODE_CODE_B:
                                    codeSet = Code128Reader.CODE_CODE_B;
                                    break;
                                case Code128Reader.CODE_CODE_C:
                                    codeSet = Code128Reader.CODE_CODE_C;
                                    break;
                                case Code128Reader.CODE_STOP:
                                    done = true;
                                    break;
                            }
                        }
                        break;
                    case Code128Reader.CODE_CODE_B:
                        if (code < 96) {
                            if (shiftUpperMode === upperMode) {
                                result += String.fromCharCode((' '.charCodeAt(0) + code));
                            }
                            else {
                                result += String.fromCharCode((' '.charCodeAt(0) + code + 128));
                            }
                            shiftUpperMode = false;
                        }
                        else {
                            if (code !== Code128Reader.CODE_STOP) {
                                lastCharacterWasPrintable = false;
                            }
                            switch (code) {
                                case Code128Reader.CODE_FNC_1:
                                    if (convertFNC1) {
                                        if (result.length === 0) {
                                            // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code
                                            // is FNC1 then this is GS1-128. We add the symbology identifier.
                                            result += ']C1';
                                        }
                                        else {
                                            // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)
                                            result += String.fromCharCode(29);
                                        }
                                    }
                                    break;
                                case Code128Reader.CODE_FNC_2:
                                case Code128Reader.CODE_FNC_3:
                                    // do nothing?
                                    break;
                                case Code128Reader.CODE_FNC_4_B:
                                    if (!upperMode && shiftUpperMode) {
                                        upperMode = true;
                                        shiftUpperMode = false;
                                    }
                                    else if (upperMode && shiftUpperMode) {
                                        upperMode = false;
                                        shiftUpperMode = false;
                                    }
                                    else {
                                        shiftUpperMode = true;
                                    }
                                    break;
                                case Code128Reader.CODE_SHIFT:
                                    isNextShifted = true;
                                    codeSet = Code128Reader.CODE_CODE_A;
                                    break;
                                case Code128Reader.CODE_CODE_A:
                                    codeSet = Code128Reader.CODE_CODE_A;
                                    break;
                                case Code128Reader.CODE_CODE_C:
                                    codeSet = Code128Reader.CODE_CODE_C;
                                    break;
                                case Code128Reader.CODE_STOP:
                                    done = true;
                                    break;
                            }
                        }
                        break;
                    case Code128Reader.CODE_CODE_C:
                        if (code < 100) {
                            if (code < 10) {
                                result += '0';
                            }
                            result += code;
                        }
                        else {
                            if (code !== Code128Reader.CODE_STOP) {
                                lastCharacterWasPrintable = false;
                            }
                            switch (code) {
                                case Code128Reader.CODE_FNC_1:
                                    if (convertFNC1) {
                                        if (result.length === 0) {
                                            // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code
                                            // is FNC1 then this is GS1-128. We add the symbology identifier.
                                            result += ']C1';
                                        }
                                        else {
                                            // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)
                                            result += String.fromCharCode(29);
                                        }
                                    }
                                    break;
                                case Code128Reader.CODE_CODE_A:
                                    codeSet = Code128Reader.CODE_CODE_A;
                                    break;
                                case Code128Reader.CODE_CODE_B:
                                    codeSet = Code128Reader.CODE_CODE_B;
                                    break;
                                case Code128Reader.CODE_STOP:
                                    done = true;
                                    break;
                            }
                        }
                        break;
                }
                // Unshift back to another code set if we were shifted
                if (unshift) {
                    codeSet = codeSet === Code128Reader.CODE_CODE_A ? Code128Reader.CODE_CODE_B : Code128Reader.CODE_CODE_A;
                }
            }
            const lastPatternSize = nextStart - lastStart;
            // Check for ample whitespace following pattern, but, to do this we first need to remember that
            // we fudged decoding CODE_STOP since it actually has 7 bars, not 6. There is a black bar left
            // to read off. Would be slightly better to properly read. Here we just skip it:
            nextStart = row.getNextUnset(nextStart);
            if (!row.isRange(nextStart, Math.min(row.getSize(), nextStart + (nextStart - lastStart) / 2), false)) {
                throw new NotFoundException();
            }
            // Pull out from sum the value of the penultimate check code
            checksumTotal -= multiplier * lastCode;
            // lastCode is the checksum then:
            if (checksumTotal % 103 !== lastCode) {
                throw new ChecksumException();
            }
            // Need to pull out the check digits from string
            const resultLength = result.length;
            if (resultLength === 0) {
                // false positive
                throw new NotFoundException();
            }
            // Only bother if the result had at least one character, and if the checksum digit happened to
            // be a printable character. If it was just interpreted as a control code, nothing to remove.
            if (resultLength > 0 && lastCharacterWasPrintable) {
                if (codeSet === Code128Reader.CODE_CODE_C) {
                    result = result.substring(0, resultLength - 2);
                }
                else {
                    result = result.substring(0, resultLength - 1);
                }
            }
            const left = (startPatternInfo[1] + startPatternInfo[0]) / 2.0;
            const right = lastStart + lastPatternSize / 2.0;
            const rawCodesSize = rawCodes.length;
            const rawBytes = new Uint8Array(rawCodesSize);
            for (let i = 0; i < rawCodesSize; i++) {
                rawBytes[i] = rawCodes[i];
            }
            const points = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];
            return new Result(result, rawBytes, 0, points, BarcodeFormat$1.CODE_128, new Date().getTime());
        }
    }
    Code128Reader.CODE_PATTERNS = [
        Int32Array.from([2, 1, 2, 2, 2, 2]),
        Int32Array.from([2, 2, 2, 1, 2, 2]),
        Int32Array.from([2, 2, 2, 2, 2, 1]),
        Int32Array.from([1, 2, 1, 2, 2, 3]),
        Int32Array.from([1, 2, 1, 3, 2, 2]),
        Int32Array.from([1, 3, 1, 2, 2, 2]),
        Int32Array.from([1, 2, 2, 2, 1, 3]),
        Int32Array.from([1, 2, 2, 3, 1, 2]),
        Int32Array.from([1, 3, 2, 2, 1, 2]),
        Int32Array.from([2, 2, 1, 2, 1, 3]),
        Int32Array.from([2, 2, 1, 3, 1, 2]),
        Int32Array.from([2, 3, 1, 2, 1, 2]),
        Int32Array.from([1, 1, 2, 2, 3, 2]),
        Int32Array.from([1, 2, 2, 1, 3, 2]),
        Int32Array.from([1, 2, 2, 2, 3, 1]),
        Int32Array.from([1, 1, 3, 2, 2, 2]),
        Int32Array.from([1, 2, 3, 1, 2, 2]),
        Int32Array.from([1, 2, 3, 2, 2, 1]),
        Int32Array.from([2, 2, 3, 2, 1, 1]),
        Int32Array.from([2, 2, 1, 1, 3, 2]),
        Int32Array.from([2, 2, 1, 2, 3, 1]),
        Int32Array.from([2, 1, 3, 2, 1, 2]),
        Int32Array.from([2, 2, 3, 1, 1, 2]),
        Int32Array.from([3, 1, 2, 1, 3, 1]),
        Int32Array.from([3, 1, 1, 2, 2, 2]),
        Int32Array.from([3, 2, 1, 1, 2, 2]),
        Int32Array.from([3, 2, 1, 2, 2, 1]),
        Int32Array.from([3, 1, 2, 2, 1, 2]),
        Int32Array.from([3, 2, 2, 1, 1, 2]),
        Int32Array.from([3, 2, 2, 2, 1, 1]),
        Int32Array.from([2, 1, 2, 1, 2, 3]),
        Int32Array.from([2, 1, 2, 3, 2, 1]),
        Int32Array.from([2, 3, 2, 1, 2, 1]),
        Int32Array.from([1, 1, 1, 3, 2, 3]),
        Int32Array.from([1, 3, 1, 1, 2, 3]),
        Int32Array.from([1, 3, 1, 3, 2, 1]),
        Int32Array.from([1, 1, 2, 3, 1, 3]),
        Int32Array.from([1, 3, 2, 1, 1, 3]),
        Int32Array.from([1, 3, 2, 3, 1, 1]),
        Int32Array.from([2, 1, 1, 3, 1, 3]),
        Int32Array.from([2, 3, 1, 1, 1, 3]),
        Int32Array.from([2, 3, 1, 3, 1, 1]),
        Int32Array.from([1, 1, 2, 1, 3, 3]),
        Int32Array.from([1, 1, 2, 3, 3, 1]),
        Int32Array.from([1, 3, 2, 1, 3, 1]),
        Int32Array.from([1, 1, 3, 1, 2, 3]),
        Int32Array.from([1, 1, 3, 3, 2, 1]),
        Int32Array.from([1, 3, 3, 1, 2, 1]),
        Int32Array.from([3, 1, 3, 1, 2, 1]),
        Int32Array.from([2, 1, 1, 3, 3, 1]),
        Int32Array.from([2, 3, 1, 1, 3, 1]),
        Int32Array.from([2, 1, 3, 1, 1, 3]),
        Int32Array.from([2, 1, 3, 3, 1, 1]),
        Int32Array.from([2, 1, 3, 1, 3, 1]),
        Int32Array.from([3, 1, 1, 1, 2, 3]),
        Int32Array.from([3, 1, 1, 3, 2, 1]),
        Int32Array.from([3, 3, 1, 1, 2, 1]),
        Int32Array.from([3, 1, 2, 1, 1, 3]),
        Int32Array.from([3, 1, 2, 3, 1, 1]),
        Int32Array.from([3, 3, 2, 1, 1, 1]),
        Int32Array.from([3, 1, 4, 1, 1, 1]),
        Int32Array.from([2, 2, 1, 4, 1, 1]),
        Int32Array.from([4, 3, 1, 1, 1, 1]),
        Int32Array.from([1, 1, 1, 2, 2, 4]),
        Int32Array.from([1, 1, 1, 4, 2, 2]),
        Int32Array.from([1, 2, 1, 1, 2, 4]),
        Int32Array.from([1, 2, 1, 4, 2, 1]),
        Int32Array.from([1, 4, 1, 1, 2, 2]),
        Int32Array.from([1, 4, 1, 2, 2, 1]),
        Int32Array.from([1, 1, 2, 2, 1, 4]),
        Int32Array.from([1, 1, 2, 4, 1, 2]),
        Int32Array.from([1, 2, 2, 1, 1, 4]),
        Int32Array.from([1, 2, 2, 4, 1, 1]),
        Int32Array.from([1, 4, 2, 1, 1, 2]),
        Int32Array.from([1, 4, 2, 2, 1, 1]),
        Int32Array.from([2, 4, 1, 2, 1, 1]),
        Int32Array.from([2, 2, 1, 1, 1, 4]),
        Int32Array.from([4, 1, 3, 1, 1, 1]),
        Int32Array.from([2, 4, 1, 1, 1, 2]),
        Int32Array.from([1, 3, 4, 1, 1, 1]),
        Int32Array.from([1, 1, 1, 2, 4, 2]),
        Int32Array.from([1, 2, 1, 1, 4, 2]),
        Int32Array.from([1, 2, 1, 2, 4, 1]),
        Int32Array.from([1, 1, 4, 2, 1, 2]),
        Int32Array.from([1, 2, 4, 1, 1, 2]),
        Int32Array.from([1, 2, 4, 2, 1, 1]),
        Int32Array.from([4, 1, 1, 2, 1, 2]),
        Int32Array.from([4, 2, 1, 1, 1, 2]),
        Int32Array.from([4, 2, 1, 2, 1, 1]),
        Int32Array.from([2, 1, 2, 1, 4, 1]),
        Int32Array.from([2, 1, 4, 1, 2, 1]),
        Int32Array.from([4, 1, 2, 1, 2, 1]),
        Int32Array.from([1, 1, 1, 1, 4, 3]),
        Int32Array.from([1, 1, 1, 3, 4, 1]),
        Int32Array.from([1, 3, 1, 1, 4, 1]),
        Int32Array.from([1, 1, 4, 1, 1, 3]),
        Int32Array.from([1, 1, 4, 3, 1, 1]),
        Int32Array.from([4, 1, 1, 1, 1, 3]),
        Int32Array.from([4, 1, 1, 3, 1, 1]),
        Int32Array.from([1, 1, 3, 1, 4, 1]),
        Int32Array.from([1, 1, 4, 1, 3, 1]),
        Int32Array.from([3, 1, 1, 1, 4, 1]),
        Int32Array.from([4, 1, 1, 1, 3, 1]),
        Int32Array.from([2, 1, 1, 4, 1, 2]),
        Int32Array.from([2, 1, 1, 2, 1, 4]),
        Int32Array.from([2, 1, 1, 2, 3, 2]),
        Int32Array.from([2, 3, 3, 1, 1, 1, 2]),
    ];
    Code128Reader.MAX_AVG_VARIANCE = 0.25;
    Code128Reader.MAX_INDIVIDUAL_VARIANCE = 0.7;
    Code128Reader.CODE_SHIFT = 98;
    Code128Reader.CODE_CODE_C = 99;
    Code128Reader.CODE_CODE_B = 100;
    Code128Reader.CODE_CODE_A = 101;
    Code128Reader.CODE_FNC_1 = 102;
    Code128Reader.CODE_FNC_2 = 97;
    Code128Reader.CODE_FNC_3 = 96;
    Code128Reader.CODE_FNC_4_A = 101;
    Code128Reader.CODE_FNC_4_B = 100;
    Code128Reader.CODE_START_A = 103;
    Code128Reader.CODE_START_B = 104;
    Code128Reader.CODE_START_C = 105;
    Code128Reader.CODE_STOP = 106;

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Decodes Code 39 barcodes. Supports "Full ASCII Code 39" if USE_CODE_39_EXTENDED_MODE is set.</p>
     *
     * @author Sean Owen
     * @see Code93Reader
     */
    class Code39Reader extends OneDReader {
        /**
         * Creates a reader that assumes all encoded data is data, and does not treat the final
         * character as a check digit. It will not decoded "extended Code 39" sequences.
         */
        // public Code39Reader() {
        //   this(false);
        // }
        /**
         * Creates a reader that can be configured to check the last character as a check digit.
         * It will not decoded "extended Code 39" sequences.
         *
         * @param usingCheckDigit if true, treat the last data character as a check digit, not
         * data, and verify that the checksum passes.
         */
        // public Code39Reader(boolean usingCheckDigit) {
        //   this(usingCheckDigit, false);
        // }
        /**
         * Creates a reader that can be configured to check the last character as a check digit,
         * or optionally attempt to decode "extended Code 39" sequences that are used to encode
         * the full ASCII character set.
         *
         * @param usingCheckDigit if true, treat the last data character as a check digit, not
         * data, and verify that the checksum passes.
         * @param extendedMode if true, will attempt to decode extended Code 39 sequences in the
         * text.
         */
        constructor(usingCheckDigit = false, extendedMode = false) {
            super();
            this.usingCheckDigit = usingCheckDigit;
            this.extendedMode = extendedMode;
            this.decodeRowResult = '';
            this.counters = new Int32Array(9);
        }
        decodeRow(rowNumber, row, hints) {
            let theCounters = this.counters;
            theCounters.fill(0);
            this.decodeRowResult = '';
            let start = Code39Reader.findAsteriskPattern(row, theCounters);
            // Read off white space
            let nextStart = row.getNextSet(start[1]);
            let end = row.getSize();
            let decodedChar;
            let lastStart;
            do {
                Code39Reader.recordPattern(row, nextStart, theCounters);
                let pattern = Code39Reader.toNarrowWidePattern(theCounters);
                if (pattern < 0) {
                    throw new NotFoundException();
                }
                decodedChar = Code39Reader.patternToChar(pattern);
                this.decodeRowResult += decodedChar;
                lastStart = nextStart;
                for (let counter of theCounters) {
                    nextStart += counter;
                }
                // Read off white space
                nextStart = row.getNextSet(nextStart);
            } while (decodedChar !== '*');
            this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1); // remove asterisk
            // Look for whitespace after pattern:
            let lastPatternSize = 0;
            for (let counter of theCounters) {
                lastPatternSize += counter;
            }
            let whiteSpaceAfterEnd = nextStart - lastStart - lastPatternSize;
            // If 50% of last pattern size, following last pattern, is not whitespace, fail
            // (but if it's whitespace to the very end of the image, that's OK)
            if (nextStart !== end && (whiteSpaceAfterEnd * 2) < lastPatternSize) {
                throw new NotFoundException();
            }
            if (this.usingCheckDigit) {
                let max = this.decodeRowResult.length - 1;
                let total = 0;
                for (let i = 0; i < max; i++) {
                    total += Code39Reader.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(i));
                }
                if (this.decodeRowResult.charAt(max) !== Code39Reader.ALPHABET_STRING.charAt(total % 43)) {
                    throw new ChecksumException();
                }
                this.decodeRowResult = this.decodeRowResult.substring(0, max);
            }
            if (this.decodeRowResult.length === 0) {
                // false positive
                throw new NotFoundException();
            }
            let resultString;
            if (this.extendedMode) {
                resultString = Code39Reader.decodeExtended(this.decodeRowResult);
            }
            else {
                resultString = this.decodeRowResult;
            }
            let left = (start[1] + start[0]) / 2.0;
            let right = lastStart + lastPatternSize / 2.0;
            return new Result(resultString, null, 0, [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)], BarcodeFormat$1.CODE_39, new Date().getTime());
        }
        static findAsteriskPattern(row, counters) {
            let width = row.getSize();
            let rowOffset = row.getNextSet(0);
            let counterPosition = 0;
            let patternStart = rowOffset;
            let isWhite = false;
            let patternLength = counters.length;
            for (let i = rowOffset; i < width; i++) {
                if (row.get(i) !== isWhite) {
                    counters[counterPosition]++;
                }
                else {
                    if (counterPosition === patternLength - 1) {
                        // Look for whitespace before start pattern, >= 50% of width of start pattern
                        if (this.toNarrowWidePattern(counters) === Code39Reader.ASTERISK_ENCODING &&
                            row.isRange(Math.max(0, patternStart - Math.floor((i - patternStart) / 2)), patternStart, false)) {
                            return [patternStart, i];
                        }
                        patternStart += counters[0] + counters[1];
                        counters.copyWithin(0, 2, 2 + counterPosition - 1);
                        counters[counterPosition - 1] = 0;
                        counters[counterPosition] = 0;
                        counterPosition--;
                    }
                    else {
                        counterPosition++;
                    }
                    counters[counterPosition] = 1;
                    isWhite = !isWhite;
                }
            }
            throw new NotFoundException();
        }
        // For efficiency, returns -1 on failure. Not throwing here saved as many as 700 exceptions
        // per image when using some of our blackbox images.
        static toNarrowWidePattern(counters) {
            let numCounters = counters.length;
            let maxNarrowCounter = 0;
            let wideCounters;
            do {
                let minCounter = 0x7fffffff;
                for (let counter of counters) {
                    if (counter < minCounter && counter > maxNarrowCounter) {
                        minCounter = counter;
                    }
                }
                maxNarrowCounter = minCounter;
                wideCounters = 0;
                let totalWideCountersWidth = 0;
                let pattern = 0;
                for (let i = 0; i < numCounters; i++) {
                    let counter = counters[i];
                    if (counter > maxNarrowCounter) {
                        pattern |= 1 << (numCounters - 1 - i);
                        wideCounters++;
                        totalWideCountersWidth += counter;
                    }
                }
                if (wideCounters === 3) {
                    // Found 3 wide counters, but are they close enough in width?
                    // We can perform a cheap, conservative check to see if any individual
                    // counter is more than 1.5 times the average:
                    for (let i = 0; i < numCounters && wideCounters > 0; i++) {
                        let counter = counters[i];
                        if (counter > maxNarrowCounter) {
                            wideCounters--;
                            // totalWideCountersWidth = 3 * average, so this checks if counter >= 3/2 * average
                            if ((counter * 2) >= totalWideCountersWidth) {
                                return -1;
                            }
                        }
                    }
                    return pattern;
                }
            } while (wideCounters > 3);
            return -1;
        }
        static patternToChar(pattern) {
            for (let i = 0; i < Code39Reader.CHARACTER_ENCODINGS.length; i++) {
                if (Code39Reader.CHARACTER_ENCODINGS[i] === pattern) {
                    return Code39Reader.ALPHABET_STRING.charAt(i);
                }
            }
            if (pattern === Code39Reader.ASTERISK_ENCODING) {
                return '*';
            }
            throw new NotFoundException();
        }
        static decodeExtended(encoded) {
            let length = encoded.length;
            let decoded = '';
            for (let i = 0; i < length; i++) {
                let c = encoded.charAt(i);
                if (c === '+' || c === '$' || c === '%' || c === '/') {
                    let next = encoded.charAt(i + 1);
                    let decodedChar = '\0';
                    switch (c) {
                        case '+':
                            // +A to +Z map to a to z
                            if (next >= 'A' && next <= 'Z') {
                                decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);
                            }
                            else {
                                throw new FormatException();
                            }
                            break;
                        case '$':
                            // $A to $Z map to control codes SH to SB
                            if (next >= 'A' && next <= 'Z') {
                                decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);
                            }
                            else {
                                throw new FormatException();
                            }
                            break;
                        case '%':
                            // %A to %E map to control codes ESC to US
                            if (next >= 'A' && next <= 'E') {
                                decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);
                            }
                            else if (next >= 'F' && next <= 'J') {
                                decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);
                            }
                            else if (next >= 'K' && next <= 'O') {
                                decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);
                            }
                            else if (next >= 'P' && next <= 'T') {
                                decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);
                            }
                            else if (next === 'U') {
                                decodedChar = '\0';
                            }
                            else if (next === 'V') {
                                decodedChar = '@';
                            }
                            else if (next === 'W') {
                                decodedChar = '`';
                            }
                            else if (next === 'X' || next === 'Y' || next === 'Z') {
                                decodedChar = '\x7f';
                            }
                            else {
                                throw new FormatException();
                            }
                            break;
                        case '/':
                            // /A to /O map to ! to , and /Z maps to :
                            if (next >= 'A' && next <= 'O') {
                                decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);
                            }
                            else if (next === 'Z') {
                                decodedChar = ':';
                            }
                            else {
                                throw new FormatException();
                            }
                            break;
                    }
                    decoded += decodedChar;
                    // bump up i again since we read two characters
                    i++;
                }
                else {
                    decoded += c;
                }
            }
            return decoded;
        }
    }
    Code39Reader.ALPHABET_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%';
    /**
     * These represent the encodings of characters, as patterns of wide and narrow bars.
     * The 9 least-significant bits of each int correspond to the pattern of wide and narrow,
     * with 1s representing "wide" and 0s representing narrow.
     */
    Code39Reader.CHARACTER_ENCODINGS = [
        0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064,
        0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C,
        0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016,
        0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x0A8,
        0x0A2, 0x08A, 0x02A // /-%
    ];
    Code39Reader.ASTERISK_ENCODING = 0x094;

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Decodes ITF barcodes.</p>
     *
     * @author Tjieco
     */
    class ITFReader extends OneDReader {
        constructor() {
            // private static W = 3; // Pixel width of a 3x wide line
            // private static w = 2; // Pixel width of a 2x wide line
            // private static N = 1; // Pixed width of a narrow line
            super(...arguments);
            // Stores the actual narrow line width of the image being decoded.
            this.narrowLineWidth = -1;
        }
        // See ITFWriter.PATTERNS
        /*

        /!**
         * Patterns of Wide / Narrow lines to indicate each digit
         *!/
        */
        decodeRow(rowNumber, row, hints) {
            // Find out where the Middle section (payload) starts & ends
            let startRange = this.decodeStart(row);
            let endRange = this.decodeEnd(row);
            let result = new StringBuilder();
            ITFReader.decodeMiddle(row, startRange[1], endRange[0], result);
            let resultString = result.toString();
            let allowedLengths = null;
            if (hints != null) {
                allowedLengths = hints.get(DecodeHintType$1.ALLOWED_LENGTHS);
            }
            if (allowedLengths == null) {
                allowedLengths = ITFReader.DEFAULT_ALLOWED_LENGTHS;
            }
            // To avoid false positives with 2D barcodes (and other patterns), make
            // an assumption that the decoded string must be a 'standard' length if it's short
            let length = resultString.length;
            let lengthOK = false;
            let maxAllowedLength = 0;
            for (let value of allowedLengths) {
                if (length === value) {
                    lengthOK = true;
                    break;
                }
                if (value > maxAllowedLength) {
                    maxAllowedLength = value;
                }
            }
            if (!lengthOK && length > maxAllowedLength) {
                lengthOK = true;
            }
            if (!lengthOK) {
                throw new FormatException();
            }
            const points = [new ResultPoint(startRange[1], rowNumber), new ResultPoint(endRange[0], rowNumber)];
            let resultReturn = new Result(resultString, null, // no natural byte representation for these barcodes
                0, points, BarcodeFormat$1.ITF, new Date().getTime());
            return resultReturn;
        }
        /*
        /!**
         * @param row          row of black/white values to search
         * @param payloadStart offset of start pattern
         * @param resultString {@link StringBuilder} to append decoded chars to
         * @throws NotFoundException if decoding could not complete successfully
         *!/*/
        static decodeMiddle(row, payloadStart, payloadEnd, resultString) {
            // Digits are interleaved in pairs - 5 black lines for one digit, and the
            // 5
            // interleaved white lines for the second digit.
            // Therefore, need to scan 10 lines and then
            // split these into two arrays
            let counterDigitPair = new Int32Array(10); // 10
            let counterBlack = new Int32Array(5); // 5
            let counterWhite = new Int32Array(5); // 5
            counterDigitPair.fill(0);
            counterBlack.fill(0);
            counterWhite.fill(0);
            while (payloadStart < payloadEnd) {
                // Get 10 runs of black/white.
                OneDReader.recordPattern(row, payloadStart, counterDigitPair);
                // Split them into each array
                for (let k = 0; k < 5; k++) {
                    let twoK = 2 * k;
                    counterBlack[k] = counterDigitPair[twoK];
                    counterWhite[k] = counterDigitPair[twoK + 1];
                }
                let bestMatch = ITFReader.decodeDigit(counterBlack);
                resultString.append(bestMatch.toString());
                bestMatch = this.decodeDigit(counterWhite);
                resultString.append(bestMatch.toString());
                counterDigitPair.forEach(function (counterDigit) {
                    payloadStart += counterDigit;
                });
            }
        }
        /*/!**
         * Identify where the start of the middle / payload section starts.
         *
         * @param row row of black/white values to search
         * @return Array, containing index of start of 'start block' and end of
         *         'start block'
         *!/*/
        decodeStart(row) {
            let endStart = ITFReader.skipWhiteSpace(row);
            let startPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.START_PATTERN);
            // Determine the width of a narrow line in pixels. We can do this by
            // getting the width of the start pattern and dividing by 4 because its
            // made up of 4 narrow lines.
            this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;
            this.validateQuietZone(row, startPattern[0]);
            return startPattern;
        }
        /*/!**
         * The start & end patterns must be pre/post fixed by a quiet zone. This
         * zone must be at least 10 times the width of a narrow line.  Scan back until
         * we either get to the start of the barcode or match the necessary number of
         * quiet zone pixels.
         *
         * Note: Its assumed the row is reversed when using this method to find
         * quiet zone after the end pattern.
         *
         * ref: http://www.barcode-1.net/i25code.html
         *
         * @param row bit array representing the scanned barcode.
         * @param startPattern index into row of the start or end pattern.
         * @throws NotFoundException if the quiet zone cannot be found
         *!/*/
        validateQuietZone(row, startPattern) {
            let quietCount = this.narrowLineWidth * 10; // expect to find this many pixels of quiet zone
            // if there are not so many pixel at all let's try as many as possible
            quietCount = quietCount < startPattern ? quietCount : startPattern;
            for (let i = startPattern - 1; quietCount > 0 && i >= 0; i--) {
                if (row.get(i)) {
                    break;
                }
                quietCount--;
            }
            if (quietCount !== 0) {
                // Unable to find the necessary number of quiet zone pixels.
                throw new NotFoundException();
            }
        }
        /*
        /!**
         * Skip all whitespace until we get to the first black line.
         *
         * @param row row of black/white values to search
         * @return index of the first black line.
         * @throws NotFoundException Throws exception if no black lines are found in the row
         *!/*/
        static skipWhiteSpace(row) {
            const width = row.getSize();
            const endStart = row.getNextSet(0);
            if (endStart === width) {
                throw new NotFoundException();
            }
            return endStart;
        }
        /*/!**
         * Identify where the end of the middle / payload section ends.
         *
         * @param row row of black/white values to search
         * @return Array, containing index of start of 'end block' and end of 'end
         *         block'
         *!/*/
        decodeEnd(row) {
            // For convenience, reverse the row and then
            // search from 'the start' for the end block
            row.reverse();
            try {
                let endStart = ITFReader.skipWhiteSpace(row);
                let endPattern;
                try {
                    endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[0]);
                }
                catch (error) {
                    if (error instanceof NotFoundException) {
                        endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[1]);
                    }
                }
                // The start & end patterns must be pre/post fixed by a quiet zone. This
                // zone must be at least 10 times the width of a narrow line.
                // ref: http://www.barcode-1.net/i25code.html
                this.validateQuietZone(row, endPattern[0]);
                // Now recalculate the indices of where the 'endblock' starts & stops to
                // accommodate
                // the reversed nature of the search
                let temp = endPattern[0];
                endPattern[0] = row.getSize() - endPattern[1];
                endPattern[1] = row.getSize() - temp;
                return endPattern;
            }
            finally {
                // Put the row back the right way.
                row.reverse();
            }
        }
        /*
        /!**
         * @param row       row of black/white values to search
         * @param rowOffset position to start search
         * @param pattern   pattern of counts of number of black and white pixels that are
         *                  being searched for as a pattern
         * @return start/end horizontal offset of guard pattern, as an array of two
         *         ints
         * @throws NotFoundException if pattern is not found
         *!/*/
        static findGuardPattern(row, rowOffset, pattern) {
            let patternLength = pattern.length;
            let counters = new Int32Array(patternLength);
            let width = row.getSize();
            let isWhite = false;
            let counterPosition = 0;
            let patternStart = rowOffset;
            counters.fill(0);
            for (let x = rowOffset; x < width; x++) {
                if (row.get(x) !== isWhite) {
                    counters[counterPosition]++;
                }
                else {
                    if (counterPosition === patternLength - 1) {
                        if (OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE) < ITFReader.MAX_AVG_VARIANCE) {
                            return [patternStart, x];
                        }
                        patternStart += counters[0] + counters[1];
                        System.arraycopy(counters, 2, counters, 0, counterPosition - 1);
                        counters[counterPosition - 1] = 0;
                        counters[counterPosition] = 0;
                        counterPosition--;
                    }
                    else {
                        counterPosition++;
                    }
                    counters[counterPosition] = 1;
                    isWhite = !isWhite;
                }
            }
            throw new NotFoundException();
        }
        /*/!**
         * Attempts to decode a sequence of ITF black/white lines into single
         * digit.
         *
         * @param counters the counts of runs of observed black/white/black/... values
         * @return The decoded digit
         * @throws NotFoundException if digit cannot be decoded
         *!/*/
        static decodeDigit(counters) {
            let bestVariance = ITFReader.MAX_AVG_VARIANCE; // worst variance we'll accept
            let bestMatch = -1;
            let max = ITFReader.PATTERNS.length;
            for (let i = 0; i < max; i++) {
                let pattern = ITFReader.PATTERNS[i];
                let variance = OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE);
                if (variance < bestVariance) {
                    bestVariance = variance;
                    bestMatch = i;
                }
                else if (variance === bestVariance) {
                    // if we find a second 'best match' with the same variance, we can not reliably report to have a suitable match
                    bestMatch = -1;
                }
            }
            if (bestMatch >= 0) {
                return bestMatch % 10;
            }
            else {
                throw new NotFoundException();
            }
        }
    }
    ITFReader.PATTERNS = [
        Int32Array.from([1, 1, 2, 2, 1]),
        Int32Array.from([2, 1, 1, 1, 2]),
        Int32Array.from([1, 2, 1, 1, 2]),
        Int32Array.from([2, 2, 1, 1, 1]),
        Int32Array.from([1, 1, 2, 1, 2]),
        Int32Array.from([2, 1, 2, 1, 1]),
        Int32Array.from([1, 2, 2, 1, 1]),
        Int32Array.from([1, 1, 1, 2, 2]),
        Int32Array.from([2, 1, 1, 2, 1]),
        Int32Array.from([1, 2, 1, 2, 1]),
        Int32Array.from([1, 1, 3, 3, 1]),
        Int32Array.from([3, 1, 1, 1, 3]),
        Int32Array.from([1, 3, 1, 1, 3]),
        Int32Array.from([3, 3, 1, 1, 1]),
        Int32Array.from([1, 1, 3, 1, 3]),
        Int32Array.from([3, 1, 3, 1, 1]),
        Int32Array.from([1, 3, 3, 1, 1]),
        Int32Array.from([1, 1, 1, 3, 3]),
        Int32Array.from([3, 1, 1, 3, 1]),
        Int32Array.from([1, 3, 1, 3, 1]) // 9
    ];
    ITFReader.MAX_AVG_VARIANCE = 0.38;
    ITFReader.MAX_INDIVIDUAL_VARIANCE = 0.5;
    /* /!** Valid ITF lengths. Anything longer than the largest value is also allowed. *!/*/
    ITFReader.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14];
    /*/!**
     * Start/end guard pattern.
     *
     * Note: The end pattern is reversed because the row is reversed before
     * searching for the END_PATTERN
     *!/*/
    ITFReader.START_PATTERN = Int32Array.from([1, 1, 1, 1]);
    ITFReader.END_PATTERN_REVERSED = [
        Int32Array.from([1, 1, 2]),
        Int32Array.from([1, 1, 3]) // 3x
    ];

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Encapsulates functionality and implementation that is common to UPC and EAN families
     * of one-dimensional barcodes.</p>
     *
     * @author dswitkin@google.com (Daniel Switkin)
     * @author Sean Owen
     * @author alasdair@google.com (Alasdair Mackintosh)
     */
    class AbstractUPCEANReader extends OneDReader {
        constructor() {
            super(...arguments);
            this.decodeRowStringBuffer = '';
        }
        // private final UPCEANExtensionSupport extensionReader;
        // private final EANManufacturerOrgSupport eanManSupport;
        /*
        protected UPCEANReader() {
            decodeRowStringBuffer = new StringBuilder(20);
            extensionReader = new UPCEANExtensionSupport();
            eanManSupport = new EANManufacturerOrgSupport();
        }
        */
        static findStartGuardPattern(row) {
            let foundStart = false;
            let startRange;
            let nextStart = 0;
            let counters = Int32Array.from([0, 0, 0]);
            while (!foundStart) {
                counters = Int32Array.from([0, 0, 0]);
                startRange = AbstractUPCEANReader.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);
                let start = startRange[0];
                nextStart = startRange[1];
                let quietStart = start - (nextStart - start);
                if (quietStart >= 0) {
                    foundStart = row.isRange(quietStart, start, false);
                }
            }
            return startRange;
        }
        static checkChecksum(s) {
            return AbstractUPCEANReader.checkStandardUPCEANChecksum(s);
        }
        static checkStandardUPCEANChecksum(s) {
            let length = s.length;
            if (length === 0)
                return false;
            let check = parseInt(s.charAt(length - 1), 10);
            return AbstractUPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;
        }
        static getStandardUPCEANChecksum(s) {
            let length = s.length;
            let sum = 0;
            for (let i = length - 1; i >= 0; i -= 2) {
                let digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);
                if (digit < 0 || digit > 9) {
                    throw new FormatException();
                }
                sum += digit;
            }
            sum *= 3;
            for (let i = length - 2; i >= 0; i -= 2) {
                let digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);
                if (digit < 0 || digit > 9) {
                    throw new FormatException();
                }
                sum += digit;
            }
            return (1000 - sum) % 10;
        }
        static decodeEnd(row, endStart) {
            return AbstractUPCEANReader.findGuardPattern(row, endStart, false, AbstractUPCEANReader.START_END_PATTERN, new Int32Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));
        }
        /**
         * @throws NotFoundException
         */
        static findGuardPatternWithoutCounters(row, rowOffset, whiteFirst, pattern) {
            return this.findGuardPattern(row, rowOffset, whiteFirst, pattern, new Int32Array(pattern.length));
        }
        /**
         * @param row row of black/white values to search
         * @param rowOffset position to start search
         * @param whiteFirst if true, indicates that the pattern specifies white/black/white/...
         * pixel counts, otherwise, it is interpreted as black/white/black/...
         * @param pattern pattern of counts of number of black and white pixels that are being
         * searched for as a pattern
         * @param counters array of counters, as long as pattern, to re-use
         * @return start/end horizontal offset of guard pattern, as an array of two ints
         * @throws NotFoundException if pattern is not found
         */
        static findGuardPattern(row, rowOffset, whiteFirst, pattern, counters) {
            let width = row.getSize();
            rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);
            let counterPosition = 0;
            let patternStart = rowOffset;
            let patternLength = pattern.length;
            let isWhite = whiteFirst;
            for (let x = rowOffset; x < width; x++) {
                if (row.get(x) !== isWhite) {
                    counters[counterPosition]++;
                }
                else {
                    if (counterPosition === patternLength - 1) {
                        if (OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader.MAX_AVG_VARIANCE) {
                            return Int32Array.from([patternStart, x]);
                        }
                        patternStart += counters[0] + counters[1];
                        let slice = counters.slice(2, counters.length - 1);
                        for (let i = 0; i < counterPosition - 1; i++) {
                            counters[i] = slice[i];
                        }
                        counters[counterPosition - 1] = 0;
                        counters[counterPosition] = 0;
                        counterPosition--;
                    }
                    else {
                        counterPosition++;
                    }
                    counters[counterPosition] = 1;
                    isWhite = !isWhite;
                }
            }
            throw new NotFoundException();
        }
        static decodeDigit(row, counters, rowOffset, patterns) {
            this.recordPattern(row, rowOffset, counters);
            let bestVariance = this.MAX_AVG_VARIANCE;
            let bestMatch = -1;
            let max = patterns.length;
            for (let i = 0; i < max; i++) {
                let pattern = patterns[i];
                let variance = OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);
                if (variance < bestVariance) {
                    bestVariance = variance;
                    bestMatch = i;
                }
            }
            if (bestMatch >= 0) {
                return bestMatch;
            }
            else {
                throw new NotFoundException();
            }
        }
    }
    // These two values are critical for determining how permissive the decoding will be.
    // We've arrived at these values through a lot of trial and error. Setting them any higher
    // lets false positives creep in quickly.
    AbstractUPCEANReader.MAX_AVG_VARIANCE = 0.48;
    AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE = 0.7;
    /**
     * Start/end guard pattern.
     */
    AbstractUPCEANReader.START_END_PATTERN = Int32Array.from([1, 1, 1]);
    /**
     * Pattern marking the middle of a UPC/EAN pattern, separating the two halves.
     */
    AbstractUPCEANReader.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1]);
    /**
     * end guard pattern.
     */
    AbstractUPCEANReader.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);
    /**
     * "Odd", or "L" patterns used to encode UPC/EAN digits.
     */
    AbstractUPCEANReader.L_PATTERNS = [
        Int32Array.from([3, 2, 1, 1]),
        Int32Array.from([2, 2, 2, 1]),
        Int32Array.from([2, 1, 2, 2]),
        Int32Array.from([1, 4, 1, 1]),
        Int32Array.from([1, 1, 3, 2]),
        Int32Array.from([1, 2, 3, 1]),
        Int32Array.from([1, 1, 1, 4]),
        Int32Array.from([1, 3, 1, 2]),
        Int32Array.from([1, 2, 1, 3]),
        Int32Array.from([3, 1, 1, 2]),
    ];

    /*
     * Copyright (C) 2010 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * @see UPCEANExtension2Support
     */
    class UPCEANExtension5Support {
        constructor() {
            this.CHECK_DIGIT_ENCODINGS = [0x18, 0x14, 0x12, 0x11, 0x0C, 0x06, 0x03, 0x0A, 0x09, 0x05];
            this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
            this.decodeRowStringBuffer = '';
        }
        decodeRow(rowNumber, row, extensionStartRange) {
            let result = this.decodeRowStringBuffer;
            let end = this.decodeMiddle(row, extensionStartRange, result);
            let resultString = result.toString();
            let extensionData = UPCEANExtension5Support.parseExtensionString(resultString);
            let resultPoints = [
                new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2.0, rowNumber),
                new ResultPoint(end, rowNumber)
            ];
            let extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat$1.UPC_EAN_EXTENSION, new Date().getTime());
            if (extensionData != null) {
                extensionResult.putAllMetadata(extensionData);
            }
            return extensionResult;
        }
        decodeMiddle(row, startRange, resultString) {
            let counters = this.decodeMiddleCounters;
            counters[0] = 0;
            counters[1] = 0;
            counters[2] = 0;
            counters[3] = 0;
            let end = row.getSize();
            let rowOffset = startRange[1];
            let lgPatternFound = 0;
            for (let x = 0; x < 5 && rowOffset < end; x++) {
                let bestMatch = AbstractUPCEANReader.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader.L_AND_G_PATTERNS);
                resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));
                for (let counter of counters) {
                    rowOffset += counter;
                }
                if (bestMatch >= 10) {
                    lgPatternFound |= 1 << (4 - x);
                }
                if (x !== 4) {
                    // Read off separator if not last
                    rowOffset = row.getNextSet(rowOffset);
                    rowOffset = row.getNextUnset(rowOffset);
                }
            }
            if (resultString.length !== 5) {
                throw new NotFoundException();
            }
            let checkDigit = this.determineCheckDigit(lgPatternFound);
            if (UPCEANExtension5Support.extensionChecksum(resultString.toString()) !== checkDigit) {
                throw new NotFoundException();
            }
            return rowOffset;
        }
        static extensionChecksum(s) {
            let length = s.length;
            let sum = 0;
            for (let i = length - 2; i >= 0; i -= 2) {
                sum += s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);
            }
            sum *= 3;
            for (let i = length - 1; i >= 0; i -= 2) {
                sum += s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);
            }
            sum *= 3;
            return sum % 10;
        }
        determineCheckDigit(lgPatternFound) {
            for (let d = 0; d < 10; d++) {
                if (lgPatternFound === this.CHECK_DIGIT_ENCODINGS[d]) {
                    return d;
                }
            }
            throw new NotFoundException();
        }
        static parseExtensionString(raw) {
            if (raw.length !== 5) {
                return null;
            }
            let value = UPCEANExtension5Support.parseExtension5String(raw);
            if (value == null) {
                return null;
            }
            return new Map([[ResultMetadataType$1.SUGGESTED_PRICE, value]]);
        }
        static parseExtension5String(raw) {
            let currency;
            switch (raw.charAt(0)) {
                case '0':
                    currency = '£';
                    break;
                case '5':
                    currency = '$';
                    break;
                case '9':
                    // Reference: http://www.jollytech.com
                    switch (raw) {
                        case '90000':
                            // No suggested retail price
                            return null;
                        case '99991':
                            // Complementary
                            return '0.00';
                        case '99990':
                            return 'Used';
                    }
                    // Otherwise... unknown currency?
                    currency = '';
                    break;
                default:
                    currency = '';
                    break;
            }
            let rawAmount = parseInt(raw.substring(1));
            let unitsString = (rawAmount / 100).toString();
            let hundredths = rawAmount % 100;
            let hundredthsString = hundredths < 10 ? '0' + hundredths : hundredths.toString(); // fixme
            return currency + unitsString + '.' + hundredthsString;
        }
    }

    /*
     * Copyright (C) 2012 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * @see UPCEANExtension5Support
     */
    class UPCEANExtension2Support {
        constructor() {
            this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
            this.decodeRowStringBuffer = '';
        }
        decodeRow(rowNumber, row, extensionStartRange) {
            let result = this.decodeRowStringBuffer;
            let end = this.decodeMiddle(row, extensionStartRange, result);
            let resultString = result.toString();
            let extensionData = UPCEANExtension2Support.parseExtensionString(resultString);
            let resultPoints = [
                new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2.0, rowNumber),
                new ResultPoint(end, rowNumber)
            ];
            let extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat$1.UPC_EAN_EXTENSION, new Date().getTime());
            if (extensionData != null) {
                extensionResult.putAllMetadata(extensionData);
            }
            return extensionResult;
        }
        decodeMiddle(row, startRange, resultString) {
            let counters = this.decodeMiddleCounters;
            counters[0] = 0;
            counters[1] = 0;
            counters[2] = 0;
            counters[3] = 0;
            let end = row.getSize();
            let rowOffset = startRange[1];
            let checkParity = 0;
            for (let x = 0; x < 2 && rowOffset < end; x++) {
                let bestMatch = AbstractUPCEANReader.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader.L_AND_G_PATTERNS);
                resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));
                for (let counter of counters) {
                    rowOffset += counter;
                }
                if (bestMatch >= 10) {
                    checkParity |= 1 << (1 - x);
                }
                if (x !== 1) {
                    // Read off separator if not last
                    rowOffset = row.getNextSet(rowOffset);
                    rowOffset = row.getNextUnset(rowOffset);
                }
            }
            if (resultString.length !== 2) {
                throw new NotFoundException();
            }
            if (parseInt(resultString.toString()) % 4 !== checkParity) {
                throw new NotFoundException();
            }
            return rowOffset;
        }
        static parseExtensionString(raw) {
            if (raw.length !== 2) {
                return null;
            }
            return new Map([[ResultMetadataType$1.ISSUE_NUMBER, parseInt(raw)]]);
        }
    }

    /*
     * Copyright (C) 2010 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    class UPCEANExtensionSupport {
        static decodeRow(rowNumber, row, rowOffset) {
            let extensionStartRange = AbstractUPCEANReader.findGuardPattern(row, rowOffset, false, this.EXTENSION_START_PATTERN, new Int32Array(this.EXTENSION_START_PATTERN.length).fill(0));
            try {
                // return null;
                let fiveSupport = new UPCEANExtension5Support();
                return fiveSupport.decodeRow(rowNumber, row, extensionStartRange);
            }
            catch (err) {
                // return null;
                let twoSupport = new UPCEANExtension2Support();
                return twoSupport.decodeRow(rowNumber, row, extensionStartRange);
            }
        }
    }
    UPCEANExtensionSupport.EXTENSION_START_PATTERN = Int32Array.from([1, 1, 2]);

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Encapsulates functionality and implementation that is common to UPC and EAN families
     * of one-dimensional barcodes.</p>
     *
     * @author dswitkin@google.com (Daniel Switkin)
     * @author Sean Owen
     * @author alasdair@google.com (Alasdair Mackintosh)
     */
    class UPCEANReader extends AbstractUPCEANReader {
        constructor() {
            super();
            this.decodeRowStringBuffer = '';
            UPCEANReader.L_AND_G_PATTERNS = UPCEANReader.L_PATTERNS.map(arr => Int32Array.from(arr));
            for (let i = 10; i < 20; i++) {
                let widths = UPCEANReader.L_PATTERNS[i - 10];
                let reversedWidths = new Int32Array(widths.length);
                for (let j = 0; j < widths.length; j++) {
                    reversedWidths[j] = widths[widths.length - j - 1];
                }
                UPCEANReader.L_AND_G_PATTERNS[i] = reversedWidths;
            }
        }
        decodeRow(rowNumber, row, hints) {
            let startGuardRange = UPCEANReader.findStartGuardPattern(row);
            let resultPointCallback = hints == null ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
            if (resultPointCallback != null) {
                const resultPoint = new ResultPoint((startGuardRange[0] + startGuardRange[1]) / 2.0, rowNumber);
                resultPointCallback.foundPossibleResultPoint(resultPoint);
            }
            let budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);
            let endStart = budello.rowOffset;
            let result = budello.resultString;
            if (resultPointCallback != null) {
                const resultPoint = new ResultPoint(endStart, rowNumber);
                resultPointCallback.foundPossibleResultPoint(resultPoint);
            }
            let endRange = UPCEANReader.decodeEnd(row, endStart);
            if (resultPointCallback != null) {
                const resultPoint = new ResultPoint((endRange[0] + endRange[1]) / 2.0, rowNumber);
                resultPointCallback.foundPossibleResultPoint(resultPoint);
            }
            // Make sure there is a quiet zone at least as big as the end pattern after the barcode. The
            // spec might want more whitespace, but in practice this is the maximum we can count on.
            let end = endRange[1];
            let quietEnd = end + (end - endRange[0]);
            if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {
                throw new NotFoundException();
            }
            let resultString = result.toString();
            // UPC/EAN should never be less than 8 chars anyway
            if (resultString.length < 8) {
                throw new FormatException();
            }
            if (!UPCEANReader.checkChecksum(resultString)) {
                throw new ChecksumException();
            }
            let left = (startGuardRange[1] + startGuardRange[0]) / 2.0;
            let right = (endRange[1] + endRange[0]) / 2.0;
            let format = this.getBarcodeFormat();
            let resultPoint = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];
            let decodeResult = new Result(resultString, null, 0, resultPoint, format, new Date().getTime());
            let extensionLength = 0;
            try {
                let extensionResult = UPCEANExtensionSupport.decodeRow(rowNumber, row, endRange[1]);
                decodeResult.putMetadata(ResultMetadataType$1.UPC_EAN_EXTENSION, extensionResult.getText());
                decodeResult.putAllMetadata(extensionResult.getResultMetadata());
                decodeResult.addResultPoints(extensionResult.getResultPoints());
                extensionLength = extensionResult.getText().length;
            }
            catch (err) {
            }
            let allowedExtensions = hints == null ? null : hints.get(DecodeHintType$1.ALLOWED_EAN_EXTENSIONS);
            if (allowedExtensions != null) {
                let valid = false;
                for (let length in allowedExtensions) {
                    if (extensionLength.toString() === length) { // check me
                        valid = true;
                        break;
                    }
                }
                if (!valid) {
                    throw new NotFoundException();
                }
            }
            if (format === BarcodeFormat$1.EAN_13 || format === BarcodeFormat$1.UPC_A) ;
            return decodeResult;
        }
        static checkChecksum(s) {
            return UPCEANReader.checkStandardUPCEANChecksum(s);
        }
        static checkStandardUPCEANChecksum(s) {
            let length = s.length;
            if (length === 0)
                return false;
            let check = parseInt(s.charAt(length - 1), 10);
            return UPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;
        }
        static getStandardUPCEANChecksum(s) {
            let length = s.length;
            let sum = 0;
            for (let i = length - 1; i >= 0; i -= 2) {
                let digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);
                if (digit < 0 || digit > 9) {
                    throw new FormatException();
                }
                sum += digit;
            }
            sum *= 3;
            for (let i = length - 2; i >= 0; i -= 2) {
                let digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);
                if (digit < 0 || digit > 9) {
                    throw new FormatException();
                }
                sum += digit;
            }
            return (1000 - sum) % 10;
        }
        static decodeEnd(row, endStart) {
            return UPCEANReader.findGuardPattern(row, endStart, false, UPCEANReader.START_END_PATTERN, new Int32Array(UPCEANReader.START_END_PATTERN.length).fill(0));
        }
    }

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Implements decoding of the EAN-13 format.</p>
     *
     * @author dswitkin@google.com (Daniel Switkin)
     * @author Sean Owen
     * @author alasdair@google.com (Alasdair Mackintosh)
     */
    class EAN13Reader extends UPCEANReader {
        constructor() {
            super();
            this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
        }
        decodeMiddle(row, startRange, resultString) {
            let counters = this.decodeMiddleCounters;
            counters[0] = 0;
            counters[1] = 0;
            counters[2] = 0;
            counters[3] = 0;
            let end = row.getSize();
            let rowOffset = startRange[1];
            let lgPatternFound = 0;
            for (let x = 0; x < 6 && rowOffset < end; x++) {
                let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_AND_G_PATTERNS);
                resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));
                for (let counter of counters) {
                    rowOffset += counter;
                }
                if (bestMatch >= 10) {
                    lgPatternFound |= 1 << (5 - x);
                }
            }
            resultString = EAN13Reader.determineFirstDigit(resultString, lgPatternFound);
            let middleRange = UPCEANReader.findGuardPattern(row, rowOffset, true, UPCEANReader.MIDDLE_PATTERN, new Int32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0));
            rowOffset = middleRange[1];
            for (let x = 0; x < 6 && rowOffset < end; x++) {
                let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);
                resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch));
                for (let counter of counters) {
                    rowOffset += counter;
                }
            }
            return { rowOffset, resultString };
        }
        getBarcodeFormat() {
            return BarcodeFormat$1.EAN_13;
        }
        static determineFirstDigit(resultString, lgPatternFound) {
            for (let d = 0; d < 10; d++) {
                if (lgPatternFound === this.FIRST_DIGIT_ENCODINGS[d]) {
                    resultString = String.fromCharCode(('0'.charCodeAt(0) + d)) + resultString;
                    return resultString;
                }
            }
            throw new NotFoundException();
        }
    }
    EAN13Reader.FIRST_DIGIT_ENCODINGS = [0x00, 0x0B, 0x0D, 0xE, 0x13, 0x19, 0x1C, 0x15, 0x16, 0x1A];

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Implements decoding of the EAN-8 format.</p>
     *
     * @author Sean Owen
     */
    class EAN8Reader extends UPCEANReader {
        constructor() {
            super();
            this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
        }
        decodeMiddle(row, startRange, resultString) {
            const counters = this.decodeMiddleCounters;
            counters[0] = 0;
            counters[1] = 0;
            counters[2] = 0;
            counters[3] = 0;
            let end = row.getSize();
            let rowOffset = startRange[1];
            for (let x = 0; x < 4 && rowOffset < end; x++) {
                let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);
                resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch));
                for (let counter of counters) {
                    rowOffset += counter;
                }
            }
            let middleRange = UPCEANReader.findGuardPattern(row, rowOffset, true, UPCEANReader.MIDDLE_PATTERN, new Int32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0));
            rowOffset = middleRange[1];
            for (let x = 0; x < 4 && rowOffset < end; x++) {
                let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);
                resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch));
                for (let counter of counters) {
                    rowOffset += counter;
                }
            }
            return { rowOffset, resultString };
        }
        getBarcodeFormat() {
            return BarcodeFormat$1.EAN_8;
        }
    }

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Encapsulates functionality and implementation that is common to all families
     * of one-dimensional barcodes.
     *
     * @author dswitkin@google.com (Daniel Switkin)
     * @author Sean Owen
     * @author sam2332 (Sam Rudloff)
     *
     * @source https://github.com/zxing/zxing/blob/3c96923276dd5785d58eb970b6ba3f80d36a9505/core/src/main/java/com/google/zxing/oned/UPCAReader.java
     *
     * @experimental
     */
    class UPCAReader extends UPCEANReader {
        constructor() {
            super(...arguments);
            this.ean13Reader = new EAN13Reader();
        }
        // @Override
        getBarcodeFormat() {
            return BarcodeFormat$1.UPC_A;
        }
        // Note that we don't try rotation without the try harder flag, even if rotation was supported.
        // @Override
        decode(image, hints) {
            return this.maybeReturnResult(this.ean13Reader.decode(image));
        }
        // @Override
        decodeRow(rowNumber, row, hints) {
            return this.maybeReturnResult(this.ean13Reader.decodeRow(rowNumber, row, hints));
        }
        // @Override
        decodeMiddle(row, startRange, resultString) {
            return this.ean13Reader.decodeMiddle(row, startRange, resultString);
        }
        maybeReturnResult(result) {
            let text = result.getText();
            if (text.charAt(0) === '0') {
                let upcaResult = new Result(text.substring(1), null, null, result.getResultPoints(), BarcodeFormat$1.UPC_A);
                if (result.getResultMetadata() != null) {
                    upcaResult.putAllMetadata(result.getResultMetadata());
                }
                return upcaResult;
            }
            else {
                throw new NotFoundException();
            }
        }
        reset() {
            this.ean13Reader.reset();
        }
    }

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // package com.google.zxing.oned;
    // import com.google.zxing.BarcodeFormat;
    // import com.google.zxing.FormatException;
    // import com.google.zxing.NotFoundException;
    // import com.google.zxing.common.BitArray;
    /**
     * <p>Implements decoding of the UPC-E format.</p>
     * <p><a href="http://www.barcodeisland.com/upce.phtml">This</a> is a great reference for
     * UPC-E information.</p>
     *
     * @author Sean Owen
     *
     * @source https://github.com/zxing/zxing/blob/3c96923276dd5785d58eb970b6ba3f80d36a9505/core/src/main/java/com/google/zxing/oned/UPCEReader.java
     *
     * @experimental
     */
    /* final */ class UPCEReader extends UPCEANReader {
        constructor() {
            super();
            this.decodeMiddleCounters = new Int32Array(4);
        }
        /**
         * @throws NotFoundException
         */
        // @Override
        decodeMiddle(row, startRange, result) {
            const counters = this.decodeMiddleCounters.map(x => x);
            counters[0] = 0;
            counters[1] = 0;
            counters[2] = 0;
            counters[3] = 0;
            const end = row.getSize();
            let rowOffset = startRange[1];
            let lgPatternFound = 0;
            for (let x = 0; x < 6 && rowOffset < end; x++) {
                const bestMatch = UPCEReader.decodeDigit(row, counters, rowOffset, UPCEReader.L_AND_G_PATTERNS);
                result += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));
                for (let counter of counters) {
                    rowOffset += counter;
                }
                if (bestMatch >= 10) {
                    lgPatternFound |= 1 << (5 - x);
                }
            }
            UPCEReader.determineNumSysAndCheckDigit(new StringBuilder(result), lgPatternFound);
            return rowOffset;
        }
        /**
         * @throws NotFoundException
         */
        // @Override
        decodeEnd(row, endStart) {
            return UPCEReader.findGuardPatternWithoutCounters(row, endStart, true, UPCEReader.MIDDLE_END_PATTERN);
        }
        /**
         * @throws FormatException
         */
        // @Override
        checkChecksum(s) {
            return UPCEANReader.checkChecksum(UPCEReader.convertUPCEtoUPCA(s));
        }
        /**
         * @throws NotFoundException
         */
        static determineNumSysAndCheckDigit(resultString, lgPatternFound) {
            for (let numSys = 0; numSys <= 1; numSys++) {
                for (let d = 0; d < 10; d++) {
                    if (lgPatternFound === this.NUMSYS_AND_CHECK_DIGIT_PATTERNS[numSys][d]) {
                        resultString.insert(0, /*(char)*/ ('0' + numSys));
                        resultString.append(/*(char)*/ ('0' + d));
                        return;
                    }
                }
            }
            throw NotFoundException.getNotFoundInstance();
        }
        // @Override
        getBarcodeFormat() {
            return BarcodeFormat$1.UPC_E;
        }
        /**
         * Expands a UPC-E value back into its full, equivalent UPC-A code value.
         *
         * @param upce UPC-E code as string of digits
         * @return equivalent UPC-A code as string of digits
         */
        static convertUPCEtoUPCA(upce) {
            // the following line is equivalent to upce.getChars(1, 7, upceChars, 0);
            const upceChars = upce.slice(1, 7).split('').map(x => x.charCodeAt(0));
            const result = new StringBuilder( /*12*/);
            result.append(upce.charAt(0));
            let lastChar = upceChars[5];
            switch (lastChar) {
                case 0:
                case 1:
                case 2:
                    result.appendChars(upceChars, 0, 2);
                    result.append(lastChar);
                    result.append('0000');
                    result.appendChars(upceChars, 2, 3);
                    break;
                case 3:
                    result.appendChars(upceChars, 0, 3);
                    result.append('00000');
                    result.appendChars(upceChars, 3, 2);
                    break;
                case 4:
                    result.appendChars(upceChars, 0, 4);
                    result.append('00000');
                    result.append(upceChars[4]);
                    break;
                default:
                    result.appendChars(upceChars, 0, 5);
                    result.append('0000');
                    result.append(lastChar);
                    break;
            }
            // Only append check digit in conversion if supplied
            if (upce.length >= 8) {
                result.append(upce.charAt(7));
            }
            return result.toString();
        }
    }
    /**
     * The pattern that marks the middle, and end, of a UPC-E pattern.
     * There is no "second half" to a UPC-E barcode.
     */
    UPCEReader.MIDDLE_END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);
    // For an UPC-E barcode, the final digit is represented by the parities used
    // to encode the middle six digits, according to the table below.
    //
    //                Parity of next 6 digits
    //    Digit   0     1     2     3     4     5
    //       0    Even   Even  Even Odd  Odd   Odd
    //       1    Even   Even  Odd  Even Odd   Odd
    //       2    Even   Even  Odd  Odd  Even  Odd
    //       3    Even   Even  Odd  Odd  Odd   Even
    //       4    Even   Odd   Even Even Odd   Odd
    //       5    Even   Odd   Odd  Even Even  Odd
    //       6    Even   Odd   Odd  Odd  Even  Even
    //       7    Even   Odd   Even Odd  Even  Odd
    //       8    Even   Odd   Even Odd  Odd   Even
    //       9    Even   Odd   Odd  Even Odd   Even
    //
    // The encoding is represented by the following array, which is a bit pattern
    // using Odd = 0 and Even = 1. For example, 5 is represented by:
    //
    //              Odd Even Even Odd Odd Even
    // in binary:
    //                0    1    1   0   0    1   == 0x19
    //
    /**
     * See {@link #L_AND_G_PATTERNS}; these values similarly represent patterns of
     * even-odd parity encodings of digits that imply both the number system (0 or 1)
     * used, and the check digit.
     */
    UPCEReader.NUMSYS_AND_CHECK_DIGIT_PATTERNS = [
        Int32Array.from([0x38, 0x34, 0x32, 0x31, 0x2C, 0x26, 0x23, 0x2A, 0x29, 0x25]),
        Int32Array.from([0x07, 0x0B, 0x0D, 0x0E, 0x13, 0x19, 0x1C, 0x15, 0x16, 0x1]),
    ];

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>A reader that can read all available UPC/EAN formats. If a caller wants to try to
     * read all such formats, it is most efficient to use this implementation rather than invoke
     * individual readers.</p>
     *
     * @author Sean Owen
     */
    class MultiFormatUPCEANReader extends OneDReader {
        constructor(hints) {
            super();
            let possibleFormats = hints == null ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
            let readers = [];
            if (possibleFormats != null) {
                if (possibleFormats.indexOf(BarcodeFormat$1.EAN_13) > -1) {
                    readers.push(new EAN13Reader());
                }
                if (possibleFormats.indexOf(BarcodeFormat$1.UPC_A) > -1) {
                    readers.push(new UPCAReader());
                }
                if (possibleFormats.indexOf(BarcodeFormat$1.EAN_8) > -1) {
                    readers.push(new EAN8Reader());
                }
                if (possibleFormats.indexOf(BarcodeFormat$1.UPC_E) > -1) {
                    readers.push(new UPCEReader());
                }
            }
            if (readers.length === 0) {
                readers.push(new EAN13Reader());
                readers.push(new UPCAReader());
                readers.push(new EAN8Reader());
                readers.push(new UPCEReader());
            }
            this.readers = readers;
        }
        decodeRow(rowNumber, row, hints) {
            for (let reader of this.readers) {
                try {
                    // const result: Result = reader.decodeRow(rowNumber, row, startGuardPattern, hints);
                    const result = reader.decodeRow(rowNumber, row, hints);
                    // Special case: a 12-digit code encoded in UPC-A is identical to a "0"
                    // followed by those 12 digits encoded as EAN-13. Each will recognize such a code,
                    // UPC-A as a 12-digit string and EAN-13 as a 13-digit string starting with "0".
                    // Individually these are correct and their readers will both read such a code
                    // and correctly call it EAN-13, or UPC-A, respectively.
                    //
                    // In this case, if we've been looking for both types, we'd like to call it
                    // a UPC-A code. But for efficiency we only run the EAN-13 decoder to also read
                    // UPC-A. So we special case it here, and convert an EAN-13 result to a UPC-A
                    // result if appropriate.
                    //
                    // But, don't return UPC-A if UPC-A was not a requested format!
                    const ean13MayBeUPCA = result.getBarcodeFormat() === BarcodeFormat$1.EAN_13 &&
                        result.getText().charAt(0) === '0';
                    // @SuppressWarnings("unchecked")
                    const possibleFormats = hints == null ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
                    const canReturnUPCA = possibleFormats == null || possibleFormats.includes(BarcodeFormat$1.UPC_A);
                    if (ean13MayBeUPCA && canReturnUPCA) {
                        const rawBytes = result.getRawBytes();
                        // Transfer the metadata across
                        const resultUPCA = new Result(result.getText().substring(1), rawBytes, (rawBytes ? rawBytes.length : null), result.getResultPoints(), BarcodeFormat$1.UPC_A);
                        resultUPCA.putAllMetadata(result.getResultMetadata());
                        return resultUPCA;
                    }
                    return result;
                }
                catch (err) {
                    // continue;
                }
            }
            throw new NotFoundException();
        }
        reset() {
            for (let reader of this.readers) {
                reader.reset();
            }
        }
    }

    // import Integer from '../../util/Integer';
    // import Float from '../../util/Float';
    class AbstractRSSReader extends OneDReader {
        constructor() {
            super();
            this.decodeFinderCounters = new Int32Array(4);
            this.dataCharacterCounters = new Int32Array(8);
            this.oddRoundingErrors = new Array(4);
            this.evenRoundingErrors = new Array(4);
            this.oddCounts = new Array(this.dataCharacterCounters.length / 2);
            this.evenCounts = new Array(this.dataCharacterCounters.length / 2);
        }
        getDecodeFinderCounters() {
            return this.decodeFinderCounters;
        }
        getDataCharacterCounters() {
            return this.dataCharacterCounters;
        }
        getOddRoundingErrors() {
            return this.oddRoundingErrors;
        }
        getEvenRoundingErrors() {
            return this.evenRoundingErrors;
        }
        getOddCounts() {
            return this.oddCounts;
        }
        getEvenCounts() {
            return this.evenCounts;
        }
        parseFinderValue(counters, finderPatterns) {
            for (let value = 0; value < finderPatterns.length; value++) {
                if (OneDReader.patternMatchVariance(counters, finderPatterns[value], AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE) < AbstractRSSReader.MAX_AVG_VARIANCE) {
                    return value;
                }
            }
            throw new NotFoundException();
        }
        /**
         * @param array values to sum
         * @return sum of values
         * @deprecated call {@link MathUtils#sum(int[])}
         */
        static count(array) {
            return MathUtils.sum(new Int32Array(array));
        }
        static increment(array, errors) {
            let index = 0;
            let biggestError = errors[0];
            for (let i = 1; i < array.length; i++) {
                if (errors[i] > biggestError) {
                    biggestError = errors[i];
                    index = i;
                }
            }
            array[index]++;
        }
        static decrement(array, errors) {
            let index = 0;
            let biggestError = errors[0];
            for (let i = 1; i < array.length; i++) {
                if (errors[i] < biggestError) {
                    biggestError = errors[i];
                    index = i;
                }
            }
            array[index]--;
        }
        static isFinderPattern(counters) {
            let firstTwoSum = counters[0] + counters[1];
            let sum = firstTwoSum + counters[2] + counters[3];
            let ratio = firstTwoSum / sum;
            if (ratio >= AbstractRSSReader.MIN_FINDER_PATTERN_RATIO && ratio <= AbstractRSSReader.MAX_FINDER_PATTERN_RATIO) {
                // passes ratio test in spec, but see if the counts are unreasonable
                let minCounter = Number.MAX_SAFE_INTEGER;
                let maxCounter = Number.MIN_SAFE_INTEGER;
                for (let counter of counters) {
                    if (counter > maxCounter) {
                        maxCounter = counter;
                    }
                    if (counter < minCounter) {
                        minCounter = counter;
                    }
                }
                return maxCounter < 10 * minCounter;
            }
            return false;
        }
    }
    AbstractRSSReader.MAX_AVG_VARIANCE = 0.2;
    AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE = 0.45;
    AbstractRSSReader.MIN_FINDER_PATTERN_RATIO = 9.5 / 12.0;
    AbstractRSSReader.MAX_FINDER_PATTERN_RATIO = 12.5 / 14.0;

    class DataCharacter {
        constructor(value, checksumPortion) {
            this.value = value;
            this.checksumPortion = checksumPortion;
        }
        getValue() {
            return this.value;
        }
        getChecksumPortion() {
            return this.checksumPortion;
        }
        toString() {
            return this.value + '(' + this.checksumPortion + ')';
        }
        equals(o) {
            if (!(o instanceof DataCharacter)) {
                return false;
            }
            const that = o;
            return this.value === that.value && this.checksumPortion === that.checksumPortion;
        }
        hashCode() {
            return this.value ^ this.checksumPortion;
        }
    }

    class FinderPattern {
        constructor(value, startEnd, start, end, rowNumber) {
            this.value = value;
            this.startEnd = startEnd;
            this.value = value;
            this.startEnd = startEnd;
            this.resultPoints = new Array();
            this.resultPoints.push(new ResultPoint(start, rowNumber));
            this.resultPoints.push(new ResultPoint(end, rowNumber));
        }
        getValue() {
            return this.value;
        }
        getStartEnd() {
            return this.startEnd;
        }
        getResultPoints() {
            return this.resultPoints;
        }
        equals(o) {
            if (!(o instanceof FinderPattern)) {
                return false;
            }
            const that = o;
            return this.value === that.value;
        }
        hashCode() {
            return this.value;
        }
    }

    /**
     * RSS util functions.
     */
    class RSSUtils {
        constructor() { }
        static getRSSvalue(widths, maxWidth, noNarrow) {
            let n = 0;
            for (let width of widths) {
                n += width;
            }
            let val = 0;
            let narrowMask = 0;
            let elements = widths.length;
            for (let bar = 0; bar < elements - 1; bar++) {
                let elmWidth;
                for (elmWidth = 1, narrowMask |= 1 << bar; elmWidth < widths[bar]; elmWidth++, narrowMask &= ~(1 << bar)) {
                    let subVal = RSSUtils.combins(n - elmWidth - 1, elements - bar - 2);
                    if (noNarrow && (narrowMask === 0) && (n - elmWidth - (elements - bar - 1) >= elements - bar - 1)) {
                        subVal -= RSSUtils.combins(n - elmWidth - (elements - bar), elements - bar - 2);
                    }
                    if (elements - bar - 1 > 1) {
                        let lessVal = 0;
                        for (let mxwElement = n - elmWidth - (elements - bar - 2); mxwElement > maxWidth; mxwElement--) {
                            lessVal += RSSUtils.combins(n - elmWidth - mxwElement - 1, elements - bar - 3);
                        }
                        subVal -= lessVal * (elements - 1 - bar);
                    }
                    else if (n - elmWidth > maxWidth) {
                        subVal--;
                    }
                    val += subVal;
                }
                n -= elmWidth;
            }
            return val;
        }
        static combins(n, r) {
            let maxDenom;
            let minDenom;
            if (n - r > r) {
                minDenom = r;
                maxDenom = n - r;
            }
            else {
                minDenom = n - r;
                maxDenom = r;
            }
            let val = 1;
            let j = 1;
            for (let i = n; i > maxDenom; i--) {
                val *= i;
                if (j <= minDenom) {
                    val /= j;
                    j++;
                }
            }
            while ((j <= minDenom)) {
                val /= j;
                j++;
            }
            return val;
        }
    }

    class BitArrayBuilder {
        static buildBitArray(pairs) {
            let charNumber = (pairs.length * 2) - 1;
            if (pairs[pairs.length - 1].getRightChar() == null) {
                charNumber -= 1;
            }
            let size = 12 * charNumber;
            let binary = new BitArray(size);
            let accPos = 0;
            let firstPair = pairs[0];
            let firstValue = firstPair.getRightChar().getValue();
            for (let i = 11; i >= 0; --i) {
                if ((firstValue & (1 << i)) != 0) {
                    binary.set(accPos);
                }
                accPos++;
            }
            for (let i = 1; i < pairs.length; ++i) {
                let currentPair = pairs[i];
                let leftValue = currentPair.getLeftChar().getValue();
                for (let j = 11; j >= 0; --j) {
                    if ((leftValue & (1 << j)) != 0) {
                        binary.set(accPos);
                    }
                    accPos++;
                }
                if (currentPair.getRightChar() != null) {
                    let rightValue = currentPair.getRightChar().getValue();
                    for (let j = 11; j >= 0; --j) {
                        if ((rightValue & (1 << j)) != 0) {
                            binary.set(accPos);
                        }
                        accPos++;
                    }
                }
            }
            return binary;
        }
    }

    class BlockParsedResult {
        constructor(finished, decodedInformation) {
            if (decodedInformation) {
                this.decodedInformation = null;
            }
            else {
                this.finished = finished;
                this.decodedInformation = decodedInformation;
            }
        }
        getDecodedInformation() {
            return this.decodedInformation;
        }
        isFinished() {
            return this.finished;
        }
    }

    class DecodedObject {
        constructor(newPosition) {
            this.newPosition = newPosition;
        }
        getNewPosition() {
            return this.newPosition;
        }
    }

    class DecodedChar extends DecodedObject {
        constructor(newPosition, value) {
            super(newPosition);
            this.value = value;
        }
        getValue() {
            return this.value;
        }
        isFNC1() {
            return this.value === DecodedChar.FNC1;
        }
    }
    DecodedChar.FNC1 = '$';

    class DecodedInformation extends DecodedObject {
        constructor(newPosition, newString, remainingValue) {
            super(newPosition);
            if (remainingValue) {
                this.remaining = true;
                this.remainingValue = this.remainingValue;
            }
            else {
                this.remaining = false;
                this.remainingValue = 0;
            }
            this.newString = newString;
        }
        getNewString() {
            return this.newString;
        }
        isRemaining() {
            return this.remaining;
        }
        getRemainingValue() {
            return this.remainingValue;
        }
    }

    class DecodedNumeric extends DecodedObject {
        constructor(newPosition, firstDigit, secondDigit) {
            super(newPosition);
            if (firstDigit < 0 || firstDigit > 10 || secondDigit < 0 || secondDigit > 10) {
                throw new FormatException();
            }
            this.firstDigit = firstDigit;
            this.secondDigit = secondDigit;
        }
        getFirstDigit() {
            return this.firstDigit;
        }
        getSecondDigit() {
            return this.secondDigit;
        }
        getValue() {
            return this.firstDigit * 10 + this.secondDigit;
        }
        isFirstDigitFNC1() {
            return this.firstDigit === DecodedNumeric.FNC1;
        }
        isSecondDigitFNC1() {
            return this.secondDigit === DecodedNumeric.FNC1;
        }
        isAnyFNC1() {
            return this.firstDigit === DecodedNumeric.FNC1 || this.secondDigit === DecodedNumeric.FNC1;
        }
    }
    DecodedNumeric.FNC1 = 10;

    class FieldParser {
        constructor() {
        }
        static parseFieldsInGeneralPurpose(rawInformation) {
            if (!rawInformation) {
                return null;
            }
            // Processing 2-digit AIs
            if (rawInformation.length < 2) {
                throw new NotFoundException();
            }
            let firstTwoDigits = rawInformation.substring(0, 2);
            for (let dataLength of FieldParser.TWO_DIGIT_DATA_LENGTH) {
                if (dataLength[0] === firstTwoDigits) {
                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
                        return FieldParser.processVariableAI(2, dataLength[2], rawInformation);
                    }
                    return FieldParser.processFixedAI(2, dataLength[1], rawInformation);
                }
            }
            if (rawInformation.length < 3) {
                throw new NotFoundException();
            }
            let firstThreeDigits = rawInformation.substring(0, 3);
            for (let dataLength of FieldParser.THREE_DIGIT_DATA_LENGTH) {
                if (dataLength[0] === firstThreeDigits) {
                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
                        return FieldParser.processVariableAI(3, dataLength[2], rawInformation);
                    }
                    return FieldParser.processFixedAI(3, dataLength[1], rawInformation);
                }
            }
            for (let dataLength of FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH) {
                if (dataLength[0] === firstThreeDigits) {
                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
                        return FieldParser.processVariableAI(4, dataLength[2], rawInformation);
                    }
                    return FieldParser.processFixedAI(4, dataLength[1], rawInformation);
                }
            }
            if (rawInformation.length < 4) {
                throw new NotFoundException();
            }
            let firstFourDigits = rawInformation.substring(0, 4);
            for (let dataLength of FieldParser.FOUR_DIGIT_DATA_LENGTH) {
                if (dataLength[0] === firstFourDigits) {
                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
                        return FieldParser.processVariableAI(4, dataLength[2], rawInformation);
                    }
                    return FieldParser.processFixedAI(4, dataLength[1], rawInformation);
                }
            }
            throw new NotFoundException();
        }
        static processFixedAI(aiSize, fieldSize, rawInformation) {
            if (rawInformation.length < aiSize) {
                throw new NotFoundException();
            }
            let ai = rawInformation.substring(0, aiSize);
            if (rawInformation.length < aiSize + fieldSize) {
                throw new NotFoundException();
            }
            let field = rawInformation.substring(aiSize, aiSize + fieldSize);
            let remaining = rawInformation.substring(aiSize + fieldSize);
            let result = '(' + ai + ')' + field;
            let parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);
            return parsedAI == null ? result : result + parsedAI;
        }
        static processVariableAI(aiSize, variableFieldSize, rawInformation) {
            let ai = rawInformation.substring(0, aiSize);
            let maxSize;
            if (rawInformation.length < aiSize + variableFieldSize) {
                maxSize = rawInformation.length;
            }
            else {
                maxSize = aiSize + variableFieldSize;
            }
            let field = rawInformation.substring(aiSize, maxSize);
            let remaining = rawInformation.substring(maxSize);
            let result = '(' + ai + ')' + field;
            let parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);
            return parsedAI == null ? result : result + parsedAI;
        }
    }
    FieldParser.VARIABLE_LENGTH = [];
    FieldParser.TWO_DIGIT_DATA_LENGTH = [
        ['00', 18],
        ['01', 14],
        ['02', 14],
        ['10', FieldParser.VARIABLE_LENGTH, 20],
        ['11', 6],
        ['12', 6],
        ['13', 6],
        ['15', 6],
        ['17', 6],
        ['20', 2],
        ['21', FieldParser.VARIABLE_LENGTH, 20],
        ['22', FieldParser.VARIABLE_LENGTH, 29],
        ['30', FieldParser.VARIABLE_LENGTH, 8],
        ['37', FieldParser.VARIABLE_LENGTH, 8],
        // internal company codes
        ['90', FieldParser.VARIABLE_LENGTH, 30],
        ['91', FieldParser.VARIABLE_LENGTH, 30],
        ['92', FieldParser.VARIABLE_LENGTH, 30],
        ['93', FieldParser.VARIABLE_LENGTH, 30],
        ['94', FieldParser.VARIABLE_LENGTH, 30],
        ['95', FieldParser.VARIABLE_LENGTH, 30],
        ['96', FieldParser.VARIABLE_LENGTH, 30],
        ['97', FieldParser.VARIABLE_LENGTH, 3],
        ['98', FieldParser.VARIABLE_LENGTH, 30],
        ['99', FieldParser.VARIABLE_LENGTH, 30],
    ];
    FieldParser.THREE_DIGIT_DATA_LENGTH = [
        // Same format as above
        ['240', FieldParser.VARIABLE_LENGTH, 30],
        ['241', FieldParser.VARIABLE_LENGTH, 30],
        ['242', FieldParser.VARIABLE_LENGTH, 6],
        ['250', FieldParser.VARIABLE_LENGTH, 30],
        ['251', FieldParser.VARIABLE_LENGTH, 30],
        ['253', FieldParser.VARIABLE_LENGTH, 17],
        ['254', FieldParser.VARIABLE_LENGTH, 20],
        ['400', FieldParser.VARIABLE_LENGTH, 30],
        ['401', FieldParser.VARIABLE_LENGTH, 30],
        ['402', 17],
        ['403', FieldParser.VARIABLE_LENGTH, 30],
        ['410', 13],
        ['411', 13],
        ['412', 13],
        ['413', 13],
        ['414', 13],
        ['420', FieldParser.VARIABLE_LENGTH, 20],
        ['421', FieldParser.VARIABLE_LENGTH, 15],
        ['422', 3],
        ['423', FieldParser.VARIABLE_LENGTH, 15],
        ['424', 3],
        ['425', 3],
        ['426', 3],
    ];
    FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH = [
        // Same format as above
        ['310', 6],
        ['311', 6],
        ['312', 6],
        ['313', 6],
        ['314', 6],
        ['315', 6],
        ['316', 6],
        ['320', 6],
        ['321', 6],
        ['322', 6],
        ['323', 6],
        ['324', 6],
        ['325', 6],
        ['326', 6],
        ['327', 6],
        ['328', 6],
        ['329', 6],
        ['330', 6],
        ['331', 6],
        ['332', 6],
        ['333', 6],
        ['334', 6],
        ['335', 6],
        ['336', 6],
        ['340', 6],
        ['341', 6],
        ['342', 6],
        ['343', 6],
        ['344', 6],
        ['345', 6],
        ['346', 6],
        ['347', 6],
        ['348', 6],
        ['349', 6],
        ['350', 6],
        ['351', 6],
        ['352', 6],
        ['353', 6],
        ['354', 6],
        ['355', 6],
        ['356', 6],
        ['357', 6],
        ['360', 6],
        ['361', 6],
        ['362', 6],
        ['363', 6],
        ['364', 6],
        ['365', 6],
        ['366', 6],
        ['367', 6],
        ['368', 6],
        ['369', 6],
        ['390', FieldParser.VARIABLE_LENGTH, 15],
        ['391', FieldParser.VARIABLE_LENGTH, 18],
        ['392', FieldParser.VARIABLE_LENGTH, 15],
        ['393', FieldParser.VARIABLE_LENGTH, 18],
        ['703', FieldParser.VARIABLE_LENGTH, 30],
    ];
    FieldParser.FOUR_DIGIT_DATA_LENGTH = [
        // Same format as above
        ['7001', 13],
        ['7002', FieldParser.VARIABLE_LENGTH, 30],
        ['7003', 10],
        ['8001', 14],
        ['8002', FieldParser.VARIABLE_LENGTH, 20],
        ['8003', FieldParser.VARIABLE_LENGTH, 30],
        ['8004', FieldParser.VARIABLE_LENGTH, 30],
        ['8005', 6],
        ['8006', 18],
        ['8007', FieldParser.VARIABLE_LENGTH, 30],
        ['8008', FieldParser.VARIABLE_LENGTH, 12],
        ['8018', 18],
        ['8020', FieldParser.VARIABLE_LENGTH, 25],
        ['8100', 6],
        ['8101', 10],
        ['8102', 2],
        ['8110', FieldParser.VARIABLE_LENGTH, 70],
        ['8200', FieldParser.VARIABLE_LENGTH, 70],
    ];

    class GeneralAppIdDecoder {
        constructor(information) {
            this.buffer = new StringBuilder();
            this.information = information;
        }
        decodeAllCodes(buff, initialPosition) {
            let currentPosition = initialPosition;
            let remaining = null;
            do {
                let info = this.decodeGeneralPurposeField(currentPosition, remaining);
                let parsedFields = FieldParser.parseFieldsInGeneralPurpose(info.getNewString());
                if (parsedFields != null) {
                    buff.append(parsedFields);
                }
                if (info.isRemaining()) {
                    remaining = '' + info.getRemainingValue();
                }
                else {
                    remaining = null;
                }
                if (currentPosition === info.getNewPosition()) { // No step forward!
                    break;
                }
                currentPosition = info.getNewPosition();
            } while (true);
            return buff.toString();
        }
        isStillNumeric(pos) {
            // It's numeric if it still has 7 positions
            // and one of the first 4 bits is "1".
            if (pos + 7 > this.information.getSize()) {
                return pos + 4 <= this.information.getSize();
            }
            for (let i = pos; i < pos + 3; ++i) {
                if (this.information.get(i)) {
                    return true;
                }
            }
            return this.information.get(pos + 3);
        }
        decodeNumeric(pos) {
            if (pos + 7 > this.information.getSize()) {
                let numeric = this.extractNumericValueFromBitArray(pos, 4);
                if (numeric === 0) {
                    return new DecodedNumeric(this.information.getSize(), DecodedNumeric.FNC1, DecodedNumeric.FNC1);
                }
                return new DecodedNumeric(this.information.getSize(), numeric - 1, DecodedNumeric.FNC1);
            }
            let numeric = this.extractNumericValueFromBitArray(pos, 7);
            let digit1 = (numeric - 8) / 11;
            let digit2 = (numeric - 8) % 11;
            return new DecodedNumeric(pos + 7, digit1, digit2);
        }
        extractNumericValueFromBitArray(pos, bits) {
            return GeneralAppIdDecoder.extractNumericValueFromBitArray(this.information, pos, bits);
        }
        static extractNumericValueFromBitArray(information, pos, bits) {
            let value = 0;
            for (let i = 0; i < bits; ++i) {
                if (information.get(pos + i)) {
                    value |= 1 << (bits - i - 1);
                }
            }
            return value;
        }
        decodeGeneralPurposeField(pos, remaining) {
            // this.buffer.setLength(0);
            this.buffer.setLengthToZero();
            if (remaining != null) {
                this.buffer.append(remaining);
            }
            this.current.setPosition(pos);
            let lastDecoded = this.parseBlocks();
            if (lastDecoded != null && lastDecoded.isRemaining()) {
                return new DecodedInformation(this.current.getPosition(), this.buffer.toString(), lastDecoded.getRemainingValue());
            }
            return new DecodedInformation(this.current.getPosition(), this.buffer.toString());
        }
        parseBlocks() {
            let isFinished;
            let result;
            do {
                let initialPosition = this.current.getPosition();
                if (this.current.isAlpha()) {
                    result = this.parseAlphaBlock();
                    isFinished = result.isFinished();
                }
                else if (this.current.isIsoIec646()) {
                    result = this.parseIsoIec646Block();
                    isFinished = result.isFinished();
                }
                else { // it must be numeric
                    result = this.parseNumericBlock();
                    isFinished = result.isFinished();
                }
                let positionChanged = initialPosition !== this.current.getPosition();
                if (!positionChanged && !isFinished) {
                    break;
                }
            } while (!isFinished);
            return result.getDecodedInformation();
        }
        parseNumericBlock() {
            while (this.isStillNumeric(this.current.getPosition())) {
                let numeric = this.decodeNumeric(this.current.getPosition());
                this.current.setPosition(numeric.getNewPosition());
                if (numeric.isFirstDigitFNC1()) {
                    let information;
                    if (numeric.isSecondDigitFNC1()) {
                        information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
                    }
                    else {
                        information = new DecodedInformation(this.current.getPosition(), this.buffer.toString(), numeric.getSecondDigit());
                    }
                    return new BlockParsedResult(true, information);
                }
                this.buffer.append(numeric.getFirstDigit());
                if (numeric.isSecondDigitFNC1()) {
                    let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
                    return new BlockParsedResult(true, information);
                }
                this.buffer.append(numeric.getSecondDigit());
            }
            if (this.isNumericToAlphaNumericLatch(this.current.getPosition())) {
                this.current.setAlpha();
                this.current.incrementPosition(4);
            }
            return new BlockParsedResult(false);
        }
        parseIsoIec646Block() {
            while (this.isStillIsoIec646(this.current.getPosition())) {
                let iso = this.decodeIsoIec646(this.current.getPosition());
                this.current.setPosition(iso.getNewPosition());
                if (iso.isFNC1()) {
                    let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
                    return new BlockParsedResult(true, information);
                }
                this.buffer.append(iso.getValue());
            }
            if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {
                this.current.incrementPosition(3);
                this.current.setNumeric();
            }
            else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {
                if (this.current.getPosition() + 5 < this.information.getSize()) {
                    this.current.incrementPosition(5);
                }
                else {
                    this.current.setPosition(this.information.getSize());
                }
                this.current.setAlpha();
            }
            return new BlockParsedResult(false);
        }
        parseAlphaBlock() {
            while (this.isStillAlpha(this.current.getPosition())) {
                let alpha = this.decodeAlphanumeric(this.current.getPosition());
                this.current.setPosition(alpha.getNewPosition());
                if (alpha.isFNC1()) {
                    let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
                    return new BlockParsedResult(true, information); // end of the char block
                }
                this.buffer.append(alpha.getValue());
            }
            if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {
                this.current.incrementPosition(3);
                this.current.setNumeric();
            }
            else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {
                if (this.current.getPosition() + 5 < this.information.getSize()) {
                    this.current.incrementPosition(5);
                }
                else {
                    this.current.setPosition(this.information.getSize());
                }
                this.current.setIsoIec646();
            }
            return new BlockParsedResult(false);
        }
        isStillIsoIec646(pos) {
            if (pos + 5 > this.information.getSize()) {
                return false;
            }
            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
            if (fiveBitValue >= 5 && fiveBitValue < 16) {
                return true;
            }
            if (pos + 7 > this.information.getSize()) {
                return false;
            }
            let sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);
            if (sevenBitValue >= 64 && sevenBitValue < 116) {
                return true;
            }
            if (pos + 8 > this.information.getSize()) {
                return false;
            }
            let eightBitValue = this.extractNumericValueFromBitArray(pos, 8);
            return eightBitValue >= 232 && eightBitValue < 253;
        }
        decodeIsoIec646(pos) {
            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
            if (fiveBitValue === 15) {
                return new DecodedChar(pos + 5, DecodedChar.FNC1);
            }
            if (fiveBitValue >= 5 && fiveBitValue < 15) {
                return new DecodedChar(pos + 5, ('0' + (fiveBitValue - 5)));
            }
            let sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);
            if (sevenBitValue >= 64 && sevenBitValue < 90) {
                return new DecodedChar(pos + 7, ('' + (sevenBitValue + 1)));
            }
            if (sevenBitValue >= 90 && sevenBitValue < 116) {
                return new DecodedChar(pos + 7, ('' + (sevenBitValue + 7)));
            }
            let eightBitValue = this.extractNumericValueFromBitArray(pos, 8);
            let c;
            switch (eightBitValue) {
                case 232:
                    c = '!';
                    break;
                case 233:
                    c = '"';
                    break;
                case 234:
                    c = '%';
                    break;
                case 235:
                    c = '&';
                    break;
                case 236:
                    c = '\'';
                    break;
                case 237:
                    c = '(';
                    break;
                case 238:
                    c = ')';
                    break;
                case 239:
                    c = '*';
                    break;
                case 240:
                    c = '+';
                    break;
                case 241:
                    c = ',';
                    break;
                case 242:
                    c = '-';
                    break;
                case 243:
                    c = '.';
                    break;
                case 244:
                    c = '/';
                    break;
                case 245:
                    c = ':';
                    break;
                case 246:
                    c = ';';
                    break;
                case 247:
                    c = '<';
                    break;
                case 248:
                    c = '=';
                    break;
                case 249:
                    c = '>';
                    break;
                case 250:
                    c = '?';
                    break;
                case 251:
                    c = '_';
                    break;
                case 252:
                    c = ' ';
                    break;
                default:
                    throw new FormatException();
            }
            return new DecodedChar(pos + 8, c);
        }
        isStillAlpha(pos) {
            if (pos + 5 > this.information.getSize()) {
                return false;
            }
            // We now check if it's a valid 5-bit value (0..9 and FNC1)
            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
            if (fiveBitValue >= 5 && fiveBitValue < 16) {
                return true;
            }
            if (pos + 6 > this.information.getSize()) {
                return false;
            }
            let sixBitValue = this.extractNumericValueFromBitArray(pos, 6);
            return sixBitValue >= 16 && sixBitValue < 63; // 63 not included
        }
        decodeAlphanumeric(pos) {
            let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
            if (fiveBitValue === 15) {
                return new DecodedChar(pos + 5, DecodedChar.FNC1);
            }
            if (fiveBitValue >= 5 && fiveBitValue < 15) {
                return new DecodedChar(pos + 5, ('0' + (fiveBitValue - 5)));
            }
            let sixBitValue = this.extractNumericValueFromBitArray(pos, 6);
            if (sixBitValue >= 32 && sixBitValue < 58) {
                return new DecodedChar(pos + 6, ('' + (sixBitValue + 33)));
            }
            let c;
            switch (sixBitValue) {
                case 58:
                    c = '*';
                    break;
                case 59:
                    c = ',';
                    break;
                case 60:
                    c = '-';
                    break;
                case 61:
                    c = '.';
                    break;
                case 62:
                    c = '/';
                    break;
                default:
                    throw new IllegalStateException('Decoding invalid alphanumeric value: ' + sixBitValue);
            }
            return new DecodedChar(pos + 6, c);
        }
        isAlphaTo646ToAlphaLatch(pos) {
            if (pos + 1 > this.information.getSize()) {
                return false;
            }
            for (let i = 0; i < 5 && i + pos < this.information.getSize(); ++i) {
                if (i === 2) {
                    if (!this.information.get(pos + 2)) {
                        return false;
                    }
                }
                else if (this.information.get(pos + i)) {
                    return false;
                }
            }
            return true;
        }
        isAlphaOr646ToNumericLatch(pos) {
            // Next is alphanumeric if there are 3 positions and they are all zeros
            if (pos + 3 > this.information.getSize()) {
                return false;
            }
            for (let i = pos; i < pos + 3; ++i) {
                if (this.information.get(i)) {
                    return false;
                }
            }
            return true;
        }
        isNumericToAlphaNumericLatch(pos) {
            // Next is alphanumeric if there are 4 positions and they are all zeros, or
            // if there is a subset of this just before the end of the symbol
            if (pos + 1 > this.information.getSize()) {
                return false;
            }
            for (let i = 0; i < 4 && i + pos < this.information.getSize(); ++i) {
                if (this.information.get(pos + i)) {
                    return false;
                }
            }
            return true;
        }
    }

    class AbstractExpandedDecoder {
        constructor(information) {
            this.information = information;
            this.generalDecoder = new GeneralAppIdDecoder(information);
        }
        getInformation() {
            return this.information;
        }
        getGeneralDecoder() {
            return this.generalDecoder;
        }
    }

    class AI01decoder extends AbstractExpandedDecoder {
        constructor(information) {
            super(information);
        }
        encodeCompressedGtin(buf, currentPos) {
            buf.append('(01)');
            let initialPosition = buf.length();
            buf.append('9');
            this.encodeCompressedGtinWithoutAI(buf, currentPos, initialPosition);
        }
        encodeCompressedGtinWithoutAI(buf, currentPos, initialBufferPosition) {
            for (let i = 0; i < 4; ++i) {
                let currentBlock = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos + 10 * i, 10);
                if (currentBlock / 100 === 0) {
                    buf.append('0');
                }
                if (currentBlock / 10 === 0) {
                    buf.append('0');
                }
                buf.append(currentBlock);
            }
            AI01decoder.appendCheckDigit(buf, initialBufferPosition);
        }
        static appendCheckDigit(buf, currentPos) {
            let checkDigit = 0;
            for (let i = 0; i < 13; i++) {
                // let digit = buf.charAt(i + currentPos) - '0';
                // To be checked
                let digit = buf.charAt(i + currentPos).charCodeAt(0) - '0'.charCodeAt(0);
                checkDigit += (i & 0x01) === 0 ? 3 * digit : digit;
            }
            checkDigit = 10 - (checkDigit % 10);
            if (checkDigit === 10) {
                checkDigit = 0;
            }
            buf.append(checkDigit);
        }
    }
    AI01decoder.GTIN_SIZE = 40;

    class AI01AndOtherAIs extends AI01decoder {
        // the second one is the encodation method, and the other two are for the variable length
        constructor(information) {
            super(information);
        }
        parseInformation() {
            let buff = new StringBuilder();
            buff.append('(01)');
            let initialGtinPosition = buff.length();
            let firstGtinDigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01AndOtherAIs.HEADER_SIZE, 4);
            buff.append(firstGtinDigit);
            this.encodeCompressedGtinWithoutAI(buff, AI01AndOtherAIs.HEADER_SIZE + 4, initialGtinPosition);
            return this.getGeneralDecoder().decodeAllCodes(buff, AI01AndOtherAIs.HEADER_SIZE + 44);
        }
    }
    AI01AndOtherAIs.HEADER_SIZE = 1 + 1 + 2; // first bit encodes the linkage flag,

    class AnyAIDecoder extends AbstractExpandedDecoder {
        constructor(information) {
            super(information);
        }
        parseInformation() {
            let buf = new StringBuilder();
            return this.getGeneralDecoder().decodeAllCodes(buf, AnyAIDecoder.HEADER_SIZE);
        }
    }
    AnyAIDecoder.HEADER_SIZE = 2 + 1 + 2;

    class AI01weightDecoder extends AI01decoder {
        constructor(information) {
            super(information);
        }
        encodeCompressedWeight(buf, currentPos, weightSize) {
            let originalWeightNumeric = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, weightSize);
            this.addWeightCode(buf, originalWeightNumeric);
            let weightNumeric = this.checkWeight(originalWeightNumeric);
            let currentDivisor = 100000;
            for (let i = 0; i < 5; ++i) {
                if (weightNumeric / currentDivisor === 0) {
                    buf.append('0');
                }
                currentDivisor /= 10;
            }
            buf.append(weightNumeric);
        }
    }

    class AI013x0xDecoder extends AI01weightDecoder {
        constructor(information) {
            super(information);
        }
        parseInformation() {
            if (this.getInformation().getSize() != AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder.GTIN_SIZE + AI013x0xDecoder.WEIGHT_SIZE) {
                throw new NotFoundException();
            }
            let buf = new StringBuilder();
            this.encodeCompressedGtin(buf, AI013x0xDecoder.HEADER_SIZE);
            this.encodeCompressedWeight(buf, AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder.GTIN_SIZE, AI013x0xDecoder.WEIGHT_SIZE);
            return buf.toString();
        }
    }
    AI013x0xDecoder.HEADER_SIZE = 4 + 1;
    AI013x0xDecoder.WEIGHT_SIZE = 15;

    class AI013103decoder extends AI013x0xDecoder {
        constructor(information) {
            super(information);
        }
        addWeightCode(buf, weight) {
            buf.append('(3103)');
        }
        checkWeight(weight) {
            return weight;
        }
    }

    class AI01320xDecoder extends AI013x0xDecoder {
        constructor(information) {
            super(information);
        }
        addWeightCode(buf, weight) {
            if (weight < 10000) {
                buf.append('(3202)');
            }
            else {
                buf.append('(3203)');
            }
        }
        checkWeight(weight) {
            if (weight < 10000) {
                return weight;
            }
            return weight - 10000;
        }
    }

    class AI01392xDecoder extends AI01decoder {
        constructor(information) {
            super(information);
        }
        parseInformation() {
            if (this.getInformation().getSize() < AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE) {
                throw new NotFoundException();
            }
            let buf = new StringBuilder();
            this.encodeCompressedGtin(buf, AI01392xDecoder.HEADER_SIZE);
            let lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE, AI01392xDecoder.LAST_DIGIT_SIZE);
            buf.append('(392');
            buf.append(lastAIdigit);
            buf.append(')');
            let decodedInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01392xDecoder.LAST_DIGIT_SIZE, null);
            buf.append(decodedInformation.getNewString());
            return buf.toString();
        }
    }
    AI01392xDecoder.HEADER_SIZE = 5 + 1 + 2;
    AI01392xDecoder.LAST_DIGIT_SIZE = 2;

    class AI01393xDecoder extends AI01decoder {
        constructor(information) {
            super(information);
        }
        parseInformation() {
            if (this.getInformation().getSize() < AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE) {
                throw new NotFoundException();
            }
            let buf = new StringBuilder();
            this.encodeCompressedGtin(buf, AI01393xDecoder.HEADER_SIZE);
            let lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE, AI01393xDecoder.LAST_DIGIT_SIZE);
            buf.append('(393');
            buf.append(lastAIdigit);
            buf.append(')');
            let firstThreeDigits = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE, AI01393xDecoder.FIRST_THREE_DIGITS_SIZE);
            if (firstThreeDigits / 100 == 0) {
                buf.append('0');
            }
            if (firstThreeDigits / 10 == 0) {
                buf.append('0');
            }
            buf.append(firstThreeDigits);
            let generalInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE + AI01393xDecoder.FIRST_THREE_DIGITS_SIZE, null);
            buf.append(generalInformation.getNewString());
            return buf.toString();
        }
    }
    AI01393xDecoder.HEADER_SIZE = 5 + 1 + 2;
    AI01393xDecoder.LAST_DIGIT_SIZE = 2;
    AI01393xDecoder.FIRST_THREE_DIGITS_SIZE = 10;

    class AI013x0x1xDecoder extends AI01weightDecoder {
        constructor(information, firstAIdigits, dateCode) {
            super(information);
            this.dateCode = dateCode;
            this.firstAIdigits = firstAIdigits;
        }
        parseInformation() {
            if (this.getInformation().getSize() != AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE + AI013x0x1xDecoder.DATE_SIZE) {
                throw new NotFoundException();
            }
            let buf = new StringBuilder();
            this.encodeCompressedGtin(buf, AI013x0x1xDecoder.HEADER_SIZE);
            this.encodeCompressedWeight(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE, AI013x0x1xDecoder.WEIGHT_SIZE);
            this.encodeCompressedDate(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE);
            return buf.toString();
        }
        encodeCompressedDate(buf, currentPos) {
            let numericDate = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, AI013x0x1xDecoder.DATE_SIZE);
            if (numericDate == 38400) {
                return;
            }
            buf.append('(');
            buf.append(this.dateCode);
            buf.append(')');
            let day = numericDate % 32;
            numericDate /= 32;
            let month = numericDate % 12 + 1;
            numericDate /= 12;
            let year = numericDate;
            if (year / 10 == 0) {
                buf.append('0');
            }
            buf.append(year);
            if (month / 10 == 0) {
                buf.append('0');
            }
            buf.append(month);
            if (day / 10 == 0) {
                buf.append('0');
            }
            buf.append(day);
        }
        addWeightCode(buf, weight) {
            buf.append('(');
            buf.append(this.firstAIdigits);
            buf.append(weight / 100000);
            buf.append(')');
        }
        checkWeight(weight) {
            return weight % 100000;
        }
    }
    AI013x0x1xDecoder.HEADER_SIZE = 7 + 1;
    AI013x0x1xDecoder.WEIGHT_SIZE = 20;
    AI013x0x1xDecoder.DATE_SIZE = 16;

    function createDecoder(information) {
        try {
            if (information.get(1)) {
                return new AI01AndOtherAIs(information);
            }
            if (!information.get(2)) {
                return new AnyAIDecoder(information);
            }
            let fourBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 4);
            switch (fourBitEncodationMethod) {
                case 4: return new AI013103decoder(information);
                case 5: return new AI01320xDecoder(information);
            }
            let fiveBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 5);
            switch (fiveBitEncodationMethod) {
                case 12: return new AI01392xDecoder(information);
                case 13: return new AI01393xDecoder(information);
            }
            let sevenBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 7);
            switch (sevenBitEncodationMethod) {
                case 56: return new AI013x0x1xDecoder(information, '310', '11');
                case 57: return new AI013x0x1xDecoder(information, '320', '11');
                case 58: return new AI013x0x1xDecoder(information, '310', '13');
                case 59: return new AI013x0x1xDecoder(information, '320', '13');
                case 60: return new AI013x0x1xDecoder(information, '310', '15');
                case 61: return new AI013x0x1xDecoder(information, '320', '15');
                case 62: return new AI013x0x1xDecoder(information, '310', '17');
                case 63: return new AI013x0x1xDecoder(information, '320', '17');
            }
        }
        catch (e) {
            console.log(e);
            throw new IllegalStateException('unknown decoder: ' + information);
        }
    }

    class ExpandedPair {
        constructor(leftChar, rightChar, finderPatter, mayBeLast) {
            this.leftchar = leftChar;
            this.rightchar = rightChar;
            this.finderpattern = finderPatter;
            this.maybeLast = mayBeLast;
        }
        mayBeLast() {
            return this.maybeLast;
        }
        getLeftChar() {
            return this.leftchar;
        }
        getRightChar() {
            return this.rightchar;
        }
        getFinderPattern() {
            return this.finderpattern;
        }
        mustBeLast() {
            return this.rightchar == null;
        }
        toString() {
            return '[ ' + this.leftchar + ', ' + this.rightchar + ' : ' + (this.finderpattern == null ? 'null' : this.finderpattern.getValue()) + ' ]';
        }
        static equals(o1, o2) {
            if (!(o1 instanceof ExpandedPair)) {
                return false;
            }
            return ExpandedPair.equalsOrNull(o1.leftchar, o2.leftchar) &&
                ExpandedPair.equalsOrNull(o1.rightchar, o2.rightchar) &&
                ExpandedPair.equalsOrNull(o1.finderpattern, o2.finderpattern);
        }
        static equalsOrNull(o1, o2) {
            return o1 === null ? o2 === null : ExpandedPair.equals(o1, o2);
        }
        hashCode() {
            // return ExpandedPair.hashNotNull(leftChar) ^ hashNotNull(rightChar) ^ hashNotNull(finderPattern);
            let value = this.leftchar.getValue() ^ this.rightchar.getValue() ^ this.finderpattern.getValue();
            return value;
        }
    }

    class ExpandedRow {
        constructor(pairs, rowNumber, wasReversed) {
            this.pairs = pairs;
            this.rowNumber = rowNumber;
            this.wasReversed = wasReversed;
        }
        getPairs() {
            return this.pairs;
        }
        getRowNumber() {
            return this.rowNumber;
        }
        isReversed() {
            return this.wasReversed;
        }
        // check implementation
        isEquivalent(otherPairs) {
            return this.checkEqualitity(this, otherPairs);
        }
        // @Override
        toString() {
            return '{ ' + this.pairs + ' }';
        }
        /**
         * Two rows are equal if they contain the same pairs in the same order.
         */
        // @Override
        // check implementation
        equals(o1, o2) {
            if (!(o1 instanceof ExpandedRow)) {
                return false;
            }
            return this.checkEqualitity(o1, o2) && o1.wasReversed === o2.wasReversed;
        }
        checkEqualitity(pair1, pair2) {
            if (!pair1 || !pair2)
                return;
            let result;
            pair1.forEach((e1, i) => {
                pair2.forEach(e2 => {
                    if (e1.getLeftChar().getValue() === e2.getLeftChar().getValue() && e1.getRightChar().getValue() === e2.getRightChar().getValue() && e1.getFinderPatter().getValue() === e2.getFinderPatter().getValue()) {
                        result = true;
                    }
                });
            });
            return result;
        }
    }

    // import java.util.ArrayList;
    // import java.util.Iterator;
    // import java.util.List;
    // import java.util.Map;
    // import java.util.Collections;
    /** @experimental */
    class RSSExpandedReader extends AbstractRSSReader {
        constructor() {
            super(...arguments);
            this.pairs = new Array(RSSExpandedReader.MAX_PAIRS);
            this.rows = new Array();
            this.startEnd = [2];
        }
        decodeRow(rowNumber, row, hints) {
            // Rows can start with even pattern in case in prev rows there where odd number of patters.
            // So lets try twice
            // this.pairs.clear();
            this.pairs.length = 0;
            this.startFromEven = false;
            try {
                return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));
            }
            catch (e) {
                // OK
                // console.log(e);
            }
            this.pairs.length = 0;
            this.startFromEven = true;
            return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));
        }
        reset() {
            this.pairs.length = 0;
            this.rows.length = 0;
        }
        // Not private for testing
        decodeRow2pairs(rowNumber, row) {
            let done = false;
            while (!done) {
                try {
                    this.pairs.push(this.retrieveNextPair(row, this.pairs, rowNumber));
                }
                catch (error) {
                    if (error instanceof NotFoundException) {
                        if (!this.pairs.length) {
                            throw new NotFoundException();
                        }
                        // exit this loop when retrieveNextPair() fails and throws
                        done = true;
                    }
                }
            }
            // TODO: verify sequence of finder patterns as in checkPairSequence()
            if (this.checkChecksum()) {
                return this.pairs;
            }
            let tryStackedDecode;
            if (this.rows.length) {
                tryStackedDecode = true;
            }
            else {
                tryStackedDecode = false;
            }
            // let tryStackedDecode = !this.rows.isEmpty();
            this.storeRow(rowNumber, false); // TODO: deal with reversed rows
            if (tryStackedDecode) {
                // When the image is 180-rotated, then rows are sorted in wrong direction.
                // Try twice with both the directions.
                let ps = this.checkRowsBoolean(false);
                if (ps != null) {
                    return ps;
                }
                ps = this.checkRowsBoolean(true);
                if (ps != null) {
                    return ps;
                }
            }
            throw new NotFoundException();
        }
        // Need to Verify
        checkRowsBoolean(reverse) {
            // Limit number of rows we are checking
            // We use recursive algorithm with pure complexity and don't want it to take forever
            // Stacked barcode can have up to 11 rows, so 25 seems reasonable enough
            if (this.rows.length > 25) {
                this.rows.length = 0; // We will never have a chance to get result, so clear it
                return null;
            }
            this.pairs.length = 0;
            if (reverse) {
                this.rows = this.rows.reverse();
                // Collections.reverse(this.rows);
            }
            let ps = null;
            try {
                ps = this.checkRows(new Array(), 0);
            }
            catch (e) {
                // OK
                console.log(e);
            }
            if (reverse) {
                this.rows = this.rows.reverse();
                // Collections.reverse(this.rows);
            }
            return ps;
        }
        // Try to construct a valid rows sequence
        // Recursion is used to implement backtracking
        checkRows(collectedRows, currentRow) {
            for (let i = currentRow; i < this.rows.length; i++) {
                let row = this.rows[i];
                this.pairs.length = 0;
                for (let collectedRow of collectedRows) {
                    this.pairs.push(collectedRow.getPairs());
                }
                this.pairs.push(row.getPairs());
                if (!RSSExpandedReader.isValidSequence(this.pairs)) {
                    continue;
                }
                if (this.checkChecksum()) {
                    return this.pairs;
                }
                let rs = new Array(collectedRows);
                rs.push(row);
                try {
                    // Recursion: try to add more rows
                    return this.checkRows(rs, i + 1);
                }
                catch (e) {
                    // We failed, try the next candidate
                    console.log(e);
                }
            }
            throw new NotFoundException();
        }
        // Whether the pairs form a valid find pattern sequence,
        // either complete or a prefix
        static isValidSequence(pairs) {
            for (let sequence of RSSExpandedReader.FINDER_PATTERN_SEQUENCES) {
                if (pairs.length > sequence.length) {
                    continue;
                }
                let stop = true;
                for (let j = 0; j < pairs.length; j++) {
                    if (pairs[j].getFinderPattern().getValue() != sequence[j]) {
                        stop = false;
                        break;
                    }
                }
                if (stop) {
                    return true;
                }
            }
            return false;
        }
        storeRow(rowNumber, wasReversed) {
            // Discard if duplicate above or below; otherwise insert in order by row number.
            let insertPos = 0;
            let prevIsSame = false;
            let nextIsSame = false;
            while (insertPos < this.rows.length) {
                let erow = this.rows[insertPos];
                if (erow.getRowNumber() > rowNumber) {
                    nextIsSame = erow.isEquivalent(this.pairs);
                    break;
                }
                prevIsSame = erow.isEquivalent(this.pairs);
                insertPos++;
            }
            if (nextIsSame || prevIsSame) {
                return;
            }
            // When the row was partially decoded (e.g. 2 pairs found instead of 3),
            // it will prevent us from detecting the barcode.
            // Try to merge partial rows
            // Check whether the row is part of an allready detected row
            if (RSSExpandedReader.isPartialRow(this.pairs, this.rows)) {
                return;
            }
            this.rows.push(insertPos, new ExpandedRow(this.pairs, rowNumber, wasReversed));
            this.removePartialRows(this.pairs, this.rows);
        }
        // Remove all the rows that contains only specified pairs
        removePartialRows(pairs, rows) {
            // for (Iterator<ExpandedRow> iterator = rows.iterator(); iterator.hasNext();) {
            //   ExpandedRow r = iterator.next();
            //   if (r.getPairs().size() == pairs.size()) {
            //     continue;
            //   }
            //   boolean allFound = true;
            //   for (ExpandedPair p : r.getPairs()) {
            //     boolean found = false;
            //     for (ExpandedPair pp : pairs) {
            //       if (p.equals(pp)) {
            //         found = true;
            //         break;
            //       }
            //     }
            //     if (!found) {
            //       allFound = false;
            //       break;
            //     }
            //   }
            //   if (allFound) {
            //     // 'pairs' contains all the pairs from the row 'r'
            //     iterator.remove();
            //   }
            // }
            for (let row of rows) {
                if (row.getPairs().length === pairs.length) {
                    continue;
                }
                for (let p of row.getPairs()) {
                    for (let pp of pairs) {
                        if (ExpandedPair.equals(p, pp)) {
                            break;
                        }
                    }
                }
            }
        }
        // Returns true when one of the rows already contains all the pairs
        static isPartialRow(pairs, rows) {
            for (let r of rows) {
                let allFound = true;
                for (let p of pairs) {
                    let found = false;
                    for (let pp of r.getPairs()) {
                        if (p.equals(pp)) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        allFound = false;
                        break;
                    }
                }
                if (allFound) {
                    // the row 'r' contain all the pairs from 'pairs'
                    return true;
                }
            }
            return false;
        }
        // Only used for unit testing
        getRows() {
            return this.rows;
        }
        // Not private for unit testing
        static constructResult(pairs) {
            let binary = BitArrayBuilder.buildBitArray(pairs);
            let decoder = createDecoder(binary);
            let resultingString = decoder.parseInformation();
            let firstPoints = pairs[0].getFinderPattern().getResultPoints();
            let lastPoints = pairs[pairs.length - 1].getFinderPattern().getResultPoints();
            let points = [firstPoints[0], firstPoints[1], lastPoints[0], lastPoints[1]];
            return new Result(resultingString, null, null, points, BarcodeFormat$1.RSS_EXPANDED, null);
        }
        checkChecksum() {
            let firstPair = this.pairs.get(0);
            let checkCharacter = firstPair.getLeftChar();
            let firstCharacter = firstPair.getRightChar();
            if (firstCharacter == null) {
                return false;
            }
            let checksum = firstCharacter.getChecksumPortion();
            let s = 2;
            for (let i = 1; i < this.pairs.size(); ++i) {
                let currentPair = this.pairs.get(i);
                checksum += currentPair.getLeftChar().getChecksumPortion();
                s++;
                let currentRightChar = currentPair.getRightChar();
                if (currentRightChar != null) {
                    checksum += currentRightChar.getChecksumPortion();
                    s++;
                }
            }
            checksum %= 211;
            let checkCharacterValue = 211 * (s - 4) + checksum;
            return checkCharacterValue == checkCharacter.getValue();
        }
        static getNextSecondBar(row, initialPos) {
            let currentPos;
            if (row.get(initialPos)) {
                currentPos = row.getNextUnset(initialPos);
                currentPos = row.getNextSet(currentPos);
            }
            else {
                currentPos = row.getNextSet(initialPos);
                currentPos = row.getNextUnset(currentPos);
            }
            return currentPos;
        }
        // not private for testing
        retrieveNextPair(row, previousPairs, rowNumber) {
            let isOddPattern = previousPairs.length % 2 == 0;
            if (this.startFromEven) {
                isOddPattern = !isOddPattern;
            }
            let pattern;
            let keepFinding = true;
            let forcedOffset = -1;
            do {
                this.findNextPair(row, previousPairs, forcedOffset);
                pattern = this.parseFoundFinderPattern(row, rowNumber, isOddPattern);
                if (pattern == null) {
                    forcedOffset = RSSExpandedReader.getNextSecondBar(row, this.startEnd[0]);
                }
                else {
                    keepFinding = false;
                }
            } while (keepFinding);
            // When stacked symbol is split over multiple rows, there's no way to guess if this pair can be last or not.
            // boolean mayBeLast = checkPairSequence(previousPairs, pattern);
            let leftChar = this.decodeDataCharacter(row, pattern, isOddPattern, true);
            if (!this.isEmptyPair(previousPairs) && previousPairs[previousPairs.length - 1].mustBeLast()) {
                throw new NotFoundException();
            }
            let rightChar;
            try {
                rightChar = this.decodeDataCharacter(row, pattern, isOddPattern, false);
            }
            catch (e) {
                rightChar = null;
                console.log(e);
            }
            return new ExpandedPair(leftChar, rightChar, pattern, true);
        }
        isEmptyPair(pairs) {
            if (pairs.length === 0) {
                return true;
            }
            return false;
        }
        findNextPair(row, previousPairs, forcedOffset) {
            let counters = this.getDecodeFinderCounters();
            counters[0] = 0;
            counters[1] = 0;
            counters[2] = 0;
            counters[3] = 0;
            let width = row.getSize();
            let rowOffset;
            if (forcedOffset >= 0) {
                rowOffset = forcedOffset;
            }
            else if (this.isEmptyPair(previousPairs)) {
                rowOffset = 0;
            }
            else {
                let lastPair = previousPairs[previousPairs.length - 1];
                rowOffset = lastPair.getFinderPattern().getStartEnd()[1];
            }
            let searchingEvenPair = previousPairs.length % 2 != 0;
            if (this.startFromEven) {
                searchingEvenPair = !searchingEvenPair;
            }
            let isWhite = false;
            while (rowOffset < width) {
                isWhite = !row.get(rowOffset);
                if (!isWhite) {
                    break;
                }
                rowOffset++;
            }
            let counterPosition = 0;
            let patternStart = rowOffset;
            for (let x = rowOffset; x < width; x++) {
                if (row.get(x) != isWhite) {
                    counters[counterPosition]++;
                }
                else {
                    if (counterPosition == 3) {
                        if (searchingEvenPair) {
                            RSSExpandedReader.reverseCounters(counters);
                        }
                        if (RSSExpandedReader.isFinderPattern(counters)) {
                            this.startEnd[0] = patternStart;
                            this.startEnd[1] = x;
                            return;
                        }
                        if (searchingEvenPair) {
                            RSSExpandedReader.reverseCounters(counters);
                        }
                        patternStart += counters[0] + counters[1];
                        counters[0] = counters[2];
                        counters[1] = counters[3];
                        counters[2] = 0;
                        counters[3] = 0;
                        counterPosition--;
                    }
                    else {
                        counterPosition++;
                    }
                    counters[counterPosition] = 1;
                    isWhite = !isWhite;
                }
            }
            throw new NotFoundException();
        }
        static reverseCounters(counters) {
            let length = counters.length;
            for (let i = 0; i < length / 2; ++i) {
                let tmp = counters[i];
                counters[i] = counters[length - i - 1];
                counters[length - i - 1] = tmp;
            }
        }
        parseFoundFinderPattern(row, rowNumber, oddPattern) {
            // Actually we found elements 2-5.
            let firstCounter;
            let start;
            let end;
            if (oddPattern) {
                // If pattern number is odd, we need to locate element 1 *before* the current block.
                let firstElementStart = this.startEnd[0] - 1;
                // Locate element 1
                while (firstElementStart >= 0 && !row.get(firstElementStart)) {
                    firstElementStart--;
                }
                firstElementStart++;
                firstCounter = this.startEnd[0] - firstElementStart;
                start = firstElementStart;
                end = this.startEnd[1];
            }
            else {
                // If pattern number is even, the pattern is reversed, so we need to locate element 1 *after* the current block.
                start = this.startEnd[0];
                end = row.getNextUnset(this.startEnd[1] + 1);
                firstCounter = end - this.startEnd[1];
            }
            // Make 'counters' hold 1-4
            let counters = this.getDecodeFinderCounters();
            System.arraycopy(counters, 0, counters, 1, counters.length - 1);
            counters[0] = firstCounter;
            let value;
            try {
                value = this.parseFinderValue(counters, RSSExpandedReader.FINDER_PATTERNS);
            }
            catch (e) {
                return null;
            }
            // return new FinderPattern(value, new int[] { start, end }, start, end, rowNumber});
            return new FinderPattern(value, [start, end], start, end, rowNumber);
        }
        decodeDataCharacter(row, pattern, isOddPattern, leftChar) {
            let counters = this.getDataCharacterCounters();
            for (let x = 0; x < counters.length; x++) {
                counters[x] = 0;
            }
            if (leftChar) {
                RSSExpandedReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);
            }
            else {
                RSSExpandedReader.recordPattern(row, pattern.getStartEnd()[1], counters);
                // reverse it
                for (let i = 0, j = counters.length - 1; i < j; i++, j--) {
                    let temp = counters[i];
                    counters[i] = counters[j];
                    counters[j] = temp;
                }
            } // counters[] has the pixels of the module
            let numModules = 17; // left and right data characters have all the same length
            let elementWidth = MathUtils.sum(new Int32Array(counters)) / numModules;
            // Sanity check: element width for pattern and the character should match
            let expectedElementWidth = (pattern.getStartEnd()[1] - pattern.getStartEnd()[0]) / 15.0;
            if (Math.abs(elementWidth - expectedElementWidth) / expectedElementWidth > 0.3) {
                throw new NotFoundException();
            }
            let oddCounts = this.getOddCounts();
            let evenCounts = this.getEvenCounts();
            let oddRoundingErrors = this.getOddRoundingErrors();
            let evenRoundingErrors = this.getEvenRoundingErrors();
            for (let i = 0; i < counters.length; i++) {
                let value = 1.0 * counters[i] / elementWidth;
                let count = value + 0.5; // Round
                if (count < 1) {
                    if (value < 0.3) {
                        throw new NotFoundException();
                    }
                    count = 1;
                }
                else if (count > 8) {
                    if (value > 8.7) {
                        throw new NotFoundException();
                    }
                    count = 8;
                }
                let offset = i / 2;
                if ((i & 0x01) == 0) {
                    oddCounts[offset] = count;
                    oddRoundingErrors[offset] = value - count;
                }
                else {
                    evenCounts[offset] = count;
                    evenRoundingErrors[offset] = value - count;
                }
            }
            this.adjustOddEvenCounts(numModules);
            let weightRowNumber = 4 * pattern.getValue() + (isOddPattern ? 0 : 2) + (leftChar ? 0 : 1) - 1;
            let oddSum = 0;
            let oddChecksumPortion = 0;
            for (let i = oddCounts.length - 1; i >= 0; i--) {
                if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {
                    let weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i];
                    oddChecksumPortion += oddCounts[i] * weight;
                }
                oddSum += oddCounts[i];
            }
            let evenChecksumPortion = 0;
            // int evenSum = 0;
            for (let i = evenCounts.length - 1; i >= 0; i--) {
                if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {
                    let weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i + 1];
                    evenChecksumPortion += evenCounts[i] * weight;
                }
                // evenSum += evenCounts[i];
            }
            let checksumPortion = oddChecksumPortion + evenChecksumPortion;
            if ((oddSum & 0x01) != 0 || oddSum > 13 || oddSum < 4) {
                throw new NotFoundException();
            }
            let group = (13 - oddSum) / 2;
            let oddWidest = RSSExpandedReader.SYMBOL_WIDEST[group];
            let evenWidest = 9 - oddWidest;
            let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, true);
            let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, false);
            let tEven = RSSExpandedReader.EVEN_TOTAL_SUBSET[group];
            let gSum = RSSExpandedReader.GSUM[group];
            let value = vOdd * tEven + vEven + gSum;
            return new DataCharacter(value, checksumPortion);
        }
        static isNotA1left(pattern, isOddPattern, leftChar) {
            // A1: pattern.getValue is 0 (A), and it's an oddPattern, and it is a left char
            return !(pattern.getValue() == 0 && isOddPattern && leftChar);
        }
        adjustOddEvenCounts(numModules) {
            let oddSum = MathUtils.sum(new Int32Array(this.getOddCounts()));
            let evenSum = MathUtils.sum(new Int32Array(this.getEvenCounts()));
            let incrementOdd = false;
            let decrementOdd = false;
            if (oddSum > 13) {
                decrementOdd = true;
            }
            else if (oddSum < 4) {
                incrementOdd = true;
            }
            let incrementEven = false;
            let decrementEven = false;
            if (evenSum > 13) {
                decrementEven = true;
            }
            else if (evenSum < 4) {
                incrementEven = true;
            }
            let mismatch = oddSum + evenSum - numModules;
            let oddParityBad = (oddSum & 0x01) == 1;
            let evenParityBad = (evenSum & 0x01) == 0;
            if (mismatch == 1) {
                if (oddParityBad) {
                    if (evenParityBad) {
                        throw new NotFoundException();
                    }
                    decrementOdd = true;
                }
                else {
                    if (!evenParityBad) {
                        throw new NotFoundException();
                    }
                    decrementEven = true;
                }
            }
            else if (mismatch == -1) {
                if (oddParityBad) {
                    if (evenParityBad) {
                        throw new NotFoundException();
                    }
                    incrementOdd = true;
                }
                else {
                    if (!evenParityBad) {
                        throw new NotFoundException();
                    }
                    incrementEven = true;
                }
            }
            else if (mismatch == 0) {
                if (oddParityBad) {
                    if (!evenParityBad) {
                        throw new NotFoundException();
                    }
                    // Both bad
                    if (oddSum < evenSum) {
                        incrementOdd = true;
                        decrementEven = true;
                    }
                    else {
                        decrementOdd = true;
                        incrementEven = true;
                    }
                }
                else {
                    if (evenParityBad) {
                        throw new NotFoundException();
                    }
                    // Nothing to do!
                }
            }
            else {
                throw new NotFoundException();
            }
            if (incrementOdd) {
                if (decrementOdd) {
                    throw new NotFoundException();
                }
                RSSExpandedReader.increment(this.getOddCounts(), this.getOddRoundingErrors());
            }
            if (decrementOdd) {
                RSSExpandedReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());
            }
            if (incrementEven) {
                if (decrementEven) {
                    throw new NotFoundException();
                }
                RSSExpandedReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());
            }
            if (decrementEven) {
                RSSExpandedReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
            }
        }
    }
    RSSExpandedReader.SYMBOL_WIDEST = [7, 5, 4, 3, 1];
    RSSExpandedReader.EVEN_TOTAL_SUBSET = [4, 20, 52, 104, 204];
    RSSExpandedReader.GSUM = [0, 348, 1388, 2948, 3988];
    RSSExpandedReader.FINDER_PATTERNS = [
        Int32Array.from([1, 8, 4, 1]),
        Int32Array.from([3, 6, 4, 1]),
        Int32Array.from([3, 4, 6, 1]),
        Int32Array.from([3, 2, 8, 1]),
        Int32Array.from([2, 6, 5, 1]),
        Int32Array.from([2, 2, 9, 1]) // F
    ];
    RSSExpandedReader.WEIGHTS = [
        [1, 3, 9, 27, 81, 32, 96, 77],
        [20, 60, 180, 118, 143, 7, 21, 63],
        [189, 145, 13, 39, 117, 140, 209, 205],
        [193, 157, 49, 147, 19, 57, 171, 91],
        [62, 186, 136, 197, 169, 85, 44, 132],
        [185, 133, 188, 142, 4, 12, 36, 108],
        [113, 128, 173, 97, 80, 29, 87, 50],
        [150, 28, 84, 41, 123, 158, 52, 156],
        [46, 138, 203, 187, 139, 206, 196, 166],
        [76, 17, 51, 153, 37, 111, 122, 155],
        [43, 129, 176, 106, 107, 110, 119, 146],
        [16, 48, 144, 10, 30, 90, 59, 177],
        [109, 116, 137, 200, 178, 112, 125, 164],
        [70, 210, 208, 202, 184, 130, 179, 115],
        [134, 191, 151, 31, 93, 68, 204, 190],
        [148, 22, 66, 198, 172, 94, 71, 2],
        [6, 18, 54, 162, 64, 192, 154, 40],
        [120, 149, 25, 75, 14, 42, 126, 167],
        [79, 26, 78, 23, 69, 207, 199, 175],
        [103, 98, 83, 38, 114, 131, 182, 124],
        [161, 61, 183, 127, 170, 88, 53, 159],
        [55, 165, 73, 8, 24, 72, 5, 15],
        [45, 135, 194, 160, 58, 174, 100, 89]
    ];
    RSSExpandedReader.FINDER_PAT_A = 0;
    RSSExpandedReader.FINDER_PAT_B = 1;
    RSSExpandedReader.FINDER_PAT_C = 2;
    RSSExpandedReader.FINDER_PAT_D = 3;
    RSSExpandedReader.FINDER_PAT_E = 4;
    RSSExpandedReader.FINDER_PAT_F = 5;
    RSSExpandedReader.FINDER_PATTERN_SEQUENCES = [
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_C],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_F],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_E],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],
    ];
    RSSExpandedReader.MAX_PAIRS = 11;

    class Pair extends DataCharacter {
        constructor(value, checksumPortion, finderPattern) {
            super(value, checksumPortion);
            this.count = 0;
            this.finderPattern = finderPattern;
        }
        getFinderPattern() {
            return this.finderPattern;
        }
        getCount() {
            return this.count;
        }
        incrementCount() {
            this.count++;
        }
    }

    class RSS14Reader extends AbstractRSSReader {
        constructor() {
            super(...arguments);
            this.possibleLeftPairs = [];
            this.possibleRightPairs = [];
        }
        decodeRow(rowNumber, row, hints) {
            const leftPair = this.decodePair(row, false, rowNumber, hints);
            RSS14Reader.addOrTally(this.possibleLeftPairs, leftPair);
            row.reverse();
            let rightPair = this.decodePair(row, true, rowNumber, hints);
            RSS14Reader.addOrTally(this.possibleRightPairs, rightPair);
            row.reverse();
            for (let left of this.possibleLeftPairs) {
                if (left.getCount() > 1) {
                    for (let right of this.possibleRightPairs) {
                        if (right.getCount() > 1 && RSS14Reader.checkChecksum(left, right)) {
                            return RSS14Reader.constructResult(left, right);
                        }
                    }
                }
            }
            throw new NotFoundException();
        }
        static addOrTally(possiblePairs, pair) {
            if (pair == null) {
                return;
            }
            let found = false;
            for (let other of possiblePairs) {
                if (other.getValue() === pair.getValue()) {
                    other.incrementCount();
                    found = true;
                    break;
                }
            }
            if (!found) {
                possiblePairs.push(pair);
            }
        }
        reset() {
            this.possibleLeftPairs.length = 0;
            this.possibleRightPairs.length = 0;
        }
        static constructResult(leftPair, rightPair) {
            let symbolValue = 4537077 * leftPair.getValue() + rightPair.getValue();
            let text = new String(symbolValue).toString();
            let buffer = new StringBuilder();
            for (let i = 13 - text.length; i > 0; i--) {
                buffer.append('0');
            }
            buffer.append(text);
            let checkDigit = 0;
            for (let i = 0; i < 13; i++) {
                let digit = buffer.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);
                checkDigit += ((i & 0x01) === 0) ? 3 * digit : digit;
            }
            checkDigit = 10 - (checkDigit % 10);
            if (checkDigit === 10) {
                checkDigit = 0;
            }
            buffer.append(checkDigit.toString());
            let leftPoints = leftPair.getFinderPattern().getResultPoints();
            let rightPoints = rightPair.getFinderPattern().getResultPoints();
            return new Result(buffer.toString(), null, 0, [leftPoints[0], leftPoints[1], rightPoints[0], rightPoints[1]], BarcodeFormat$1.RSS_14, new Date().getTime());
        }
        static checkChecksum(leftPair, rightPair) {
            let checkValue = (leftPair.getChecksumPortion() + 16 * rightPair.getChecksumPortion()) % 79;
            let targetCheckValue = 9 * leftPair.getFinderPattern().getValue() + rightPair.getFinderPattern().getValue();
            if (targetCheckValue > 72) {
                targetCheckValue--;
            }
            if (targetCheckValue > 8) {
                targetCheckValue--;
            }
            return checkValue === targetCheckValue;
        }
        decodePair(row, right, rowNumber, hints) {
            try {
                let startEnd = this.findFinderPattern(row, right);
                let pattern = this.parseFoundFinderPattern(row, rowNumber, right, startEnd);
                let resultPointCallback = hints == null ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
                if (resultPointCallback != null) {
                    let center = (startEnd[0] + startEnd[1]) / 2.0;
                    if (right) {
                        // row is actually reversed
                        center = row.getSize() - 1 - center;
                    }
                    resultPointCallback.foundPossibleResultPoint(new ResultPoint(center, rowNumber));
                }
                let outside = this.decodeDataCharacter(row, pattern, true);
                let inside = this.decodeDataCharacter(row, pattern, false);
                return new Pair(1597 * outside.getValue() + inside.getValue(), outside.getChecksumPortion() + 4 * inside.getChecksumPortion(), pattern);
            }
            catch (err) {
                return null;
            }
        }
        decodeDataCharacter(row, pattern, outsideChar) {
            let counters = this.getDataCharacterCounters();
            for (let x = 0; x < counters.length; x++) {
                counters[x] = 0;
            }
            if (outsideChar) {
                OneDReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);
            }
            else {
                OneDReader.recordPattern(row, pattern.getStartEnd()[1] + 1, counters);
                // reverse it
                for (let i = 0, j = counters.length - 1; i < j; i++, j--) {
                    let temp = counters[i];
                    counters[i] = counters[j];
                    counters[j] = temp;
                }
            }
            let numModules = outsideChar ? 16 : 15;
            let elementWidth = MathUtils.sum(new Int32Array(counters)) / numModules;
            let oddCounts = this.getOddCounts();
            let evenCounts = this.getEvenCounts();
            let oddRoundingErrors = this.getOddRoundingErrors();
            let evenRoundingErrors = this.getEvenRoundingErrors();
            for (let i = 0; i < counters.length; i++) {
                let value = counters[i] / elementWidth;
                let count = Math.floor(value + 0.5);
                if (count < 1) {
                    count = 1;
                }
                else if (count > 8) {
                    count = 8;
                }
                let offset = Math.floor(i / 2);
                if ((i & 0x01) === 0) {
                    oddCounts[offset] = count;
                    oddRoundingErrors[offset] = value - count;
                }
                else {
                    evenCounts[offset] = count;
                    evenRoundingErrors[offset] = value - count;
                }
            }
            this.adjustOddEvenCounts(outsideChar, numModules);
            let oddSum = 0;
            let oddChecksumPortion = 0;
            for (let i = oddCounts.length - 1; i >= 0; i--) {
                oddChecksumPortion *= 9;
                oddChecksumPortion += oddCounts[i];
                oddSum += oddCounts[i];
            }
            let evenChecksumPortion = 0;
            let evenSum = 0;
            for (let i = evenCounts.length - 1; i >= 0; i--) {
                evenChecksumPortion *= 9;
                evenChecksumPortion += evenCounts[i];
                evenSum += evenCounts[i];
            }
            let checksumPortion = oddChecksumPortion + 3 * evenChecksumPortion;
            if (outsideChar) {
                if ((oddSum & 0x01) !== 0 || oddSum > 12 || oddSum < 4) {
                    throw new NotFoundException();
                }
                let group = (12 - oddSum) / 2;
                let oddWidest = RSS14Reader.OUTSIDE_ODD_WIDEST[group];
                let evenWidest = 9 - oddWidest;
                let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, false);
                let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, true);
                let tEven = RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET[group];
                let gSum = RSS14Reader.OUTSIDE_GSUM[group];
                return new DataCharacter(vOdd * tEven + vEven + gSum, checksumPortion);
            }
            else {
                if ((evenSum & 0x01) !== 0 || evenSum > 10 || evenSum < 4) {
                    throw new NotFoundException();
                }
                let group = (10 - evenSum) / 2;
                let oddWidest = RSS14Reader.INSIDE_ODD_WIDEST[group];
                let evenWidest = 9 - oddWidest;
                let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, true);
                let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, false);
                let tOdd = RSS14Reader.INSIDE_ODD_TOTAL_SUBSET[group];
                let gSum = RSS14Reader.INSIDE_GSUM[group];
                return new DataCharacter(vEven * tOdd + vOdd + gSum, checksumPortion);
            }
        }
        findFinderPattern(row, rightFinderPattern) {
            let counters = this.getDecodeFinderCounters();
            counters[0] = 0;
            counters[1] = 0;
            counters[2] = 0;
            counters[3] = 0;
            let width = row.getSize();
            let isWhite = false;
            let rowOffset = 0;
            while (rowOffset < width) {
                isWhite = !row.get(rowOffset);
                if (rightFinderPattern === isWhite) {
                    // Will encounter white first when searching for right finder pattern
                    break;
                }
                rowOffset++;
            }
            let counterPosition = 0;
            let patternStart = rowOffset;
            for (let x = rowOffset; x < width; x++) {
                if (row.get(x) !== isWhite) {
                    counters[counterPosition]++;
                }
                else {
                    if (counterPosition === 3) {
                        if (AbstractRSSReader.isFinderPattern(counters)) {
                            return [patternStart, x];
                        }
                        patternStart += counters[0] + counters[1];
                        counters[0] = counters[2];
                        counters[1] = counters[3];
                        counters[2] = 0;
                        counters[3] = 0;
                        counterPosition--;
                    }
                    else {
                        counterPosition++;
                    }
                    counters[counterPosition] = 1;
                    isWhite = !isWhite;
                }
            }
            throw new NotFoundException();
        }
        parseFoundFinderPattern(row, rowNumber, right, startEnd) {
            // Actually we found elements 2-5
            let firstIsBlack = row.get(startEnd[0]);
            let firstElementStart = startEnd[0] - 1;
            // Locate element 1
            while (firstElementStart >= 0 && firstIsBlack !== row.get(firstElementStart)) {
                firstElementStart--;
            }
            firstElementStart++;
            const firstCounter = startEnd[0] - firstElementStart;
            // Make 'counters' hold 1-4
            const counters = this.getDecodeFinderCounters();
            const copy = new Int32Array(counters.length);
            System.arraycopy(counters, 0, copy, 1, counters.length - 1);
            copy[0] = firstCounter;
            const value = this.parseFinderValue(copy, RSS14Reader.FINDER_PATTERNS);
            let start = firstElementStart;
            let end = startEnd[1];
            if (right) {
                // row is actually reversed
                start = row.getSize() - 1 - start;
                end = row.getSize() - 1 - end;
            }
            return new FinderPattern(value, [firstElementStart, startEnd[1]], start, end, rowNumber);
        }
        adjustOddEvenCounts(outsideChar, numModules) {
            let oddSum = MathUtils.sum(new Int32Array(this.getOddCounts()));
            let evenSum = MathUtils.sum(new Int32Array(this.getEvenCounts()));
            let incrementOdd = false;
            let decrementOdd = false;
            let incrementEven = false;
            let decrementEven = false;
            if (outsideChar) {
                if (oddSum > 12) {
                    decrementOdd = true;
                }
                else if (oddSum < 4) {
                    incrementOdd = true;
                }
                if (evenSum > 12) {
                    decrementEven = true;
                }
                else if (evenSum < 4) {
                    incrementEven = true;
                }
            }
            else {
                if (oddSum > 11) {
                    decrementOdd = true;
                }
                else if (oddSum < 5) {
                    incrementOdd = true;
                }
                if (evenSum > 10) {
                    decrementEven = true;
                }
                else if (evenSum < 4) {
                    incrementEven = true;
                }
            }
            let mismatch = oddSum + evenSum - numModules;
            let oddParityBad = (oddSum & 0x01) === (outsideChar ? 1 : 0);
            let evenParityBad = (evenSum & 0x01) === 1;
            if (mismatch === 1) {
                if (oddParityBad) {
                    if (evenParityBad) {
                        throw new NotFoundException();
                    }
                    decrementOdd = true;
                }
                else {
                    if (!evenParityBad) {
                        throw new NotFoundException();
                    }
                    decrementEven = true;
                }
            }
            else if (mismatch === -1) {
                if (oddParityBad) {
                    if (evenParityBad) {
                        throw new NotFoundException();
                    }
                    incrementOdd = true;
                }
                else {
                    if (!evenParityBad) {
                        throw new NotFoundException();
                    }
                    incrementEven = true;
                }
            }
            else if (mismatch === 0) {
                if (oddParityBad) {
                    if (!evenParityBad) {
                        throw new NotFoundException();
                    }
                    // Both bad
                    if (oddSum < evenSum) {
                        incrementOdd = true;
                        decrementEven = true;
                    }
                    else {
                        decrementOdd = true;
                        incrementEven = true;
                    }
                }
                else {
                    if (evenParityBad) {
                        throw new NotFoundException();
                    }
                    // Nothing to do!
                }
            }
            else {
                throw new NotFoundException();
            }
            if (incrementOdd) {
                if (decrementOdd) {
                    throw new NotFoundException();
                }
                AbstractRSSReader.increment(this.getOddCounts(), this.getOddRoundingErrors());
            }
            if (decrementOdd) {
                AbstractRSSReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());
            }
            if (incrementEven) {
                if (decrementEven) {
                    throw new NotFoundException();
                }
                AbstractRSSReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());
            }
            if (decrementEven) {
                AbstractRSSReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
            }
        }
    }
    RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET = [1, 10, 34, 70, 126];
    RSS14Reader.INSIDE_ODD_TOTAL_SUBSET = [4, 20, 48, 81];
    RSS14Reader.OUTSIDE_GSUM = [0, 161, 961, 2015, 2715];
    RSS14Reader.INSIDE_GSUM = [0, 336, 1036, 1516];
    RSS14Reader.OUTSIDE_ODD_WIDEST = [8, 6, 4, 3, 1];
    RSS14Reader.INSIDE_ODD_WIDEST = [2, 4, 6, 8];
    RSS14Reader.FINDER_PATTERNS = [
        Int32Array.from([3, 8, 2, 1]),
        Int32Array.from([3, 5, 5, 1]),
        Int32Array.from([3, 3, 7, 1]),
        Int32Array.from([3, 1, 9, 1]),
        Int32Array.from([2, 7, 4, 1]),
        Int32Array.from([2, 5, 6, 1]),
        Int32Array.from([2, 3, 8, 1]),
        Int32Array.from([1, 5, 7, 1]),
        Int32Array.from([1, 3, 9, 1]),
    ];

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * @author Daniel Switkin <dswitkin@google.com>
     * @author Sean Owen
     */
    class MultiFormatOneDReader extends OneDReader {
        constructor(hints) {
            super();
            this.readers = [];
            const possibleFormats = !hints ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
            const useCode39CheckDigit = hints && hints.get(DecodeHintType$1.ASSUME_CODE_39_CHECK_DIGIT) !== undefined;
            if (possibleFormats) {
                if (possibleFormats.includes(BarcodeFormat$1.EAN_13) ||
                    possibleFormats.includes(BarcodeFormat$1.UPC_A) ||
                    possibleFormats.includes(BarcodeFormat$1.EAN_8) ||
                    possibleFormats.includes(BarcodeFormat$1.UPC_E)) {
                    this.readers.push(new MultiFormatUPCEANReader(hints));
                }
                if (possibleFormats.includes(BarcodeFormat$1.CODE_39)) {
                    this.readers.push(new Code39Reader(useCode39CheckDigit));
                }
                // if (possibleFormats.includes(BarcodeFormat.CODE_93)) {
                //    this.readers.push(new Code93Reader());
                // }
                if (possibleFormats.includes(BarcodeFormat$1.CODE_128)) {
                    this.readers.push(new Code128Reader());
                }
                if (possibleFormats.includes(BarcodeFormat$1.ITF)) {
                    this.readers.push(new ITFReader());
                }
                // if (possibleFormats.includes(BarcodeFormat.CODABAR)) {
                //    this.readers.push(new CodaBarReader());
                // }
                if (possibleFormats.includes(BarcodeFormat$1.RSS_14)) {
                    this.readers.push(new RSS14Reader());
                }
                if (possibleFormats.includes(BarcodeFormat$1.RSS_EXPANDED)) {
                    console.warn('RSS Expanded reader IS NOT ready for production yet! use at your own risk.');
                    this.readers.push(new RSSExpandedReader());
                }
            }
            if (this.readers.length === 0) {
                this.readers.push(new MultiFormatUPCEANReader(hints));
                this.readers.push(new Code39Reader());
                // this.readers.push(new CodaBarReader());
                // this.readers.push(new Code93Reader());
                this.readers.push(new MultiFormatUPCEANReader(hints));
                this.readers.push(new Code128Reader());
                this.readers.push(new ITFReader());
                this.readers.push(new RSS14Reader());
                // this.readers.push(new RSSExpandedReader());
            }
        }
        // @Override
        decodeRow(rowNumber, row, hints) {
            for (let i = 0; i < this.readers.length; i++) {
                try {
                    return this.readers[i].decodeRow(rowNumber, row, hints);
                }
                catch (re) {
                    // continue
                }
            }
            throw new NotFoundException();
        }
        // @Override
        reset() {
            this.readers.forEach(reader => reader.reset());
        }
    }

    /**
     * @deprecated Moving to @zxing/browser
     *
     * Barcode reader reader to use from browser.
     */
    class BrowserBarcodeReader extends BrowserCodeReader {
        /**
         * Creates an instance of BrowserBarcodeReader.
         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
         * @param {Map<DecodeHintType, any>} hints
         */
        constructor(timeBetweenScansMillis = 500, hints) {
            super(new MultiFormatOneDReader(hints), timeBetweenScansMillis, hints);
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will
     * use blocks of differing sizes within one version, so, this encapsulates the parameters for
     * each set of blocks. It also holds the number of error-correction codewords per block since it
     * will be the same across all blocks within one version.</p>
     */
    class ECBlocks {
        constructor(ecCodewords, ecBlocks1, ecBlocks2) {
            this.ecCodewords = ecCodewords;
            this.ecBlocks = [ecBlocks1];
            ecBlocks2 && this.ecBlocks.push(ecBlocks2);
        }
        getECCodewords() {
            return this.ecCodewords;
        }
        getECBlocks() {
            return this.ecBlocks;
        }
    }
    /**
     * <p>Encapsulates the parameters for one error-correction block in one symbol version.
     * This includes the number of data codewords, and the number of times a block with these
     * parameters is used consecutively in the Data Matrix code version's format.</p>
     */
    class ECB {
        constructor(count, dataCodewords) {
            this.count = count;
            this.dataCodewords = dataCodewords;
        }
        getCount() {
            return this.count;
        }
        getDataCodewords() {
            return this.dataCodewords;
        }
    }
    /**
     * The Version object encapsulates attributes about a particular
     * size Data Matrix Code.
     *
     * @author bbrown@google.com (Brian Brown)
     */
    class Version {
        constructor(versionNumber, symbolSizeRows, symbolSizeColumns, dataRegionSizeRows, dataRegionSizeColumns, ecBlocks) {
            this.versionNumber = versionNumber;
            this.symbolSizeRows = symbolSizeRows;
            this.symbolSizeColumns = symbolSizeColumns;
            this.dataRegionSizeRows = dataRegionSizeRows;
            this.dataRegionSizeColumns = dataRegionSizeColumns;
            this.ecBlocks = ecBlocks;
            // Calculate the total number of codewords
            let total = 0;
            const ecCodewords = ecBlocks.getECCodewords();
            const ecbArray = ecBlocks.getECBlocks();
            for (let ecBlock of ecbArray) {
                total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
            }
            this.totalCodewords = total;
        }
        getVersionNumber() {
            return this.versionNumber;
        }
        getSymbolSizeRows() {
            return this.symbolSizeRows;
        }
        getSymbolSizeColumns() {
            return this.symbolSizeColumns;
        }
        getDataRegionSizeRows() {
            return this.dataRegionSizeRows;
        }
        getDataRegionSizeColumns() {
            return this.dataRegionSizeColumns;
        }
        getTotalCodewords() {
            return this.totalCodewords;
        }
        getECBlocks() {
            return this.ecBlocks;
        }
        /**
         * <p>Deduces version information from Data Matrix dimensions.</p>
         *
         * @param numRows Number of rows in modules
         * @param numColumns Number of columns in modules
         * @return Version for a Data Matrix Code of those dimensions
         * @throws FormatException if dimensions do correspond to a valid Data Matrix size
         */
        static getVersionForDimensions(numRows, numColumns) {
            if ((numRows & 0x01) !== 0 || (numColumns & 0x01) !== 0) {
                throw new FormatException();
            }
            for (let version of Version.VERSIONS) {
                if (version.symbolSizeRows === numRows && version.symbolSizeColumns === numColumns) {
                    return version;
                }
            }
            throw new FormatException();
        }
        //  @Override
        toString() {
            return '' + this.versionNumber;
        }
        /**
         * See ISO 16022:2006 5.5.1 Table 7
         */
        static buildVersions() {
            return [
                new Version(1, 10, 10, 8, 8, new ECBlocks(5, new ECB(1, 3))),
                new Version(2, 12, 12, 10, 10, new ECBlocks(7, new ECB(1, 5))),
                new Version(3, 14, 14, 12, 12, new ECBlocks(10, new ECB(1, 8))),
                new Version(4, 16, 16, 14, 14, new ECBlocks(12, new ECB(1, 12))),
                new Version(5, 18, 18, 16, 16, new ECBlocks(14, new ECB(1, 18))),
                new Version(6, 20, 20, 18, 18, new ECBlocks(18, new ECB(1, 22))),
                new Version(7, 22, 22, 20, 20, new ECBlocks(20, new ECB(1, 30))),
                new Version(8, 24, 24, 22, 22, new ECBlocks(24, new ECB(1, 36))),
                new Version(9, 26, 26, 24, 24, new ECBlocks(28, new ECB(1, 44))),
                new Version(10, 32, 32, 14, 14, new ECBlocks(36, new ECB(1, 62))),
                new Version(11, 36, 36, 16, 16, new ECBlocks(42, new ECB(1, 86))),
                new Version(12, 40, 40, 18, 18, new ECBlocks(48, new ECB(1, 114))),
                new Version(13, 44, 44, 20, 20, new ECBlocks(56, new ECB(1, 144))),
                new Version(14, 48, 48, 22, 22, new ECBlocks(68, new ECB(1, 174))),
                new Version(15, 52, 52, 24, 24, new ECBlocks(42, new ECB(2, 102))),
                new Version(16, 64, 64, 14, 14, new ECBlocks(56, new ECB(2, 140))),
                new Version(17, 72, 72, 16, 16, new ECBlocks(36, new ECB(4, 92))),
                new Version(18, 80, 80, 18, 18, new ECBlocks(48, new ECB(4, 114))),
                new Version(19, 88, 88, 20, 20, new ECBlocks(56, new ECB(4, 144))),
                new Version(20, 96, 96, 22, 22, new ECBlocks(68, new ECB(4, 174))),
                new Version(21, 104, 104, 24, 24, new ECBlocks(56, new ECB(6, 136))),
                new Version(22, 120, 120, 18, 18, new ECBlocks(68, new ECB(6, 175))),
                new Version(23, 132, 132, 20, 20, new ECBlocks(62, new ECB(8, 163))),
                new Version(24, 144, 144, 22, 22, new ECBlocks(62, new ECB(8, 156), new ECB(2, 155))),
                new Version(25, 8, 18, 6, 16, new ECBlocks(7, new ECB(1, 5))),
                new Version(26, 8, 32, 6, 14, new ECBlocks(11, new ECB(1, 10))),
                new Version(27, 12, 26, 10, 24, new ECBlocks(14, new ECB(1, 16))),
                new Version(28, 12, 36, 10, 16, new ECBlocks(18, new ECB(1, 22))),
                new Version(29, 16, 36, 14, 16, new ECBlocks(24, new ECB(1, 32))),
                new Version(30, 16, 48, 14, 22, new ECBlocks(28, new ECB(1, 49)))
            ];
        }
    }
    Version.VERSIONS = Version.buildVersions();

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * @author bbrown@google.com (Brian Brown)
     */
    class BitMatrixParser {
        /**
         * @param bitMatrix {@link BitMatrix} to parse
         * @throws FormatException if dimension is < 8 or > 144 or not 0 mod 2
         */
        constructor(bitMatrix) {
            const dimension = bitMatrix.getHeight();
            if (dimension < 8 || dimension > 144 || (dimension & 0x01) !== 0) {
                throw new FormatException();
            }
            this.version = BitMatrixParser.readVersion(bitMatrix);
            this.mappingBitMatrix = this.extractDataRegion(bitMatrix);
            this.readMappingMatrix = new BitMatrix(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());
        }
        getVersion() {
            return this.version;
        }
        /**
         * <p>Creates the version object based on the dimension of the original bit matrix from
         * the datamatrix code.</p>
         *
         * <p>See ISO 16022:2006 Table 7 - ECC 200 symbol attributes</p>
         *
         * @param bitMatrix Original {@link BitMatrix} including alignment patterns
         * @return {@link Version} encapsulating the Data Matrix Code's "version"
         * @throws FormatException if the dimensions of the mapping matrix are not valid
         * Data Matrix dimensions.
         */
        static readVersion(bitMatrix) {
            const numRows = bitMatrix.getHeight();
            const numColumns = bitMatrix.getWidth();
            return Version.getVersionForDimensions(numRows, numColumns);
        }
        /**
         * <p>Reads the bits in the {@link BitMatrix} representing the mapping matrix (No alignment patterns)
         * in the correct order in order to reconstitute the codewords bytes contained within the
         * Data Matrix Code.</p>
         *
         * @return bytes encoded within the Data Matrix Code
         * @throws FormatException if the exact number of bytes expected is not read
         */
        readCodewords() {
            const result = new Int8Array(this.version.getTotalCodewords());
            let resultOffset = 0;
            let row = 4;
            let column = 0;
            const numRows = this.mappingBitMatrix.getHeight();
            const numColumns = this.mappingBitMatrix.getWidth();
            let corner1Read = false;
            let corner2Read = false;
            let corner3Read = false;
            let corner4Read = false;
            // Read all of the codewords
            do {
                // Check the four corner cases
                if ((row === numRows) && (column === 0) && !corner1Read) {
                    result[resultOffset++] = this.readCorner1(numRows, numColumns) & 0xff;
                    row -= 2;
                    column += 2;
                    corner1Read = true;
                }
                else if ((row === numRows - 2) && (column === 0) && ((numColumns & 0x03) !== 0) && !corner2Read) {
                    result[resultOffset++] = this.readCorner2(numRows, numColumns) & 0xff;
                    row -= 2;
                    column += 2;
                    corner2Read = true;
                }
                else if ((row === numRows + 4) && (column === 2) && ((numColumns & 0x07) === 0) && !corner3Read) {
                    result[resultOffset++] = this.readCorner3(numRows, numColumns) & 0xff;
                    row -= 2;
                    column += 2;
                    corner3Read = true;
                }
                else if ((row === numRows - 2) && (column === 0) && ((numColumns & 0x07) === 4) && !corner4Read) {
                    result[resultOffset++] = this.readCorner4(numRows, numColumns) & 0xff;
                    row -= 2;
                    column += 2;
                    corner4Read = true;
                }
                else {
                    // Sweep upward diagonally to the right
                    do {
                        if ((row < numRows) && (column >= 0) && !this.readMappingMatrix.get(column, row)) {
                            result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;
                        }
                        row -= 2;
                        column += 2;
                    } while ((row >= 0) && (column < numColumns));
                    row += 1;
                    column += 3;
                    // Sweep downward diagonally to the left
                    do {
                        if ((row >= 0) && (column < numColumns) && !this.readMappingMatrix.get(column, row)) {
                            result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;
                        }
                        row += 2;
                        column -= 2;
                    } while ((row < numRows) && (column >= 0));
                    row += 3;
                    column += 1;
                }
            } while ((row < numRows) || (column < numColumns));
            if (resultOffset !== this.version.getTotalCodewords()) {
                throw new FormatException();
            }
            return result;
        }
        /**
         * <p>Reads a bit of the mapping matrix accounting for boundary wrapping.</p>
         *
         * @param row Row to read in the mapping matrix
         * @param column Column to read in the mapping matrix
         * @param numRows Number of rows in the mapping matrix
         * @param numColumns Number of columns in the mapping matrix
         * @return value of the given bit in the mapping matrix
         */
        readModule(row, column, numRows, numColumns) {
            // Adjust the row and column indices based on boundary wrapping
            if (row < 0) {
                row += numRows;
                column += 4 - ((numRows + 4) & 0x07);
            }
            if (column < 0) {
                column += numColumns;
                row += 4 - ((numColumns + 4) & 0x07);
            }
            this.readMappingMatrix.set(column, row);
            return this.mappingBitMatrix.get(column, row);
        }
        /**
         * <p>Reads the 8 bits of the standard Utah-shaped pattern.</p>
         *
         * <p>See ISO 16022:2006, 5.8.1 Figure 6</p>
         *
         * @param row Current row in the mapping matrix, anchored at the 8th bit (LSB) of the pattern
         * @param column Current column in the mapping matrix, anchored at the 8th bit (LSB) of the pattern
         * @param numRows Number of rows in the mapping matrix
         * @param numColumns Number of columns in the mapping matrix
         * @return byte from the utah shape
         */
        readUtah(row, column, numRows, numColumns) {
            let currentByte = 0;
            if (this.readModule(row - 2, column - 2, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(row - 2, column - 1, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(row - 1, column - 2, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(row - 1, column - 1, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(row - 1, column, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(row, column - 2, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(row, column - 1, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(row, column, numRows, numColumns)) {
                currentByte |= 1;
            }
            return currentByte;
        }
        /**
         * <p>Reads the 8 bits of the special corner condition 1.</p>
         *
         * <p>See ISO 16022:2006, Figure F.3</p>
         *
         * @param numRows Number of rows in the mapping matrix
         * @param numColumns Number of columns in the mapping matrix
         * @return byte from the Corner condition 1
         */
        readCorner1(numRows, numColumns) {
            let currentByte = 0;
            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(numRows - 1, 1, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(numRows - 1, 2, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(2, numColumns - 1, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(3, numColumns - 1, numRows, numColumns)) {
                currentByte |= 1;
            }
            return currentByte;
        }
        /**
         * <p>Reads the 8 bits of the special corner condition 2.</p>
         *
         * <p>See ISO 16022:2006, Figure F.4</p>
         *
         * @param numRows Number of rows in the mapping matrix
         * @param numColumns Number of columns in the mapping matrix
         * @return byte from the Corner condition 2
         */
        readCorner2(numRows, numColumns) {
            let currentByte = 0;
            if (this.readModule(numRows - 3, 0, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(numRows - 2, 0, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 4, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 3, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
                currentByte |= 1;
            }
            return currentByte;
        }
        /**
         * <p>Reads the 8 bits of the special corner condition 3.</p>
         *
         * <p>See ISO 16022:2006, Figure F.5</p>
         *
         * @param numRows Number of rows in the mapping matrix
         * @param numColumns Number of columns in the mapping matrix
         * @return byte from the Corner condition 3
         */
        readCorner3(numRows, numColumns) {
            let currentByte = 0;
            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 3, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(1, numColumns - 3, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(1, numColumns - 2, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
                currentByte |= 1;
            }
            return currentByte;
        }
        /**
         * <p>Reads the 8 bits of the special corner condition 4.</p>
         *
         * <p>See ISO 16022:2006, Figure F.6</p>
         *
         * @param numRows Number of rows in the mapping matrix
         * @param numColumns Number of columns in the mapping matrix
         * @return byte from the Corner condition 4
         */
        readCorner4(numRows, numColumns) {
            let currentByte = 0;
            if (this.readModule(numRows - 3, 0, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(numRows - 2, 0, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(2, numColumns - 1, numRows, numColumns)) {
                currentByte |= 1;
            }
            currentByte <<= 1;
            if (this.readModule(3, numColumns - 1, numRows, numColumns)) {
                currentByte |= 1;
            }
            return currentByte;
        }
        /**
         * <p>Extracts the data region from a {@link BitMatrix} that contains
         * alignment patterns.</p>
         *
         * @param bitMatrix Original {@link BitMatrix} with alignment patterns
         * @return BitMatrix that has the alignment patterns removed
         */
        extractDataRegion(bitMatrix) {
            const symbolSizeRows = this.version.getSymbolSizeRows();
            const symbolSizeColumns = this.version.getSymbolSizeColumns();
            if (bitMatrix.getHeight() !== symbolSizeRows) {
                throw new IllegalArgumentException('Dimension of bitMatrix must match the version size');
            }
            const dataRegionSizeRows = this.version.getDataRegionSizeRows();
            const dataRegionSizeColumns = this.version.getDataRegionSizeColumns();
            const numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;
            const numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;
            const sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;
            const sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;
            const bitMatrixWithoutAlignment = new BitMatrix(sizeDataRegionColumn, sizeDataRegionRow);
            for (let dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow) {
                const dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;
                for (let dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn) {
                    const dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;
                    for (let i = 0; i < dataRegionSizeRows; ++i) {
                        const readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i;
                        const writeRowOffset = dataRegionRowOffset + i;
                        for (let j = 0; j < dataRegionSizeColumns; ++j) {
                            const readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j;
                            if (bitMatrix.get(readColumnOffset, readRowOffset)) {
                                const writeColumnOffset = dataRegionColumnOffset + j;
                                bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);
                            }
                        }
                    }
                }
            }
            return bitMatrixWithoutAlignment;
        }
    }

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Encapsulates a block of data within a Data Matrix Code. Data Matrix Codes may split their data into
     * multiple blocks, each of which is a unit of data and error-correction codewords. Each
     * is represented by an instance of this class.</p>
     *
     * @author bbrown@google.com (Brian Brown)
     */
    class DataBlock {
        constructor(numDataCodewords, codewords) {
            this.numDataCodewords = numDataCodewords;
            this.codewords = codewords;
        }
        /**
         * <p>When Data Matrix Codes use multiple data blocks, they actually interleave the bytes of each of them.
         * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This
         * method will separate the data into original blocks.</p>
         *
         * @param rawCodewords bytes as read directly from the Data Matrix Code
         * @param version version of the Data Matrix Code
         * @return DataBlocks containing original bytes, "de-interleaved" from representation in the
         *         Data Matrix Code
         */
        static getDataBlocks(rawCodewords, version) {
            // Figure out the number and size of data blocks used by this version
            const ecBlocks = version.getECBlocks();
            // First count the total number of data blocks
            let totalBlocks = 0;
            const ecBlockArray = ecBlocks.getECBlocks();
            for (let ecBlock of ecBlockArray) {
                totalBlocks += ecBlock.getCount();
            }
            // Now establish DataBlocks of the appropriate size and number of data codewords
            const result = new Array(totalBlocks);
            let numResultBlocks = 0;
            for (let ecBlock of ecBlockArray) {
                for (let i = 0; i < ecBlock.getCount(); i++) {
                    const numDataCodewords = ecBlock.getDataCodewords();
                    const numBlockCodewords = ecBlocks.getECCodewords() + numDataCodewords;
                    result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));
                }
            }
            // All blocks have the same amount of data, except that the last n
            // (where n may be 0) have 1 less byte. Figure out where these start.
            // TODO(bbrown): There is only one case where there is a difference for Data Matrix for size 144
            const longerBlocksTotalCodewords = result[0].codewords.length;
            // int shorterBlocksTotalCodewords = longerBlocksTotalCodewords - 1;
            const longerBlocksNumDataCodewords = longerBlocksTotalCodewords - ecBlocks.getECCodewords();
            const shorterBlocksNumDataCodewords = longerBlocksNumDataCodewords - 1;
            // The last elements of result may be 1 element shorter for 144 matrix
            // first fill out as many elements as all of them have minus 1
            let rawCodewordsOffset = 0;
            for (let i = 0; i < shorterBlocksNumDataCodewords; i++) {
                for (let j = 0; j < numResultBlocks; j++) {
                    result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];
                }
            }
            // Fill out the last data block in the longer ones
            const specialVersion = version.getVersionNumber() === 24;
            const numLongerBlocks = specialVersion ? 8 : numResultBlocks;
            for (let j = 0; j < numLongerBlocks; j++) {
                result[j].codewords[longerBlocksNumDataCodewords - 1] = rawCodewords[rawCodewordsOffset++];
            }
            // Now add in error correction blocks
            const max = result[0].codewords.length;
            for (let i = longerBlocksNumDataCodewords; i < max; i++) {
                for (let j = 0; j < numResultBlocks; j++) {
                    const jOffset = specialVersion ? (j + 8) % numResultBlocks : j;
                    const iOffset = specialVersion && jOffset > 7 ? i - 1 : i;
                    result[jOffset].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
                }
            }
            if (rawCodewordsOffset !== rawCodewords.length) {
                throw new IllegalArgumentException();
            }
            return result;
        }
        getNumDataCodewords() {
            return this.numDataCodewords;
        }
        getCodewords() {
            return this.codewords;
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>This provides an easy abstraction to read bits at a time from a sequence of bytes, where the
     * number of bits read is not often a multiple of 8.</p>
     *
     * <p>This class is thread-safe but not reentrant -- unless the caller modifies the bytes array
     * it passed in, in which case all bets are off.</p>
     *
     * @author Sean Owen
     */
    class BitSource {
        /**
         * @param bytes bytes from which this will read bits. Bits will be read from the first byte first.
         * Bits are read within a byte from most-significant to least-significant bit.
         */
        constructor(bytes) {
            this.bytes = bytes;
            this.byteOffset = 0;
            this.bitOffset = 0;
        }
        /**
         * @return index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.
         */
        getBitOffset() {
            return this.bitOffset;
        }
        /**
         * @return index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.
         */
        getByteOffset() {
            return this.byteOffset;
        }
        /**
         * @param numBits number of bits to read
         * @return int representing the bits read. The bits will appear as the least-significant
         *         bits of the int
         * @throws IllegalArgumentException if numBits isn't in [1,32] or more than is available
         */
        readBits(numBits /*int*/) {
            if (numBits < 1 || numBits > 32 || numBits > this.available()) {
                throw new IllegalArgumentException('' + numBits);
            }
            let result = 0;
            let bitOffset = this.bitOffset;
            let byteOffset = this.byteOffset;
            const bytes = this.bytes;
            // First, read remainder from current byte
            if (bitOffset > 0) {
                const bitsLeft = 8 - bitOffset;
                const toRead = numBits < bitsLeft ? numBits : bitsLeft;
                const bitsToNotRead = bitsLeft - toRead;
                const mask = (0xFF >> (8 - toRead)) << bitsToNotRead;
                result = (bytes[byteOffset] & mask) >> bitsToNotRead;
                numBits -= toRead;
                bitOffset += toRead;
                if (bitOffset === 8) {
                    bitOffset = 0;
                    byteOffset++;
                }
            }
            // Next read whole bytes
            if (numBits > 0) {
                while (numBits >= 8) {
                    result = (result << 8) | (bytes[byteOffset] & 0xFF);
                    byteOffset++;
                    numBits -= 8;
                }
                // Finally read a partial byte
                if (numBits > 0) {
                    const bitsToNotRead = 8 - numBits;
                    const mask = (0xFF >> bitsToNotRead) << bitsToNotRead;
                    result = (result << numBits) | ((bytes[byteOffset] & mask) >> bitsToNotRead);
                    bitOffset += numBits;
                }
            }
            this.bitOffset = bitOffset;
            this.byteOffset = byteOffset;
            return result;
        }
        /**
         * @return number of bits that can be read successfully
         */
        available() {
            return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
        }
    }

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var Mode;
    (function (Mode) {
        Mode[Mode["PAD_ENCODE"] = 0] = "PAD_ENCODE";
        Mode[Mode["ASCII_ENCODE"] = 1] = "ASCII_ENCODE";
        Mode[Mode["C40_ENCODE"] = 2] = "C40_ENCODE";
        Mode[Mode["TEXT_ENCODE"] = 3] = "TEXT_ENCODE";
        Mode[Mode["ANSIX12_ENCODE"] = 4] = "ANSIX12_ENCODE";
        Mode[Mode["EDIFACT_ENCODE"] = 5] = "EDIFACT_ENCODE";
        Mode[Mode["BASE256_ENCODE"] = 6] = "BASE256_ENCODE";
    })(Mode || (Mode = {}));
    /**
     * <p>Data Matrix Codes can encode text as bits in one of several modes, and can use multiple modes
     * in one Data Matrix Code. This class decodes the bits back into text.</p>
     *
     * <p>See ISO 16022:2006, 5.2.1 - 5.2.9.2</p>
     *
     * @author bbrown@google.com (Brian Brown)
     * @author Sean Owen
     */
    class DecodedBitStreamParser {
        static decode(bytes) {
            const bits = new BitSource(bytes);
            const result = new StringBuilder();
            const resultTrailer = new StringBuilder();
            const byteSegments = new Array();
            let mode = Mode.ASCII_ENCODE;
            do {
                if (mode === Mode.ASCII_ENCODE) {
                    mode = this.decodeAsciiSegment(bits, result, resultTrailer);
                }
                else {
                    switch (mode) {
                        case Mode.C40_ENCODE:
                            this.decodeC40Segment(bits, result);
                            break;
                        case Mode.TEXT_ENCODE:
                            this.decodeTextSegment(bits, result);
                            break;
                        case Mode.ANSIX12_ENCODE:
                            this.decodeAnsiX12Segment(bits, result);
                            break;
                        case Mode.EDIFACT_ENCODE:
                            this.decodeEdifactSegment(bits, result);
                            break;
                        case Mode.BASE256_ENCODE:
                            this.decodeBase256Segment(bits, result, byteSegments);
                            break;
                        default:
                            throw new FormatException();
                    }
                    mode = Mode.ASCII_ENCODE;
                }
            } while (mode !== Mode.PAD_ENCODE && bits.available() > 0);
            if (resultTrailer.length() > 0) {
                result.append(resultTrailer.toString());
            }
            return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, null);
        }
        /**
         * See ISO 16022:2006, 5.2.3 and Annex C, Table C.2
         */
        static decodeAsciiSegment(bits, result, resultTrailer) {
            let upperShift = false;
            do {
                let oneByte = bits.readBits(8);
                if (oneByte === 0) {
                    throw new FormatException();
                }
                else if (oneByte <= 128) { // ASCII data (ASCII value + 1)
                    if (upperShift) {
                        oneByte += 128;
                        // upperShift = false;
                    }
                    result.append(String.fromCharCode(oneByte - 1));
                    return Mode.ASCII_ENCODE;
                }
                else if (oneByte === 129) { // Pad
                    return Mode.PAD_ENCODE;
                }
                else if (oneByte <= 229) { // 2-digit data 00-99 (Numeric Value + 130)
                    const value = oneByte - 130;
                    if (value < 10) { // pad with '0' for single digit values
                        result.append('0');
                    }
                    result.append('' + value);
                }
                else {
                    switch (oneByte) {
                        case 230: // Latch to C40 encodation
                            return Mode.C40_ENCODE;
                        case 231: // Latch to Base 256 encodation
                            return Mode.BASE256_ENCODE;
                        case 232: // FNC1
                            result.append(String.fromCharCode(29)); // translate as ASCII 29
                            break;
                        case 233: // Structured Append
                        case 234: // Reader Programming
                            // Ignore these symbols for now
                            // throw ReaderException.getInstance();
                            break;
                        case 235: // Upper Shift (shift to Extended ASCII)
                            upperShift = true;
                            break;
                        case 236: // 05 Macro
                            result.append('[)>\u001E05\u001D');
                            resultTrailer.insert(0, '\u001E\u0004');
                            break;
                        case 237: // 06 Macro
                            result.append('[)>\u001E06\u001D');
                            resultTrailer.insert(0, '\u001E\u0004');
                            break;
                        case 238: // Latch to ANSI X12 encodation
                            return Mode.ANSIX12_ENCODE;
                        case 239: // Latch to Text encodation
                            return Mode.TEXT_ENCODE;
                        case 240: // Latch to EDIFACT encodation
                            return Mode.EDIFACT_ENCODE;
                        case 241: // ECI Character
                            // TODO(bbrown): I think we need to support ECI
                            // throw ReaderException.getInstance();
                            // Ignore this symbol for now
                            break;
                        default:
                            // Not to be used in ASCII encodation
                            // but work around encoders that end with 254, latch back to ASCII
                            if (oneByte !== 254 || bits.available() !== 0) {
                                throw new FormatException();
                            }
                            break;
                    }
                }
            } while (bits.available() > 0);
            return Mode.ASCII_ENCODE;
        }
        /**
         * See ISO 16022:2006, 5.2.5 and Annex C, Table C.1
         */
        static decodeC40Segment(bits, result) {
            // Three C40 values are encoded in a 16-bit value as
            // (1600 * C1) + (40 * C2) + C3 + 1
            // TODO(bbrown): The Upper Shift with C40 doesn't work in the 4 value scenario all the time
            let upperShift = false;
            const cValues = [];
            let shift = 0;
            do {
                // If there is only one byte left then it will be encoded as ASCII
                if (bits.available() === 8) {
                    return;
                }
                const firstByte = bits.readBits(8);
                if (firstByte === 254) { // Unlatch codeword
                    return;
                }
                this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
                for (let i = 0; i < 3; i++) {
                    const cValue = cValues[i];
                    switch (shift) {
                        case 0:
                            if (cValue < 3) {
                                shift = cValue + 1;
                            }
                            else if (cValue < this.C40_BASIC_SET_CHARS.length) {
                                const c40char = this.C40_BASIC_SET_CHARS[cValue];
                                if (upperShift) {
                                    result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));
                                    upperShift = false;
                                }
                                else {
                                    result.append(c40char);
                                }
                            }
                            else {
                                throw new FormatException();
                            }
                            break;
                        case 1:
                            if (upperShift) {
                                result.append(String.fromCharCode(cValue + 128));
                                upperShift = false;
                            }
                            else {
                                result.append(String.fromCharCode(cValue));
                            }
                            shift = 0;
                            break;
                        case 2:
                            if (cValue < this.C40_SHIFT2_SET_CHARS.length) {
                                const c40char = this.C40_SHIFT2_SET_CHARS[cValue];
                                if (upperShift) {
                                    result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));
                                    upperShift = false;
                                }
                                else {
                                    result.append(c40char);
                                }
                            }
                            else {
                                switch (cValue) {
                                    case 27: // FNC1
                                        result.append(String.fromCharCode(29)); // translate as ASCII 29
                                        break;
                                    case 30: // Upper Shift
                                        upperShift = true;
                                        break;
                                    default:
                                        throw new FormatException();
                                }
                            }
                            shift = 0;
                            break;
                        case 3:
                            if (upperShift) {
                                result.append(String.fromCharCode(cValue + 224));
                                upperShift = false;
                            }
                            else {
                                result.append(String.fromCharCode(cValue + 96));
                            }
                            shift = 0;
                            break;
                        default:
                            throw new FormatException();
                    }
                }
            } while (bits.available() > 0);
        }
        /**
         * See ISO 16022:2006, 5.2.6 and Annex C, Table C.2
         */
        static decodeTextSegment(bits, result) {
            // Three Text values are encoded in a 16-bit value as
            // (1600 * C1) + (40 * C2) + C3 + 1
            // TODO(bbrown): The Upper Shift with Text doesn't work in the 4 value scenario all the time
            let upperShift = false;
            let cValues = [];
            let shift = 0;
            do {
                // If there is only one byte left then it will be encoded as ASCII
                if (bits.available() === 8) {
                    return;
                }
                const firstByte = bits.readBits(8);
                if (firstByte === 254) { // Unlatch codeword
                    return;
                }
                this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
                for (let i = 0; i < 3; i++) {
                    const cValue = cValues[i];
                    switch (shift) {
                        case 0:
                            if (cValue < 3) {
                                shift = cValue + 1;
                            }
                            else if (cValue < this.TEXT_BASIC_SET_CHARS.length) {
                                const textChar = this.TEXT_BASIC_SET_CHARS[cValue];
                                if (upperShift) {
                                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                                    upperShift = false;
                                }
                                else {
                                    result.append(textChar);
                                }
                            }
                            else {
                                throw new FormatException();
                            }
                            break;
                        case 1:
                            if (upperShift) {
                                result.append(String.fromCharCode(cValue + 128));
                                upperShift = false;
                            }
                            else {
                                result.append(String.fromCharCode(cValue));
                            }
                            shift = 0;
                            break;
                        case 2:
                            // Shift 2 for Text is the same encoding as C40
                            if (cValue < this.TEXT_SHIFT2_SET_CHARS.length) {
                                const textChar = this.TEXT_SHIFT2_SET_CHARS[cValue];
                                if (upperShift) {
                                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                                    upperShift = false;
                                }
                                else {
                                    result.append(textChar);
                                }
                            }
                            else {
                                switch (cValue) {
                                    case 27: // FNC1
                                        result.append(String.fromCharCode(29)); // translate as ASCII 29
                                        break;
                                    case 30: // Upper Shift
                                        upperShift = true;
                                        break;
                                    default:
                                        throw new FormatException();
                                }
                            }
                            shift = 0;
                            break;
                        case 3:
                            if (cValue < this.TEXT_SHIFT3_SET_CHARS.length) {
                                const textChar = this.TEXT_SHIFT3_SET_CHARS[cValue];
                                if (upperShift) {
                                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                                    upperShift = false;
                                }
                                else {
                                    result.append(textChar);
                                }
                                shift = 0;
                            }
                            else {
                                throw new FormatException();
                            }
                            break;
                        default:
                            throw new FormatException();
                    }
                }
            } while (bits.available() > 0);
        }
        /**
         * See ISO 16022:2006, 5.2.7
         */
        static decodeAnsiX12Segment(bits, result) {
            // Three ANSI X12 values are encoded in a 16-bit value as
            // (1600 * C1) + (40 * C2) + C3 + 1
            const cValues = [];
            do {
                // If there is only one byte left then it will be encoded as ASCII
                if (bits.available() === 8) {
                    return;
                }
                const firstByte = bits.readBits(8);
                if (firstByte === 254) { // Unlatch codeword
                    return;
                }
                this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
                for (let i = 0; i < 3; i++) {
                    const cValue = cValues[i];
                    switch (cValue) {
                        case 0: // X12 segment terminator <CR>
                            result.append('\r');
                            break;
                        case 1: // X12 segment separator *
                            result.append('*');
                            break;
                        case 2: // X12 sub-element separator >
                            result.append('>');
                            break;
                        case 3: // space
                            result.append(' ');
                            break;
                        default:
                            if (cValue < 14) { // 0 - 9
                                result.append(String.fromCharCode(cValue + 44));
                            }
                            else if (cValue < 40) { // A - Z
                                result.append(String.fromCharCode(cValue + 51));
                            }
                            else {
                                throw new FormatException();
                            }
                            break;
                    }
                }
            } while (bits.available() > 0);
        }
        static parseTwoBytes(firstByte, secondByte, result) {
            let fullBitValue = (firstByte << 8) + secondByte - 1;
            let temp = Math.floor(fullBitValue / 1600);
            result[0] = temp;
            fullBitValue -= temp * 1600;
            temp = Math.floor(fullBitValue / 40);
            result[1] = temp;
            result[2] = fullBitValue - temp * 40;
        }
        /**
         * See ISO 16022:2006, 5.2.8 and Annex C Table C.3
         */
        static decodeEdifactSegment(bits, result) {
            do {
                // If there is only two or less bytes left then it will be encoded as ASCII
                if (bits.available() <= 16) {
                    return;
                }
                for (let i = 0; i < 4; i++) {
                    let edifactValue = bits.readBits(6);
                    // Check for the unlatch character
                    if (edifactValue === 0x1F) { // 011111
                        // Read rest of byte, which should be 0, and stop
                        const bitsLeft = 8 - bits.getBitOffset();
                        if (bitsLeft !== 8) {
                            bits.readBits(bitsLeft);
                        }
                        return;
                    }
                    if ((edifactValue & 0x20) === 0) { // no 1 in the leading (6th) bit
                        edifactValue |= 0x40; // Add a leading 01 to the 6 bit binary value
                    }
                    result.append(String.fromCharCode(edifactValue));
                }
            } while (bits.available() > 0);
        }
        /**
         * See ISO 16022:2006, 5.2.9 and Annex B, B.2
         */
        static decodeBase256Segment(bits, result, byteSegments) {
            // Figure out how long the Base 256 Segment is.
            let codewordPosition = 1 + bits.getByteOffset(); // position is 1-indexed
            const d1 = this.unrandomize255State(bits.readBits(8), codewordPosition++);
            let count;
            if (d1 === 0) { // Read the remainder of the symbol
                count = bits.available() / 8 | 0;
            }
            else if (d1 < 250) {
                count = d1;
            }
            else {
                count = 250 * (d1 - 249) + this.unrandomize255State(bits.readBits(8), codewordPosition++);
            }
            // We're seeing NegativeArraySizeException errors from users.
            if (count < 0) {
                throw new FormatException();
            }
            const bytes = new Uint8Array(count);
            for (let i = 0; i < count; i++) {
                // Have seen this particular error in the wild, such as at
                // http://www.bcgen.com/demo/IDAutomationStreamingDataMatrix.aspx?MODE=3&D=Fred&PFMT=3&PT=F&X=0.3&O=0&LM=0.2
                if (bits.available() < 8) {
                    throw new FormatException();
                }
                bytes[i] = this.unrandomize255State(bits.readBits(8), codewordPosition++);
            }
            byteSegments.push(bytes);
            try {
                result.append(StringEncoding.decode(bytes, StringUtils.ISO88591));
            }
            catch (uee) {
                throw new IllegalStateException('Platform does not support required encoding: ' + uee.message);
            }
        }
        /**
         * See ISO 16022:2006, Annex B, B.2
         */
        static unrandomize255State(randomizedBase256Codeword, base256CodewordPosition) {
            const pseudoRandomNumber = ((149 * base256CodewordPosition) % 255) + 1;
            const tempVariable = randomizedBase256Codeword - pseudoRandomNumber;
            return tempVariable >= 0 ? tempVariable : tempVariable + 256;
        }
    }
    /**
     * See ISO 16022:2006, Annex C Table C.1
     * The C40 Basic Character Set (*'s used for placeholders for the shift values)
     */
    DecodedBitStreamParser.C40_BASIC_SET_CHARS = [
        '*', '*', '*', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
    ];
    DecodedBitStreamParser.C40_SHIFT2_SET_CHARS = [
        '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.',
        '/', ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '^', '_'
    ];
    /**
     * See ISO 16022:2006, Annex C Table C.2
     * The Text Basic Character Set (*'s used for placeholders for the shift values)
     */
    DecodedBitStreamParser.TEXT_BASIC_SET_CHARS = [
        '*', '*', '*', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
    ];
    // Shift 2 for Text is the same encoding as C40
    DecodedBitStreamParser.TEXT_SHIFT2_SET_CHARS = DecodedBitStreamParser.C40_SHIFT2_SET_CHARS;
    DecodedBitStreamParser.TEXT_SHIFT3_SET_CHARS = [
        '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '{', '|', '}', '~', String.fromCharCode(127)
    ];

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>The main class which implements Data Matrix Code decoding -- as opposed to locating and extracting
     * the Data Matrix Code from an image.</p>
     *
     * @author bbrown@google.com (Brian Brown)
     */
    class Decoder$1 {
        constructor() {
            this.rsDecoder = new ReedSolomonDecoder(GenericGF.DATA_MATRIX_FIELD_256);
        }
        /**
         * <p>Decodes a Data Matrix Code represented as a {@link BitMatrix}. A 1 or "true" is taken
         * to mean a black module.</p>
         *
         * @param bits booleans representing white/black Data Matrix Code modules
         * @return text and bytes encoded within the Data Matrix Code
         * @throws FormatException if the Data Matrix Code cannot be decoded
         * @throws ChecksumException if error correction fails
         */
        decode(bits) {
            // Construct a parser and read version, error-correction level
            const parser = new BitMatrixParser(bits);
            const version = parser.getVersion();
            // Read codewords
            const codewords = parser.readCodewords();
            // Separate into data blocks
            const dataBlocks = DataBlock.getDataBlocks(codewords, version);
            // Count total number of data bytes
            let totalBytes = 0;
            for (let db of dataBlocks) {
                totalBytes += db.getNumDataCodewords();
            }
            const resultBytes = new Uint8Array(totalBytes);
            const dataBlocksCount = dataBlocks.length;
            // Error-correct and copy data blocks together into a stream of bytes
            for (let j = 0; j < dataBlocksCount; j++) {
                const dataBlock = dataBlocks[j];
                const codewordBytes = dataBlock.getCodewords();
                const numDataCodewords = dataBlock.getNumDataCodewords();
                this.correctErrors(codewordBytes, numDataCodewords);
                for (let i = 0; i < numDataCodewords; i++) {
                    // De-interlace data blocks.
                    resultBytes[i * dataBlocksCount + j] = codewordBytes[i];
                }
            }
            // Decode the contents of that stream of bytes
            return DecodedBitStreamParser.decode(resultBytes);
        }
        /**
         * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
         * correct the errors in-place using Reed-Solomon error correction.</p>
         *
         * @param codewordBytes data and error correction codewords
         * @param numDataCodewords number of codewords that are data bytes
         * @throws ChecksumException if error correction fails
         */
        correctErrors(codewordBytes, numDataCodewords) {
            // const numCodewords = codewordBytes.length;
            // First read into an array of ints
            const codewordsInts = new Int32Array(codewordBytes);
            // for (let i = 0; i < numCodewords; i++) {
            //   codewordsInts[i] = codewordBytes[i] & 0xFF;
            // }
            try {
                this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
            }
            catch (ignored /* ReedSolomonException */) {
                throw new ChecksumException();
            }
            // Copy back into array of bytes -- only need to worry about the bytes that were data
            // We don't care about errors in the error-correction codewords
            for (let i = 0; i < numDataCodewords; i++) {
                codewordBytes[i] = codewordsInts[i];
            }
        }
    }

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Encapsulates logic that can detect a Data Matrix Code in an image, even if the Data Matrix Code
     * is rotated or skewed, or partially obscured.</p>
     *
     * @author Sean Owen
     */
    class Detector$1 {
        constructor(image) {
            this.image = image;
            this.rectangleDetector = new WhiteRectangleDetector(this.image);
        }
        /**
         * <p>Detects a Data Matrix Code in an image.</p>
         *
         * @return {@link DetectorResult} encapsulating results of detecting a Data Matrix Code
         * @throws NotFoundException if no Data Matrix Code can be found
         */
        detect() {
            const cornerPoints = this.rectangleDetector.detect();
            let points = this.detectSolid1(cornerPoints);
            points = this.detectSolid2(points);
            points[3] = this.correctTopRight(points);
            if (!points[3]) {
                throw new NotFoundException();
            }
            points = this.shiftToModuleCenter(points);
            const topLeft = points[0];
            const bottomLeft = points[1];
            const bottomRight = points[2];
            const topRight = points[3];
            let dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;
            let dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;
            if ((dimensionTop & 0x01) === 1) {
                dimensionTop += 1;
            }
            if ((dimensionRight & 0x01) === 1) {
                dimensionRight += 1;
            }
            if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {
                // The matrix is square
                dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);
            }
            let bits = Detector$1.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);
            return new DetectorResult(bits, [topLeft, bottomLeft, bottomRight, topRight]);
        }
        static shiftPoint(point, to, div) {
            let x = (to.getX() - point.getX()) / (div + 1);
            let y = (to.getY() - point.getY()) / (div + 1);
            return new ResultPoint(point.getX() + x, point.getY() + y);
        }
        static moveAway(point, fromX, fromY) {
            let x = point.getX();
            let y = point.getY();
            if (x < fromX) {
                x -= 1;
            }
            else {
                x += 1;
            }
            if (y < fromY) {
                y -= 1;
            }
            else {
                y += 1;
            }
            return new ResultPoint(x, y);
        }
        /**
         * Detect a solid side which has minimum transition.
         */
        detectSolid1(cornerPoints) {
            // 0  2
            // 1  3
            let pointA = cornerPoints[0];
            let pointB = cornerPoints[1];
            let pointC = cornerPoints[3];
            let pointD = cornerPoints[2];
            let trAB = this.transitionsBetween(pointA, pointB);
            let trBC = this.transitionsBetween(pointB, pointC);
            let trCD = this.transitionsBetween(pointC, pointD);
            let trDA = this.transitionsBetween(pointD, pointA);
            // 0..3
            // :  :
            // 1--2
            let min = trAB;
            let points = [pointD, pointA, pointB, pointC];
            if (min > trBC) {
                min = trBC;
                points[0] = pointA;
                points[1] = pointB;
                points[2] = pointC;
                points[3] = pointD;
            }
            if (min > trCD) {
                min = trCD;
                points[0] = pointB;
                points[1] = pointC;
                points[2] = pointD;
                points[3] = pointA;
            }
            if (min > trDA) {
                points[0] = pointC;
                points[1] = pointD;
                points[2] = pointA;
                points[3] = pointB;
            }
            return points;
        }
        /**
         * Detect a second solid side next to first solid side.
         */
        detectSolid2(points) {
            // A..D
            // :  :
            // B--C
            let pointA = points[0];
            let pointB = points[1];
            let pointC = points[2];
            let pointD = points[3];
            // Transition detection on the edge is not stable.
            // To safely detect, shift the points to the module center.
            let tr = this.transitionsBetween(pointA, pointD);
            let pointBs = Detector$1.shiftPoint(pointB, pointC, (tr + 1) * 4);
            let pointCs = Detector$1.shiftPoint(pointC, pointB, (tr + 1) * 4);
            let trBA = this.transitionsBetween(pointBs, pointA);
            let trCD = this.transitionsBetween(pointCs, pointD);
            // 0..3
            // |  :
            // 1--2
            if (trBA < trCD) {
                // solid sides: A-B-C
                points[0] = pointA;
                points[1] = pointB;
                points[2] = pointC;
                points[3] = pointD;
            }
            else {
                // solid sides: B-C-D
                points[0] = pointB;
                points[1] = pointC;
                points[2] = pointD;
                points[3] = pointA;
            }
            return points;
        }
        /**
         * Calculates the corner position of the white top right module.
         */
        correctTopRight(points) {
            // A..D
            // |  :
            // B--C
            let pointA = points[0];
            let pointB = points[1];
            let pointC = points[2];
            let pointD = points[3];
            // shift points for safe transition detection.
            let trTop = this.transitionsBetween(pointA, pointD);
            let trRight = this.transitionsBetween(pointB, pointD);
            let pointAs = Detector$1.shiftPoint(pointA, pointB, (trRight + 1) * 4);
            let pointCs = Detector$1.shiftPoint(pointC, pointB, (trTop + 1) * 4);
            trTop = this.transitionsBetween(pointAs, pointD);
            trRight = this.transitionsBetween(pointCs, pointD);
            let candidate1 = new ResultPoint(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));
            let candidate2 = new ResultPoint(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));
            if (!this.isValid(candidate1)) {
                if (this.isValid(candidate2)) {
                    return candidate2;
                }
                return null;
            }
            if (!this.isValid(candidate2)) {
                return candidate1;
            }
            let sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);
            let sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);
            if (sumc1 > sumc2) {
                return candidate1;
            }
            else {
                return candidate2;
            }
        }
        /**
         * Shift the edge points to the module center.
         */
        shiftToModuleCenter(points) {
            // A..D
            // |  :
            // B--C
            let pointA = points[0];
            let pointB = points[1];
            let pointC = points[2];
            let pointD = points[3];
            // calculate pseudo dimensions
            let dimH = this.transitionsBetween(pointA, pointD) + 1;
            let dimV = this.transitionsBetween(pointC, pointD) + 1;
            // shift points for safe dimension detection
            let pointAs = Detector$1.shiftPoint(pointA, pointB, dimV * 4);
            let pointCs = Detector$1.shiftPoint(pointC, pointB, dimH * 4);
            //  calculate more precise dimensions
            dimH = this.transitionsBetween(pointAs, pointD) + 1;
            dimV = this.transitionsBetween(pointCs, pointD) + 1;
            if ((dimH & 0x01) === 1) {
                dimH += 1;
            }
            if ((dimV & 0x01) === 1) {
                dimV += 1;
            }
            // WhiteRectangleDetector returns points inside of the rectangle.
            // I want points on the edges.
            let centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;
            let centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;
            pointA = Detector$1.moveAway(pointA, centerX, centerY);
            pointB = Detector$1.moveAway(pointB, centerX, centerY);
            pointC = Detector$1.moveAway(pointC, centerX, centerY);
            pointD = Detector$1.moveAway(pointD, centerX, centerY);
            let pointBs;
            let pointDs;
            // shift points to the center of each modules
            pointAs = Detector$1.shiftPoint(pointA, pointB, dimV * 4);
            pointAs = Detector$1.shiftPoint(pointAs, pointD, dimH * 4);
            pointBs = Detector$1.shiftPoint(pointB, pointA, dimV * 4);
            pointBs = Detector$1.shiftPoint(pointBs, pointC, dimH * 4);
            pointCs = Detector$1.shiftPoint(pointC, pointD, dimV * 4);
            pointCs = Detector$1.shiftPoint(pointCs, pointB, dimH * 4);
            pointDs = Detector$1.shiftPoint(pointD, pointC, dimV * 4);
            pointDs = Detector$1.shiftPoint(pointDs, pointA, dimH * 4);
            return [pointAs, pointBs, pointCs, pointDs];
        }
        isValid(p) {
            return p.getX() >= 0 && p.getX() < this.image.getWidth() && p.getY() > 0 && p.getY() < this.image.getHeight();
        }
        static sampleGrid(image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {
            const sampler = GridSamplerInstance.getInstance();
            return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());
        }
        /**
         * Counts the number of black/white transitions between two points, using something like Bresenham's algorithm.
         */
        transitionsBetween(from, to) {
            // See QR Code Detector, sizeOfBlackWhiteBlackRun()
            let fromX = Math.trunc(from.getX());
            let fromY = Math.trunc(from.getY());
            let toX = Math.trunc(to.getX());
            let toY = Math.trunc(to.getY());
            let steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
            if (steep) {
                let temp = fromX;
                fromX = fromY;
                fromY = temp;
                temp = toX;
                toX = toY;
                toY = temp;
            }
            let dx = Math.abs(toX - fromX);
            let dy = Math.abs(toY - fromY);
            let error = -dx / 2;
            let ystep = fromY < toY ? 1 : -1;
            let xstep = fromX < toX ? 1 : -1;
            let transitions = 0;
            let inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);
            for (let x = fromX, y = fromY; x !== toX; x += xstep) {
                let isBlack = this.image.get(steep ? y : x, steep ? x : y);
                if (isBlack !== inBlack) {
                    transitions++;
                    inBlack = isBlack;
                }
                error += dy;
                if (error > 0) {
                    if (y === toY) {
                        break;
                    }
                    y += ystep;
                    error -= dx;
                }
            }
            return transitions;
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * This implementation can detect and decode Data Matrix codes in an image.
     *
     * @author bbrown@google.com (Brian Brown)
     */
    class DataMatrixReader {
        constructor() {
            this.decoder = new Decoder$1();
        }
        /**
         * Locates and decodes a Data Matrix code in an image.
         *
         * @return a String representing the content encoded by the Data Matrix code
         * @throws NotFoundException if a Data Matrix code cannot be found
         * @throws FormatException if a Data Matrix code cannot be decoded
         * @throws ChecksumException if error correction fails
         */
        // @Override
        // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {
        //   return decode(image, null);
        // }
        // @Override
        decode(image, hints = null) {
            let decoderResult;
            let points;
            if (hints != null && hints.has(DecodeHintType$1.PURE_BARCODE)) {
                const bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());
                decoderResult = this.decoder.decode(bits);
                points = DataMatrixReader.NO_POINTS;
            }
            else {
                const detectorResult = new Detector$1(image.getBlackMatrix()).detect();
                decoderResult = this.decoder.decode(detectorResult.getBits());
                points = detectorResult.getPoints();
            }
            const rawBytes = decoderResult.getRawBytes();
            const result = new Result(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat$1.DATA_MATRIX, System.currentTimeMillis());
            const byteSegments = decoderResult.getByteSegments();
            if (byteSegments != null) {
                result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);
            }
            const ecLevel = decoderResult.getECLevel();
            if (ecLevel != null) {
                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);
            }
            return result;
        }
        // @Override
        reset() {
            // do nothing
        }
        /**
         * This method detects a code in a "pure" image -- that is, pure monochrome image
         * which contains only an unrotated, unskewed, image of a code, with some white border
         * around it. This is a specialized method that works exceptionally fast in this special
         * case.
         *
         * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)
         */
        static extractPureBits(image) {
            const leftTopBlack = image.getTopLeftOnBit();
            const rightBottomBlack = image.getBottomRightOnBit();
            if (leftTopBlack == null || rightBottomBlack == null) {
                throw new NotFoundException();
            }
            const moduleSize = this.moduleSize(leftTopBlack, image);
            let top = leftTopBlack[1];
            const bottom = rightBottomBlack[1];
            let left = leftTopBlack[0];
            const right = rightBottomBlack[0];
            const matrixWidth = (right - left + 1) / moduleSize;
            const matrixHeight = (bottom - top + 1) / moduleSize;
            if (matrixWidth <= 0 || matrixHeight <= 0) {
                throw new NotFoundException();
            }
            // Push in the "border" by half the module width so that we start
            // sampling in the middle of the module. Just in case the image is a
            // little off, this will help recover.
            const nudge = moduleSize / 2;
            top += nudge;
            left += nudge;
            // Now just read off the bits
            const bits = new BitMatrix(matrixWidth, matrixHeight);
            for (let y = 0; y < matrixHeight; y++) {
                const iOffset = top + y * moduleSize;
                for (let x = 0; x < matrixWidth; x++) {
                    if (image.get(left + x * moduleSize, iOffset)) {
                        bits.set(x, y);
                    }
                }
            }
            return bits;
        }
        static moduleSize(leftTopBlack, image) {
            const width = image.getWidth();
            let x = leftTopBlack[0];
            const y = leftTopBlack[1];
            while (x < width && image.get(x, y)) {
                x++;
            }
            if (x === width) {
                throw new NotFoundException();
            }
            const moduleSize = x - leftTopBlack[0];
            if (moduleSize === 0) {
                throw new NotFoundException();
            }
            return moduleSize;
        }
    }
    DataMatrixReader.NO_POINTS = [];

    /**
     * @deprecated Moving to @zxing/browser
     *
     * QR Code reader to use from browser.
     */
    class BrowserDatamatrixCodeReader extends BrowserCodeReader {
        /**
         * Creates an instance of BrowserQRCodeReader.
         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
         */
        constructor(timeBetweenScansMillis = 500) {
            super(new DataMatrixReader(), timeBetweenScansMillis);
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var ErrorCorrectionLevelValues;
    (function (ErrorCorrectionLevelValues) {
        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["L"] = 0] = "L";
        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["M"] = 1] = "M";
        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["Q"] = 2] = "Q";
        ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["H"] = 3] = "H";
    })(ErrorCorrectionLevelValues || (ErrorCorrectionLevelValues = {}));
    /**
     * <p>See ISO 18004:2006, 6.5.1. This enum encapsulates the four error correction levels
     * defined by the QR code standard.</p>
     *
     * @author Sean Owen
     */
    class ErrorCorrectionLevel {
        constructor(value, stringValue, bits /*int*/) {
            this.value = value;
            this.stringValue = stringValue;
            this.bits = bits;
            ErrorCorrectionLevel.FOR_BITS.set(bits, this);
            ErrorCorrectionLevel.FOR_VALUE.set(value, this);
        }
        getValue() {
            return this.value;
        }
        getBits() {
            return this.bits;
        }
        static fromString(s) {
            switch (s) {
                case 'L': return ErrorCorrectionLevel.L;
                case 'M': return ErrorCorrectionLevel.M;
                case 'Q': return ErrorCorrectionLevel.Q;
                case 'H': return ErrorCorrectionLevel.H;
                default: throw new ArgumentException(s + 'not available');
            }
        }
        toString() {
            return this.stringValue;
        }
        equals(o) {
            if (!(o instanceof ErrorCorrectionLevel)) {
                return false;
            }
            const other = o;
            return this.value === other.value;
        }
        /**
         * @param bits int containing the two bits encoding a QR Code's error correction level
         * @return ErrorCorrectionLevel representing the encoded error correction level
         */
        static forBits(bits /*int*/) {
            if (bits < 0 || bits >= ErrorCorrectionLevel.FOR_BITS.size) {
                throw new IllegalArgumentException();
            }
            return ErrorCorrectionLevel.FOR_BITS.get(bits);
        }
    }
    ErrorCorrectionLevel.FOR_BITS = new Map();
    ErrorCorrectionLevel.FOR_VALUE = new Map();
    /** L = ~7% correction */
    ErrorCorrectionLevel.L = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.L, 'L', 0x01);
    /** M = ~15% correction */
    ErrorCorrectionLevel.M = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.M, 'M', 0x00);
    /** Q = ~25% correction */
    ErrorCorrectionLevel.Q = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.Q, 'Q', 0x03);
    /** H = ~30% correction */
    ErrorCorrectionLevel.H = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.H, 'H', 0x02);

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Encapsulates a QR Code's format information, including the data mask used and
     * error correction level.</p>
     *
     * @author Sean Owen
     * @see DataMask
     * @see ErrorCorrectionLevel
     */
    class FormatInformation {
        constructor(formatInfo /*int*/) {
            // Bits 3,4
            this.errorCorrectionLevel = ErrorCorrectionLevel.forBits((formatInfo >> 3) & 0x03);
            // Bottom 3 bits
            this.dataMask = /*(byte) */ (formatInfo & 0x07);
        }
        static numBitsDiffering(a /*int*/, b /*int*/) {
            return Integer.bitCount(a ^ b);
        }
        /**
         * @param maskedFormatInfo1 format info indicator, with mask still applied
         * @param maskedFormatInfo2 second copy of same info; both are checked at the same time
         *  to establish best match
         * @return information about the format it specifies, or {@code null}
         *  if doesn't seem to match any known pattern
         */
        static decodeFormatInformation(maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {
            const formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);
            if (formatInfo !== null) {
                return formatInfo;
            }
            // Should return null, but, some QR codes apparently
            // do not mask this info. Try again by actually masking the pattern
            // first
            return FormatInformation.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation.FORMAT_INFO_MASK_QR);
        }
        static doDecodeFormatInformation(maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {
            // Find the int in FORMAT_INFO_DECODE_LOOKUP with fewest bits differing
            let bestDifference = Number.MAX_SAFE_INTEGER;
            let bestFormatInfo = 0;
            for (const decodeInfo of FormatInformation.FORMAT_INFO_DECODE_LOOKUP) {
                const targetInfo = decodeInfo[0];
                if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {
                    // Found an exact match
                    return new FormatInformation(decodeInfo[1]);
                }
                let bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo1, targetInfo);
                if (bitsDifference < bestDifference) {
                    bestFormatInfo = decodeInfo[1];
                    bestDifference = bitsDifference;
                }
                if (maskedFormatInfo1 !== maskedFormatInfo2) {
                    // also try the other option
                    bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo2, targetInfo);
                    if (bitsDifference < bestDifference) {
                        bestFormatInfo = decodeInfo[1];
                        bestDifference = bitsDifference;
                    }
                }
            }
            // Hamming distance of the 32 masked codes is 7, by construction, so <= 3 bits
            // differing means we found a match
            if (bestDifference <= 3) {
                return new FormatInformation(bestFormatInfo);
            }
            return null;
        }
        getErrorCorrectionLevel() {
            return this.errorCorrectionLevel;
        }
        getDataMask() {
            return this.dataMask;
        }
        /*@Override*/
        hashCode() {
            return (this.errorCorrectionLevel.getBits() << 3) | this.dataMask;
        }
        /*@Override*/
        equals(o) {
            if (!(o instanceof FormatInformation)) {
                return false;
            }
            const other = o;
            return this.errorCorrectionLevel === other.errorCorrectionLevel &&
                this.dataMask === other.dataMask;
        }
    }
    FormatInformation.FORMAT_INFO_MASK_QR = 0x5412;
    /**
     * See ISO 18004:2006, Annex C, Table C.1
     */
    FormatInformation.FORMAT_INFO_DECODE_LOOKUP = [
        Int32Array.from([0x5412, 0x00]),
        Int32Array.from([0x5125, 0x01]),
        Int32Array.from([0x5E7C, 0x02]),
        Int32Array.from([0x5B4B, 0x03]),
        Int32Array.from([0x45F9, 0x04]),
        Int32Array.from([0x40CE, 0x05]),
        Int32Array.from([0x4F97, 0x06]),
        Int32Array.from([0x4AA0, 0x07]),
        Int32Array.from([0x77C4, 0x08]),
        Int32Array.from([0x72F3, 0x09]),
        Int32Array.from([0x7DAA, 0x0A]),
        Int32Array.from([0x789D, 0x0B]),
        Int32Array.from([0x662F, 0x0C]),
        Int32Array.from([0x6318, 0x0D]),
        Int32Array.from([0x6C41, 0x0E]),
        Int32Array.from([0x6976, 0x0F]),
        Int32Array.from([0x1689, 0x10]),
        Int32Array.from([0x13BE, 0x11]),
        Int32Array.from([0x1CE7, 0x12]),
        Int32Array.from([0x19D0, 0x13]),
        Int32Array.from([0x0762, 0x14]),
        Int32Array.from([0x0255, 0x15]),
        Int32Array.from([0x0D0C, 0x16]),
        Int32Array.from([0x083B, 0x17]),
        Int32Array.from([0x355F, 0x18]),
        Int32Array.from([0x3068, 0x19]),
        Int32Array.from([0x3F31, 0x1A]),
        Int32Array.from([0x3A06, 0x1B]),
        Int32Array.from([0x24B4, 0x1C]),
        Int32Array.from([0x2183, 0x1D]),
        Int32Array.from([0x2EDA, 0x1E]),
        Int32Array.from([0x2BED, 0x1F]),
    ];

    /**
     * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will
     * use blocks of differing sizes within one version, so, this encapsulates the parameters for
     * each set of blocks. It also holds the number of error-correction codewords per block since it
     * will be the same across all blocks within one version.</p>
     */
    class ECBlocks$1 {
        constructor(ecCodewordsPerBlock /*int*/, ...ecBlocks) {
            this.ecCodewordsPerBlock = ecCodewordsPerBlock;
            this.ecBlocks = ecBlocks;
        }
        getECCodewordsPerBlock() {
            return this.ecCodewordsPerBlock;
        }
        getNumBlocks() {
            let total = 0;
            const ecBlocks = this.ecBlocks;
            for (const ecBlock of ecBlocks) {
                total += ecBlock.getCount();
            }
            return total;
        }
        getTotalECCodewords() {
            return this.ecCodewordsPerBlock * this.getNumBlocks();
        }
        getECBlocks() {
            return this.ecBlocks;
        }
    }

    /**
     * <p>Encapsulates the parameters for one error-correction block in one symbol version.
     * This includes the number of data codewords, and the number of times a block with these
     * parameters is used consecutively in the QR code version's format.</p>
     */
    class ECB$1 {
        constructor(count /*int*/, dataCodewords /*int*/) {
            this.count = count;
            this.dataCodewords = dataCodewords;
        }
        getCount() {
            return this.count;
        }
        getDataCodewords() {
            return this.dataCodewords;
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * See ISO 18004:2006 Annex D
     *
     * @author Sean Owen
     */
    class Version$1 {
        constructor(versionNumber /*int*/, alignmentPatternCenters, ...ecBlocks) {
            this.versionNumber = versionNumber;
            this.alignmentPatternCenters = alignmentPatternCenters;
            this.ecBlocks = ecBlocks;
            let total = 0;
            const ecCodewords = ecBlocks[0].getECCodewordsPerBlock();
            const ecbArray = ecBlocks[0].getECBlocks();
            for (const ecBlock of ecbArray) {
                total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
            }
            this.totalCodewords = total;
        }
        getVersionNumber() {
            return this.versionNumber;
        }
        getAlignmentPatternCenters() {
            return this.alignmentPatternCenters;
        }
        getTotalCodewords() {
            return this.totalCodewords;
        }
        getDimensionForVersion() {
            return 17 + 4 * this.versionNumber;
        }
        getECBlocksForLevel(ecLevel) {
            return this.ecBlocks[ecLevel.getValue()];
            // TYPESCRIPTPORT: original was using ordinal, and using the order of levels as defined in ErrorCorrectionLevel enum (LMQH)
            // I will use the direct value from ErrorCorrectionLevelValues enum which in typescript goes to a number
        }
        /**
         * <p>Deduces version information purely from QR Code dimensions.</p>
         *
         * @param dimension dimension in modules
         * @return Version for a QR Code of that dimension
         * @throws FormatException if dimension is not 1 mod 4
         */
        static getProvisionalVersionForDimension(dimension /*int*/) {
            if (dimension % 4 !== 1) {
                throw new FormatException();
            }
            try {
                return this.getVersionForNumber((dimension - 17) / 4);
            }
            catch (ignored /*: IllegalArgumentException*/) {
                throw new FormatException();
            }
        }
        static getVersionForNumber(versionNumber /*int*/) {
            if (versionNumber < 1 || versionNumber > 40) {
                throw new IllegalArgumentException();
            }
            return Version$1.VERSIONS[versionNumber - 1];
        }
        static decodeVersionInformation(versionBits /*int*/) {
            let bestDifference = Number.MAX_SAFE_INTEGER;
            let bestVersion = 0;
            for (let i = 0; i < Version$1.VERSION_DECODE_INFO.length; i++) {
                const targetVersion = Version$1.VERSION_DECODE_INFO[i];
                // Do the version info bits match exactly? done.
                if (targetVersion === versionBits) {
                    return Version$1.getVersionForNumber(i + 7);
                }
                // Otherwise see if this is the closest to a real version info bit string
                // we have seen so far
                const bitsDifference = FormatInformation.numBitsDiffering(versionBits, targetVersion);
                if (bitsDifference < bestDifference) {
                    bestVersion = i + 7;
                    bestDifference = bitsDifference;
                }
            }
            // We can tolerate up to 3 bits of error since no two version info codewords will
            // differ in less than 8 bits.
            if (bestDifference <= 3) {
                return Version$1.getVersionForNumber(bestVersion);
            }
            // If we didn't find a close enough match, fail
            return null;
        }
        /**
         * See ISO 18004:2006 Annex E
         */
        buildFunctionPattern() {
            const dimension = this.getDimensionForVersion();
            const bitMatrix = new BitMatrix(dimension);
            // Top left finder pattern + separator + format
            bitMatrix.setRegion(0, 0, 9, 9);
            // Top right finder pattern + separator + format
            bitMatrix.setRegion(dimension - 8, 0, 8, 9);
            // Bottom left finder pattern + separator + format
            bitMatrix.setRegion(0, dimension - 8, 9, 8);
            // Alignment patterns
            const max = this.alignmentPatternCenters.length;
            for (let x = 0; x < max; x++) {
                const i = this.alignmentPatternCenters[x] - 2;
                for (let y = 0; y < max; y++) {
                    if ((x === 0 && (y === 0 || y === max - 1)) || (x === max - 1 && y === 0)) {
                        // No alignment patterns near the three finder patterns
                        continue;
                    }
                    bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);
                }
            }
            // Vertical timing pattern
            bitMatrix.setRegion(6, 9, 1, dimension - 17);
            // Horizontal timing pattern
            bitMatrix.setRegion(9, 6, dimension - 17, 1);
            if (this.versionNumber > 6) {
                // Version info, top right
                bitMatrix.setRegion(dimension - 11, 0, 3, 6);
                // Version info, bottom left
                bitMatrix.setRegion(0, dimension - 11, 6, 3);
            }
            return bitMatrix;
        }
        /*@Override*/
        toString() {
            return '' + this.versionNumber;
        }
    }
    /**
     * See ISO 18004:2006 Annex D.
     * Element i represents the raw version bits that specify version i + 7
     */
    Version$1.VERSION_DECODE_INFO = Int32Array.from([
        0x07C94, 0x085BC, 0x09A99, 0x0A4D3, 0x0BBF6,
        0x0C762, 0x0D847, 0x0E60D, 0x0F928, 0x10B78,
        0x1145D, 0x12A17, 0x13532, 0x149A6, 0x15683,
        0x168C9, 0x177EC, 0x18EC4, 0x191E1, 0x1AFAB,
        0x1B08E, 0x1CC1A, 0x1D33F, 0x1ED75, 0x1F250,
        0x209D5, 0x216F0, 0x228BA, 0x2379F, 0x24B0B,
        0x2542E, 0x26A64, 0x27541, 0x28C69
    ]);
    /**
     * See ISO 18004:2006 6.5.1 Table 9
     */
    Version$1.VERSIONS = [
        new Version$1(1, new Int32Array(0), new ECBlocks$1(7, new ECB$1(1, 19)), new ECBlocks$1(10, new ECB$1(1, 16)), new ECBlocks$1(13, new ECB$1(1, 13)), new ECBlocks$1(17, new ECB$1(1, 9))),
        new Version$1(2, Int32Array.from([6, 18]), new ECBlocks$1(10, new ECB$1(1, 34)), new ECBlocks$1(16, new ECB$1(1, 28)), new ECBlocks$1(22, new ECB$1(1, 22)), new ECBlocks$1(28, new ECB$1(1, 16))),
        new Version$1(3, Int32Array.from([6, 22]), new ECBlocks$1(15, new ECB$1(1, 55)), new ECBlocks$1(26, new ECB$1(1, 44)), new ECBlocks$1(18, new ECB$1(2, 17)), new ECBlocks$1(22, new ECB$1(2, 13))),
        new Version$1(4, Int32Array.from([6, 26]), new ECBlocks$1(20, new ECB$1(1, 80)), new ECBlocks$1(18, new ECB$1(2, 32)), new ECBlocks$1(26, new ECB$1(2, 24)), new ECBlocks$1(16, new ECB$1(4, 9))),
        new Version$1(5, Int32Array.from([6, 30]), new ECBlocks$1(26, new ECB$1(1, 108)), new ECBlocks$1(24, new ECB$1(2, 43)), new ECBlocks$1(18, new ECB$1(2, 15), new ECB$1(2, 16)), new ECBlocks$1(22, new ECB$1(2, 11), new ECB$1(2, 12))),
        new Version$1(6, Int32Array.from([6, 34]), new ECBlocks$1(18, new ECB$1(2, 68)), new ECBlocks$1(16, new ECB$1(4, 27)), new ECBlocks$1(24, new ECB$1(4, 19)), new ECBlocks$1(28, new ECB$1(4, 15))),
        new Version$1(7, Int32Array.from([6, 22, 38]), new ECBlocks$1(20, new ECB$1(2, 78)), new ECBlocks$1(18, new ECB$1(4, 31)), new ECBlocks$1(18, new ECB$1(2, 14), new ECB$1(4, 15)), new ECBlocks$1(26, new ECB$1(4, 13), new ECB$1(1, 14))),
        new Version$1(8, Int32Array.from([6, 24, 42]), new ECBlocks$1(24, new ECB$1(2, 97)), new ECBlocks$1(22, new ECB$1(2, 38), new ECB$1(2, 39)), new ECBlocks$1(22, new ECB$1(4, 18), new ECB$1(2, 19)), new ECBlocks$1(26, new ECB$1(4, 14), new ECB$1(2, 15))),
        new Version$1(9, Int32Array.from([6, 26, 46]), new ECBlocks$1(30, new ECB$1(2, 116)), new ECBlocks$1(22, new ECB$1(3, 36), new ECB$1(2, 37)), new ECBlocks$1(20, new ECB$1(4, 16), new ECB$1(4, 17)), new ECBlocks$1(24, new ECB$1(4, 12), new ECB$1(4, 13))),
        new Version$1(10, Int32Array.from([6, 28, 50]), new ECBlocks$1(18, new ECB$1(2, 68), new ECB$1(2, 69)), new ECBlocks$1(26, new ECB$1(4, 43), new ECB$1(1, 44)), new ECBlocks$1(24, new ECB$1(6, 19), new ECB$1(2, 20)), new ECBlocks$1(28, new ECB$1(6, 15), new ECB$1(2, 16))),
        new Version$1(11, Int32Array.from([6, 30, 54]), new ECBlocks$1(20, new ECB$1(4, 81)), new ECBlocks$1(30, new ECB$1(1, 50), new ECB$1(4, 51)), new ECBlocks$1(28, new ECB$1(4, 22), new ECB$1(4, 23)), new ECBlocks$1(24, new ECB$1(3, 12), new ECB$1(8, 13))),
        new Version$1(12, Int32Array.from([6, 32, 58]), new ECBlocks$1(24, new ECB$1(2, 92), new ECB$1(2, 93)), new ECBlocks$1(22, new ECB$1(6, 36), new ECB$1(2, 37)), new ECBlocks$1(26, new ECB$1(4, 20), new ECB$1(6, 21)), new ECBlocks$1(28, new ECB$1(7, 14), new ECB$1(4, 15))),
        new Version$1(13, Int32Array.from([6, 34, 62]), new ECBlocks$1(26, new ECB$1(4, 107)), new ECBlocks$1(22, new ECB$1(8, 37), new ECB$1(1, 38)), new ECBlocks$1(24, new ECB$1(8, 20), new ECB$1(4, 21)), new ECBlocks$1(22, new ECB$1(12, 11), new ECB$1(4, 12))),
        new Version$1(14, Int32Array.from([6, 26, 46, 66]), new ECBlocks$1(30, new ECB$1(3, 115), new ECB$1(1, 116)), new ECBlocks$1(24, new ECB$1(4, 40), new ECB$1(5, 41)), new ECBlocks$1(20, new ECB$1(11, 16), new ECB$1(5, 17)), new ECBlocks$1(24, new ECB$1(11, 12), new ECB$1(5, 13))),
        new Version$1(15, Int32Array.from([6, 26, 48, 70]), new ECBlocks$1(22, new ECB$1(5, 87), new ECB$1(1, 88)), new ECBlocks$1(24, new ECB$1(5, 41), new ECB$1(5, 42)), new ECBlocks$1(30, new ECB$1(5, 24), new ECB$1(7, 25)), new ECBlocks$1(24, new ECB$1(11, 12), new ECB$1(7, 13))),
        new Version$1(16, Int32Array.from([6, 26, 50, 74]), new ECBlocks$1(24, new ECB$1(5, 98), new ECB$1(1, 99)), new ECBlocks$1(28, new ECB$1(7, 45), new ECB$1(3, 46)), new ECBlocks$1(24, new ECB$1(15, 19), new ECB$1(2, 20)), new ECBlocks$1(30, new ECB$1(3, 15), new ECB$1(13, 16))),
        new Version$1(17, Int32Array.from([6, 30, 54, 78]), new ECBlocks$1(28, new ECB$1(1, 107), new ECB$1(5, 108)), new ECBlocks$1(28, new ECB$1(10, 46), new ECB$1(1, 47)), new ECBlocks$1(28, new ECB$1(1, 22), new ECB$1(15, 23)), new ECBlocks$1(28, new ECB$1(2, 14), new ECB$1(17, 15))),
        new Version$1(18, Int32Array.from([6, 30, 56, 82]), new ECBlocks$1(30, new ECB$1(5, 120), new ECB$1(1, 121)), new ECBlocks$1(26, new ECB$1(9, 43), new ECB$1(4, 44)), new ECBlocks$1(28, new ECB$1(17, 22), new ECB$1(1, 23)), new ECBlocks$1(28, new ECB$1(2, 14), new ECB$1(19, 15))),
        new Version$1(19, Int32Array.from([6, 30, 58, 86]), new ECBlocks$1(28, new ECB$1(3, 113), new ECB$1(4, 114)), new ECBlocks$1(26, new ECB$1(3, 44), new ECB$1(11, 45)), new ECBlocks$1(26, new ECB$1(17, 21), new ECB$1(4, 22)), new ECBlocks$1(26, new ECB$1(9, 13), new ECB$1(16, 14))),
        new Version$1(20, Int32Array.from([6, 34, 62, 90]), new ECBlocks$1(28, new ECB$1(3, 107), new ECB$1(5, 108)), new ECBlocks$1(26, new ECB$1(3, 41), new ECB$1(13, 42)), new ECBlocks$1(30, new ECB$1(15, 24), new ECB$1(5, 25)), new ECBlocks$1(28, new ECB$1(15, 15), new ECB$1(10, 16))),
        new Version$1(21, Int32Array.from([6, 28, 50, 72, 94]), new ECBlocks$1(28, new ECB$1(4, 116), new ECB$1(4, 117)), new ECBlocks$1(26, new ECB$1(17, 42)), new ECBlocks$1(28, new ECB$1(17, 22), new ECB$1(6, 23)), new ECBlocks$1(30, new ECB$1(19, 16), new ECB$1(6, 17))),
        new Version$1(22, Int32Array.from([6, 26, 50, 74, 98]), new ECBlocks$1(28, new ECB$1(2, 111), new ECB$1(7, 112)), new ECBlocks$1(28, new ECB$1(17, 46)), new ECBlocks$1(30, new ECB$1(7, 24), new ECB$1(16, 25)), new ECBlocks$1(24, new ECB$1(34, 13))),
        new Version$1(23, Int32Array.from([6, 30, 54, 78, 102]), new ECBlocks$1(30, new ECB$1(4, 121), new ECB$1(5, 122)), new ECBlocks$1(28, new ECB$1(4, 47), new ECB$1(14, 48)), new ECBlocks$1(30, new ECB$1(11, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(16, 15), new ECB$1(14, 16))),
        new Version$1(24, Int32Array.from([6, 28, 54, 80, 106]), new ECBlocks$1(30, new ECB$1(6, 117), new ECB$1(4, 118)), new ECBlocks$1(28, new ECB$1(6, 45), new ECB$1(14, 46)), new ECBlocks$1(30, new ECB$1(11, 24), new ECB$1(16, 25)), new ECBlocks$1(30, new ECB$1(30, 16), new ECB$1(2, 17))),
        new Version$1(25, Int32Array.from([6, 32, 58, 84, 110]), new ECBlocks$1(26, new ECB$1(8, 106), new ECB$1(4, 107)), new ECBlocks$1(28, new ECB$1(8, 47), new ECB$1(13, 48)), new ECBlocks$1(30, new ECB$1(7, 24), new ECB$1(22, 25)), new ECBlocks$1(30, new ECB$1(22, 15), new ECB$1(13, 16))),
        new Version$1(26, Int32Array.from([6, 30, 58, 86, 114]), new ECBlocks$1(28, new ECB$1(10, 114), new ECB$1(2, 115)), new ECBlocks$1(28, new ECB$1(19, 46), new ECB$1(4, 47)), new ECBlocks$1(28, new ECB$1(28, 22), new ECB$1(6, 23)), new ECBlocks$1(30, new ECB$1(33, 16), new ECB$1(4, 17))),
        new Version$1(27, Int32Array.from([6, 34, 62, 90, 118]), new ECBlocks$1(30, new ECB$1(8, 122), new ECB$1(4, 123)), new ECBlocks$1(28, new ECB$1(22, 45), new ECB$1(3, 46)), new ECBlocks$1(30, new ECB$1(8, 23), new ECB$1(26, 24)), new ECBlocks$1(30, new ECB$1(12, 15), new ECB$1(28, 16))),
        new Version$1(28, Int32Array.from([6, 26, 50, 74, 98, 122]), new ECBlocks$1(30, new ECB$1(3, 117), new ECB$1(10, 118)), new ECBlocks$1(28, new ECB$1(3, 45), new ECB$1(23, 46)), new ECBlocks$1(30, new ECB$1(4, 24), new ECB$1(31, 25)), new ECBlocks$1(30, new ECB$1(11, 15), new ECB$1(31, 16))),
        new Version$1(29, Int32Array.from([6, 30, 54, 78, 102, 126]), new ECBlocks$1(30, new ECB$1(7, 116), new ECB$1(7, 117)), new ECBlocks$1(28, new ECB$1(21, 45), new ECB$1(7, 46)), new ECBlocks$1(30, new ECB$1(1, 23), new ECB$1(37, 24)), new ECBlocks$1(30, new ECB$1(19, 15), new ECB$1(26, 16))),
        new Version$1(30, Int32Array.from([6, 26, 52, 78, 104, 130]), new ECBlocks$1(30, new ECB$1(5, 115), new ECB$1(10, 116)), new ECBlocks$1(28, new ECB$1(19, 47), new ECB$1(10, 48)), new ECBlocks$1(30, new ECB$1(15, 24), new ECB$1(25, 25)), new ECBlocks$1(30, new ECB$1(23, 15), new ECB$1(25, 16))),
        new Version$1(31, Int32Array.from([6, 30, 56, 82, 108, 134]), new ECBlocks$1(30, new ECB$1(13, 115), new ECB$1(3, 116)), new ECBlocks$1(28, new ECB$1(2, 46), new ECB$1(29, 47)), new ECBlocks$1(30, new ECB$1(42, 24), new ECB$1(1, 25)), new ECBlocks$1(30, new ECB$1(23, 15), new ECB$1(28, 16))),
        new Version$1(32, Int32Array.from([6, 34, 60, 86, 112, 138]), new ECBlocks$1(30, new ECB$1(17, 115)), new ECBlocks$1(28, new ECB$1(10, 46), new ECB$1(23, 47)), new ECBlocks$1(30, new ECB$1(10, 24), new ECB$1(35, 25)), new ECBlocks$1(30, new ECB$1(19, 15), new ECB$1(35, 16))),
        new Version$1(33, Int32Array.from([6, 30, 58, 86, 114, 142]), new ECBlocks$1(30, new ECB$1(17, 115), new ECB$1(1, 116)), new ECBlocks$1(28, new ECB$1(14, 46), new ECB$1(21, 47)), new ECBlocks$1(30, new ECB$1(29, 24), new ECB$1(19, 25)), new ECBlocks$1(30, new ECB$1(11, 15), new ECB$1(46, 16))),
        new Version$1(34, Int32Array.from([6, 34, 62, 90, 118, 146]), new ECBlocks$1(30, new ECB$1(13, 115), new ECB$1(6, 116)), new ECBlocks$1(28, new ECB$1(14, 46), new ECB$1(23, 47)), new ECBlocks$1(30, new ECB$1(44, 24), new ECB$1(7, 25)), new ECBlocks$1(30, new ECB$1(59, 16), new ECB$1(1, 17))),
        new Version$1(35, Int32Array.from([6, 30, 54, 78, 102, 126, 150]), new ECBlocks$1(30, new ECB$1(12, 121), new ECB$1(7, 122)), new ECBlocks$1(28, new ECB$1(12, 47), new ECB$1(26, 48)), new ECBlocks$1(30, new ECB$1(39, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(22, 15), new ECB$1(41, 16))),
        new Version$1(36, Int32Array.from([6, 24, 50, 76, 102, 128, 154]), new ECBlocks$1(30, new ECB$1(6, 121), new ECB$1(14, 122)), new ECBlocks$1(28, new ECB$1(6, 47), new ECB$1(34, 48)), new ECBlocks$1(30, new ECB$1(46, 24), new ECB$1(10, 25)), new ECBlocks$1(30, new ECB$1(2, 15), new ECB$1(64, 16))),
        new Version$1(37, Int32Array.from([6, 28, 54, 80, 106, 132, 158]), new ECBlocks$1(30, new ECB$1(17, 122), new ECB$1(4, 123)), new ECBlocks$1(28, new ECB$1(29, 46), new ECB$1(14, 47)), new ECBlocks$1(30, new ECB$1(49, 24), new ECB$1(10, 25)), new ECBlocks$1(30, new ECB$1(24, 15), new ECB$1(46, 16))),
        new Version$1(38, Int32Array.from([6, 32, 58, 84, 110, 136, 162]), new ECBlocks$1(30, new ECB$1(4, 122), new ECB$1(18, 123)), new ECBlocks$1(28, new ECB$1(13, 46), new ECB$1(32, 47)), new ECBlocks$1(30, new ECB$1(48, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(42, 15), new ECB$1(32, 16))),
        new Version$1(39, Int32Array.from([6, 26, 54, 82, 110, 138, 166]), new ECBlocks$1(30, new ECB$1(20, 117), new ECB$1(4, 118)), new ECBlocks$1(28, new ECB$1(40, 47), new ECB$1(7, 48)), new ECBlocks$1(30, new ECB$1(43, 24), new ECB$1(22, 25)), new ECBlocks$1(30, new ECB$1(10, 15), new ECB$1(67, 16))),
        new Version$1(40, Int32Array.from([6, 30, 58, 86, 114, 142, 170]), new ECBlocks$1(30, new ECB$1(19, 118), new ECB$1(6, 119)), new ECBlocks$1(28, new ECB$1(18, 47), new ECB$1(31, 48)), new ECBlocks$1(30, new ECB$1(34, 24), new ECB$1(34, 25)), new ECBlocks$1(30, new ECB$1(20, 15), new ECB$1(61, 16)))
    ];

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var DataMaskValues;
    (function (DataMaskValues) {
        DataMaskValues[DataMaskValues["DATA_MASK_000"] = 0] = "DATA_MASK_000";
        DataMaskValues[DataMaskValues["DATA_MASK_001"] = 1] = "DATA_MASK_001";
        DataMaskValues[DataMaskValues["DATA_MASK_010"] = 2] = "DATA_MASK_010";
        DataMaskValues[DataMaskValues["DATA_MASK_011"] = 3] = "DATA_MASK_011";
        DataMaskValues[DataMaskValues["DATA_MASK_100"] = 4] = "DATA_MASK_100";
        DataMaskValues[DataMaskValues["DATA_MASK_101"] = 5] = "DATA_MASK_101";
        DataMaskValues[DataMaskValues["DATA_MASK_110"] = 6] = "DATA_MASK_110";
        DataMaskValues[DataMaskValues["DATA_MASK_111"] = 7] = "DATA_MASK_111";
    })(DataMaskValues || (DataMaskValues = {}));
    /**
     * <p>Encapsulates data masks for the data bits in a QR code, per ISO 18004:2006 6.8. Implementations
     * of this class can un-mask a raw BitMatrix. For simplicity, they will unmask the entire BitMatrix,
     * including areas used for finder patterns, timing patterns, etc. These areas should be unused
     * after the point they are unmasked anyway.</p>
     *
     * <p>Note that the diagram in section 6.8.1 is misleading since it indicates that i is column position
     * and j is row position. In fact, as the text says, i is row position and j is column position.</p>
     *
     * @author Sean Owen
     */
    class DataMask {
        // See ISO 18004:2006 6.8.1
        constructor(value, isMasked) {
            this.value = value;
            this.isMasked = isMasked;
        }
        // End of enum constants.
        /**
         * <p>Implementations of this method reverse the data masking process applied to a QR Code and
         * make its bits ready to read.</p>
         *
         * @param bits representation of QR Code bits
         * @param dimension dimension of QR Code, represented by bits, being unmasked
         */
        unmaskBitMatrix(bits, dimension /*int*/) {
            for (let i = 0; i < dimension; i++) {
                for (let j = 0; j < dimension; j++) {
                    if (this.isMasked(i, j)) {
                        bits.flip(j, i);
                    }
                }
            }
        }
    }
    DataMask.values = new Map([
        /**
         * 000: mask bits for which (x + y) mod 2 == 0
         */
        [DataMaskValues.DATA_MASK_000, new DataMask(DataMaskValues.DATA_MASK_000, (i /*int*/, j /*int*/) => { return ((i + j) & 0x01) === 0; })],
        /**
         * 001: mask bits for which x mod 2 == 0
         */
        [DataMaskValues.DATA_MASK_001, new DataMask(DataMaskValues.DATA_MASK_001, (i /*int*/, j /*int*/) => { return (i & 0x01) === 0; })],
        /**
         * 010: mask bits for which y mod 3 == 0
         */
        [DataMaskValues.DATA_MASK_010, new DataMask(DataMaskValues.DATA_MASK_010, (i /*int*/, j /*int*/) => { return j % 3 === 0; })],
        /**
         * 011: mask bits for which (x + y) mod 3 == 0
         */
        [DataMaskValues.DATA_MASK_011, new DataMask(DataMaskValues.DATA_MASK_011, (i /*int*/, j /*int*/) => { return (i + j) % 3 === 0; })],
        /**
         * 100: mask bits for which (x/2 + y/3) mod 2 == 0
         */
        [DataMaskValues.DATA_MASK_100, new DataMask(DataMaskValues.DATA_MASK_100, (i /*int*/, j /*int*/) => { return ((Math.floor(i / 2) + Math.floor(j / 3)) & 0x01) === 0; })],
        /**
         * 101: mask bits for which xy mod 2 + xy mod 3 == 0
         * equivalently, such that xy mod 6 == 0
         */
        [DataMaskValues.DATA_MASK_101, new DataMask(DataMaskValues.DATA_MASK_101, (i /*int*/, j /*int*/) => { return (i * j) % 6 === 0; })],
        /**
         * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0
         * equivalently, such that xy mod 6 < 3
         */
        [DataMaskValues.DATA_MASK_110, new DataMask(DataMaskValues.DATA_MASK_110, (i /*int*/, j /*int*/) => { return ((i * j) % 6) < 3; })],
        /**
         * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0
         * equivalently, such that (x + y + xy mod 3) mod 2 == 0
         */
        [DataMaskValues.DATA_MASK_111, new DataMask(DataMaskValues.DATA_MASK_111, (i /*int*/, j /*int*/) => { return ((i + j + ((i * j) % 3)) & 0x01) === 0; })],
    ]);

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * @author Sean Owen
     */
    class BitMatrixParser$1 {
        /**
         * @param bitMatrix {@link BitMatrix} to parse
         * @throws FormatException if dimension is not >= 21 and 1 mod 4
         */
        constructor(bitMatrix) {
            const dimension = bitMatrix.getHeight();
            if (dimension < 21 || (dimension & 0x03) !== 1) {
                throw new FormatException();
            }
            this.bitMatrix = bitMatrix;
        }
        /**
         * <p>Reads format information from one of its two locations within the QR Code.</p>
         *
         * @return {@link FormatInformation} encapsulating the QR Code's format info
         * @throws FormatException if both format information locations cannot be parsed as
         * the valid encoding of format information
         */
        readFormatInformation() {
            if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== undefined) {
                return this.parsedFormatInfo;
            }
            // Read top-left format info bits
            let formatInfoBits1 = 0;
            for (let i = 0; i < 6; i++) {
                formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);
            }
            // .. and skip a bit in the timing pattern ...
            formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);
            formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);
            formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);
            // .. and skip a bit in the timing pattern ...
            for (let j = 5; j >= 0; j--) {
                formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);
            }
            // Read the top-right/bottom-left pattern too
            const dimension = this.bitMatrix.getHeight();
            let formatInfoBits2 = 0;
            const jMin = dimension - 7;
            for (let j = dimension - 1; j >= jMin; j--) {
                formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);
            }
            for (let i = dimension - 8; i < dimension; i++) {
                formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);
            }
            this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits1, formatInfoBits2);
            if (this.parsedFormatInfo !== null) {
                return this.parsedFormatInfo;
            }
            throw new FormatException();
        }
        /**
         * <p>Reads version information from one of its two locations within the QR Code.</p>
         *
         * @return {@link Version} encapsulating the QR Code's version
         * @throws FormatException if both version information locations cannot be parsed as
         * the valid encoding of version information
         */
        readVersion() {
            if (this.parsedVersion !== null && this.parsedVersion !== undefined) {
                return this.parsedVersion;
            }
            const dimension = this.bitMatrix.getHeight();
            const provisionalVersion = Math.floor((dimension - 17) / 4);
            if (provisionalVersion <= 6) {
                return Version$1.getVersionForNumber(provisionalVersion);
            }
            // Read top-right version info: 3 wide by 6 tall
            let versionBits = 0;
            const ijMin = dimension - 11;
            for (let j = 5; j >= 0; j--) {
                for (let i = dimension - 9; i >= ijMin; i--) {
                    versionBits = this.copyBit(i, j, versionBits);
                }
            }
            let theParsedVersion = Version$1.decodeVersionInformation(versionBits);
            if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
                this.parsedVersion = theParsedVersion;
                return theParsedVersion;
            }
            // Hmm, failed. Try bottom left: 6 wide by 3 tall
            versionBits = 0;
            for (let i = 5; i >= 0; i--) {
                for (let j = dimension - 9; j >= ijMin; j--) {
                    versionBits = this.copyBit(i, j, versionBits);
                }
            }
            theParsedVersion = Version$1.decodeVersionInformation(versionBits);
            if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
                this.parsedVersion = theParsedVersion;
                return theParsedVersion;
            }
            throw new FormatException();
        }
        copyBit(i /*int*/, j /*int*/, versionBits /*int*/) {
            const bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);
            return bit ? (versionBits << 1) | 0x1 : versionBits << 1;
        }
        /**
         * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the
         * correct order in order to reconstruct the codewords bytes contained within the
         * QR Code.</p>
         *
         * @return bytes encoded within the QR Code
         * @throws FormatException if the exact number of bytes expected is not read
         */
        readCodewords() {
            const formatInfo = this.readFormatInformation();
            const version = this.readVersion();
            // Get the data mask for the format used in this QR Code. This will exclude
            // some bits from reading as we wind through the bit matrix.
            const dataMask = DataMask.values.get(formatInfo.getDataMask());
            const dimension = this.bitMatrix.getHeight();
            dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
            const functionPattern = version.buildFunctionPattern();
            let readingUp = true;
            const result = new Uint8Array(version.getTotalCodewords());
            let resultOffset = 0;
            let currentByte = 0;
            let bitsRead = 0;
            // Read columns in pairs, from right to left
            for (let j = dimension - 1; j > 0; j -= 2) {
                if (j === 6) {
                    // Skip whole column with vertical alignment pattern
                    // saves time and makes the other code proceed more cleanly
                    j--;
                }
                // Read alternatingly from bottom to top then top to bottom
                for (let count = 0; count < dimension; count++) {
                    const i = readingUp ? dimension - 1 - count : count;
                    for (let col = 0; col < 2; col++) {
                        // Ignore bits covered by the function pattern
                        if (!functionPattern.get(j - col, i)) {
                            // Read a bit
                            bitsRead++;
                            currentByte <<= 1;
                            if (this.bitMatrix.get(j - col, i)) {
                                currentByte |= 1;
                            }
                            // If we've made a whole byte, save it off
                            if (bitsRead === 8) {
                                result[resultOffset++] = /*(byte) */ currentByte;
                                bitsRead = 0;
                                currentByte = 0;
                            }
                        }
                    }
                }
                readingUp = !readingUp; // readingUp ^= true; // readingUp = !readingUp; // switch directions
            }
            if (resultOffset !== version.getTotalCodewords()) {
                throw new FormatException();
            }
            return result;
        }
        /**
         * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.
         */
        remask() {
            if (this.parsedFormatInfo === null) {
                return; // We have no format information, and have no data mask
            }
            const dataMask = DataMask.values[this.parsedFormatInfo.getDataMask()];
            const dimension = this.bitMatrix.getHeight();
            dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
        }
        /**
         * Prepare the parser for a mirrored operation.
         * This flag has effect only on the {@link #readFormatInformation()} and the
         * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the
         * {@link #mirror()} method should be called.
         *
         * @param mirror Whether to read version and format information mirrored.
         */
        setMirror(isMirror) {
            this.parsedVersion = null;
            this.parsedFormatInfo = null;
            this.isMirror = isMirror;
        }
        /** Mirror the bit matrix in order to attempt a second reading. */
        mirror() {
            const bitMatrix = this.bitMatrix;
            for (let x = 0, width = bitMatrix.getWidth(); x < width; x++) {
                for (let y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {
                    if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {
                        bitMatrix.flip(y, x);
                        bitMatrix.flip(x, y);
                    }
                }
            }
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Encapsulates a block of data within a QR Code. QR Codes may split their data into
     * multiple blocks, each of which is a unit of data and error-correction codewords. Each
     * is represented by an instance of this class.</p>
     *
     * @author Sean Owen
     */
    class DataBlock$1 {
        constructor(numDataCodewords /*int*/, codewords) {
            this.numDataCodewords = numDataCodewords;
            this.codewords = codewords;
        }
        /**
         * <p>When QR Codes use multiple data blocks, they are actually interleaved.
         * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This
         * method will separate the data into original blocks.</p>
         *
         * @param rawCodewords bytes as read directly from the QR Code
         * @param version version of the QR Code
         * @param ecLevel error-correction level of the QR Code
         * @return DataBlocks containing original bytes, "de-interleaved" from representation in the
         *         QR Code
         */
        static getDataBlocks(rawCodewords, version, ecLevel) {
            if (rawCodewords.length !== version.getTotalCodewords()) {
                throw new IllegalArgumentException();
            }
            // Figure out the number and size of data blocks used by this version and
            // error correction level
            const ecBlocks = version.getECBlocksForLevel(ecLevel);
            // First count the total number of data blocks
            let totalBlocks = 0;
            const ecBlockArray = ecBlocks.getECBlocks();
            for (const ecBlock of ecBlockArray) {
                totalBlocks += ecBlock.getCount();
            }
            // Now establish DataBlocks of the appropriate size and number of data codewords
            const result = new Array(totalBlocks);
            let numResultBlocks = 0;
            for (const ecBlock of ecBlockArray) {
                for (let i = 0; i < ecBlock.getCount(); i++) {
                    const numDataCodewords = ecBlock.getDataCodewords();
                    const numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;
                    result[numResultBlocks++] = new DataBlock$1(numDataCodewords, new Uint8Array(numBlockCodewords));
                }
            }
            // All blocks have the same amount of data, except that the last n
            // (where n may be 0) have 1 more byte. Figure out where these start.
            const shorterBlocksTotalCodewords = result[0].codewords.length;
            let longerBlocksStartAt = result.length - 1;
            // TYPESCRIPTPORT: check length is correct here
            while (longerBlocksStartAt >= 0) {
                const numCodewords = result[longerBlocksStartAt].codewords.length;
                if (numCodewords === shorterBlocksTotalCodewords) {
                    break;
                }
                longerBlocksStartAt--;
            }
            longerBlocksStartAt++;
            const shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock();
            // The last elements of result may be 1 element longer
            // first fill out as many elements as all of them have
            let rawCodewordsOffset = 0;
            for (let i = 0; i < shorterBlocksNumDataCodewords; i++) {
                for (let j = 0; j < numResultBlocks; j++) {
                    result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];
                }
            }
            // Fill out the last data block in the longer ones
            for (let j = longerBlocksStartAt; j < numResultBlocks; j++) {
                result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];
            }
            // Now add in error correction blocks
            const max = result[0].codewords.length;
            for (let i = shorterBlocksNumDataCodewords; i < max; i++) {
                for (let j = 0; j < numResultBlocks; j++) {
                    const iOffset = j < longerBlocksStartAt ? i : i + 1;
                    result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
                }
            }
            return result;
        }
        getNumDataCodewords() {
            return this.numDataCodewords;
        }
        getCodewords() {
            return this.codewords;
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var ModeValues;
    (function (ModeValues) {
        ModeValues[ModeValues["TERMINATOR"] = 0] = "TERMINATOR";
        ModeValues[ModeValues["NUMERIC"] = 1] = "NUMERIC";
        ModeValues[ModeValues["ALPHANUMERIC"] = 2] = "ALPHANUMERIC";
        ModeValues[ModeValues["STRUCTURED_APPEND"] = 3] = "STRUCTURED_APPEND";
        ModeValues[ModeValues["BYTE"] = 4] = "BYTE";
        ModeValues[ModeValues["ECI"] = 5] = "ECI";
        ModeValues[ModeValues["KANJI"] = 6] = "KANJI";
        ModeValues[ModeValues["FNC1_FIRST_POSITION"] = 7] = "FNC1_FIRST_POSITION";
        ModeValues[ModeValues["FNC1_SECOND_POSITION"] = 8] = "FNC1_SECOND_POSITION";
        /** See GBT 18284-2000; "Hanzi" is a transliteration of this mode name. */
        ModeValues[ModeValues["HANZI"] = 9] = "HANZI";
    })(ModeValues || (ModeValues = {}));
    /**
     * <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which
     * data can be encoded to bits in the QR code standard.</p>
     *
     * @author Sean Owen
     */
    class Mode$1 {
        constructor(value, stringValue, characterCountBitsForVersions, bits /*int*/) {
            this.value = value;
            this.stringValue = stringValue;
            this.characterCountBitsForVersions = characterCountBitsForVersions;
            this.bits = bits;
            Mode$1.FOR_BITS.set(bits, this);
            Mode$1.FOR_VALUE.set(value, this);
        }
        /**
         * @param bits four bits encoding a QR Code data mode
         * @return Mode encoded by these bits
         * @throws IllegalArgumentException if bits do not correspond to a known mode
         */
        static forBits(bits /*int*/) {
            const mode = Mode$1.FOR_BITS.get(bits);
            if (undefined === mode) {
                throw new IllegalArgumentException();
            }
            return mode;
        }
        /**
         * @param version version in question
         * @return number of bits used, in this QR Code symbol {@link Version}, to encode the
         *         count of characters that will follow encoded in this Mode
         */
        getCharacterCountBits(version) {
            const versionNumber = version.getVersionNumber();
            let offset;
            if (versionNumber <= 9) {
                offset = 0;
            }
            else if (versionNumber <= 26) {
                offset = 1;
            }
            else {
                offset = 2;
            }
            return this.characterCountBitsForVersions[offset];
        }
        getValue() {
            return this.value;
        }
        getBits() {
            return this.bits;
        }
        equals(o) {
            if (!(o instanceof Mode$1)) {
                return false;
            }
            const other = o;
            return this.value === other.value;
        }
        toString() {
            return this.stringValue;
        }
    }
    Mode$1.FOR_BITS = new Map();
    Mode$1.FOR_VALUE = new Map();
    Mode$1.TERMINATOR = new Mode$1(ModeValues.TERMINATOR, 'TERMINATOR', Int32Array.from([0, 0, 0]), 0x00); // Not really a mode...
    Mode$1.NUMERIC = new Mode$1(ModeValues.NUMERIC, 'NUMERIC', Int32Array.from([10, 12, 14]), 0x01);
    Mode$1.ALPHANUMERIC = new Mode$1(ModeValues.ALPHANUMERIC, 'ALPHANUMERIC', Int32Array.from([9, 11, 13]), 0x02);
    Mode$1.STRUCTURED_APPEND = new Mode$1(ModeValues.STRUCTURED_APPEND, 'STRUCTURED_APPEND', Int32Array.from([0, 0, 0]), 0x03); // Not supported
    Mode$1.BYTE = new Mode$1(ModeValues.BYTE, 'BYTE', Int32Array.from([8, 16, 16]), 0x04);
    Mode$1.ECI = new Mode$1(ModeValues.ECI, 'ECI', Int32Array.from([0, 0, 0]), 0x07); // character counts don't apply
    Mode$1.KANJI = new Mode$1(ModeValues.KANJI, 'KANJI', Int32Array.from([8, 10, 12]), 0x08);
    Mode$1.FNC1_FIRST_POSITION = new Mode$1(ModeValues.FNC1_FIRST_POSITION, 'FNC1_FIRST_POSITION', Int32Array.from([0, 0, 0]), 0x05);
    Mode$1.FNC1_SECOND_POSITION = new Mode$1(ModeValues.FNC1_SECOND_POSITION, 'FNC1_SECOND_POSITION', Int32Array.from([0, 0, 0]), 0x09);
    /** See GBT 18284-2000; "Hanzi" is a transliteration of this mode name. */
    Mode$1.HANZI = new Mode$1(ModeValues.HANZI, 'HANZI', Int32Array.from([8, 10, 12]), 0x0D);

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*import java.io.UnsupportedEncodingException;*/
    /*import java.util.ArrayList;*/
    /*import java.util.Collection;*/
    /*import java.util.List;*/
    /*import java.util.Map;*/
    /**
     * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes
     * in one QR Code. This class decodes the bits back into text.</p>
     *
     * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>
     *
     * @author Sean Owen
     */
    class DecodedBitStreamParser$1 {
        static decode(bytes, version, ecLevel, hints) {
            const bits = new BitSource(bytes);
            let result = new StringBuilder();
            const byteSegments = new Array(); // 1
            // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below
            let symbolSequence = -1;
            let parityData = -1;
            try {
                let currentCharacterSetECI = null;
                let fc1InEffect = false;
                let mode;
                do {
                    // While still another segment to read...
                    if (bits.available() < 4) {
                        // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here
                        mode = Mode$1.TERMINATOR;
                    }
                    else {
                        const modeBits = bits.readBits(4);
                        mode = Mode$1.forBits(modeBits); // mode is encoded by 4 bits
                    }
                    switch (mode) {
                        case Mode$1.TERMINATOR:
                            break;
                        case Mode$1.FNC1_FIRST_POSITION:
                        case Mode$1.FNC1_SECOND_POSITION:
                            // We do little with FNC1 except alter the parsed result a bit according to the spec
                            fc1InEffect = true;
                            break;
                        case Mode$1.STRUCTURED_APPEND:
                            if (bits.available() < 16) {
                                throw new FormatException();
                            }
                            // sequence number and parity is added later to the result metadata
                            // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue
                            symbolSequence = bits.readBits(8);
                            parityData = bits.readBits(8);
                            break;
                        case Mode$1.ECI:
                            // Count doesn't apply to ECI
                            const value = DecodedBitStreamParser$1.parseECIValue(bits);
                            currentCharacterSetECI = CharacterSetECI.getCharacterSetECIByValue(value);
                            if (currentCharacterSetECI === null) {
                                throw new FormatException();
                            }
                            break;
                        case Mode$1.HANZI:
                            // First handle Hanzi mode which does not start with character count
                            // Chinese mode contains a sub set indicator right after mode indicator
                            const subset = bits.readBits(4);
                            const countHanzi = bits.readBits(mode.getCharacterCountBits(version));
                            if (subset === DecodedBitStreamParser$1.GB2312_SUBSET) {
                                DecodedBitStreamParser$1.decodeHanziSegment(bits, result, countHanzi);
                            }
                            break;
                        default:
                            // "Normal" QR code modes:
                            // How many characters will follow, encoded in this mode?
                            const count = bits.readBits(mode.getCharacterCountBits(version));
                            switch (mode) {
                                case Mode$1.NUMERIC:
                                    DecodedBitStreamParser$1.decodeNumericSegment(bits, result, count);
                                    break;
                                case Mode$1.ALPHANUMERIC:
                                    DecodedBitStreamParser$1.decodeAlphanumericSegment(bits, result, count, fc1InEffect);
                                    break;
                                case Mode$1.BYTE:
                                    DecodedBitStreamParser$1.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);
                                    break;
                                case Mode$1.KANJI:
                                    DecodedBitStreamParser$1.decodeKanjiSegment(bits, result, count);
                                    break;
                                default:
                                    throw new FormatException();
                            }
                            break;
                    }
                } while (mode !== Mode$1.TERMINATOR);
            }
            catch (iae /*: IllegalArgumentException*/) {
                // from readBits() calls
                throw new FormatException();
            }
            return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);
        }
        /**
         * See specification GBT 18284-2000
         */
        static decodeHanziSegment(bits, result, count /*int*/) {
            // Don't crash trying to read more bits than we have available.
            if (count * 13 > bits.available()) {
                throw new FormatException();
            }
            // Each character will require 2 bytes. Read the characters as 2-byte pairs
            // and decode as GB2312 afterwards
            const buffer = new Uint8Array(2 * count);
            let offset = 0;
            while (count > 0) {
                // Each 13 bits encodes a 2-byte character
                const twoBytes = bits.readBits(13);
                let assembledTwoBytes = (((twoBytes / 0x060) << 8) & 0xFFFFFFFF) | (twoBytes % 0x060);
                if (assembledTwoBytes < 0x003BF) {
                    // In the 0xA1A1 to 0xAAFE range
                    assembledTwoBytes += 0x0A1A1;
                }
                else {
                    // In the 0xB0A1 to 0xFAFE range
                    assembledTwoBytes += 0x0A6A1;
                }
                buffer[offset] = /*(byte) */ ((assembledTwoBytes >> 8) & 0xFF);
                buffer[offset + 1] = /*(byte) */ (assembledTwoBytes & 0xFF);
                offset += 2;
                count--;
            }
            try {
                result.append(StringEncoding.decode(buffer, StringUtils.GB2312));
                // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point
            }
            catch (ignored /*: UnsupportedEncodingException*/) {
                throw new FormatException(ignored);
            }
        }
        static decodeKanjiSegment(bits, result, count /*int*/) {
            // Don't crash trying to read more bits than we have available.
            if (count * 13 > bits.available()) {
                throw new FormatException();
            }
            // Each character will require 2 bytes. Read the characters as 2-byte pairs
            // and decode as Shift_JIS afterwards
            const buffer = new Uint8Array(2 * count);
            let offset = 0;
            while (count > 0) {
                // Each 13 bits encodes a 2-byte character
                const twoBytes = bits.readBits(13);
                let assembledTwoBytes = (((twoBytes / 0x0C0) << 8) & 0xFFFFFFFF) | (twoBytes % 0x0C0);
                if (assembledTwoBytes < 0x01F00) {
                    // In the 0x8140 to 0x9FFC range
                    assembledTwoBytes += 0x08140;
                }
                else {
                    // In the 0xE040 to 0xEBBF range
                    assembledTwoBytes += 0x0C140;
                }
                buffer[offset] = /*(byte) */ (assembledTwoBytes >> 8);
                buffer[offset + 1] = /*(byte) */ assembledTwoBytes;
                offset += 2;
                count--;
            }
            // Shift_JIS may not be supported in some environments:
            try {
                result.append(StringEncoding.decode(buffer, StringUtils.SHIFT_JIS));
                // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point
            }
            catch (ignored /*: UnsupportedEncodingException*/) {
                throw new FormatException(ignored);
            }
        }
        static decodeByteSegment(bits, result, count /*int*/, currentCharacterSetECI, byteSegments, hints) {
            // Don't crash trying to read more bits than we have available.
            if (8 * count > bits.available()) {
                throw new FormatException();
            }
            const readBytes = new Uint8Array(count);
            for (let i = 0; i < count; i++) {
                readBytes[i] = /*(byte) */ bits.readBits(8);
            }
            let encoding;
            if (currentCharacterSetECI === null) {
                // The spec isn't clear on this mode; see
                // section 6.4.5: t does not say which encoding to assuming
                // upon decoding. I have seen ISO-8859-1 used as well as
                // Shift_JIS -- without anything like an ECI designator to
                // give a hint.
                encoding = StringUtils.guessEncoding(readBytes, hints);
            }
            else {
                encoding = currentCharacterSetECI.getName();
            }
            try {
                result.append(StringEncoding.decode(readBytes, encoding));
            }
            catch (ignored /*: UnsupportedEncodingException*/) {
                throw new FormatException(ignored);
            }
            byteSegments.push(readBytes);
        }
        static toAlphaNumericChar(value /*int*/) {
            if (value >= DecodedBitStreamParser$1.ALPHANUMERIC_CHARS.length) {
                throw new FormatException();
            }
            return DecodedBitStreamParser$1.ALPHANUMERIC_CHARS[value];
        }
        static decodeAlphanumericSegment(bits, result, count /*int*/, fc1InEffect) {
            // Read two characters at a time
            const start = result.length();
            while (count > 1) {
                if (bits.available() < 11) {
                    throw new FormatException();
                }
                const nextTwoCharsBits = bits.readBits(11);
                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));
                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(nextTwoCharsBits % 45));
                count -= 2;
            }
            if (count === 1) {
                // special case: one character left
                if (bits.available() < 6) {
                    throw new FormatException();
                }
                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(bits.readBits(6)));
            }
            // See section 6.4.8.1, 6.4.8.2
            if (fc1InEffect) {
                // We need to massage the result a bit if in an FNC1 mode:
                for (let i = start; i < result.length(); i++) {
                    if (result.charAt(i) === '%') {
                        if (i < result.length() - 1 && result.charAt(i + 1) === '%') {
                            // %% is rendered as %
                            result.deleteCharAt(i + 1);
                        }
                        else {
                            // In alpha mode, % should be converted to FNC1 separator 0x1D
                            result.setCharAt(i, String.fromCharCode(0x1D));
                        }
                    }
                }
            }
        }
        static decodeNumericSegment(bits, result, count /*int*/) {
            // Read three digits at a time
            while (count >= 3) {
                // Each 10 bits encodes three digits
                if (bits.available() < 10) {
                    throw new FormatException();
                }
                const threeDigitsBits = bits.readBits(10);
                if (threeDigitsBits >= 1000) {
                    throw new FormatException();
                }
                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));
                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));
                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(threeDigitsBits % 10));
                count -= 3;
            }
            if (count === 2) {
                // Two digits left over to read, encoded in 7 bits
                if (bits.available() < 7) {
                    throw new FormatException();
                }
                const twoDigitsBits = bits.readBits(7);
                if (twoDigitsBits >= 100) {
                    throw new FormatException();
                }
                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));
                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(twoDigitsBits % 10));
            }
            else if (count === 1) {
                // One digit left over to read
                if (bits.available() < 4) {
                    throw new FormatException();
                }
                const digitBits = bits.readBits(4);
                if (digitBits >= 10) {
                    throw new FormatException();
                }
                result.append(DecodedBitStreamParser$1.toAlphaNumericChar(digitBits));
            }
        }
        static parseECIValue(bits) {
            const firstByte = bits.readBits(8);
            if ((firstByte & 0x80) === 0) {
                // just one byte
                return firstByte & 0x7F;
            }
            if ((firstByte & 0xC0) === 0x80) {
                // two bytes
                const secondByte = bits.readBits(8);
                return (((firstByte & 0x3F) << 8) & 0xFFFFFFFF) | secondByte;
            }
            if ((firstByte & 0xE0) === 0xC0) {
                // three bytes
                const secondThirdBytes = bits.readBits(16);
                return (((firstByte & 0x1F) << 16) & 0xFFFFFFFF) | secondThirdBytes;
            }
            throw new FormatException();
        }
    }
    /**
     * See ISO 18004:2006, 6.4.4 Table 5
     */
    DecodedBitStreamParser$1.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';
    DecodedBitStreamParser$1.GB2312_SUBSET = 1;
    // function Uint8ArrayToString(a: Uint8Array): string {
    //     const CHUNK_SZ = 0x8000;
    //     const c = new StringBuilder();
    //     for (let i = 0, length = a.length; i < length; i += CHUNK_SZ) {
    //         c.append(String.fromCharCode.apply(null, a.subarray(i, i + CHUNK_SZ)));
    //     }
    //     return c.toString();
    // }

    /*
     * Copyright 2013 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Meta-data container for QR Code decoding. Instances of this class may be used to convey information back to the
     * decoding caller. Callers are expected to process this.
     *
     * @see com.google.zxing.common.DecoderResult#getOther()
     */
    class QRCodeDecoderMetaData {
        constructor(mirrored) {
            this.mirrored = mirrored;
        }
        /**
         * @return true if the QR Code was mirrored.
         */
        isMirrored() {
            return this.mirrored;
        }
        /**
         * Apply the result points' order correction due to mirroring.
         *
         * @param points Array of points to apply mirror correction to.
         */
        applyMirroredCorrection(points) {
            if (!this.mirrored || points === null || points.length < 3) {
                return;
            }
            const bottomLeft = points[0];
            points[0] = points[2];
            points[2] = bottomLeft;
            // No need to 'fix' top-left and alignment pattern.
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*import java.util.Map;*/
    /**
     * <p>The main class which implements QR Code decoding -- as opposed to locating and extracting
     * the QR Code from an image.</p>
     *
     * @author Sean Owen
     */
    class Decoder$2 {
        constructor() {
            this.rsDecoder = new ReedSolomonDecoder(GenericGF.QR_CODE_FIELD_256);
        }
        // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {
        //   return decode(image, null)
        // }
        /**
         * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.
         * "true" is taken to mean a black module.</p>
         *
         * @param image booleans representing white/black QR Code modules
         * @param hints decoding hints that should be used to influence decoding
         * @return text and bytes encoded within the QR Code
         * @throws FormatException if the QR Code cannot be decoded
         * @throws ChecksumException if error correction fails
         */
        decodeBooleanArray(image, hints) {
            return this.decodeBitMatrix(BitMatrix.parseFromBooleanArray(image), hints);
        }
        // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {
        //   return decode(bits, null)
        // }
        /**
         * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or "true" is taken to mean a black module.</p>
         *
         * @param bits booleans representing white/black QR Code modules
         * @param hints decoding hints that should be used to influence decoding
         * @return text and bytes encoded within the QR Code
         * @throws FormatException if the QR Code cannot be decoded
         * @throws ChecksumException if error correction fails
         */
        decodeBitMatrix(bits, hints) {
            // Construct a parser and read version, error-correction level
            const parser = new BitMatrixParser$1(bits);
            let ex = null;
            try {
                return this.decodeBitMatrixParser(parser, hints);
            }
            catch (e /*: FormatException, ChecksumException*/) {
                ex = e;
            }
            try {
                // Revert the bit matrix
                parser.remask();
                // Will be attempting a mirrored reading of the version and format info.
                parser.setMirror(true);
                // Preemptively read the version.
                parser.readVersion();
                // Preemptively read the format information.
                parser.readFormatInformation();
                /*
                 * Since we're here, this means we have successfully detected some kind
                 * of version and format information when mirrored. This is a good sign,
                 * that the QR code may be mirrored, and we should try once more with a
                 * mirrored content.
                 */
                // Prepare for a mirrored reading.
                parser.mirror();
                const result = this.decodeBitMatrixParser(parser, hints);
                // Success! Notify the caller that the code was mirrored.
                result.setOther(new QRCodeDecoderMetaData(true));
                return result;
            }
            catch (e /*FormatException | ChecksumException*/) {
                // Throw the exception from the original reading
                if (ex !== null) {
                    throw ex;
                }
                throw e;
            }
        }
        decodeBitMatrixParser(parser, hints) {
            const version = parser.readVersion();
            const ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();
            // Read codewords
            const codewords = parser.readCodewords();
            // Separate into data blocks
            const dataBlocks = DataBlock$1.getDataBlocks(codewords, version, ecLevel);
            // Count total number of data bytes
            let totalBytes = 0;
            for (const dataBlock of dataBlocks) {
                totalBytes += dataBlock.getNumDataCodewords();
            }
            const resultBytes = new Uint8Array(totalBytes);
            let resultOffset = 0;
            // Error-correct and copy data blocks together into a stream of bytes
            for (const dataBlock of dataBlocks) {
                const codewordBytes = dataBlock.getCodewords();
                const numDataCodewords = dataBlock.getNumDataCodewords();
                this.correctErrors(codewordBytes, numDataCodewords);
                for (let i = 0; i < numDataCodewords; i++) {
                    resultBytes[resultOffset++] = codewordBytes[i];
                }
            }
            // Decode the contents of that stream of bytes
            return DecodedBitStreamParser$1.decode(resultBytes, version, ecLevel, hints);
        }
        /**
         * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
         * correct the errors in-place using Reed-Solomon error correction.</p>
         *
         * @param codewordBytes data and error correction codewords
         * @param numDataCodewords number of codewords that are data bytes
         * @throws ChecksumException if error correction fails
         */
        correctErrors(codewordBytes, numDataCodewords /*int*/) {
            // const numCodewords = codewordBytes.length;
            // First read into an array of ints
            const codewordsInts = new Int32Array(codewordBytes);
            // TYPESCRIPTPORT: not realy necessary to transform to ints? could redesign everything to work with unsigned bytes?
            // const codewordsInts = new Int32Array(numCodewords)
            // for (let i = 0; i < numCodewords; i++) {
            //   codewordsInts[i] = codewordBytes[i] & 0xFF
            // }
            try {
                this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
            }
            catch (ignored /*: ReedSolomonException*/) {
                throw new ChecksumException();
            }
            // Copy back into array of bytes -- only need to worry about the bytes that were data
            // We don't care about errors in the error-correction codewords
            for (let i = 0; i < numDataCodewords; i++) {
                codewordBytes[i] = /*(byte) */ codewordsInts[i];
            }
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Encapsulates an alignment pattern, which are the smaller square patterns found in
     * all but the simplest QR Codes.</p>
     *
     * @author Sean Owen
     */
    class AlignmentPattern extends ResultPoint {
        constructor(posX /*float*/, posY /*float*/, estimatedModuleSize /*float*/) {
            super(posX, posY);
            this.estimatedModuleSize = estimatedModuleSize;
        }
        /**
         * <p>Determines if this alignment pattern "about equals" an alignment pattern at the stated
         * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>
         */
        aboutEquals(moduleSize /*float*/, i /*float*/, j /*float*/) {
            if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {
                const moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
                return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;
            }
            return false;
        }
        /**
         * Combines this object's current estimate of a finder pattern position and module size
         * with a new estimate. It returns a new {@code FinderPattern} containing an average of the two.
         */
        combineEstimate(i /*float*/, j /*float*/, newModuleSize /*float*/) {
            const combinedX = (this.getX() + j) / 2.0;
            const combinedY = (this.getY() + i) / 2.0;
            const combinedModuleSize = (this.estimatedModuleSize + newModuleSize) / 2.0;
            return new AlignmentPattern(combinedX, combinedY, combinedModuleSize);
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*import java.util.ArrayList;*/
    /*import java.util.List;*/
    /**
     * <p>This class attempts to find alignment patterns in a QR Code. Alignment patterns look like finder
     * patterns but are smaller and appear at regular intervals throughout the image.</p>
     *
     * <p>At the moment this only looks for the bottom-right alignment pattern.</p>
     *
     * <p>This is mostly a simplified copy of {@link FinderPatternFinder}. It is copied,
     * pasted and stripped down here for maximum performance but does unfortunately duplicate
     * some code.</p>
     *
     * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.</p>
     *
     * @author Sean Owen
     */
    class AlignmentPatternFinder {
        /**
         * <p>Creates a finder that will look in a portion of the whole image.</p>
         *
         * @param image image to search
         * @param startX left column from which to start searching
         * @param startY top row from which to start searching
         * @param width width of region to search
         * @param height height of region to search
         * @param moduleSize estimated module size so far
         */
        constructor(image, startX /*int*/, startY /*int*/, width /*int*/, height /*int*/, moduleSize /*float*/, resultPointCallback) {
            this.image = image;
            this.startX = startX;
            this.startY = startY;
            this.width = width;
            this.height = height;
            this.moduleSize = moduleSize;
            this.resultPointCallback = resultPointCallback;
            this.possibleCenters = []; // new Array<any>(5))
            // TYPESCRIPTPORT: array initialization without size as the length is checked below
            this.crossCheckStateCount = new Int32Array(3);
        }
        /**
         * <p>This method attempts to find the bottom-right alignment pattern in the image. It is a bit messy since
         * it's pretty performance-critical and so is written to be fast foremost.</p>
         *
         * @return {@link AlignmentPattern} if found
         * @throws NotFoundException if not found
         */
        find() {
            const startX = this.startX;
            const height = this.height;
            const width = this.width;
            const maxJ = startX + width;
            const middleI = this.startY + (height / 2);
            // We are looking for black/white/black modules in 1:1:1 ratio
            // this tracks the number of black/white/black modules seen so far
            const stateCount = new Int32Array(3);
            const image = this.image;
            for (let iGen = 0; iGen < height; iGen++) {
                // Search from middle outwards
                const i = middleI + ((iGen & 0x01) === 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));
                stateCount[0] = 0;
                stateCount[1] = 0;
                stateCount[2] = 0;
                let j = startX;
                // Burn off leading white pixels before anything else; if we start in the middle of
                // a white run, it doesn't make sense to count its length, since we don't know if the
                // white run continued to the left of the start point
                while (j < maxJ && !image.get(j, i)) {
                    j++;
                }
                let currentState = 0;
                while (j < maxJ) {
                    if (image.get(j, i)) {
                        // Black pixel
                        if (currentState === 1) { // Counting black pixels
                            stateCount[1]++;
                        }
                        else { // Counting white pixels
                            if (currentState === 2) { // A winner?
                                if (this.foundPatternCross(stateCount)) { // Yes
                                    const confirmed = this.handlePossibleCenter(stateCount, i, j);
                                    if (confirmed !== null) {
                                        return confirmed;
                                    }
                                }
                                stateCount[0] = stateCount[2];
                                stateCount[1] = 1;
                                stateCount[2] = 0;
                                currentState = 1;
                            }
                            else {
                                stateCount[++currentState]++;
                            }
                        }
                    }
                    else { // White pixel
                        if (currentState === 1) { // Counting black pixels
                            currentState++;
                        }
                        stateCount[currentState]++;
                    }
                    j++;
                }
                if (this.foundPatternCross(stateCount)) {
                    const confirmed = this.handlePossibleCenter(stateCount, i, maxJ);
                    if (confirmed !== null) {
                        return confirmed;
                    }
                }
            }
            // Hmm, nothing we saw was observed and confirmed twice. If we had
            // any guess at all, return it.
            if (this.possibleCenters.length !== 0) {
                return this.possibleCenters[0];
            }
            throw new NotFoundException();
        }
        /**
         * Given a count of black/white/black pixels just seen and an end position,
         * figures the location of the center of this black/white/black run.
         */
        static centerFromEnd(stateCount, end /*int*/) {
            return (end - stateCount[2]) - stateCount[1] / 2.0;
        }
        /**
         * @param stateCount count of black/white/black pixels just read
         * @return true iff the proportions of the counts is close enough to the 1/1/1 ratios
         *         used by alignment patterns to be considered a match
         */
        foundPatternCross(stateCount) {
            const moduleSize = this.moduleSize;
            const maxVariance = moduleSize / 2.0;
            for (let i = 0; i < 3; i++) {
                if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {
                    return false;
                }
            }
            return true;
        }
        /**
         * <p>After a horizontal scan finds a potential alignment pattern, this method
         * "cross-checks" by scanning down vertically through the center of the possible
         * alignment pattern to see if the same proportion is detected.</p>
         *
         * @param startI row where an alignment pattern was detected
         * @param centerJ center of the section that appears to cross an alignment pattern
         * @param maxCount maximum reasonable number of modules that should be
         * observed in any reading state, based on the results of the horizontal scan
         * @return vertical center of alignment pattern, or {@link Float#NaN} if not found
         */
        crossCheckVertical(startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {
            const image = this.image;
            const maxI = image.getHeight();
            const stateCount = this.crossCheckStateCount;
            stateCount[0] = 0;
            stateCount[1] = 0;
            stateCount[2] = 0;
            // Start counting up from center
            let i = startI;
            while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {
                stateCount[1]++;
                i--;
            }
            // If already too many modules in this state or ran off the edge:
            if (i < 0 || stateCount[1] > maxCount) {
                return NaN;
            }
            while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {
                stateCount[0]++;
                i--;
            }
            if (stateCount[0] > maxCount) {
                return NaN;
            }
            // Now also count down from center
            i = startI + 1;
            while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {
                stateCount[1]++;
                i++;
            }
            if (i === maxI || stateCount[1] > maxCount) {
                return NaN;
            }
            while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {
                stateCount[2]++;
                i++;
            }
            if (stateCount[2] > maxCount) {
                return NaN;
            }
            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
            if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
                return NaN;
            }
            return this.foundPatternCross(stateCount) ? AlignmentPatternFinder.centerFromEnd(stateCount, i) : NaN;
        }
        /**
         * <p>This is called when a horizontal scan finds a possible alignment pattern. It will
         * cross check with a vertical scan, and if successful, will see if this pattern had been
         * found on a previous horizontal scan. If so, we consider it confirmed and conclude we have
         * found the alignment pattern.</p>
         *
         * @param stateCount reading state module counts from horizontal scan
         * @param i row where alignment pattern may be found
         * @param j end of possible alignment pattern in row
         * @return {@link AlignmentPattern} if we have found the same pattern twice, or null if not
         */
        handlePossibleCenter(stateCount, i /*int*/, j /*int*/) {
            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
            const centerJ = AlignmentPatternFinder.centerFromEnd(stateCount, j);
            const centerI = this.crossCheckVertical(i, /*(int) */ centerJ, 2 * stateCount[1], stateCountTotal);
            if (!isNaN(centerI)) {
                const estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;
                for (const center of this.possibleCenters) {
                    // Look for about the same center and module size:
                    if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                        return center.combineEstimate(centerI, centerJ, estimatedModuleSize);
                    }
                }
                // Hadn't found this before; save it
                const point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);
                this.possibleCenters.push(point);
                if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {
                    this.resultPointCallback.foundPossibleResultPoint(point);
                }
            }
            return null;
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Encapsulates a finder pattern, which are the three square patterns found in
     * the corners of QR Codes. It also encapsulates a count of similar finder patterns,
     * as a convenience to the finder's bookkeeping.</p>
     *
     * @author Sean Owen
     */
    class FinderPattern$1 extends ResultPoint {
        // FinderPattern(posX: number/*float*/, posY: number/*float*/, estimatedModuleSize: number/*float*/) {
        //   this(posX, posY, estimatedModuleSize, 1)
        // }
        constructor(posX /*float*/, posY /*float*/, estimatedModuleSize /*float*/, count /*int*/) {
            super(posX, posY);
            this.estimatedModuleSize = estimatedModuleSize;
            this.count = count;
            if (undefined === count) {
                this.count = 1;
            }
        }
        getEstimatedModuleSize() {
            return this.estimatedModuleSize;
        }
        getCount() {
            return this.count;
        }
        /*
        void incrementCount() {
          this.count++
        }
         */
        /**
         * <p>Determines if this finder pattern "about equals" a finder pattern at the stated
         * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>
         */
        aboutEquals(moduleSize /*float*/, i /*float*/, j /*float*/) {
            if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {
                const moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
                return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;
            }
            return false;
        }
        /**
         * Combines this object's current estimate of a finder pattern position and module size
         * with a new estimate. It returns a new {@code FinderPattern} containing a weighted average
         * based on count.
         */
        combineEstimate(i /*float*/, j /*float*/, newModuleSize /*float*/) {
            const combinedCount = this.count + 1;
            const combinedX = (this.count * this.getX() + j) / combinedCount;
            const combinedY = (this.count * this.getY() + i) / combinedCount;
            const combinedModuleSize = (this.count * this.estimatedModuleSize + newModuleSize) / combinedCount;
            return new FinderPattern$1(combinedX, combinedY, combinedModuleSize, combinedCount);
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Encapsulates information about finder patterns in an image, including the location of
     * the three finder patterns, and their estimated module size.</p>
     *
     * @author Sean Owen
     */
    class FinderPatternInfo {
        constructor(patternCenters) {
            this.bottomLeft = patternCenters[0];
            this.topLeft = patternCenters[1];
            this.topRight = patternCenters[2];
        }
        getBottomLeft() {
            return this.bottomLeft;
        }
        getTopLeft() {
            return this.topLeft;
        }
        getTopRight() {
            return this.topRight;
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*import java.io.Serializable;*/
    /*import java.util.ArrayList;*/
    /*import java.util.Collections;*/
    /*import java.util.Comparator;*/
    /*import java.util.List;*/
    /*import java.util.Map;*/
    /**
     * <p>This class attempts to find finder patterns in a QR Code. Finder patterns are the square
     * markers at three corners of a QR Code.</p>
     *
     * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.
     *
     * @author Sean Owen
     */
    class FinderPatternFinder {
        /**
         * <p>Creates a finder that will search the image for three finder patterns.</p>
         *
         * @param image image to search
         */
        // public constructor(image: BitMatrix) {
        //   this(image, null)
        // }
        constructor(image, resultPointCallback) {
            this.image = image;
            this.resultPointCallback = resultPointCallback;
            this.possibleCenters = [];
            this.crossCheckStateCount = new Int32Array(5);
            this.resultPointCallback = resultPointCallback;
        }
        getImage() {
            return this.image;
        }
        getPossibleCenters() {
            return this.possibleCenters;
        }
        find(hints) {
            const tryHarder = (hints !== null && hints !== undefined) && undefined !== hints.get(DecodeHintType$1.TRY_HARDER);
            const pureBarcode = (hints !== null && hints !== undefined) && undefined !== hints.get(DecodeHintType$1.PURE_BARCODE);
            const image = this.image;
            const maxI = image.getHeight();
            const maxJ = image.getWidth();
            // We are looking for black/white/black/white/black modules in
            // 1:1:3:1:1 ratio; this tracks the number of such modules seen so far
            // Let's assume that the maximum version QR Code we support takes up 1/4 the height of the
            // image, and then account for the center being 3 modules in size. This gives the smallest
            // number of pixels the center could be, so skip this often. When trying harder, look for all
            // QR versions regardless of how dense they are.
            let iSkip = Math.floor((3 * maxI) / (4 * FinderPatternFinder.MAX_MODULES));
            if (iSkip < FinderPatternFinder.MIN_SKIP || tryHarder) {
                iSkip = FinderPatternFinder.MIN_SKIP;
            }
            let done = false;
            const stateCount = new Int32Array(5);
            for (let i = iSkip - 1; i < maxI && !done; i += iSkip) {
                // Get a row of black/white values
                stateCount[0] = 0;
                stateCount[1] = 0;
                stateCount[2] = 0;
                stateCount[3] = 0;
                stateCount[4] = 0;
                let currentState = 0;
                for (let j = 0; j < maxJ; j++) {
                    if (image.get(j, i)) {
                        // Black pixel
                        if ((currentState & 1) === 1) { // Counting white pixels
                            currentState++;
                        }
                        stateCount[currentState]++;
                    }
                    else { // White pixel
                        if ((currentState & 1) === 0) { // Counting black pixels
                            if (currentState === 4) { // A winner?
                                if (FinderPatternFinder.foundPatternCross(stateCount)) { // Yes
                                    const confirmed = this.handlePossibleCenter(stateCount, i, j, pureBarcode);
                                    if (confirmed === true) {
                                        // Start examining every other line. Checking each line turned out to be too
                                        // expensive and didn't improve performance.
                                        iSkip = 2;
                                        if (this.hasSkipped === true) {
                                            done = this.haveMultiplyConfirmedCenters();
                                        }
                                        else {
                                            const rowSkip = this.findRowSkip();
                                            if (rowSkip > stateCount[2]) {
                                                // Skip rows between row of lower confirmed center
                                                // and top of presumed third confirmed center
                                                // but back up a bit to get a full chance of detecting
                                                // it, entire width of center of finder pattern
                                                // Skip by rowSkip, but back off by stateCount[2] (size of last center
                                                // of pattern we saw) to be conservative, and also back off by iSkip which
                                                // is about to be re-added
                                                i += rowSkip - stateCount[2] - iSkip;
                                                j = maxJ - 1;
                                            }
                                        }
                                    }
                                    else {
                                        stateCount[0] = stateCount[2];
                                        stateCount[1] = stateCount[3];
                                        stateCount[2] = stateCount[4];
                                        stateCount[3] = 1;
                                        stateCount[4] = 0;
                                        currentState = 3;
                                        continue;
                                    }
                                    // Clear state to start looking again
                                    currentState = 0;
                                    stateCount[0] = 0;
                                    stateCount[1] = 0;
                                    stateCount[2] = 0;
                                    stateCount[3] = 0;
                                    stateCount[4] = 0;
                                }
                                else { // No, shift counts back by two
                                    stateCount[0] = stateCount[2];
                                    stateCount[1] = stateCount[3];
                                    stateCount[2] = stateCount[4];
                                    stateCount[3] = 1;
                                    stateCount[4] = 0;
                                    currentState = 3;
                                }
                            }
                            else {
                                stateCount[++currentState]++;
                            }
                        }
                        else { // Counting white pixels
                            stateCount[currentState]++;
                        }
                    }
                }
                if (FinderPatternFinder.foundPatternCross(stateCount)) {
                    const confirmed = this.handlePossibleCenter(stateCount, i, maxJ, pureBarcode);
                    if (confirmed === true) {
                        iSkip = stateCount[0];
                        if (this.hasSkipped) {
                            // Found a third one
                            done = this.haveMultiplyConfirmedCenters();
                        }
                    }
                }
            }
            const patternInfo = this.selectBestPatterns();
            ResultPoint.orderBestPatterns(patternInfo);
            return new FinderPatternInfo(patternInfo);
        }
        /**
         * Given a count of black/white/black/white/black pixels just seen and an end position,
         * figures the location of the center of this run.
         */
        static centerFromEnd(stateCount, end /*int*/) {
            return (end - stateCount[4] - stateCount[3]) - stateCount[2] / 2.0;
        }
        /**
         * @param stateCount count of black/white/black/white/black pixels just read
         * @return true iff the proportions of the counts is close enough to the 1/1/3/1/1 ratios
         *         used by finder patterns to be considered a match
         */
        static foundPatternCross(stateCount) {
            let totalModuleSize = 0;
            for (let i = 0; i < 5; i++) {
                const count = stateCount[i];
                if (count === 0) {
                    return false;
                }
                totalModuleSize += count;
            }
            if (totalModuleSize < 7) {
                return false;
            }
            const moduleSize = totalModuleSize / 7.0;
            const maxVariance = moduleSize / 2.0;
            // Allow less than 50% variance from 1-1-3-1-1 proportions
            return Math.abs(moduleSize - stateCount[0]) < maxVariance &&
                Math.abs(moduleSize - stateCount[1]) < maxVariance &&
                Math.abs(3.0 * moduleSize - stateCount[2]) < 3 * maxVariance &&
                Math.abs(moduleSize - stateCount[3]) < maxVariance &&
                Math.abs(moduleSize - stateCount[4]) < maxVariance;
        }
        getCrossCheckStateCount() {
            const crossCheckStateCount = this.crossCheckStateCount;
            crossCheckStateCount[0] = 0;
            crossCheckStateCount[1] = 0;
            crossCheckStateCount[2] = 0;
            crossCheckStateCount[3] = 0;
            crossCheckStateCount[4] = 0;
            return crossCheckStateCount;
        }
        /**
         * After a vertical and horizontal scan finds a potential finder pattern, this method
         * "cross-cross-cross-checks" by scanning down diagonally through the center of the possible
         * finder pattern to see if the same proportion is detected.
         *
         * @param startI row where a finder pattern was detected
         * @param centerJ center of the section that appears to cross a finder pattern
         * @param maxCount maximum reasonable number of modules that should be
         *  observed in any reading state, based on the results of the horizontal scan
         * @param originalStateCountTotal The original state count total.
         * @return true if proportions are withing expected limits
         */
        crossCheckDiagonal(startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {
            const stateCount = this.getCrossCheckStateCount();
            // Start counting up, left from center finding black center mass
            let i = 0;
            const image = this.image;
            while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i)) {
                stateCount[2]++;
                i++;
            }
            if (startI < i || centerJ < i) {
                return false;
            }
            // Continue up, left finding white space
            while (startI >= i && centerJ >= i && !image.get(centerJ - i, startI - i) &&
            stateCount[1] <= maxCount) {
                stateCount[1]++;
                i++;
            }
            // If already too many modules in this state or ran off the edge:
            if (startI < i || centerJ < i || stateCount[1] > maxCount) {
                return false;
            }
            // Continue up, left finding black border
            while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i) &&
            stateCount[0] <= maxCount) {
                stateCount[0]++;
                i++;
            }
            if (stateCount[0] > maxCount) {
                return false;
            }
            const maxI = image.getHeight();
            const maxJ = image.getWidth();
            // Now also count down, right from center
            i = 1;
            while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i)) {
                stateCount[2]++;
                i++;
            }
            // Ran off the edge?
            if (startI + i >= maxI || centerJ + i >= maxJ) {
                return false;
            }
            while (startI + i < maxI && centerJ + i < maxJ && !image.get(centerJ + i, startI + i) &&
            stateCount[3] < maxCount) {
                stateCount[3]++;
                i++;
            }
            if (startI + i >= maxI || centerJ + i >= maxJ || stateCount[3] >= maxCount) {
                return false;
            }
            while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i) &&
            stateCount[4] < maxCount) {
                stateCount[4]++;
                i++;
            }
            if (stateCount[4] >= maxCount) {
                return false;
            }
            // If we found a finder-pattern-like section, but its size is more than 100% different than
            // the original, assume it's a false positive
            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
            return Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal &&
                FinderPatternFinder.foundPatternCross(stateCount);
        }
        /**
         * <p>After a horizontal scan finds a potential finder pattern, this method
         * "cross-checks" by scanning down vertically through the center of the possible
         * finder pattern to see if the same proportion is detected.</p>
         *
         * @param startI row where a finder pattern was detected
         * @param centerJ center of the section that appears to cross a finder pattern
         * @param maxCount maximum reasonable number of modules that should be
         * observed in any reading state, based on the results of the horizontal scan
         * @return vertical center of finder pattern, or {@link Float#NaN} if not found
         */
        crossCheckVertical(startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {
            const image = this.image;
            const maxI = image.getHeight();
            const stateCount = this.getCrossCheckStateCount();
            // Start counting up from center
            let i = startI;
            while (i >= 0 && image.get(centerJ, i)) {
                stateCount[2]++;
                i--;
            }
            if (i < 0) {
                return NaN;
            }
            while (i >= 0 && !image.get(centerJ, i) && stateCount[1] <= maxCount) {
                stateCount[1]++;
                i--;
            }
            // If already too many modules in this state or ran off the edge:
            if (i < 0 || stateCount[1] > maxCount) {
                return NaN;
            }
            while (i >= 0 && image.get(centerJ, i) && stateCount[0] <= maxCount) {
                stateCount[0]++;
                i--;
            }
            if (stateCount[0] > maxCount) {
                return NaN;
            }
            // Now also count down from center
            i = startI + 1;
            while (i < maxI && image.get(centerJ, i)) {
                stateCount[2]++;
                i++;
            }
            if (i === maxI) {
                return NaN;
            }
            while (i < maxI && !image.get(centerJ, i) && stateCount[3] < maxCount) {
                stateCount[3]++;
                i++;
            }
            if (i === maxI || stateCount[3] >= maxCount) {
                return NaN;
            }
            while (i < maxI && image.get(centerJ, i) && stateCount[4] < maxCount) {
                stateCount[4]++;
                i++;
            }
            if (stateCount[4] >= maxCount) {
                return NaN;
            }
            // If we found a finder-pattern-like section, but its size is more than 40% different than
            // the original, assume it's a false positive
            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +
                stateCount[4];
            if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
                return NaN;
            }
            return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, i) : NaN;
        }
        /**
         * <p>Like {@link #crossCheckVertical(int, int, int, int)}, and in fact is basically identical,
         * except it reads horizontally instead of vertically. This is used to cross-cross
         * check a vertical cross check and locate the real center of the alignment pattern.</p>
         */
        crossCheckHorizontal(startJ /*int*/, centerI /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {
            const image = this.image;
            const maxJ = image.getWidth();
            const stateCount = this.getCrossCheckStateCount();
            let j = startJ;
            while (j >= 0 && image.get(j, centerI)) {
                stateCount[2]++;
                j--;
            }
            if (j < 0) {
                return NaN;
            }
            while (j >= 0 && !image.get(j, centerI) && stateCount[1] <= maxCount) {
                stateCount[1]++;
                j--;
            }
            if (j < 0 || stateCount[1] > maxCount) {
                return NaN;
            }
            while (j >= 0 && image.get(j, centerI) && stateCount[0] <= maxCount) {
                stateCount[0]++;
                j--;
            }
            if (stateCount[0] > maxCount) {
                return NaN;
            }
            j = startJ + 1;
            while (j < maxJ && image.get(j, centerI)) {
                stateCount[2]++;
                j++;
            }
            if (j === maxJ) {
                return NaN;
            }
            while (j < maxJ && !image.get(j, centerI) && stateCount[3] < maxCount) {
                stateCount[3]++;
                j++;
            }
            if (j === maxJ || stateCount[3] >= maxCount) {
                return NaN;
            }
            while (j < maxJ && image.get(j, centerI) && stateCount[4] < maxCount) {
                stateCount[4]++;
                j++;
            }
            if (stateCount[4] >= maxCount) {
                return NaN;
            }
            // If we found a finder-pattern-like section, but its size is significantly different than
            // the original, assume it's a false positive
            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +
                stateCount[4];
            if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {
                return NaN;
            }
            return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, j) : NaN;
        }
        /**
         * <p>This is called when a horizontal scan finds a possible alignment pattern. It will
         * cross check with a vertical scan, and if successful, will, ah, cross-cross-check
         * with another horizontal scan. This is needed primarily to locate the real horizontal
         * center of the pattern in cases of extreme skew.
         * And then we cross-cross-cross check with another diagonal scan.</p>
         *
         * <p>If that succeeds the finder pattern location is added to a list that tracks
         * the number of times each location has been nearly-matched as a finder pattern.
         * Each additional find is more evidence that the location is in fact a finder
         * pattern center
         *
         * @param stateCount reading state module counts from horizontal scan
         * @param i row where finder pattern may be found
         * @param j end of possible finder pattern in row
         * @param pureBarcode true if in "pure barcode" mode
         * @return true if a finder pattern candidate was found this time
         */
        handlePossibleCenter(stateCount, i /*int*/, j /*int*/, pureBarcode) {
            const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +
                stateCount[4];
            let centerJ = FinderPatternFinder.centerFromEnd(stateCount, j);
            let centerI = this.crossCheckVertical(i, /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal);
            if (!isNaN(centerI)) {
                // Re-cross check
                centerJ = this.crossCheckHorizontal(/*(int) */ Math.floor(centerJ), /*(int) */ Math.floor(centerI), stateCount[2], stateCountTotal);
                if (!isNaN(centerJ) &&
                    (!pureBarcode || this.crossCheckDiagonal(/*(int) */ Math.floor(centerI), /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal))) {
                    const estimatedModuleSize = stateCountTotal / 7.0;
                    let found = false;
                    const possibleCenters = this.possibleCenters;
                    for (let index = 0, length = possibleCenters.length; index < length; index++) {
                        const center = possibleCenters[index];
                        // Look for about the same center and module size:
                        if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                            possibleCenters[index] = center.combineEstimate(centerI, centerJ, estimatedModuleSize);
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        const point = new FinderPattern$1(centerJ, centerI, estimatedModuleSize);
                        possibleCenters.push(point);
                        if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {
                            this.resultPointCallback.foundPossibleResultPoint(point);
                        }
                    }
                    return true;
                }
            }
            return false;
        }
        /**
         * @return number of rows we could safely skip during scanning, based on the first
         *         two finder patterns that have been located. In some cases their position will
         *         allow us to infer that the third pattern must lie below a certain point farther
         *         down in the image.
         */
        findRowSkip() {
            const max = this.possibleCenters.length;
            if (max <= 1) {
                return 0;
            }
            let firstConfirmedCenter = null;
            for (const center of this.possibleCenters) {
                if (center.getCount() >= FinderPatternFinder.CENTER_QUORUM) {
                    if (firstConfirmedCenter == null) {
                        firstConfirmedCenter = center;
                    }
                    else {
                        // We have two confirmed centers
                        // How far down can we skip before resuming looking for the next
                        // pattern? In the worst case, only the difference between the
                        // difference in the x / y coordinates of the two centers.
                        // This is the case where you find top left last.
                        this.hasSkipped = true;
                        return /*(int) */ Math.floor((Math.abs(firstConfirmedCenter.getX() - center.getX()) -
                            Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2);
                    }
                }
            }
            return 0;
        }
        /**
         * @return true iff we have found at least 3 finder patterns that have been detected
         *         at least {@link #CENTER_QUORUM} times each, and, the estimated module size of the
         *         candidates is "pretty similar"
         */
        haveMultiplyConfirmedCenters() {
            let confirmedCount = 0;
            let totalModuleSize = 0.0;
            const max = this.possibleCenters.length;
            for (const pattern of this.possibleCenters) {
                if (pattern.getCount() >= FinderPatternFinder.CENTER_QUORUM) {
                    confirmedCount++;
                    totalModuleSize += pattern.getEstimatedModuleSize();
                }
            }
            if (confirmedCount < 3) {
                return false;
            }
            // OK, we have at least 3 confirmed centers, but, it's possible that one is a "false positive"
            // and that we need to keep looking. We detect this by asking if the estimated module sizes
            // vary too much. We arbitrarily say that when the total deviation from average exceeds
            // 5% of the total module size estimates, it's too much.
            const average = totalModuleSize / max;
            let totalDeviation = 0.0;
            for (const pattern of this.possibleCenters) {
                totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);
            }
            return totalDeviation <= 0.05 * totalModuleSize;
        }
        /**
         * @return the 3 best {@link FinderPattern}s from our list of candidates. The "best" are
         *         those that have been detected at least {@link #CENTER_QUORUM} times, and whose module
         *         size differs from the average among those patterns the least
         * @throws NotFoundException if 3 such finder patterns do not exist
         */
        selectBestPatterns() {
            const startSize = this.possibleCenters.length;
            if (startSize < 3) {
                // Couldn't find enough finder patterns
                throw new NotFoundException();
            }
            const possibleCenters = this.possibleCenters;
            let average;
            // Filter outlier possibilities whose module size is too different
            if (startSize > 3) {
                // But we can only afford to do so if we have at least 4 possibilities to choose from
                let totalModuleSize = 0.0;
                let square = 0.0;
                for (const center of this.possibleCenters) {
                    const size = center.getEstimatedModuleSize();
                    totalModuleSize += size;
                    square += size * size;
                }
                average = totalModuleSize / startSize;
                let stdDev = Math.sqrt(square / startSize - average * average);
                possibleCenters.sort(
                    /**
                     * <p>Orders by furthest from average</p>
                     */
                        // FurthestFromAverageComparator implements Comparator<FinderPattern>
                    (center1, center2) => {
                        const dA = Math.abs(center2.getEstimatedModuleSize() - average);
                        const dB = Math.abs(center1.getEstimatedModuleSize() - average);
                        return dA < dB ? -1 : dA > dB ? 1 : 0;
                    });
                const limit = Math.max(0.2 * average, stdDev);
                for (let i = 0; i < possibleCenters.length && possibleCenters.length > 3; i++) {
                    const pattern = possibleCenters[i];
                    if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {
                        possibleCenters.splice(i, 1);
                        i--;
                    }
                }
            }
            if (possibleCenters.length > 3) {
                // Throw away all but those first size candidate points we found.
                let totalModuleSize = 0.0;
                for (const possibleCenter of possibleCenters) {
                    totalModuleSize += possibleCenter.getEstimatedModuleSize();
                }
                average = totalModuleSize / possibleCenters.length;
                possibleCenters.sort(
                    /**
                     * <p>Orders by {@link FinderPattern#getCount()}, descending.</p>
                     */
                        // CenterComparator implements Comparator<FinderPattern>
                    (center1, center2) => {
                        if (center2.getCount() === center1.getCount()) {
                            const dA = Math.abs(center2.getEstimatedModuleSize() - average);
                            const dB = Math.abs(center1.getEstimatedModuleSize() - average);
                            return dA < dB ? 1 : dA > dB ? -1 : 0;
                        }
                        else {
                            return center2.getCount() - center1.getCount();
                        }
                    });
                possibleCenters.splice(3); // this is not realy necessary as we only return first 3 anyway
            }
            return [
                possibleCenters[0],
                possibleCenters[1],
                possibleCenters[2]
            ];
        }
    }
    FinderPatternFinder.CENTER_QUORUM = 2;
    FinderPatternFinder.MIN_SKIP = 3; // 1 pixel/module times 3 modules/center
    FinderPatternFinder.MAX_MODULES = 57; // support up to version 10 for mobile clients

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*import java.util.Map;*/
    /**
     * <p>Encapsulates logic that can detect a QR Code in an image, even if the QR Code
     * is rotated or skewed, or partially obscured.</p>
     *
     * @author Sean Owen
     */
    class Detector$2 {
        constructor(image) {
            this.image = image;
        }
        getImage() {
            return this.image;
        }
        getResultPointCallback() {
            return this.resultPointCallback;
        }
        /**
         * <p>Detects a QR Code in an image.</p>
         *
         * @return {@link DetectorResult} encapsulating results of detecting a QR Code
         * @throws NotFoundException if QR Code cannot be found
         * @throws FormatException if a QR Code cannot be decoded
         */
        // public detect(): DetectorResult /*throws NotFoundException, FormatException*/ {
        //   return detect(null)
        // }
        /**
         * <p>Detects a QR Code in an image.</p>
         *
         * @param hints optional hints to detector
         * @return {@link DetectorResult} encapsulating results of detecting a QR Code
         * @throws NotFoundException if QR Code cannot be found
         * @throws FormatException if a QR Code cannot be decoded
         */
        detect(hints) {
            this.resultPointCallback = (hints === null || hints === undefined) ? null :
                /*(ResultPointCallback) */ hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
            const finder = new FinderPatternFinder(this.image, this.resultPointCallback);
            const info = finder.find(hints);
            return this.processFinderPatternInfo(info);
        }
        processFinderPatternInfo(info) {
            const topLeft = info.getTopLeft();
            const topRight = info.getTopRight();
            const bottomLeft = info.getBottomLeft();
            const moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);
            if (moduleSize < 1.0) {
                throw new NotFoundException('No pattern found in proccess finder.');
            }
            const dimension = Detector$2.computeDimension(topLeft, topRight, bottomLeft, moduleSize);
            const provisionalVersion = Version$1.getProvisionalVersionForDimension(dimension);
            const modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;
            let alignmentPattern = null;
            // Anything above version 1 has an alignment pattern
            if (provisionalVersion.getAlignmentPatternCenters().length > 0) {
                // Guess where a "bottom right" finder pattern would have been
                const bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
                const bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();
                // Estimate that alignment pattern is closer by 3 modules
                // from "bottom right" to known top left location
                const correctionToTopLeft = 1.0 - 3.0 / modulesBetweenFPCenters;
                const estAlignmentX = /*(int) */ Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));
                const estAlignmentY = /*(int) */ Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));
                // Kind of arbitrary -- expand search radius before giving up
                for (let i = 4; i <= 16; i <<= 1) {
                    try {
                        alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);
                        break;
                    }
                    catch (re /*NotFoundException*/) {
                        if (!(re instanceof NotFoundException)) {
                            throw re;
                        }
                        // try next round
                    }
                }
                // If we didn't find alignment pattern... well try anyway without it
            }
            const transform = Detector$2.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);
            const bits = Detector$2.sampleGrid(this.image, transform, dimension);
            let points;
            if (alignmentPattern === null) {
                points = [bottomLeft, topLeft, topRight];
            }
            else {
                points = [bottomLeft, topLeft, topRight, alignmentPattern];
            }
            return new DetectorResult(bits, points);
        }
        static createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension /*int*/) {
            const dimMinusThree = dimension - 3.5;
            let bottomRightX; /*float*/
            let bottomRightY; /*float*/
            let sourceBottomRightX; /*float*/
            let sourceBottomRightY; /*float*/
            if (alignmentPattern !== null) {
                bottomRightX = alignmentPattern.getX();
                bottomRightY = alignmentPattern.getY();
                sourceBottomRightX = dimMinusThree - 3.0;
                sourceBottomRightY = sourceBottomRightX;
            }
            else {
                // Don't have an alignment pattern, just make up the bottom-right point
                bottomRightX = (topRight.getX() - topLeft.getX()) + bottomLeft.getX();
                bottomRightY = (topRight.getY() - topLeft.getY()) + bottomLeft.getY();
                sourceBottomRightX = dimMinusThree;
                sourceBottomRightY = dimMinusThree;
            }
            return PerspectiveTransform.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());
        }
        static sampleGrid(image, transform, dimension /*int*/) {
            const sampler = GridSamplerInstance.getInstance();
            return sampler.sampleGridWithTransform(image, dimension, dimension, transform);
        }
        /**
         * <p>Computes the dimension (number of modules on a size) of the QR Code based on the position
         * of the finder patterns and estimated module size.</p>
         */
        static computeDimension(topLeft, topRight, bottomLeft, moduleSize /*float*/) {
            const tltrCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, topRight) / moduleSize);
            const tlblCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, bottomLeft) / moduleSize);
            let dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;
            switch (dimension & 0x03) { // mod 4
                case 0:
                    dimension++;
                    break;
                // 1? do nothing
                case 2:
                    dimension--;
                    break;
                case 3:
                    throw new NotFoundException('Dimensions could be not found.');
            }
            return dimension;
        }
        /**
         * <p>Computes an average estimated module size based on estimated derived from the positions
         * of the three finder patterns.</p>
         *
         * @param topLeft detected top-left finder pattern center
         * @param topRight detected top-right finder pattern center
         * @param bottomLeft detected bottom-left finder pattern center
         * @return estimated module size
         */
        calculateModuleSize(topLeft, topRight, bottomLeft) {
            // Take the average
            return (this.calculateModuleSizeOneWay(topLeft, topRight) +
                this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;
        }
        /**
         * <p>Estimates module size based on two finder patterns -- it uses
         * {@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the
         * width of each, measuring along the axis between their centers.</p>
         */
        calculateModuleSizeOneWay(pattern, otherPattern) {
            const moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(pattern.getX()),
                /*(int) */ Math.floor(pattern.getY()),
                /*(int) */ Math.floor(otherPattern.getX()),
                /*(int) */ Math.floor(otherPattern.getY()));
            const moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(otherPattern.getX()),
                /*(int) */ Math.floor(otherPattern.getY()),
                /*(int) */ Math.floor(pattern.getX()),
                /*(int) */ Math.floor(pattern.getY()));
            if (isNaN(moduleSizeEst1)) {
                return moduleSizeEst2 / 7.0;
            }
            if (isNaN(moduleSizeEst2)) {
                return moduleSizeEst1 / 7.0;
            }
            // Average them, and divide by 7 since we've counted the width of 3 black modules,
            // and 1 white and 1 black module on either side. Ergo, divide sum by 14.
            return (moduleSizeEst1 + moduleSizeEst2) / 14.0;
        }
        /**
         * See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of
         * a finder pattern by looking for a black-white-black run from the center in the direction
         * of another point (another finder pattern center), and in the opposite direction too.
         */
        sizeOfBlackWhiteBlackRunBothWays(fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {
            let result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);
            // Now count other way -- don't run off image though of course
            let scale = 1.0;
            let otherToX = fromX - (toX - fromX);
            if (otherToX < 0) {
                scale = fromX / /*(float) */ (fromX - otherToX);
                otherToX = 0;
            }
            else if (otherToX >= this.image.getWidth()) {
                scale = (this.image.getWidth() - 1 - fromX) / /*(float) */ (otherToX - fromX);
                otherToX = this.image.getWidth() - 1;
            }
            let otherToY = /*(int) */ Math.floor(fromY - (toY - fromY) * scale);
            scale = 1.0;
            if (otherToY < 0) {
                scale = fromY / /*(float) */ (fromY - otherToY);
                otherToY = 0;
            }
            else if (otherToY >= this.image.getHeight()) {
                scale = (this.image.getHeight() - 1 - fromY) / /*(float) */ (otherToY - fromY);
                otherToY = this.image.getHeight() - 1;
            }
            otherToX = /*(int) */ Math.floor(fromX + (otherToX - fromX) * scale);
            result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);
            // Middle pixel is double-counted this way; subtract 1
            return result - 1.0;
        }
        /**
         * <p>This method traces a line from a point in the image, in the direction towards another point.
         * It begins in a black region, and keeps going until it finds white, then black, then white again.
         * It reports the distance from the start to this point.</p>
         *
         * <p>This is used when figuring out how wide a finder pattern is, when the finder pattern
         * may be skewed or rotated.</p>
         */
        sizeOfBlackWhiteBlackRun(fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {
            // Mild variant of Bresenham's algorithm
            // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm
            const steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
            if (steep) {
                let temp = fromX;
                fromX = fromY;
                fromY = temp;
                temp = toX;
                toX = toY;
                toY = temp;
            }
            const dx = Math.abs(toX - fromX);
            const dy = Math.abs(toY - fromY);
            let error = -dx / 2;
            const xstep = fromX < toX ? 1 : -1;
            const ystep = fromY < toY ? 1 : -1;
            // In black pixels, looking for white, first or second time.
            let state = 0;
            // Loop up until x == toX, but not beyond
            const xLimit = toX + xstep;
            for (let x = fromX, y = fromY; x !== xLimit; x += xstep) {
                const realX = steep ? y : x;
                const realY = steep ? x : y;
                // Does current pixel mean we have moved white to black or vice versa?
                // Scanning black in state 0,2 and white in state 1, so if we find the wrong
                // color, advance to next state or end if we are in state 2 already
                if ((state === 1) === this.image.get(realX, realY)) {
                    if (state === 2) {
                        return MathUtils.distance(x, y, fromX, fromY);
                    }
                    state++;
                }
                error += dy;
                if (error > 0) {
                    if (y === toY) {
                        break;
                    }
                    y += ystep;
                    error -= dx;
                }
            }
            // Found black-white-black; give the benefit of the doubt that the next pixel outside the image
            // is "white" so this last point at (toX+xStep,toY) is the right ending. This is really a
            // small approximation; (toX+xStep,toY+yStep) might be really correct. Ignore this.
            if (state === 2) {
                return MathUtils.distance(toX + xstep, toY, fromX, fromY);
            }
            // else we didn't find even black-white-black; no estimate is really possible
            return NaN;
        }
        /**
         * <p>Attempts to locate an alignment pattern in a limited region of the image, which is
         * guessed to contain it. This method uses {@link AlignmentPattern}.</p>
         *
         * @param overallEstModuleSize estimated module size so far
         * @param estAlignmentX x coordinate of center of area probably containing alignment pattern
         * @param estAlignmentY y coordinate of above
         * @param allowanceFactor number of pixels in all directions to search from the center
         * @return {@link AlignmentPattern} if found, or null otherwise
         * @throws NotFoundException if an unexpected error occurs during detection
         */
        findAlignmentInRegion(overallEstModuleSize /*float*/, estAlignmentX /*int*/, estAlignmentY /*int*/, allowanceFactor /*float*/) {
            // Look for an alignment pattern (3 modules in size) around where it
            // should be
            const allowance = /*(int) */ Math.floor(allowanceFactor * overallEstModuleSize);
            const alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);
            const alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);
            if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {
                throw new NotFoundException('Alignment top exceeds estimated module size.');
            }
            const alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);
            const alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);
            if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {
                throw new NotFoundException('Alignment bottom exceeds estimated module size.');
            }
            const alignmentFinder = new AlignmentPatternFinder(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);
            return alignmentFinder.find();
        }
    }

    /*
     * Copyright 2007 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*import java.util.List;*/
    /*import java.util.Map;*/
    /**
     * This implementation can detect and decode QR Codes in an image.
     *
     * @author Sean Owen
     */
    class QRCodeReader {
        constructor() {
            this.decoder = new Decoder$2();
        }
        getDecoder() {
            return this.decoder;
        }
        /**
         * Locates and decodes a QR code in an image.
         *
         * @return a representing: string the content encoded by the QR code
         * @throws NotFoundException if a QR code cannot be found
         * @throws FormatException if a QR code cannot be decoded
         * @throws ChecksumException if error correction fails
         */
        /*@Override*/
        // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {
        //   return this.decode(image, null)
        // }
        /*@Override*/
        decode(image, hints) {
            let decoderResult;
            let points;
            if (hints !== undefined && hints !== null && undefined !== hints.get(DecodeHintType$1.PURE_BARCODE)) {
                const bits = QRCodeReader.extractPureBits(image.getBlackMatrix());
                decoderResult = this.decoder.decodeBitMatrix(bits, hints);
                points = QRCodeReader.NO_POINTS;
            }
            else {
                const detectorResult = new Detector$2(image.getBlackMatrix()).detect(hints);
                decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);
                points = detectorResult.getPoints();
            }
            // If the code was mirrored: swap the bottom-left and the top-right points.
            if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {
                decoderResult.getOther().applyMirroredCorrection(points);
            }
            const result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat$1.QR_CODE, undefined);
            const byteSegments = decoderResult.getByteSegments();
            if (byteSegments !== null) {
                result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);
            }
            const ecLevel = decoderResult.getECLevel();
            if (ecLevel !== null) {
                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);
            }
            if (decoderResult.hasStructuredAppend()) {
                result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());
                result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());
            }
            return result;
        }
        /*@Override*/
        reset() {
            // do nothing
        }
        /**
         * This method detects a code in a "pure" image -- that is, pure monochrome image
         * which contains only an unrotated, unskewed, image of a code, with some white border
         * around it. This is a specialized method that works exceptionally fast in this special
         * case.
         *
         * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)
         */
        static extractPureBits(image) {
            const leftTopBlack = image.getTopLeftOnBit();
            const rightBottomBlack = image.getBottomRightOnBit();
            if (leftTopBlack === null || rightBottomBlack === null) {
                throw new NotFoundException();
            }
            const moduleSize = this.moduleSize(leftTopBlack, image);
            let top = leftTopBlack[1];
            let bottom = rightBottomBlack[1];
            let left = leftTopBlack[0];
            let right = rightBottomBlack[0];
            // Sanity check!
            if (left >= right || top >= bottom) {
                throw new NotFoundException();
            }
            if (bottom - top !== right - left) {
                // Special case, where bottom-right module wasn't black so we found something else in the last row
                // Assume it's a square, so use height as the width
                right = left + (bottom - top);
                if (right >= image.getWidth()) {
                    // Abort if that would not make sense -- off image
                    throw new NotFoundException();
                }
            }
            const matrixWidth = Math.round((right - left + 1) / moduleSize);
            const matrixHeight = Math.round((bottom - top + 1) / moduleSize);
            if (matrixWidth <= 0 || matrixHeight <= 0) {
                throw new NotFoundException();
            }
            if (matrixHeight !== matrixWidth) {
                // Only possibly decode square regions
                throw new NotFoundException();
            }
            // Push in the "border" by half the module width so that we start
            // sampling in the middle of the module. Just in case the image is a
            // little off, this will help recover.
            const nudge = /*(int) */ Math.floor(moduleSize / 2.0);
            top += nudge;
            left += nudge;
            // But careful that this does not sample off the edge
            // "right" is the farthest-right valid pixel location -- right+1 is not necessarily
            // This is positive by how much the inner x loop below would be too large
            const nudgedTooFarRight = left + /*(int) */ Math.floor((matrixWidth - 1) * moduleSize) - right;
            if (nudgedTooFarRight > 0) {
                if (nudgedTooFarRight > nudge) {
                    // Neither way fits; abort
                    throw new NotFoundException();
                }
                left -= nudgedTooFarRight;
            }
            // See logic above
            const nudgedTooFarDown = top + /*(int) */ Math.floor((matrixHeight - 1) * moduleSize) - bottom;
            if (nudgedTooFarDown > 0) {
                if (nudgedTooFarDown > nudge) {
                    // Neither way fits; abort
                    throw new NotFoundException();
                }
                top -= nudgedTooFarDown;
            }
            // Now just read off the bits
            const bits = new BitMatrix(matrixWidth, matrixHeight);
            for (let y = 0; y < matrixHeight; y++) {
                const iOffset = top + /*(int) */ Math.floor(y * moduleSize);
                for (let x = 0; x < matrixWidth; x++) {
                    if (image.get(left + /*(int) */ Math.floor(x * moduleSize), iOffset)) {
                        bits.set(x, y);
                    }
                }
            }
            return bits;
        }
        static moduleSize(leftTopBlack, image) {
            const height = image.getHeight();
            const width = image.getWidth();
            let x = leftTopBlack[0];
            let y = leftTopBlack[1];
            let inBlack = true;
            let transitions = 0;
            while (x < width && y < height) {
                if (inBlack !== image.get(x, y)) {
                    if (++transitions === 5) {
                        break;
                    }
                    inBlack = !inBlack;
                }
                x++;
                y++;
            }
            if (x === width || y === height) {
                throw new NotFoundException();
            }
            return (x - leftTopBlack[0]) / 7.0;
        }
    }
    QRCodeReader.NO_POINTS = new Array();

    /*
    * Copyright 2009 ZXing authors
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    /**
     * @author SITA Lab (kevin.osullivan@sita.aero)
     * @author Guenther Grau
     */
    /*public final*/ class PDF417Common {
        PDF417Common() {
        }
        /**
         * @param moduleBitCount values to sum
         * @return sum of values
         * @deprecated call {@link MathUtils#sum(int[])}
         */
        // @Deprecated
        static getBitCountSum(moduleBitCount) {
            return MathUtils.sum(moduleBitCount);
        }
        static toIntArray(list) {
            if (list == null || !list.length) {
                return PDF417Common.EMPTY_INT_ARRAY;
            }
            const result = new Int32Array(list.length);
            let i = 0;
            for (const integer of list) {
                result[i++] = integer;
            }
            return result;
        }
        /**
         * @param symbol encoded symbol to translate to a codeword
         * @return the codeword corresponding to the symbol.
         */
        static getCodeword(symbol /*int*/) {
            const i = Arrays.binarySearch(PDF417Common.SYMBOL_TABLE, symbol & 0x3FFFF);
            if (i < 0) {
                return -1;
            }
            return (PDF417Common.CODEWORD_TABLE[i] - 1) % PDF417Common.NUMBER_OF_CODEWORDS;
        }
    }
    PDF417Common.NUMBER_OF_CODEWORDS = 929;
    // Maximum Codewords (Data + Error).
    PDF417Common.MAX_CODEWORDS_IN_BARCODE = PDF417Common.NUMBER_OF_CODEWORDS - 1;
    PDF417Common.MIN_ROWS_IN_BARCODE = 3;
    PDF417Common.MAX_ROWS_IN_BARCODE = 90;
    // One left row indication column + max 30 data columns + one right row indicator column
    // public static /*final*/ MAX_CODEWORDS_IN_ROW: /*int*/ number = 32;
    PDF417Common.MODULES_IN_CODEWORD = 17;
    PDF417Common.MODULES_IN_STOP_PATTERN = 18;
    PDF417Common.BARS_IN_MODULE = 8;
    PDF417Common.EMPTY_INT_ARRAY = new Int32Array([]);
    /**
     * The sorted table of all possible symbols. Extracted from the PDF417
     * specification. The index of a symbol in this table corresponds to the
     * index into the codeword table.
     */
    PDF417Common.SYMBOL_TABLE = Int32Array.from([
        0x1025e, 0x1027a, 0x1029e, 0x102bc, 0x102f2, 0x102f4, 0x1032e, 0x1034e, 0x1035c, 0x10396, 0x103a6, 0x103ac,
        0x10422, 0x10428, 0x10436, 0x10442, 0x10444, 0x10448, 0x10450, 0x1045e, 0x10466, 0x1046c, 0x1047a, 0x10482,
        0x1049e, 0x104a0, 0x104bc, 0x104c6, 0x104d8, 0x104ee, 0x104f2, 0x104f4, 0x10504, 0x10508, 0x10510, 0x1051e,
        0x10520, 0x1053c, 0x10540, 0x10578, 0x10586, 0x1058c, 0x10598, 0x105b0, 0x105be, 0x105ce, 0x105dc, 0x105e2,
        0x105e4, 0x105e8, 0x105f6, 0x1062e, 0x1064e, 0x1065c, 0x1068e, 0x1069c, 0x106b8, 0x106de, 0x106fa, 0x10716,
        0x10726, 0x1072c, 0x10746, 0x1074c, 0x10758, 0x1076e, 0x10792, 0x10794, 0x107a2, 0x107a4, 0x107a8, 0x107b6,
        0x10822, 0x10828, 0x10842, 0x10848, 0x10850, 0x1085e, 0x10866, 0x1086c, 0x1087a, 0x10882, 0x10884, 0x10890,
        0x1089e, 0x108a0, 0x108bc, 0x108c6, 0x108cc, 0x108d8, 0x108ee, 0x108f2, 0x108f4, 0x10902, 0x10908, 0x1091e,
        0x10920, 0x1093c, 0x10940, 0x10978, 0x10986, 0x10998, 0x109b0, 0x109be, 0x109ce, 0x109dc, 0x109e2, 0x109e4,
        0x109e8, 0x109f6, 0x10a08, 0x10a10, 0x10a1e, 0x10a20, 0x10a3c, 0x10a40, 0x10a78, 0x10af0, 0x10b06, 0x10b0c,
        0x10b18, 0x10b30, 0x10b3e, 0x10b60, 0x10b7c, 0x10b8e, 0x10b9c, 0x10bb8, 0x10bc2, 0x10bc4, 0x10bc8, 0x10bd0,
        0x10bde, 0x10be6, 0x10bec, 0x10c2e, 0x10c4e, 0x10c5c, 0x10c62, 0x10c64, 0x10c68, 0x10c76, 0x10c8e, 0x10c9c,
        0x10cb8, 0x10cc2, 0x10cc4, 0x10cc8, 0x10cd0, 0x10cde, 0x10ce6, 0x10cec, 0x10cfa, 0x10d0e, 0x10d1c, 0x10d38,
        0x10d70, 0x10d7e, 0x10d82, 0x10d84, 0x10d88, 0x10d90, 0x10d9e, 0x10da0, 0x10dbc, 0x10dc6, 0x10dcc, 0x10dd8,
        0x10dee, 0x10df2, 0x10df4, 0x10e16, 0x10e26, 0x10e2c, 0x10e46, 0x10e58, 0x10e6e, 0x10e86, 0x10e8c, 0x10e98,
        0x10eb0, 0x10ebe, 0x10ece, 0x10edc, 0x10f0a, 0x10f12, 0x10f14, 0x10f22, 0x10f28, 0x10f36, 0x10f42, 0x10f44,
        0x10f48, 0x10f50, 0x10f5e, 0x10f66, 0x10f6c, 0x10fb2, 0x10fb4, 0x11022, 0x11028, 0x11042, 0x11048, 0x11050,
        0x1105e, 0x1107a, 0x11082, 0x11084, 0x11090, 0x1109e, 0x110a0, 0x110bc, 0x110c6, 0x110cc, 0x110d8, 0x110ee,
        0x110f2, 0x110f4, 0x11102, 0x1111e, 0x11120, 0x1113c, 0x11140, 0x11178, 0x11186, 0x11198, 0x111b0, 0x111be,
        0x111ce, 0x111dc, 0x111e2, 0x111e4, 0x111e8, 0x111f6, 0x11208, 0x1121e, 0x11220, 0x11278, 0x112f0, 0x1130c,
        0x11330, 0x1133e, 0x11360, 0x1137c, 0x1138e, 0x1139c, 0x113b8, 0x113c2, 0x113c8, 0x113d0, 0x113de, 0x113e6,
        0x113ec, 0x11408, 0x11410, 0x1141e, 0x11420, 0x1143c, 0x11440, 0x11478, 0x114f0, 0x115e0, 0x1160c, 0x11618,
        0x11630, 0x1163e, 0x11660, 0x1167c, 0x116c0, 0x116f8, 0x1171c, 0x11738, 0x11770, 0x1177e, 0x11782, 0x11784,
        0x11788, 0x11790, 0x1179e, 0x117a0, 0x117bc, 0x117c6, 0x117cc, 0x117d8, 0x117ee, 0x1182e, 0x11834, 0x1184e,
        0x1185c, 0x11862, 0x11864, 0x11868, 0x11876, 0x1188e, 0x1189c, 0x118b8, 0x118c2, 0x118c8, 0x118d0, 0x118de,
        0x118e6, 0x118ec, 0x118fa, 0x1190e, 0x1191c, 0x11938, 0x11970, 0x1197e, 0x11982, 0x11984, 0x11990, 0x1199e,
        0x119a0, 0x119bc, 0x119c6, 0x119cc, 0x119d8, 0x119ee, 0x119f2, 0x119f4, 0x11a0e, 0x11a1c, 0x11a38, 0x11a70,
        0x11a7e, 0x11ae0, 0x11afc, 0x11b08, 0x11b10, 0x11b1e, 0x11b20, 0x11b3c, 0x11b40, 0x11b78, 0x11b8c, 0x11b98,
        0x11bb0, 0x11bbe, 0x11bce, 0x11bdc, 0x11be2, 0x11be4, 0x11be8, 0x11bf6, 0x11c16, 0x11c26, 0x11c2c, 0x11c46,
        0x11c4c, 0x11c58, 0x11c6e, 0x11c86, 0x11c98, 0x11cb0, 0x11cbe, 0x11cce, 0x11cdc, 0x11ce2, 0x11ce4, 0x11ce8,
        0x11cf6, 0x11d06, 0x11d0c, 0x11d18, 0x11d30, 0x11d3e, 0x11d60, 0x11d7c, 0x11d8e, 0x11d9c, 0x11db8, 0x11dc4,
        0x11dc8, 0x11dd0, 0x11dde, 0x11de6, 0x11dec, 0x11dfa, 0x11e0a, 0x11e12, 0x11e14, 0x11e22, 0x11e24, 0x11e28,
        0x11e36, 0x11e42, 0x11e44, 0x11e50, 0x11e5e, 0x11e66, 0x11e6c, 0x11e82, 0x11e84, 0x11e88, 0x11e90, 0x11e9e,
        0x11ea0, 0x11ebc, 0x11ec6, 0x11ecc, 0x11ed8, 0x11eee, 0x11f1a, 0x11f2e, 0x11f32, 0x11f34, 0x11f4e, 0x11f5c,
        0x11f62, 0x11f64, 0x11f68, 0x11f76, 0x12048, 0x1205e, 0x12082, 0x12084, 0x12090, 0x1209e, 0x120a0, 0x120bc,
        0x120d8, 0x120f2, 0x120f4, 0x12108, 0x1211e, 0x12120, 0x1213c, 0x12140, 0x12178, 0x12186, 0x12198, 0x121b0,
        0x121be, 0x121e2, 0x121e4, 0x121e8, 0x121f6, 0x12204, 0x12210, 0x1221e, 0x12220, 0x12278, 0x122f0, 0x12306,
        0x1230c, 0x12330, 0x1233e, 0x12360, 0x1237c, 0x1238e, 0x1239c, 0x123b8, 0x123c2, 0x123c8, 0x123d0, 0x123e6,
        0x123ec, 0x1241e, 0x12420, 0x1243c, 0x124f0, 0x125e0, 0x12618, 0x1263e, 0x12660, 0x1267c, 0x126c0, 0x126f8,
        0x12738, 0x12770, 0x1277e, 0x12782, 0x12784, 0x12790, 0x1279e, 0x127a0, 0x127bc, 0x127c6, 0x127cc, 0x127d8,
        0x127ee, 0x12820, 0x1283c, 0x12840, 0x12878, 0x128f0, 0x129e0, 0x12bc0, 0x12c18, 0x12c30, 0x12c3e, 0x12c60,
        0x12c7c, 0x12cc0, 0x12cf8, 0x12df0, 0x12e1c, 0x12e38, 0x12e70, 0x12e7e, 0x12ee0, 0x12efc, 0x12f04, 0x12f08,
        0x12f10, 0x12f20, 0x12f3c, 0x12f40, 0x12f78, 0x12f86, 0x12f8c, 0x12f98, 0x12fb0, 0x12fbe, 0x12fce, 0x12fdc,
        0x1302e, 0x1304e, 0x1305c, 0x13062, 0x13068, 0x1308e, 0x1309c, 0x130b8, 0x130c2, 0x130c8, 0x130d0, 0x130de,
        0x130ec, 0x130fa, 0x1310e, 0x13138, 0x13170, 0x1317e, 0x13182, 0x13184, 0x13190, 0x1319e, 0x131a0, 0x131bc,
        0x131c6, 0x131cc, 0x131d8, 0x131f2, 0x131f4, 0x1320e, 0x1321c, 0x13270, 0x1327e, 0x132e0, 0x132fc, 0x13308,
        0x1331e, 0x13320, 0x1333c, 0x13340, 0x13378, 0x13386, 0x13398, 0x133b0, 0x133be, 0x133ce, 0x133dc, 0x133e2,
        0x133e4, 0x133e8, 0x133f6, 0x1340e, 0x1341c, 0x13438, 0x13470, 0x1347e, 0x134e0, 0x134fc, 0x135c0, 0x135f8,
        0x13608, 0x13610, 0x1361e, 0x13620, 0x1363c, 0x13640, 0x13678, 0x136f0, 0x1370c, 0x13718, 0x13730, 0x1373e,
        0x13760, 0x1377c, 0x1379c, 0x137b8, 0x137c2, 0x137c4, 0x137c8, 0x137d0, 0x137de, 0x137e6, 0x137ec, 0x13816,
        0x13826, 0x1382c, 0x13846, 0x1384c, 0x13858, 0x1386e, 0x13874, 0x13886, 0x13898, 0x138b0, 0x138be, 0x138ce,
        0x138dc, 0x138e2, 0x138e4, 0x138e8, 0x13906, 0x1390c, 0x13930, 0x1393e, 0x13960, 0x1397c, 0x1398e, 0x1399c,
        0x139b8, 0x139c8, 0x139d0, 0x139de, 0x139e6, 0x139ec, 0x139fa, 0x13a06, 0x13a0c, 0x13a18, 0x13a30, 0x13a3e,
        0x13a60, 0x13a7c, 0x13ac0, 0x13af8, 0x13b0e, 0x13b1c, 0x13b38, 0x13b70, 0x13b7e, 0x13b88, 0x13b90, 0x13b9e,
        0x13ba0, 0x13bbc, 0x13bcc, 0x13bd8, 0x13bee, 0x13bf2, 0x13bf4, 0x13c12, 0x13c14, 0x13c22, 0x13c24, 0x13c28,
        0x13c36, 0x13c42, 0x13c48, 0x13c50, 0x13c5e, 0x13c66, 0x13c6c, 0x13c82, 0x13c84, 0x13c90, 0x13c9e, 0x13ca0,
        0x13cbc, 0x13cc6, 0x13ccc, 0x13cd8, 0x13cee, 0x13d02, 0x13d04, 0x13d08, 0x13d10, 0x13d1e, 0x13d20, 0x13d3c,
        0x13d40, 0x13d78, 0x13d86, 0x13d8c, 0x13d98, 0x13db0, 0x13dbe, 0x13dce, 0x13ddc, 0x13de4, 0x13de8, 0x13df6,
        0x13e1a, 0x13e2e, 0x13e32, 0x13e34, 0x13e4e, 0x13e5c, 0x13e62, 0x13e64, 0x13e68, 0x13e76, 0x13e8e, 0x13e9c,
        0x13eb8, 0x13ec2, 0x13ec4, 0x13ec8, 0x13ed0, 0x13ede, 0x13ee6, 0x13eec, 0x13f26, 0x13f2c, 0x13f3a, 0x13f46,
        0x13f4c, 0x13f58, 0x13f6e, 0x13f72, 0x13f74, 0x14082, 0x1409e, 0x140a0, 0x140bc, 0x14104, 0x14108, 0x14110,
        0x1411e, 0x14120, 0x1413c, 0x14140, 0x14178, 0x1418c, 0x14198, 0x141b0, 0x141be, 0x141e2, 0x141e4, 0x141e8,
        0x14208, 0x14210, 0x1421e, 0x14220, 0x1423c, 0x14240, 0x14278, 0x142f0, 0x14306, 0x1430c, 0x14318, 0x14330,
        0x1433e, 0x14360, 0x1437c, 0x1438e, 0x143c2, 0x143c4, 0x143c8, 0x143d0, 0x143e6, 0x143ec, 0x14408, 0x14410,
        0x1441e, 0x14420, 0x1443c, 0x14440, 0x14478, 0x144f0, 0x145e0, 0x1460c, 0x14618, 0x14630, 0x1463e, 0x14660,
        0x1467c, 0x146c0, 0x146f8, 0x1471c, 0x14738, 0x14770, 0x1477e, 0x14782, 0x14784, 0x14788, 0x14790, 0x147a0,
        0x147bc, 0x147c6, 0x147cc, 0x147d8, 0x147ee, 0x14810, 0x14820, 0x1483c, 0x14840, 0x14878, 0x148f0, 0x149e0,
        0x14bc0, 0x14c30, 0x14c3e, 0x14c60, 0x14c7c, 0x14cc0, 0x14cf8, 0x14df0, 0x14e38, 0x14e70, 0x14e7e, 0x14ee0,
        0x14efc, 0x14f04, 0x14f08, 0x14f10, 0x14f1e, 0x14f20, 0x14f3c, 0x14f40, 0x14f78, 0x14f86, 0x14f8c, 0x14f98,
        0x14fb0, 0x14fce, 0x14fdc, 0x15020, 0x15040, 0x15078, 0x150f0, 0x151e0, 0x153c0, 0x15860, 0x1587c, 0x158c0,
        0x158f8, 0x159f0, 0x15be0, 0x15c70, 0x15c7e, 0x15ce0, 0x15cfc, 0x15dc0, 0x15df8, 0x15e08, 0x15e10, 0x15e20,
        0x15e40, 0x15e78, 0x15ef0, 0x15f0c, 0x15f18, 0x15f30, 0x15f60, 0x15f7c, 0x15f8e, 0x15f9c, 0x15fb8, 0x1604e,
        0x1605c, 0x1608e, 0x1609c, 0x160b8, 0x160c2, 0x160c4, 0x160c8, 0x160de, 0x1610e, 0x1611c, 0x16138, 0x16170,
        0x1617e, 0x16184, 0x16188, 0x16190, 0x1619e, 0x161a0, 0x161bc, 0x161c6, 0x161cc, 0x161d8, 0x161f2, 0x161f4,
        0x1620e, 0x1621c, 0x16238, 0x16270, 0x1627e, 0x162e0, 0x162fc, 0x16304, 0x16308, 0x16310, 0x1631e, 0x16320,
        0x1633c, 0x16340, 0x16378, 0x16386, 0x1638c, 0x16398, 0x163b0, 0x163be, 0x163ce, 0x163dc, 0x163e2, 0x163e4,
        0x163e8, 0x163f6, 0x1640e, 0x1641c, 0x16438, 0x16470, 0x1647e, 0x164e0, 0x164fc, 0x165c0, 0x165f8, 0x16610,
        0x1661e, 0x16620, 0x1663c, 0x16640, 0x16678, 0x166f0, 0x16718, 0x16730, 0x1673e, 0x16760, 0x1677c, 0x1678e,
        0x1679c, 0x167b8, 0x167c2, 0x167c4, 0x167c8, 0x167d0, 0x167de, 0x167e6, 0x167ec, 0x1681c, 0x16838, 0x16870,
        0x168e0, 0x168fc, 0x169c0, 0x169f8, 0x16bf0, 0x16c10, 0x16c1e, 0x16c20, 0x16c3c, 0x16c40, 0x16c78, 0x16cf0,
        0x16de0, 0x16e18, 0x16e30, 0x16e3e, 0x16e60, 0x16e7c, 0x16ec0, 0x16ef8, 0x16f1c, 0x16f38, 0x16f70, 0x16f7e,
        0x16f84, 0x16f88, 0x16f90, 0x16f9e, 0x16fa0, 0x16fbc, 0x16fc6, 0x16fcc, 0x16fd8, 0x17026, 0x1702c, 0x17046,
        0x1704c, 0x17058, 0x1706e, 0x17086, 0x1708c, 0x17098, 0x170b0, 0x170be, 0x170ce, 0x170dc, 0x170e8, 0x17106,
        0x1710c, 0x17118, 0x17130, 0x1713e, 0x17160, 0x1717c, 0x1718e, 0x1719c, 0x171b8, 0x171c2, 0x171c4, 0x171c8,
        0x171d0, 0x171de, 0x171e6, 0x171ec, 0x171fa, 0x17206, 0x1720c, 0x17218, 0x17230, 0x1723e, 0x17260, 0x1727c,
        0x172c0, 0x172f8, 0x1730e, 0x1731c, 0x17338, 0x17370, 0x1737e, 0x17388, 0x17390, 0x1739e, 0x173a0, 0x173bc,
        0x173cc, 0x173d8, 0x173ee, 0x173f2, 0x173f4, 0x1740c, 0x17418, 0x17430, 0x1743e, 0x17460, 0x1747c, 0x174c0,
        0x174f8, 0x175f0, 0x1760e, 0x1761c, 0x17638, 0x17670, 0x1767e, 0x176e0, 0x176fc, 0x17708, 0x17710, 0x1771e,
        0x17720, 0x1773c, 0x17740, 0x17778, 0x17798, 0x177b0, 0x177be, 0x177dc, 0x177e2, 0x177e4, 0x177e8, 0x17822,
        0x17824, 0x17828, 0x17836, 0x17842, 0x17844, 0x17848, 0x17850, 0x1785e, 0x17866, 0x1786c, 0x17882, 0x17884,
        0x17888, 0x17890, 0x1789e, 0x178a0, 0x178bc, 0x178c6, 0x178cc, 0x178d8, 0x178ee, 0x178f2, 0x178f4, 0x17902,
        0x17904, 0x17908, 0x17910, 0x1791e, 0x17920, 0x1793c, 0x17940, 0x17978, 0x17986, 0x1798c, 0x17998, 0x179b0,
        0x179be, 0x179ce, 0x179dc, 0x179e2, 0x179e4, 0x179e8, 0x179f6, 0x17a04, 0x17a08, 0x17a10, 0x17a1e, 0x17a20,
        0x17a3c, 0x17a40, 0x17a78, 0x17af0, 0x17b06, 0x17b0c, 0x17b18, 0x17b30, 0x17b3e, 0x17b60, 0x17b7c, 0x17b8e,
        0x17b9c, 0x17bb8, 0x17bc4, 0x17bc8, 0x17bd0, 0x17bde, 0x17be6, 0x17bec, 0x17c2e, 0x17c32, 0x17c34, 0x17c4e,
        0x17c5c, 0x17c62, 0x17c64, 0x17c68, 0x17c76, 0x17c8e, 0x17c9c, 0x17cb8, 0x17cc2, 0x17cc4, 0x17cc8, 0x17cd0,
        0x17cde, 0x17ce6, 0x17cec, 0x17d0e, 0x17d1c, 0x17d38, 0x17d70, 0x17d82, 0x17d84, 0x17d88, 0x17d90, 0x17d9e,
        0x17da0, 0x17dbc, 0x17dc6, 0x17dcc, 0x17dd8, 0x17dee, 0x17e26, 0x17e2c, 0x17e3a, 0x17e46, 0x17e4c, 0x17e58,
        0x17e6e, 0x17e72, 0x17e74, 0x17e86, 0x17e8c, 0x17e98, 0x17eb0, 0x17ece, 0x17edc, 0x17ee2, 0x17ee4, 0x17ee8,
        0x17ef6, 0x1813a, 0x18172, 0x18174, 0x18216, 0x18226, 0x1823a, 0x1824c, 0x18258, 0x1826e, 0x18272, 0x18274,
        0x18298, 0x182be, 0x182e2, 0x182e4, 0x182e8, 0x182f6, 0x1835e, 0x1837a, 0x183ae, 0x183d6, 0x18416, 0x18426,
        0x1842c, 0x1843a, 0x18446, 0x18458, 0x1846e, 0x18472, 0x18474, 0x18486, 0x184b0, 0x184be, 0x184ce, 0x184dc,
        0x184e2, 0x184e4, 0x184e8, 0x184f6, 0x18506, 0x1850c, 0x18518, 0x18530, 0x1853e, 0x18560, 0x1857c, 0x1858e,
        0x1859c, 0x185b8, 0x185c2, 0x185c4, 0x185c8, 0x185d0, 0x185de, 0x185e6, 0x185ec, 0x185fa, 0x18612, 0x18614,
        0x18622, 0x18628, 0x18636, 0x18642, 0x18650, 0x1865e, 0x1867a, 0x18682, 0x18684, 0x18688, 0x18690, 0x1869e,
        0x186a0, 0x186bc, 0x186c6, 0x186cc, 0x186d8, 0x186ee, 0x186f2, 0x186f4, 0x1872e, 0x1874e, 0x1875c, 0x18796,
        0x187a6, 0x187ac, 0x187d2, 0x187d4, 0x18826, 0x1882c, 0x1883a, 0x18846, 0x1884c, 0x18858, 0x1886e, 0x18872,
        0x18874, 0x18886, 0x18898, 0x188b0, 0x188be, 0x188ce, 0x188dc, 0x188e2, 0x188e4, 0x188e8, 0x188f6, 0x1890c,
        0x18930, 0x1893e, 0x18960, 0x1897c, 0x1898e, 0x189b8, 0x189c2, 0x189c8, 0x189d0, 0x189de, 0x189e6, 0x189ec,
        0x189fa, 0x18a18, 0x18a30, 0x18a3e, 0x18a60, 0x18a7c, 0x18ac0, 0x18af8, 0x18b1c, 0x18b38, 0x18b70, 0x18b7e,
        0x18b82, 0x18b84, 0x18b88, 0x18b90, 0x18b9e, 0x18ba0, 0x18bbc, 0x18bc6, 0x18bcc, 0x18bd8, 0x18bee, 0x18bf2,
        0x18bf4, 0x18c22, 0x18c24, 0x18c28, 0x18c36, 0x18c42, 0x18c48, 0x18c50, 0x18c5e, 0x18c66, 0x18c7a, 0x18c82,
        0x18c84, 0x18c90, 0x18c9e, 0x18ca0, 0x18cbc, 0x18ccc, 0x18cf2, 0x18cf4, 0x18d04, 0x18d08, 0x18d10, 0x18d1e,
        0x18d20, 0x18d3c, 0x18d40, 0x18d78, 0x18d86, 0x18d98, 0x18dce, 0x18de2, 0x18de4, 0x18de8, 0x18e2e, 0x18e32,
        0x18e34, 0x18e4e, 0x18e5c, 0x18e62, 0x18e64, 0x18e68, 0x18e8e, 0x18e9c, 0x18eb8, 0x18ec2, 0x18ec4, 0x18ec8,
        0x18ed0, 0x18efa, 0x18f16, 0x18f26, 0x18f2c, 0x18f46, 0x18f4c, 0x18f58, 0x18f6e, 0x18f8a, 0x18f92, 0x18f94,
        0x18fa2, 0x18fa4, 0x18fa8, 0x18fb6, 0x1902c, 0x1903a, 0x19046, 0x1904c, 0x19058, 0x19072, 0x19074, 0x19086,
        0x19098, 0x190b0, 0x190be, 0x190ce, 0x190dc, 0x190e2, 0x190e8, 0x190f6, 0x19106, 0x1910c, 0x19130, 0x1913e,
        0x19160, 0x1917c, 0x1918e, 0x1919c, 0x191b8, 0x191c2, 0x191c8, 0x191d0, 0x191de, 0x191e6, 0x191ec, 0x191fa,
        0x19218, 0x1923e, 0x19260, 0x1927c, 0x192c0, 0x192f8, 0x19338, 0x19370, 0x1937e, 0x19382, 0x19384, 0x19390,
        0x1939e, 0x193a0, 0x193bc, 0x193c6, 0x193cc, 0x193d8, 0x193ee, 0x193f2, 0x193f4, 0x19430, 0x1943e, 0x19460,
        0x1947c, 0x194c0, 0x194f8, 0x195f0, 0x19638, 0x19670, 0x1967e, 0x196e0, 0x196fc, 0x19702, 0x19704, 0x19708,
        0x19710, 0x19720, 0x1973c, 0x19740, 0x19778, 0x19786, 0x1978c, 0x19798, 0x197b0, 0x197be, 0x197ce, 0x197dc,
        0x197e2, 0x197e4, 0x197e8, 0x19822, 0x19824, 0x19842, 0x19848, 0x19850, 0x1985e, 0x19866, 0x1987a, 0x19882,
        0x19884, 0x19890, 0x1989e, 0x198a0, 0x198bc, 0x198cc, 0x198f2, 0x198f4, 0x19902, 0x19908, 0x1991e, 0x19920,
        0x1993c, 0x19940, 0x19978, 0x19986, 0x19998, 0x199ce, 0x199e2, 0x199e4, 0x199e8, 0x19a08, 0x19a10, 0x19a1e,
        0x19a20, 0x19a3c, 0x19a40, 0x19a78, 0x19af0, 0x19b18, 0x19b3e, 0x19b60, 0x19b9c, 0x19bc2, 0x19bc4, 0x19bc8,
        0x19bd0, 0x19be6, 0x19c2e, 0x19c34, 0x19c4e, 0x19c5c, 0x19c62, 0x19c64, 0x19c68, 0x19c8e, 0x19c9c, 0x19cb8,
        0x19cc2, 0x19cc8, 0x19cd0, 0x19ce6, 0x19cfa, 0x19d0e, 0x19d1c, 0x19d38, 0x19d70, 0x19d7e, 0x19d82, 0x19d84,
        0x19d88, 0x19d90, 0x19da0, 0x19dcc, 0x19df2, 0x19df4, 0x19e16, 0x19e26, 0x19e2c, 0x19e46, 0x19e4c, 0x19e58,
        0x19e74, 0x19e86, 0x19e8c, 0x19e98, 0x19eb0, 0x19ebe, 0x19ece, 0x19ee2, 0x19ee4, 0x19ee8, 0x19f0a, 0x19f12,
        0x19f14, 0x19f22, 0x19f24, 0x19f28, 0x19f42, 0x19f44, 0x19f48, 0x19f50, 0x19f5e, 0x19f6c, 0x19f9a, 0x19fae,
        0x19fb2, 0x19fb4, 0x1a046, 0x1a04c, 0x1a072, 0x1a074, 0x1a086, 0x1a08c, 0x1a098, 0x1a0b0, 0x1a0be, 0x1a0e2,
        0x1a0e4, 0x1a0e8, 0x1a0f6, 0x1a106, 0x1a10c, 0x1a118, 0x1a130, 0x1a13e, 0x1a160, 0x1a17c, 0x1a18e, 0x1a19c,
        0x1a1b8, 0x1a1c2, 0x1a1c4, 0x1a1c8, 0x1a1d0, 0x1a1de, 0x1a1e6, 0x1a1ec, 0x1a218, 0x1a230, 0x1a23e, 0x1a260,
        0x1a27c, 0x1a2c0, 0x1a2f8, 0x1a31c, 0x1a338, 0x1a370, 0x1a37e, 0x1a382, 0x1a384, 0x1a388, 0x1a390, 0x1a39e,
        0x1a3a0, 0x1a3bc, 0x1a3c6, 0x1a3cc, 0x1a3d8, 0x1a3ee, 0x1a3f2, 0x1a3f4, 0x1a418, 0x1a430, 0x1a43e, 0x1a460,
        0x1a47c, 0x1a4c0, 0x1a4f8, 0x1a5f0, 0x1a61c, 0x1a638, 0x1a670, 0x1a67e, 0x1a6e0, 0x1a6fc, 0x1a702, 0x1a704,
        0x1a708, 0x1a710, 0x1a71e, 0x1a720, 0x1a73c, 0x1a740, 0x1a778, 0x1a786, 0x1a78c, 0x1a798, 0x1a7b0, 0x1a7be,
        0x1a7ce, 0x1a7dc, 0x1a7e2, 0x1a7e4, 0x1a7e8, 0x1a830, 0x1a860, 0x1a87c, 0x1a8c0, 0x1a8f8, 0x1a9f0, 0x1abe0,
        0x1ac70, 0x1ac7e, 0x1ace0, 0x1acfc, 0x1adc0, 0x1adf8, 0x1ae04, 0x1ae08, 0x1ae10, 0x1ae20, 0x1ae3c, 0x1ae40,
        0x1ae78, 0x1aef0, 0x1af06, 0x1af0c, 0x1af18, 0x1af30, 0x1af3e, 0x1af60, 0x1af7c, 0x1af8e, 0x1af9c, 0x1afb8,
        0x1afc4, 0x1afc8, 0x1afd0, 0x1afde, 0x1b042, 0x1b05e, 0x1b07a, 0x1b082, 0x1b084, 0x1b088, 0x1b090, 0x1b09e,
        0x1b0a0, 0x1b0bc, 0x1b0cc, 0x1b0f2, 0x1b0f4, 0x1b102, 0x1b104, 0x1b108, 0x1b110, 0x1b11e, 0x1b120, 0x1b13c,
        0x1b140, 0x1b178, 0x1b186, 0x1b198, 0x1b1ce, 0x1b1e2, 0x1b1e4, 0x1b1e8, 0x1b204, 0x1b208, 0x1b210, 0x1b21e,
        0x1b220, 0x1b23c, 0x1b240, 0x1b278, 0x1b2f0, 0x1b30c, 0x1b33e, 0x1b360, 0x1b39c, 0x1b3c2, 0x1b3c4, 0x1b3c8,
        0x1b3d0, 0x1b3e6, 0x1b410, 0x1b41e, 0x1b420, 0x1b43c, 0x1b440, 0x1b478, 0x1b4f0, 0x1b5e0, 0x1b618, 0x1b660,
        0x1b67c, 0x1b6c0, 0x1b738, 0x1b782, 0x1b784, 0x1b788, 0x1b790, 0x1b79e, 0x1b7a0, 0x1b7cc, 0x1b82e, 0x1b84e,
        0x1b85c, 0x1b88e, 0x1b89c, 0x1b8b8, 0x1b8c2, 0x1b8c4, 0x1b8c8, 0x1b8d0, 0x1b8e6, 0x1b8fa, 0x1b90e, 0x1b91c,
        0x1b938, 0x1b970, 0x1b97e, 0x1b982, 0x1b984, 0x1b988, 0x1b990, 0x1b99e, 0x1b9a0, 0x1b9cc, 0x1b9f2, 0x1b9f4,
        0x1ba0e, 0x1ba1c, 0x1ba38, 0x1ba70, 0x1ba7e, 0x1bae0, 0x1bafc, 0x1bb08, 0x1bb10, 0x1bb20, 0x1bb3c, 0x1bb40,
        0x1bb98, 0x1bbce, 0x1bbe2, 0x1bbe4, 0x1bbe8, 0x1bc16, 0x1bc26, 0x1bc2c, 0x1bc46, 0x1bc4c, 0x1bc58, 0x1bc72,
        0x1bc74, 0x1bc86, 0x1bc8c, 0x1bc98, 0x1bcb0, 0x1bcbe, 0x1bcce, 0x1bce2, 0x1bce4, 0x1bce8, 0x1bd06, 0x1bd0c,
        0x1bd18, 0x1bd30, 0x1bd3e, 0x1bd60, 0x1bd7c, 0x1bd9c, 0x1bdc2, 0x1bdc4, 0x1bdc8, 0x1bdd0, 0x1bde6, 0x1bdfa,
        0x1be12, 0x1be14, 0x1be22, 0x1be24, 0x1be28, 0x1be42, 0x1be44, 0x1be48, 0x1be50, 0x1be5e, 0x1be66, 0x1be82,
        0x1be84, 0x1be88, 0x1be90, 0x1be9e, 0x1bea0, 0x1bebc, 0x1becc, 0x1bef4, 0x1bf1a, 0x1bf2e, 0x1bf32, 0x1bf34,
        0x1bf4e, 0x1bf5c, 0x1bf62, 0x1bf64, 0x1bf68, 0x1c09a, 0x1c0b2, 0x1c0b4, 0x1c11a, 0x1c132, 0x1c134, 0x1c162,
        0x1c164, 0x1c168, 0x1c176, 0x1c1ba, 0x1c21a, 0x1c232, 0x1c234, 0x1c24e, 0x1c25c, 0x1c262, 0x1c264, 0x1c268,
        0x1c276, 0x1c28e, 0x1c2c2, 0x1c2c4, 0x1c2c8, 0x1c2d0, 0x1c2de, 0x1c2e6, 0x1c2ec, 0x1c2fa, 0x1c316, 0x1c326,
        0x1c33a, 0x1c346, 0x1c34c, 0x1c372, 0x1c374, 0x1c41a, 0x1c42e, 0x1c432, 0x1c434, 0x1c44e, 0x1c45c, 0x1c462,
        0x1c464, 0x1c468, 0x1c476, 0x1c48e, 0x1c49c, 0x1c4b8, 0x1c4c2, 0x1c4c8, 0x1c4d0, 0x1c4de, 0x1c4e6, 0x1c4ec,
        0x1c4fa, 0x1c51c, 0x1c538, 0x1c570, 0x1c57e, 0x1c582, 0x1c584, 0x1c588, 0x1c590, 0x1c59e, 0x1c5a0, 0x1c5bc,
        0x1c5c6, 0x1c5cc, 0x1c5d8, 0x1c5ee, 0x1c5f2, 0x1c5f4, 0x1c616, 0x1c626, 0x1c62c, 0x1c63a, 0x1c646, 0x1c64c,
        0x1c658, 0x1c66e, 0x1c672, 0x1c674, 0x1c686, 0x1c68c, 0x1c698, 0x1c6b0, 0x1c6be, 0x1c6ce, 0x1c6dc, 0x1c6e2,
        0x1c6e4, 0x1c6e8, 0x1c712, 0x1c714, 0x1c722, 0x1c728, 0x1c736, 0x1c742, 0x1c744, 0x1c748, 0x1c750, 0x1c75e,
        0x1c766, 0x1c76c, 0x1c77a, 0x1c7ae, 0x1c7d6, 0x1c7ea, 0x1c81a, 0x1c82e, 0x1c832, 0x1c834, 0x1c84e, 0x1c85c,
        0x1c862, 0x1c864, 0x1c868, 0x1c876, 0x1c88e, 0x1c89c, 0x1c8b8, 0x1c8c2, 0x1c8c8, 0x1c8d0, 0x1c8de, 0x1c8e6,
        0x1c8ec, 0x1c8fa, 0x1c90e, 0x1c938, 0x1c970, 0x1c97e, 0x1c982, 0x1c984, 0x1c990, 0x1c99e, 0x1c9a0, 0x1c9bc,
        0x1c9c6, 0x1c9cc, 0x1c9d8, 0x1c9ee, 0x1c9f2, 0x1c9f4, 0x1ca38, 0x1ca70, 0x1ca7e, 0x1cae0, 0x1cafc, 0x1cb02,
        0x1cb04, 0x1cb08, 0x1cb10, 0x1cb20, 0x1cb3c, 0x1cb40, 0x1cb78, 0x1cb86, 0x1cb8c, 0x1cb98, 0x1cbb0, 0x1cbbe,
        0x1cbce, 0x1cbdc, 0x1cbe2, 0x1cbe4, 0x1cbe8, 0x1cbf6, 0x1cc16, 0x1cc26, 0x1cc2c, 0x1cc3a, 0x1cc46, 0x1cc58,
        0x1cc72, 0x1cc74, 0x1cc86, 0x1ccb0, 0x1ccbe, 0x1ccce, 0x1cce2, 0x1cce4, 0x1cce8, 0x1cd06, 0x1cd0c, 0x1cd18,
        0x1cd30, 0x1cd3e, 0x1cd60, 0x1cd7c, 0x1cd9c, 0x1cdc2, 0x1cdc4, 0x1cdc8, 0x1cdd0, 0x1cdde, 0x1cde6, 0x1cdfa,
        0x1ce22, 0x1ce28, 0x1ce42, 0x1ce50, 0x1ce5e, 0x1ce66, 0x1ce7a, 0x1ce82, 0x1ce84, 0x1ce88, 0x1ce90, 0x1ce9e,
        0x1cea0, 0x1cebc, 0x1cecc, 0x1cef2, 0x1cef4, 0x1cf2e, 0x1cf32, 0x1cf34, 0x1cf4e, 0x1cf5c, 0x1cf62, 0x1cf64,
        0x1cf68, 0x1cf96, 0x1cfa6, 0x1cfac, 0x1cfca, 0x1cfd2, 0x1cfd4, 0x1d02e, 0x1d032, 0x1d034, 0x1d04e, 0x1d05c,
        0x1d062, 0x1d064, 0x1d068, 0x1d076, 0x1d08e, 0x1d09c, 0x1d0b8, 0x1d0c2, 0x1d0c4, 0x1d0c8, 0x1d0d0, 0x1d0de,
        0x1d0e6, 0x1d0ec, 0x1d0fa, 0x1d11c, 0x1d138, 0x1d170, 0x1d17e, 0x1d182, 0x1d184, 0x1d188, 0x1d190, 0x1d19e,
        0x1d1a0, 0x1d1bc, 0x1d1c6, 0x1d1cc, 0x1d1d8, 0x1d1ee, 0x1d1f2, 0x1d1f4, 0x1d21c, 0x1d238, 0x1d270, 0x1d27e,
        0x1d2e0, 0x1d2fc, 0x1d302, 0x1d304, 0x1d308, 0x1d310, 0x1d31e, 0x1d320, 0x1d33c, 0x1d340, 0x1d378, 0x1d386,
        0x1d38c, 0x1d398, 0x1d3b0, 0x1d3be, 0x1d3ce, 0x1d3dc, 0x1d3e2, 0x1d3e4, 0x1d3e8, 0x1d3f6, 0x1d470, 0x1d47e,
        0x1d4e0, 0x1d4fc, 0x1d5c0, 0x1d5f8, 0x1d604, 0x1d608, 0x1d610, 0x1d620, 0x1d640, 0x1d678, 0x1d6f0, 0x1d706,
        0x1d70c, 0x1d718, 0x1d730, 0x1d73e, 0x1d760, 0x1d77c, 0x1d78e, 0x1d79c, 0x1d7b8, 0x1d7c2, 0x1d7c4, 0x1d7c8,
        0x1d7d0, 0x1d7de, 0x1d7e6, 0x1d7ec, 0x1d826, 0x1d82c, 0x1d83a, 0x1d846, 0x1d84c, 0x1d858, 0x1d872, 0x1d874,
        0x1d886, 0x1d88c, 0x1d898, 0x1d8b0, 0x1d8be, 0x1d8ce, 0x1d8e2, 0x1d8e4, 0x1d8e8, 0x1d8f6, 0x1d90c, 0x1d918,
        0x1d930, 0x1d93e, 0x1d960, 0x1d97c, 0x1d99c, 0x1d9c2, 0x1d9c4, 0x1d9c8, 0x1d9d0, 0x1d9e6, 0x1d9fa, 0x1da0c,
        0x1da18, 0x1da30, 0x1da3e, 0x1da60, 0x1da7c, 0x1dac0, 0x1daf8, 0x1db38, 0x1db82, 0x1db84, 0x1db88, 0x1db90,
        0x1db9e, 0x1dba0, 0x1dbcc, 0x1dbf2, 0x1dbf4, 0x1dc22, 0x1dc42, 0x1dc44, 0x1dc48, 0x1dc50, 0x1dc5e, 0x1dc66,
        0x1dc7a, 0x1dc82, 0x1dc84, 0x1dc88, 0x1dc90, 0x1dc9e, 0x1dca0, 0x1dcbc, 0x1dccc, 0x1dcf2, 0x1dcf4, 0x1dd04,
        0x1dd08, 0x1dd10, 0x1dd1e, 0x1dd20, 0x1dd3c, 0x1dd40, 0x1dd78, 0x1dd86, 0x1dd98, 0x1ddce, 0x1dde2, 0x1dde4,
        0x1dde8, 0x1de2e, 0x1de32, 0x1de34, 0x1de4e, 0x1de5c, 0x1de62, 0x1de64, 0x1de68, 0x1de8e, 0x1de9c, 0x1deb8,
        0x1dec2, 0x1dec4, 0x1dec8, 0x1ded0, 0x1dee6, 0x1defa, 0x1df16, 0x1df26, 0x1df2c, 0x1df46, 0x1df4c, 0x1df58,
        0x1df72, 0x1df74, 0x1df8a, 0x1df92, 0x1df94, 0x1dfa2, 0x1dfa4, 0x1dfa8, 0x1e08a, 0x1e092, 0x1e094, 0x1e0a2,
        0x1e0a4, 0x1e0a8, 0x1e0b6, 0x1e0da, 0x1e10a, 0x1e112, 0x1e114, 0x1e122, 0x1e124, 0x1e128, 0x1e136, 0x1e142,
        0x1e144, 0x1e148, 0x1e150, 0x1e166, 0x1e16c, 0x1e17a, 0x1e19a, 0x1e1b2, 0x1e1b4, 0x1e20a, 0x1e212, 0x1e214,
        0x1e222, 0x1e224, 0x1e228, 0x1e236, 0x1e242, 0x1e248, 0x1e250, 0x1e25e, 0x1e266, 0x1e26c, 0x1e27a, 0x1e282,
        0x1e284, 0x1e288, 0x1e290, 0x1e2a0, 0x1e2bc, 0x1e2c6, 0x1e2cc, 0x1e2d8, 0x1e2ee, 0x1e2f2, 0x1e2f4, 0x1e31a,
        0x1e332, 0x1e334, 0x1e35c, 0x1e362, 0x1e364, 0x1e368, 0x1e3ba, 0x1e40a, 0x1e412, 0x1e414, 0x1e422, 0x1e428,
        0x1e436, 0x1e442, 0x1e448, 0x1e450, 0x1e45e, 0x1e466, 0x1e46c, 0x1e47a, 0x1e482, 0x1e484, 0x1e490, 0x1e49e,
        0x1e4a0, 0x1e4bc, 0x1e4c6, 0x1e4cc, 0x1e4d8, 0x1e4ee, 0x1e4f2, 0x1e4f4, 0x1e502, 0x1e504, 0x1e508, 0x1e510,
        0x1e51e, 0x1e520, 0x1e53c, 0x1e540, 0x1e578, 0x1e586, 0x1e58c, 0x1e598, 0x1e5b0, 0x1e5be, 0x1e5ce, 0x1e5dc,
        0x1e5e2, 0x1e5e4, 0x1e5e8, 0x1e5f6, 0x1e61a, 0x1e62e, 0x1e632, 0x1e634, 0x1e64e, 0x1e65c, 0x1e662, 0x1e668,
        0x1e68e, 0x1e69c, 0x1e6b8, 0x1e6c2, 0x1e6c4, 0x1e6c8, 0x1e6d0, 0x1e6e6, 0x1e6fa, 0x1e716, 0x1e726, 0x1e72c,
        0x1e73a, 0x1e746, 0x1e74c, 0x1e758, 0x1e772, 0x1e774, 0x1e792, 0x1e794, 0x1e7a2, 0x1e7a4, 0x1e7a8, 0x1e7b6,
        0x1e812, 0x1e814, 0x1e822, 0x1e824, 0x1e828, 0x1e836, 0x1e842, 0x1e844, 0x1e848, 0x1e850, 0x1e85e, 0x1e866,
        0x1e86c, 0x1e87a, 0x1e882, 0x1e884, 0x1e888, 0x1e890, 0x1e89e, 0x1e8a0, 0x1e8bc, 0x1e8c6, 0x1e8cc, 0x1e8d8,
        0x1e8ee, 0x1e8f2, 0x1e8f4, 0x1e902, 0x1e904, 0x1e908, 0x1e910, 0x1e920, 0x1e93c, 0x1e940, 0x1e978, 0x1e986,
        0x1e98c, 0x1e998, 0x1e9b0, 0x1e9be, 0x1e9ce, 0x1e9dc, 0x1e9e2, 0x1e9e4, 0x1e9e8, 0x1e9f6, 0x1ea04, 0x1ea08,
        0x1ea10, 0x1ea20, 0x1ea40, 0x1ea78, 0x1eaf0, 0x1eb06, 0x1eb0c, 0x1eb18, 0x1eb30, 0x1eb3e, 0x1eb60, 0x1eb7c,
        0x1eb8e, 0x1eb9c, 0x1ebb8, 0x1ebc2, 0x1ebc4, 0x1ebc8, 0x1ebd0, 0x1ebde, 0x1ebe6, 0x1ebec, 0x1ec1a, 0x1ec2e,
        0x1ec32, 0x1ec34, 0x1ec4e, 0x1ec5c, 0x1ec62, 0x1ec64, 0x1ec68, 0x1ec8e, 0x1ec9c, 0x1ecb8, 0x1ecc2, 0x1ecc4,
        0x1ecc8, 0x1ecd0, 0x1ece6, 0x1ecfa, 0x1ed0e, 0x1ed1c, 0x1ed38, 0x1ed70, 0x1ed7e, 0x1ed82, 0x1ed84, 0x1ed88,
        0x1ed90, 0x1ed9e, 0x1eda0, 0x1edcc, 0x1edf2, 0x1edf4, 0x1ee16, 0x1ee26, 0x1ee2c, 0x1ee3a, 0x1ee46, 0x1ee4c,
        0x1ee58, 0x1ee6e, 0x1ee72, 0x1ee74, 0x1ee86, 0x1ee8c, 0x1ee98, 0x1eeb0, 0x1eebe, 0x1eece, 0x1eedc, 0x1eee2,
        0x1eee4, 0x1eee8, 0x1ef12, 0x1ef22, 0x1ef24, 0x1ef28, 0x1ef36, 0x1ef42, 0x1ef44, 0x1ef48, 0x1ef50, 0x1ef5e,
        0x1ef66, 0x1ef6c, 0x1ef7a, 0x1efae, 0x1efb2, 0x1efb4, 0x1efd6, 0x1f096, 0x1f0a6, 0x1f0ac, 0x1f0ba, 0x1f0ca,
        0x1f0d2, 0x1f0d4, 0x1f116, 0x1f126, 0x1f12c, 0x1f13a, 0x1f146, 0x1f14c, 0x1f158, 0x1f16e, 0x1f172, 0x1f174,
        0x1f18a, 0x1f192, 0x1f194, 0x1f1a2, 0x1f1a4, 0x1f1a8, 0x1f1da, 0x1f216, 0x1f226, 0x1f22c, 0x1f23a, 0x1f246,
        0x1f258, 0x1f26e, 0x1f272, 0x1f274, 0x1f286, 0x1f28c, 0x1f298, 0x1f2b0, 0x1f2be, 0x1f2ce, 0x1f2dc, 0x1f2e2,
        0x1f2e4, 0x1f2e8, 0x1f2f6, 0x1f30a, 0x1f312, 0x1f314, 0x1f322, 0x1f328, 0x1f342, 0x1f344, 0x1f348, 0x1f350,
        0x1f35e, 0x1f366, 0x1f37a, 0x1f39a, 0x1f3ae, 0x1f3b2, 0x1f3b4, 0x1f416, 0x1f426, 0x1f42c, 0x1f43a, 0x1f446,
        0x1f44c, 0x1f458, 0x1f46e, 0x1f472, 0x1f474, 0x1f486, 0x1f48c, 0x1f498, 0x1f4b0, 0x1f4be, 0x1f4ce, 0x1f4dc,
        0x1f4e2, 0x1f4e4, 0x1f4e8, 0x1f4f6, 0x1f506, 0x1f50c, 0x1f518, 0x1f530, 0x1f53e, 0x1f560, 0x1f57c, 0x1f58e,
        0x1f59c, 0x1f5b8, 0x1f5c2, 0x1f5c4, 0x1f5c8, 0x1f5d0, 0x1f5de, 0x1f5e6, 0x1f5ec, 0x1f5fa, 0x1f60a, 0x1f612,
        0x1f614, 0x1f622, 0x1f624, 0x1f628, 0x1f636, 0x1f642, 0x1f644, 0x1f648, 0x1f650, 0x1f65e, 0x1f666, 0x1f67a,
        0x1f682, 0x1f684, 0x1f688, 0x1f690, 0x1f69e, 0x1f6a0, 0x1f6bc, 0x1f6cc, 0x1f6f2, 0x1f6f4, 0x1f71a, 0x1f72e,
        0x1f732, 0x1f734, 0x1f74e, 0x1f75c, 0x1f762, 0x1f764, 0x1f768, 0x1f776, 0x1f796, 0x1f7a6, 0x1f7ac, 0x1f7ba,
        0x1f7d2, 0x1f7d4, 0x1f89a, 0x1f8ae, 0x1f8b2, 0x1f8b4, 0x1f8d6, 0x1f8ea, 0x1f91a, 0x1f92e, 0x1f932, 0x1f934,
        0x1f94e, 0x1f95c, 0x1f962, 0x1f964, 0x1f968, 0x1f976, 0x1f996, 0x1f9a6, 0x1f9ac, 0x1f9ba, 0x1f9ca, 0x1f9d2,
        0x1f9d4, 0x1fa1a, 0x1fa2e, 0x1fa32, 0x1fa34, 0x1fa4e, 0x1fa5c, 0x1fa62, 0x1fa64, 0x1fa68, 0x1fa76, 0x1fa8e,
        0x1fa9c, 0x1fab8, 0x1fac2, 0x1fac4, 0x1fac8, 0x1fad0, 0x1fade, 0x1fae6, 0x1faec, 0x1fb16, 0x1fb26, 0x1fb2c,
        0x1fb3a, 0x1fb46, 0x1fb4c, 0x1fb58, 0x1fb6e, 0x1fb72, 0x1fb74, 0x1fb8a, 0x1fb92, 0x1fb94, 0x1fba2, 0x1fba4,
        0x1fba8, 0x1fbb6, 0x1fbda
    ]);
    /**
     * This table contains to codewords for all symbols.
     */
    PDF417Common.CODEWORD_TABLE = Int32Array.from([
        2627, 1819, 2622, 2621, 1813, 1812, 2729, 2724, 2723, 2779, 2774, 2773, 902, 896, 908, 868, 865, 861, 859, 2511,
        873, 871, 1780, 835, 2493, 825, 2491, 842, 837, 844, 1764, 1762, 811, 810, 809, 2483, 807, 2482, 806, 2480, 815,
        814, 813, 812, 2484, 817, 816, 1745, 1744, 1742, 1746, 2655, 2637, 2635, 2626, 2625, 2623, 2628, 1820, 2752,
        2739, 2737, 2728, 2727, 2725, 2730, 2785, 2783, 2778, 2777, 2775, 2780, 787, 781, 747, 739, 736, 2413, 754, 752,
        1719, 692, 689, 681, 2371, 678, 2369, 700, 697, 694, 703, 1688, 1686, 642, 638, 2343, 631, 2341, 627, 2338, 651,
        646, 643, 2345, 654, 652, 1652, 1650, 1647, 1654, 601, 599, 2322, 596, 2321, 594, 2319, 2317, 611, 610, 608, 606,
        2324, 603, 2323, 615, 614, 612, 1617, 1616, 1614, 1612, 616, 1619, 1618, 2575, 2538, 2536, 905, 901, 898, 909,
        2509, 2507, 2504, 870, 867, 864, 860, 2512, 875, 872, 1781, 2490, 2489, 2487, 2485, 1748, 836, 834, 832, 830,
        2494, 827, 2492, 843, 841, 839, 845, 1765, 1763, 2701, 2676, 2674, 2653, 2648, 2656, 2634, 2633, 2631, 2629,
        1821, 2638, 2636, 2770, 2763, 2761, 2750, 2745, 2753, 2736, 2735, 2733, 2731, 1848, 2740, 2738, 2786, 2784, 591,
        588, 576, 569, 566, 2296, 1590, 537, 534, 526, 2276, 522, 2274, 545, 542, 539, 548, 1572, 1570, 481, 2245, 466,
        2242, 462, 2239, 492, 485, 482, 2249, 496, 494, 1534, 1531, 1528, 1538, 413, 2196, 406, 2191, 2188, 425, 419,
        2202, 415, 2199, 432, 430, 427, 1472, 1467, 1464, 433, 1476, 1474, 368, 367, 2160, 365, 2159, 362, 2157, 2155,
        2152, 378, 377, 375, 2166, 372, 2165, 369, 2162, 383, 381, 379, 2168, 1419, 1418, 1416, 1414, 385, 1411, 384,
        1423, 1422, 1420, 1424, 2461, 802, 2441, 2439, 790, 786, 783, 794, 2409, 2406, 2403, 750, 742, 738, 2414, 756,
        753, 1720, 2367, 2365, 2362, 2359, 1663, 693, 691, 684, 2373, 680, 2370, 702, 699, 696, 704, 1690, 1687, 2337,
        2336, 2334, 2332, 1624, 2329, 1622, 640, 637, 2344, 634, 2342, 630, 2340, 650, 648, 645, 2346, 655, 653, 1653,
        1651, 1649, 1655, 2612, 2597, 2595, 2571, 2568, 2565, 2576, 2534, 2529, 2526, 1787, 2540, 2537, 907, 904, 900,
        910, 2503, 2502, 2500, 2498, 1768, 2495, 1767, 2510, 2508, 2506, 869, 866, 863, 2513, 876, 874, 1782, 2720, 2713,
        2711, 2697, 2694, 2691, 2702, 2672, 2670, 2664, 1828, 2678, 2675, 2647, 2646, 2644, 2642, 1823, 2639, 1822, 2654,
        2652, 2650, 2657, 2771, 1855, 2765, 2762, 1850, 1849, 2751, 2749, 2747, 2754, 353, 2148, 344, 342, 336, 2142,
        332, 2140, 345, 1375, 1373, 306, 2130, 299, 2128, 295, 2125, 319, 314, 311, 2132, 1354, 1352, 1349, 1356, 262,
        257, 2101, 253, 2096, 2093, 274, 273, 267, 2107, 263, 2104, 280, 278, 275, 1316, 1311, 1308, 1320, 1318, 2052,
        202, 2050, 2044, 2040, 219, 2063, 212, 2060, 208, 2055, 224, 221, 2066, 1260, 1258, 1252, 231, 1248, 229, 1266,
        1264, 1261, 1268, 155, 1998, 153, 1996, 1994, 1991, 1988, 165, 164, 2007, 162, 2006, 159, 2003, 2000, 172, 171,
        169, 2012, 166, 2010, 1186, 1184, 1182, 1179, 175, 1176, 173, 1192, 1191, 1189, 1187, 176, 1194, 1193, 2313,
        2307, 2305, 592, 589, 2294, 2292, 2289, 578, 572, 568, 2297, 580, 1591, 2272, 2267, 2264, 1547, 538, 536, 529,
        2278, 525, 2275, 547, 544, 541, 1574, 1571, 2237, 2235, 2229, 1493, 2225, 1489, 478, 2247, 470, 2244, 465, 2241,
        493, 488, 484, 2250, 498, 495, 1536, 1533, 1530, 1539, 2187, 2186, 2184, 2182, 1432, 2179, 1430, 2176, 1427, 414,
        412, 2197, 409, 2195, 405, 2193, 2190, 426, 424, 421, 2203, 418, 2201, 431, 429, 1473, 1471, 1469, 1466, 434,
        1477, 1475, 2478, 2472, 2470, 2459, 2457, 2454, 2462, 803, 2437, 2432, 2429, 1726, 2443, 2440, 792, 789, 785,
        2401, 2399, 2393, 1702, 2389, 1699, 2411, 2408, 2405, 745, 741, 2415, 758, 755, 1721, 2358, 2357, 2355, 2353,
        1661, 2350, 1660, 2347, 1657, 2368, 2366, 2364, 2361, 1666, 690, 687, 2374, 683, 2372, 701, 698, 705, 1691, 1689,
        2619, 2617, 2610, 2608, 2605, 2613, 2593, 2588, 2585, 1803, 2599, 2596, 2563, 2561, 2555, 1797, 2551, 1795, 2573,
        2570, 2567, 2577, 2525, 2524, 2522, 2520, 1786, 2517, 1785, 2514, 1783, 2535, 2533, 2531, 2528, 1788, 2541, 2539,
        906, 903, 911, 2721, 1844, 2715, 2712, 1838, 1836, 2699, 2696, 2693, 2703, 1827, 1826, 1824, 2673, 2671, 2669,
        2666, 1829, 2679, 2677, 1858, 1857, 2772, 1854, 1853, 1851, 1856, 2766, 2764, 143, 1987, 139, 1986, 135, 133,
        131, 1984, 128, 1983, 125, 1981, 138, 137, 136, 1985, 1133, 1132, 1130, 112, 110, 1974, 107, 1973, 104, 1971,
        1969, 122, 121, 119, 117, 1977, 114, 1976, 124, 1115, 1114, 1112, 1110, 1117, 1116, 84, 83, 1953, 81, 1952, 78,
        1950, 1948, 1945, 94, 93, 91, 1959, 88, 1958, 85, 1955, 99, 97, 95, 1961, 1086, 1085, 1083, 1081, 1078, 100,
        1090, 1089, 1087, 1091, 49, 47, 1917, 44, 1915, 1913, 1910, 1907, 59, 1926, 56, 1925, 53, 1922, 1919, 66, 64,
        1931, 61, 1929, 1042, 1040, 1038, 71, 1035, 70, 1032, 68, 1048, 1047, 1045, 1043, 1050, 1049, 12, 10, 1869, 1867,
        1864, 1861, 21, 1880, 19, 1877, 1874, 1871, 28, 1888, 25, 1886, 22, 1883, 982, 980, 977, 974, 32, 30, 991, 989,
        987, 984, 34, 995, 994, 992, 2151, 2150, 2147, 2146, 2144, 356, 355, 354, 2149, 2139, 2138, 2136, 2134, 1359,
        343, 341, 338, 2143, 335, 2141, 348, 347, 346, 1376, 1374, 2124, 2123, 2121, 2119, 1326, 2116, 1324, 310, 308,
        305, 2131, 302, 2129, 298, 2127, 320, 318, 316, 313, 2133, 322, 321, 1355, 1353, 1351, 1357, 2092, 2091, 2089,
        2087, 1276, 2084, 1274, 2081, 1271, 259, 2102, 256, 2100, 252, 2098, 2095, 272, 269, 2108, 266, 2106, 281, 279,
        277, 1317, 1315, 1313, 1310, 282, 1321, 1319, 2039, 2037, 2035, 2032, 1203, 2029, 1200, 1197, 207, 2053, 205,
        2051, 201, 2049, 2046, 2043, 220, 218, 2064, 215, 2062, 211, 2059, 228, 226, 223, 2069, 1259, 1257, 1254, 232,
        1251, 230, 1267, 1265, 1263, 2316, 2315, 2312, 2311, 2309, 2314, 2304, 2303, 2301, 2299, 1593, 2308, 2306, 590,
        2288, 2287, 2285, 2283, 1578, 2280, 1577, 2295, 2293, 2291, 579, 577, 574, 571, 2298, 582, 581, 1592, 2263, 2262,
        2260, 2258, 1545, 2255, 1544, 2252, 1541, 2273, 2271, 2269, 2266, 1550, 535, 532, 2279, 528, 2277, 546, 543, 549,
        1575, 1573, 2224, 2222, 2220, 1486, 2217, 1485, 2214, 1482, 1479, 2238, 2236, 2234, 2231, 1496, 2228, 1492, 480,
        477, 2248, 473, 2246, 469, 2243, 490, 487, 2251, 497, 1537, 1535, 1532, 2477, 2476, 2474, 2479, 2469, 2468, 2466,
        2464, 1730, 2473, 2471, 2453, 2452, 2450, 2448, 1729, 2445, 1728, 2460, 2458, 2456, 2463, 805, 804, 2428, 2427,
        2425, 2423, 1725, 2420, 1724, 2417, 1722, 2438, 2436, 2434, 2431, 1727, 2444, 2442, 793, 791, 788, 795, 2388,
        2386, 2384, 1697, 2381, 1696, 2378, 1694, 1692, 2402, 2400, 2398, 2395, 1703, 2392, 1701, 2412, 2410, 2407, 751,
        748, 744, 2416, 759, 757, 1807, 2620, 2618, 1806, 1805, 2611, 2609, 2607, 2614, 1802, 1801, 1799, 2594, 2592,
        2590, 2587, 1804, 2600, 2598, 1794, 1793, 1791, 1789, 2564, 2562, 2560, 2557, 1798, 2554, 1796, 2574, 2572, 2569,
        2578, 1847, 1846, 2722, 1843, 1842, 1840, 1845, 2716, 2714, 1835, 1834, 1832, 1830, 1839, 1837, 2700, 2698, 2695,
        2704, 1817, 1811, 1810, 897, 862, 1777, 829, 826, 838, 1760, 1758, 808, 2481, 1741, 1740, 1738, 1743, 2624, 1818,
        2726, 2776, 782, 740, 737, 1715, 686, 679, 695, 1682, 1680, 639, 628, 2339, 647, 644, 1645, 1643, 1640, 1648,
        602, 600, 597, 595, 2320, 593, 2318, 609, 607, 604, 1611, 1610, 1608, 1606, 613, 1615, 1613, 2328, 926, 924, 892,
        886, 899, 857, 850, 2505, 1778, 824, 823, 821, 819, 2488, 818, 2486, 833, 831, 828, 840, 1761, 1759, 2649, 2632,
        2630, 2746, 2734, 2732, 2782, 2781, 570, 567, 1587, 531, 527, 523, 540, 1566, 1564, 476, 467, 463, 2240, 486,
        483, 1524, 1521, 1518, 1529, 411, 403, 2192, 399, 2189, 423, 416, 1462, 1457, 1454, 428, 1468, 1465, 2210, 366,
        363, 2158, 360, 2156, 357, 2153, 376, 373, 370, 2163, 1410, 1409, 1407, 1405, 382, 1402, 380, 1417, 1415, 1412,
        1421, 2175, 2174, 777, 774, 771, 784, 732, 725, 722, 2404, 743, 1716, 676, 674, 668, 2363, 665, 2360, 685, 1684,
        1681, 626, 624, 622, 2335, 620, 2333, 617, 2330, 641, 635, 649, 1646, 1644, 1642, 2566, 928, 925, 2530, 2527,
        894, 891, 888, 2501, 2499, 2496, 858, 856, 854, 851, 1779, 2692, 2668, 2665, 2645, 2643, 2640, 2651, 2768, 2759,
        2757, 2744, 2743, 2741, 2748, 352, 1382, 340, 337, 333, 1371, 1369, 307, 300, 296, 2126, 315, 312, 1347, 1342,
        1350, 261, 258, 250, 2097, 246, 2094, 271, 268, 264, 1306, 1301, 1298, 276, 1312, 1309, 2115, 203, 2048, 195,
        2045, 191, 2041, 213, 209, 2056, 1246, 1244, 1238, 225, 1234, 222, 1256, 1253, 1249, 1262, 2080, 2079, 154, 1997,
        150, 1995, 147, 1992, 1989, 163, 160, 2004, 156, 2001, 1175, 1174, 1172, 1170, 1167, 170, 1164, 167, 1185, 1183,
        1180, 1177, 174, 1190, 1188, 2025, 2024, 2022, 587, 586, 564, 559, 556, 2290, 573, 1588, 520, 518, 512, 2268,
        508, 2265, 530, 1568, 1565, 461, 457, 2233, 450, 2230, 446, 2226, 479, 471, 489, 1526, 1523, 1520, 397, 395,
        2185, 392, 2183, 389, 2180, 2177, 410, 2194, 402, 422, 1463, 1461, 1459, 1456, 1470, 2455, 799, 2433, 2430, 779,
        776, 773, 2397, 2394, 2390, 734, 728, 724, 746, 1717, 2356, 2354, 2351, 2348, 1658, 677, 675, 673, 670, 667, 688,
        1685, 1683, 2606, 2589, 2586, 2559, 2556, 2552, 927, 2523, 2521, 2518, 2515, 1784, 2532, 895, 893, 890, 2718,
        2709, 2707, 2689, 2687, 2684, 2663, 2662, 2660, 2658, 1825, 2667, 2769, 1852, 2760, 2758, 142, 141, 1139, 1138,
        134, 132, 129, 126, 1982, 1129, 1128, 1126, 1131, 113, 111, 108, 105, 1972, 101, 1970, 120, 118, 115, 1109, 1108,
        1106, 1104, 123, 1113, 1111, 82, 79, 1951, 75, 1949, 72, 1946, 92, 89, 86, 1956, 1077, 1076, 1074, 1072, 98,
        1069, 96, 1084, 1082, 1079, 1088, 1968, 1967, 48, 45, 1916, 42, 1914, 39, 1911, 1908, 60, 57, 54, 1923, 50, 1920,
        1031, 1030, 1028, 1026, 67, 1023, 65, 1020, 62, 1041, 1039, 1036, 1033, 69, 1046, 1044, 1944, 1943, 1941, 11, 9,
        1868, 7, 1865, 1862, 1859, 20, 1878, 16, 1875, 13, 1872, 970, 968, 966, 963, 29, 960, 26, 23, 983, 981, 978, 975,
        33, 971, 31, 990, 988, 985, 1906, 1904, 1902, 993, 351, 2145, 1383, 331, 330, 328, 326, 2137, 323, 2135, 339,
        1372, 1370, 294, 293, 291, 289, 2122, 286, 2120, 283, 2117, 309, 303, 317, 1348, 1346, 1344, 245, 244, 242, 2090,
        239, 2088, 236, 2085, 2082, 260, 2099, 249, 270, 1307, 1305, 1303, 1300, 1314, 189, 2038, 186, 2036, 183, 2033,
        2030, 2026, 206, 198, 2047, 194, 216, 1247, 1245, 1243, 1240, 227, 1237, 1255, 2310, 2302, 2300, 2286, 2284,
        2281, 565, 563, 561, 558, 575, 1589, 2261, 2259, 2256, 2253, 1542, 521, 519, 517, 514, 2270, 511, 533, 1569,
        1567, 2223, 2221, 2218, 2215, 1483, 2211, 1480, 459, 456, 453, 2232, 449, 474, 491, 1527, 1525, 1522, 2475, 2467,
        2465, 2451, 2449, 2446, 801, 800, 2426, 2424, 2421, 2418, 1723, 2435, 780, 778, 775, 2387, 2385, 2382, 2379,
        1695, 2375, 1693, 2396, 735, 733, 730, 727, 749, 1718, 2616, 2615, 2604, 2603, 2601, 2584, 2583, 2581, 2579,
        1800, 2591, 2550, 2549, 2547, 2545, 1792, 2542, 1790, 2558, 929, 2719, 1841, 2710, 2708, 1833, 1831, 2690, 2688,
        2686, 1815, 1809, 1808, 1774, 1756, 1754, 1737, 1736, 1734, 1739, 1816, 1711, 1676, 1674, 633, 629, 1638, 1636,
        1633, 1641, 598, 1605, 1604, 1602, 1600, 605, 1609, 1607, 2327, 887, 853, 1775, 822, 820, 1757, 1755, 1584, 524,
        1560, 1558, 468, 464, 1514, 1511, 1508, 1519, 408, 404, 400, 1452, 1447, 1444, 417, 1458, 1455, 2208, 364, 361,
        358, 2154, 1401, 1400, 1398, 1396, 374, 1393, 371, 1408, 1406, 1403, 1413, 2173, 2172, 772, 726, 723, 1712, 672,
        669, 666, 682, 1678, 1675, 625, 623, 621, 618, 2331, 636, 632, 1639, 1637, 1635, 920, 918, 884, 880, 889, 849,
        848, 847, 846, 2497, 855, 852, 1776, 2641, 2742, 2787, 1380, 334, 1367, 1365, 301, 297, 1340, 1338, 1335, 1343,
        255, 251, 247, 1296, 1291, 1288, 265, 1302, 1299, 2113, 204, 196, 192, 2042, 1232, 1230, 1224, 214, 1220, 210,
        1242, 1239, 1235, 1250, 2077, 2075, 151, 148, 1993, 144, 1990, 1163, 1162, 1160, 1158, 1155, 161, 1152, 157,
        1173, 1171, 1168, 1165, 168, 1181, 1178, 2021, 2020, 2018, 2023, 585, 560, 557, 1585, 516, 509, 1562, 1559, 458,
        447, 2227, 472, 1516, 1513, 1510, 398, 396, 393, 390, 2181, 386, 2178, 407, 1453, 1451, 1449, 1446, 420, 1460,
        2209, 769, 764, 720, 712, 2391, 729, 1713, 664, 663, 661, 659, 2352, 656, 2349, 671, 1679, 1677, 2553, 922, 919,
        2519, 2516, 885, 883, 881, 2685, 2661, 2659, 2767, 2756, 2755, 140, 1137, 1136, 130, 127, 1125, 1124, 1122, 1127,
        109, 106, 102, 1103, 1102, 1100, 1098, 116, 1107, 1105, 1980, 80, 76, 73, 1947, 1068, 1067, 1065, 1063, 90, 1060,
        87, 1075, 1073, 1070, 1080, 1966, 1965, 46, 43, 40, 1912, 36, 1909, 1019, 1018, 1016, 1014, 58, 1011, 55, 1008,
        51, 1029, 1027, 1024, 1021, 63, 1037, 1034, 1940, 1939, 1937, 1942, 8, 1866, 4, 1863, 1, 1860, 956, 954, 952,
        949, 946, 17, 14, 969, 967, 964, 961, 27, 957, 24, 979, 976, 972, 1901, 1900, 1898, 1896, 986, 1905, 1903, 350,
        349, 1381, 329, 327, 324, 1368, 1366, 292, 290, 287, 284, 2118, 304, 1341, 1339, 1337, 1345, 243, 240, 237, 2086,
        233, 2083, 254, 1297, 1295, 1293, 1290, 1304, 2114, 190, 187, 184, 2034, 180, 2031, 177, 2027, 199, 1233, 1231,
        1229, 1226, 217, 1223, 1241, 2078, 2076, 584, 555, 554, 552, 550, 2282, 562, 1586, 507, 506, 504, 502, 2257, 499,
        2254, 515, 1563, 1561, 445, 443, 441, 2219, 438, 2216, 435, 2212, 460, 454, 475, 1517, 1515, 1512, 2447, 798,
        797, 2422, 2419, 770, 768, 766, 2383, 2380, 2376, 721, 719, 717, 714, 731, 1714, 2602, 2582, 2580, 2548, 2546,
        2543, 923, 921, 2717, 2706, 2705, 2683, 2682, 2680, 1771, 1752, 1750, 1733, 1732, 1731, 1735, 1814, 1707, 1670,
        1668, 1631, 1629, 1626, 1634, 1599, 1598, 1596, 1594, 1603, 1601, 2326, 1772, 1753, 1751, 1581, 1554, 1552, 1504,
        1501, 1498, 1509, 1442, 1437, 1434, 401, 1448, 1445, 2206, 1392, 1391, 1389, 1387, 1384, 359, 1399, 1397, 1394,
        1404, 2171, 2170, 1708, 1672, 1669, 619, 1632, 1630, 1628, 1773, 1378, 1363, 1361, 1333, 1328, 1336, 1286, 1281,
        1278, 248, 1292, 1289, 2111, 1218, 1216, 1210, 197, 1206, 193, 1228, 1225, 1221, 1236, 2073, 2071, 1151, 1150,
        1148, 1146, 152, 1143, 149, 1140, 145, 1161, 1159, 1156, 1153, 158, 1169, 1166, 2017, 2016, 2014, 2019, 1582,
        510, 1556, 1553, 452, 448, 1506, 1500, 394, 391, 387, 1443, 1441, 1439, 1436, 1450, 2207, 765, 716, 713, 1709,
        662, 660, 657, 1673, 1671, 916, 914, 879, 878, 877, 882, 1135, 1134, 1121, 1120, 1118, 1123, 1097, 1096, 1094,
        1092, 103, 1101, 1099, 1979, 1059, 1058, 1056, 1054, 77, 1051, 74, 1066, 1064, 1061, 1071, 1964, 1963, 1007,
        1006, 1004, 1002, 999, 41, 996, 37, 1017, 1015, 1012, 1009, 52, 1025, 1022, 1936, 1935, 1933, 1938, 942, 940,
        938, 935, 932, 5, 2, 955, 953, 950, 947, 18, 943, 15, 965, 962, 958, 1895, 1894, 1892, 1890, 973, 1899, 1897,
        1379, 325, 1364, 1362, 288, 285, 1334, 1332, 1330, 241, 238, 234, 1287, 1285, 1283, 1280, 1294, 2112, 188, 185,
        181, 178, 2028, 1219, 1217, 1215, 1212, 200, 1209, 1227, 2074, 2072, 583, 553, 551, 1583, 505, 503, 500, 513,
        1557, 1555, 444, 442, 439, 436, 2213, 455, 451, 1507, 1505, 1502, 796, 763, 762, 760, 767, 711, 710, 708, 706,
        2377, 718, 715, 1710, 2544, 917, 915, 2681, 1627, 1597, 1595, 2325, 1769, 1749, 1747, 1499, 1438, 1435, 2204,
        1390, 1388, 1385, 1395, 2169, 2167, 1704, 1665, 1662, 1625, 1623, 1620, 1770, 1329, 1282, 1279, 2109, 1214, 1207,
        1222, 2068, 2065, 1149, 1147, 1144, 1141, 146, 1157, 1154, 2013, 2011, 2008, 2015, 1579, 1549, 1546, 1495, 1487,
        1433, 1431, 1428, 1425, 388, 1440, 2205, 1705, 658, 1667, 1664, 1119, 1095, 1093, 1978, 1057, 1055, 1052, 1062,
        1962, 1960, 1005, 1003, 1000, 997, 38, 1013, 1010, 1932, 1930, 1927, 1934, 941, 939, 936, 933, 6, 930, 3, 951,
        948, 944, 1889, 1887, 1884, 1881, 959, 1893, 1891, 35, 1377, 1360, 1358, 1327, 1325, 1322, 1331, 1277, 1275,
        1272, 1269, 235, 1284, 2110, 1205, 1204, 1201, 1198, 182, 1195, 179, 1213, 2070, 2067, 1580, 501, 1551, 1548,
        440, 437, 1497, 1494, 1490, 1503, 761, 709, 707, 1706, 913, 912, 2198, 1386, 2164, 2161, 1621, 1766, 2103, 1208,
        2058, 2054, 1145, 1142, 2005, 2002, 1999, 2009, 1488, 1429, 1426, 2200, 1698, 1659, 1656, 1975, 1053, 1957, 1954,
        1001, 998, 1924, 1921, 1918, 1928, 937, 934, 931, 1879, 1876, 1873, 1870, 945, 1885, 1882, 1323, 1273, 1270,
        2105, 1202, 1199, 1196, 1211, 2061, 2057, 1576, 1543, 1540, 1484, 1481, 1478, 1491, 1700
    ]);

    /*
    * Copyright 2007 ZXing authors
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    // import java.util.List;
    /**
     * @author Guenther Grau
     */
    /*public final*/ class PDF417DetectorResult {
        constructor(bits, points) {
            this.bits = bits;
            this.points = points;
        }
        getBits() {
            return this.bits;
        }
        getPoints() {
            return this.points;
        }
    }

    /*
    * Copyright 2009 ZXing authors
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    // import java.util.ArrayList;
    // import java.util.Arrays;
    // import java.util.List;
    // import java.util.Map;
    /**
     * <p>Encapsulates logic that can detect a PDF417 Code in an image, even if the
     * PDF417 Code is rotated or skewed, or partially obscured.</p>
     *
     * @author SITA Lab (kevin.osullivan@sita.aero)
     * @author dswitkin@google.com (Daniel Switkin)
     * @author Guenther Grau
     */
    /*public*/ /*final*/ class Detector$3 {
        /**
         * <p>Detects a PDF417 Code in an image. Only checks 0 and 180 degree rotations.</p>
         *
         * @param image barcode image to decode
         * @param hints optional hints to detector
         * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will
         * be found and returned
         * @return {@link PDF417DetectorResult} encapsulating results of detecting a PDF417 code
         * @throws NotFoundException if no PDF417 Code can be found
         */
        static detectMultiple(image, hints, multiple) {
            // TODO detection improvement, tryHarder could try several different luminance thresholds/blackpoints or even
            // different binarizers
            // boolean tryHarder = hints != null && hints.containsKey(DecodeHintType.TRY_HARDER);
            let bitMatrix = image.getBlackMatrix();
            let barcodeCoordinates = Detector$3.detect(multiple, bitMatrix);
            if (!barcodeCoordinates.length) {
                bitMatrix = bitMatrix.clone();
                bitMatrix.rotate180();
                barcodeCoordinates = Detector$3.detect(multiple, bitMatrix);
            }
            return new PDF417DetectorResult(bitMatrix, barcodeCoordinates);
        }
        /**
         * Detects PDF417 codes in an image. Only checks 0 degree rotation
         * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will
         * be found and returned
         * @param bitMatrix bit matrix to detect barcodes in
         * @return List of ResultPoint arrays containing the coordinates of found barcodes
         */
        static detect(multiple, bitMatrix) {
            const barcodeCoordinates = new Array();
            let row = 0;
            let column = 0;
            let foundBarcodeInRow = false;
            while (row < bitMatrix.getHeight()) {
                const vertices = Detector$3.findVertices(bitMatrix, row, column);
                if (vertices[0] == null && vertices[3] == null) {
                    if (!foundBarcodeInRow) {
                        // we didn't find any barcode so that's the end of searching
                        break;
                    }
                    // we didn't find a barcode starting at the given column and row. Try again from the first column and slightly
                    // below the lowest barcode we found so far.
                    foundBarcodeInRow = false;
                    column = 0;
                    for (const barcodeCoordinate of barcodeCoordinates) {
                        if (barcodeCoordinate[1] != null) {
                            row = Math.trunc(Math.max(row, barcodeCoordinate[1].getY()));
                        }
                        if (barcodeCoordinate[3] != null) {
                            row = Math.max(row, Math.trunc(barcodeCoordinate[3].getY()));
                        }
                    }
                    row += Detector$3.ROW_STEP;
                    continue;
                }
                foundBarcodeInRow = true;
                barcodeCoordinates.push(vertices);
                if (!multiple) {
                    break;
                }
                // if we didn't find a right row indicator column, then continue the search for the next barcode after the
                // start pattern of the barcode just found.
                if (vertices[2] != null) {
                    column = Math.trunc(vertices[2].getX());
                    row = Math.trunc(vertices[2].getY());
                }
                else {
                    column = Math.trunc(vertices[4].getX());
                    row = Math.trunc(vertices[4].getY());
                }
            }
            return barcodeCoordinates;
        }
        /**
         * Locate the vertices and the codewords area of a black blob using the Start
         * and Stop patterns as locators.
         *
         * @param matrix the scanned barcode image.
         * @return an array containing the vertices:
         *           vertices[0] x, y top left barcode
         *           vertices[1] x, y bottom left barcode
         *           vertices[2] x, y top right barcode
         *           vertices[3] x, y bottom right barcode
         *           vertices[4] x, y top left codeword area
         *           vertices[5] x, y bottom left codeword area
         *           vertices[6] x, y top right codeword area
         *           vertices[7] x, y bottom right codeword area
         */
        static findVertices(matrix, startRow, startColumn) {
            const height = matrix.getHeight();
            const width = matrix.getWidth();
            // const result = new ResultPoint[8];
            const result = new Array(8);
            Detector$3.copyToResult(result, Detector$3.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector$3.START_PATTERN), Detector$3.INDEXES_START_PATTERN);
            if (result[4] != null) {
                startColumn = Math.trunc(result[4].getX());
                startRow = Math.trunc(result[4].getY());
            }
            Detector$3.copyToResult(result, Detector$3.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector$3.STOP_PATTERN), Detector$3.INDEXES_STOP_PATTERN);
            return result;
        }
        static copyToResult(result, tmpResult, destinationIndexes) {
            for (let i = 0; i < destinationIndexes.length; i++) {
                result[destinationIndexes[i]] = tmpResult[i];
            }
        }
        static findRowsWithPattern(matrix, height, width, startRow, startColumn, pattern) {
            // const result = new ResultPoint[4];
            const result = new Array(4);
            let found = false;
            const counters = new Int32Array(pattern.length);
            for (; startRow < height; startRow += Detector$3.ROW_STEP) {
                let loc = Detector$3.findGuardPattern(matrix, startColumn, startRow, width, false, pattern, counters);
                if (loc != null) {
                    while (startRow > 0) {
                        const previousRowLoc = Detector$3.findGuardPattern(matrix, startColumn, --startRow, width, false, pattern, counters);
                        if (previousRowLoc != null) {
                            loc = previousRowLoc;
                        }
                        else {
                            startRow++;
                            break;
                        }
                    }
                    result[0] = new ResultPoint(loc[0], startRow);
                    result[1] = new ResultPoint(loc[1], startRow);
                    found = true;
                    break;
                }
            }
            let stopRow = startRow + 1;
            // Last row of the current symbol that contains pattern
            if (found) {
                let skippedRowCount = 0;
                let previousRowLoc = Int32Array.from([Math.trunc(result[0].getX()), Math.trunc(result[1].getX())]);
                for (; stopRow < height; stopRow++) {
                    const loc = Detector$3.findGuardPattern(matrix, previousRowLoc[0], stopRow, width, false, pattern, counters);
                    // a found pattern is only considered to belong to the same barcode if the start and end positions
                    // don't differ too much. Pattern drift should be not bigger than two for consecutive rows. With
                    // a higher number of skipped rows drift could be larger. To keep it simple for now, we allow a slightly
                    // larger drift and don't check for skipped rows.
                    if (loc != null &&
                        Math.abs(previousRowLoc[0] - loc[0]) < Detector$3.MAX_PATTERN_DRIFT &&
                        Math.abs(previousRowLoc[1] - loc[1]) < Detector$3.MAX_PATTERN_DRIFT) {
                        previousRowLoc = loc;
                        skippedRowCount = 0;
                    }
                    else {
                        if (skippedRowCount > Detector$3.SKIPPED_ROW_COUNT_MAX) {
                            break;
                        }
                        else {
                            skippedRowCount++;
                        }
                    }
                }
                stopRow -= skippedRowCount + 1;
                result[2] = new ResultPoint(previousRowLoc[0], stopRow);
                result[3] = new ResultPoint(previousRowLoc[1], stopRow);
            }
            if (stopRow - startRow < Detector$3.BARCODE_MIN_HEIGHT) {
                Arrays.fill(result, null);
            }
            return result;
        }
        /**
         * @param matrix row of black/white values to search
         * @param column x position to start search
         * @param row y position to start search
         * @param width the number of pixels to search on this row
         * @param pattern pattern of counts of number of black and white pixels that are
         *                 being searched for as a pattern
         * @param counters array of counters, as long as pattern, to re-use
         * @return start/end horizontal offset of guard pattern, as an array of two ints.
         */
        static findGuardPattern(matrix, column, row, width, whiteFirst, pattern, counters) {
            Arrays.fillWithin(counters, 0, counters.length, 0);
            let patternStart = column;
            let pixelDrift = 0;
            // if there are black pixels left of the current pixel shift to the left, but only for MAX_PIXEL_DRIFT pixels
            while (matrix.get(patternStart, row) && patternStart > 0 && pixelDrift++ < Detector$3.MAX_PIXEL_DRIFT) {
                patternStart--;
            }
            let x = patternStart;
            let counterPosition = 0;
            let patternLength = pattern.length;
            for (let isWhite = whiteFirst; x < width; x++) {
                let pixel = matrix.get(x, row);
                if (pixel !== isWhite) {
                    counters[counterPosition]++;
                }
                else {
                    if (counterPosition === patternLength - 1) {
                        if (Detector$3.patternMatchVariance(counters, pattern, Detector$3.MAX_INDIVIDUAL_VARIANCE) < Detector$3.MAX_AVG_VARIANCE) {
                            return new Int32Array([patternStart, x]);
                        }
                        patternStart += counters[0] + counters[1];
                        System.arraycopy(counters, 2, counters, 0, counterPosition - 1);
                        counters[counterPosition - 1] = 0;
                        counters[counterPosition] = 0;
                        counterPosition--;
                    }
                    else {
                        counterPosition++;
                    }
                    counters[counterPosition] = 1;
                    isWhite = !isWhite;
                }
            }
            if (counterPosition === patternLength - 1 &&
                Detector$3.patternMatchVariance(counters, pattern, Detector$3.MAX_INDIVIDUAL_VARIANCE) < Detector$3.MAX_AVG_VARIANCE) {
                return new Int32Array([patternStart, x - 1]);
            }
            return null;
        }
        /**
         * Determines how closely a set of observed counts of runs of black/white
         * values matches a given target pattern. This is reported as the ratio of
         * the total variance from the expected pattern proportions across all
         * pattern elements, to the length of the pattern.
         *
         * @param counters observed counters
         * @param pattern expected pattern
         * @param maxIndividualVariance The most any counter can differ before we give up
         * @return ratio of total variance between counters and pattern compared to total pattern size
         */
        static patternMatchVariance(counters, pattern, maxIndividualVariance) {
            let numCounters = counters.length;
            let total = 0;
            let patternLength = 0;
            for (let i = 0; i < numCounters; i++) {
                total += counters[i];
                patternLength += pattern[i];
            }
            if (total < patternLength) {
                // If we don't even have one pixel per unit of bar width, assume this
                // is too small to reliably match, so fail:
                return /*Float.POSITIVE_INFINITY*/ Infinity;
            }
            // We're going to fake floating-point math in integers. We just need to use more bits.
            // Scale up patternLength so that intermediate values below like scaledCounter will have
            // more "significant digits".
            let unitBarWidth = total / patternLength;
            maxIndividualVariance *= unitBarWidth;
            let totalVariance = 0.0;
            for (let x = 0; x < numCounters; x++) {
                let counter = counters[x];
                let scaledPattern = pattern[x] * unitBarWidth;
                let variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;
                if (variance > maxIndividualVariance) {
                    return /*Float.POSITIVE_INFINITY*/ Infinity;
                }
                totalVariance += variance;
            }
            return totalVariance / total;
        }
    }
    Detector$3.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5]);
    Detector$3.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3]);
    Detector$3.MAX_AVG_VARIANCE = 0.42;
    Detector$3.MAX_INDIVIDUAL_VARIANCE = 0.8;
    // B S B S B S B S Bar/Space pattern
    // 11111111 0 1 0 1 0 1 000
    Detector$3.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3]);
    // 1111111 0 1 000 1 0 1 00 1
    Detector$3.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1]);
    Detector$3.MAX_PIXEL_DRIFT = 3;
    Detector$3.MAX_PATTERN_DRIFT = 5;
    // if we set the value too low, then we don't detect the correct height of the bar if the start patterns are damaged.
    // if we set the value too high, then we might detect the start pattern from a neighbor barcode.
    Detector$3.SKIPPED_ROW_COUNT_MAX = 25;
    // A PDF471 barcode should have at least 3 rows, with each row being >= 3 times the module width. Therefore it should be at least
    // 9 pixels tall. To be conservative, we use about half the size to ensure we don't miss it.
    Detector$3.ROW_STEP = 5;
    Detector$3.BARCODE_MIN_HEIGHT = 10;

    /*
    * Copyright 2012 ZXing authors
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    /**
     * @author Sean Owen
     * @see com.google.zxing.common.reedsolomon.GenericGFPoly
     */
    /*final*/ class ModulusPoly {
        constructor(field, coefficients) {
            if (coefficients.length === 0) {
                throw new IllegalArgumentException();
            }
            this.field = field;
            let coefficientsLength = /*int*/ coefficients.length;
            if (coefficientsLength > 1 && coefficients[0] === 0) {
                // Leading term must be non-zero for anything except the constant polynomial "0"
                let firstNonZero = /*int*/ 1;
                while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
                    firstNonZero++;
                }
                if (firstNonZero === coefficientsLength) {
                    this.coefficients = new Int32Array([0]);
                }
                else {
                    this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
                    System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
                }
            }
            else {
                this.coefficients = coefficients;
            }
        }
        getCoefficients() {
            return this.coefficients;
        }
        /**
         * @return degree of this polynomial
         */
        getDegree() {
            return this.coefficients.length - 1;
        }
        /**
         * @return true iff this polynomial is the monomial "0"
         */
        isZero() {
            return this.coefficients[0] === 0;
        }
        /**
         * @return coefficient of x^degree term in this polynomial
         */
        getCoefficient(degree) {
            return this.coefficients[this.coefficients.length - 1 - degree];
        }
        /**
         * @return evaluation of this polynomial at a given point
         */
        evaluateAt(a) {
            if (a === 0) {
                // Just return the x^0 coefficient
                return this.getCoefficient(0);
            }
            if (a === 1) {
                // Just the sum of the coefficients
                let sum = /*int*/ 0;
                for (let coefficient /*int*/ of this.coefficients) {
                    sum = this.field.add(sum, coefficient);
                }
                return sum;
            }
            let result = /*int*/ this.coefficients[0];
            let size = /*int*/ this.coefficients.length;
            for (let i /*int*/ = 1; i < size; i++) {
                result = this.field.add(this.field.multiply(a, result), this.coefficients[i]);
            }
            return result;
        }
        add(other) {
            if (!this.field.equals(other.field)) {
                throw new IllegalArgumentException('ModulusPolys do not have same ModulusGF field');
            }
            if (this.isZero()) {
                return other;
            }
            if (other.isZero()) {
                return this;
            }
            let smallerCoefficients = this.coefficients;
            let largerCoefficients = other.coefficients;
            if (smallerCoefficients.length > largerCoefficients.length) {
                let temp = smallerCoefficients;
                smallerCoefficients = largerCoefficients;
                largerCoefficients = temp;
            }
            let sumDiff = new Int32Array(largerCoefficients.length);
            let lengthDiff = /*int*/ largerCoefficients.length - smallerCoefficients.length;
            // Copy high-order terms only found in higher-degree polynomial's coefficients
            System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
            for (let i /*int*/ = lengthDiff; i < largerCoefficients.length; i++) {
                sumDiff[i] = this.field.add(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
            }
            return new ModulusPoly(this.field, sumDiff);
        }
        subtract(other) {
            if (!this.field.equals(other.field)) {
                throw new IllegalArgumentException('ModulusPolys do not have same ModulusGF field');
            }
            if (other.isZero()) {
                return this;
            }
            return this.add(other.negative());
        }
        multiply(other) {
            if (other instanceof ModulusPoly) {
                return this.multiplyOther(other);
            }
            return this.multiplyScalar(other);
        }
        multiplyOther(other) {
            if (!this.field.equals(other.field)) {
                throw new IllegalArgumentException('ModulusPolys do not have same ModulusGF field');
            }
            if (this.isZero() || other.isZero()) {
                // return this.field.getZero();
                return new ModulusPoly(this.field, new Int32Array([0]));
            }
            let aCoefficients = this.coefficients;
            let aLength = /*int*/ aCoefficients.length;
            let bCoefficients = other.coefficients;
            let bLength = /*int*/ bCoefficients.length;
            let product = new Int32Array(aLength + bLength - 1);
            for (let i /*int*/ = 0; i < aLength; i++) {
                let aCoeff = /*int*/ aCoefficients[i];
                for (let j /*int*/ = 0; j < bLength; j++) {
                    product[i + j] = this.field.add(product[i + j], this.field.multiply(aCoeff, bCoefficients[j]));
                }
            }
            return new ModulusPoly(this.field, product);
        }
        negative() {
            let size = /*int*/ this.coefficients.length;
            let negativeCoefficients = new Int32Array(size);
            for (let i /*int*/ = 0; i < size; i++) {
                negativeCoefficients[i] = this.field.subtract(0, this.coefficients[i]);
            }
            return new ModulusPoly(this.field, negativeCoefficients);
        }
        multiplyScalar(scalar) {
            if (scalar === 0) {
                return new ModulusPoly(this.field, new Int32Array([0]));
            }
            if (scalar === 1) {
                return this;
            }
            let size = /*int*/ this.coefficients.length;
            let product = new Int32Array(size);
            for (let i /*int*/ = 0; i < size; i++) {
                product[i] = this.field.multiply(this.coefficients[i], scalar);
            }
            return new ModulusPoly(this.field, product);
        }
        multiplyByMonomial(degree, coefficient) {
            if (degree < 0) {
                throw new IllegalArgumentException();
            }
            if (coefficient === 0) {
                return new ModulusPoly(this.field, new Int32Array([0]));
            }
            let size = /*int*/ this.coefficients.length;
            let product = new Int32Array(size + degree);
            for (let i /*int*/ = 0; i < size; i++) {
                product[i] = this.field.multiply(this.coefficients[i], coefficient);
            }
            return new ModulusPoly(this.field, product);
        }
        /*
        ModulusPoly[] divide(other: ModulusPoly) {
          if (!field.equals(other.field)) {
            throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
          }
          if (other.isZero()) {
            throw new IllegalArgumentException("Divide by 0");
          }

          let quotient: ModulusPoly = field.getZero();
          let remainder: ModulusPoly = this;

          let denominatorLeadingTerm: /*int/ number = other.getCoefficient(other.getDegree());
          let inverseDenominatorLeadingTerm: /*int/ number = field.inverse(denominatorLeadingTerm);

          while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {
            let degreeDifference: /*int/ number = remainder.getDegree() - other.getDegree();
            let scale: /*int/ number = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);
            let term: ModulusPoly = other.multiplyByMonomial(degreeDifference, scale);
            let iterationQuotient: ModulusPoly = field.buildMonomial(degreeDifference, scale);
            quotient = quotient.add(iterationQuotient);
            remainder = remainder.subtract(term);
          }

          return new ModulusPoly[] { quotient, remainder };
        }
        */
        // @Override
        toString() {
            let result = new StringBuilder( /*8 * this.getDegree()*/); // dynamic string size in JS
            for (let degree /*int*/ = this.getDegree(); degree >= 0; degree--) {
                let coefficient = /*int*/ this.getCoefficient(degree);
                if (coefficient !== 0) {
                    if (coefficient < 0) {
                        result.append(' - ');
                        coefficient = -coefficient;
                    }
                    else {
                        if (result.length() > 0) {
                            result.append(' + ');
                        }
                    }
                    if (degree === 0 || coefficient !== 1) {
                        result.append(coefficient);
                    }
                    if (degree !== 0) {
                        if (degree === 1) {
                            result.append('x');
                        }
                        else {
                            result.append('x^');
                            result.append(degree);
                        }
                    }
                }
            }
            return result.toString();
        }
    }

    class ModulusBase {
        add(a, b) {
            return (a + b) % this.modulus;
        }
        subtract(a, b) {
            return (this.modulus + a - b) % this.modulus;
        }
        exp(a) {
            return this.expTable[a];
        }
        log(a) {
            if (a === 0) {
                throw new IllegalArgumentException();
            }
            return this.logTable[a];
        }
        inverse(a) {
            if (a === 0) {
                throw new ArithmeticException();
            }
            return this.expTable[this.modulus - this.logTable[a] - 1];
        }
        multiply(a, b) {
            if (a === 0 || b === 0) {
                return 0;
            }
            return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.modulus - 1)];
        }
        getSize() {
            return this.modulus;
        }
        equals(o) {
            return o === this;
        }
    }

    /*
     * Copyright 2012 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>A field based on powers of a generator integer, modulo some modulus.</p>
     *
     * @author Sean Owen
     * @see com.google.zxing.common.reedsolomon.GenericGF
     */
    /*public final*/ class ModulusGF extends ModulusBase {
        // private /*final*/ modulus: /*int*/ number;
        constructor(modulus, generator) {
            super();
            this.modulus = modulus;
            this.expTable = new Int32Array(modulus);
            this.logTable = new Int32Array(modulus);
            let x = /*int*/ 1;
            for (let i /*int*/ = 0; i < modulus; i++) {
                this.expTable[i] = x;
                x = (x * generator) % modulus;
            }
            for (let i /*int*/ = 0; i < modulus - 1; i++) {
                this.logTable[this.expTable[i]] = i;
            }
            // logTable[0] == 0 but this should never be used
            this.zero = new ModulusPoly(this, new Int32Array([0]));
            this.one = new ModulusPoly(this, new Int32Array([1]));
        }
        getZero() {
            return this.zero;
        }
        getOne() {
            return this.one;
        }
        buildMonomial(degree, coefficient) {
            if (degree < 0) {
                throw new IllegalArgumentException();
            }
            if (coefficient === 0) {
                return this.zero;
            }
            let coefficients = new Int32Array(degree + 1);
            coefficients[0] = coefficient;
            return new ModulusPoly(this, coefficients);
        }
    }
    ModulusGF.PDF417_GF = new ModulusGF(PDF417Common.NUMBER_OF_CODEWORDS, 3);

    /*
    * Copyright 2012 ZXing authors
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    /**
     * <p>PDF417 error correction implementation.</p>
     *
     * <p>This <a href="http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Example">example</a>
     * is quite useful in understanding the algorithm.</p>
     *
     * @author Sean Owen
     * @see com.google.zxing.common.reedsolomon.ReedSolomonDecoder
     */
    /*public final*/ class ErrorCorrection {
        constructor() {
            this.field = ModulusGF.PDF417_GF;
        }
        /**
         * @param received received codewords
         * @param numECCodewords number of those codewords used for EC
         * @param erasures location of erasures
         * @return number of errors
         * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors
         */
        decode(received, numECCodewords, erasures) {
            let poly = new ModulusPoly(this.field, received);
            let S = new Int32Array(numECCodewords);
            let error = false;
            for (let i /*int*/ = numECCodewords; i > 0; i--) {
                let evaluation = poly.evaluateAt(this.field.exp(i));
                S[numECCodewords - i] = evaluation;
                if (evaluation !== 0) {
                    error = true;
                }
            }
            if (!error) {
                return 0;
            }
            let knownErrors = this.field.getOne();
            if (erasures != null) {
                for (const erasure of erasures) {
                    let b = this.field.exp(received.length - 1 - erasure);
                    // Add (1 - bx) term:
                    let term = new ModulusPoly(this.field, new Int32Array([this.field.subtract(0, b), 1]));
                    knownErrors = knownErrors.multiply(term);
                }
            }
            let syndrome = new ModulusPoly(this.field, S);
            // syndrome = syndrome.multiply(knownErrors);
            let sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);
            let sigma = sigmaOmega[0];
            let omega = sigmaOmega[1];
            // sigma = sigma.multiply(knownErrors);
            let errorLocations = this.findErrorLocations(sigma);
            let errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);
            for (let i /*int*/ = 0; i < errorLocations.length; i++) {
                let position = received.length - 1 - this.field.log(errorLocations[i]);
                if (position < 0) {
                    throw ChecksumException.getChecksumInstance();
                }
                received[position] = this.field.subtract(received[position], errorMagnitudes[i]);
            }
            return errorLocations.length;
        }
        /**
         *
         * @param ModulusPoly
         * @param a
         * @param ModulusPoly
         * @param b
         * @param int
         * @param R
         * @throws ChecksumException
         */
        runEuclideanAlgorithm(a, b, R) {
            // Assume a's degree is >= b's
            if (a.getDegree() < b.getDegree()) {
                let temp = a;
                a = b;
                b = temp;
            }
            let rLast = a;
            let r = b;
            let tLast = this.field.getZero();
            let t = this.field.getOne();
            // Run Euclidean algorithm until r's degree is less than R/2
            while (r.getDegree() >= Math.round(R / 2)) {
                let rLastLast = rLast;
                let tLastLast = tLast;
                rLast = r;
                tLast = t;
                // Divide rLastLast by rLast, with quotient in q and remainder in r
                if (rLast.isZero()) {
                    // Oops, Euclidean algorithm already terminated?
                    throw ChecksumException.getChecksumInstance();
                }
                r = rLastLast;
                let q = this.field.getZero();
                let denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
                let dltInverse = this.field.inverse(denominatorLeadingTerm);
                while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {
                    let degreeDiff = r.getDegree() - rLast.getDegree();
                    let scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);
                    q = q.add(this.field.buildMonomial(degreeDiff, scale));
                    r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));
                }
                t = q.multiply(tLast).subtract(tLastLast).negative();
            }
            let sigmaTildeAtZero = t.getCoefficient(0);
            if (sigmaTildeAtZero === 0) {
                throw ChecksumException.getChecksumInstance();
            }
            let inverse = this.field.inverse(sigmaTildeAtZero);
            let sigma = t.multiply(inverse);
            let omega = r.multiply(inverse);
            return [sigma, omega];
        }
        /**
         *
         * @param errorLocator
         * @throws ChecksumException
         */
        findErrorLocations(errorLocator) {
            // This is a direct application of Chien's search
            let numErrors = errorLocator.getDegree();
            let result = new Int32Array(numErrors);
            let e = 0;
            for (let i /*int*/ = 1; i < this.field.getSize() && e < numErrors; i++) {
                if (errorLocator.evaluateAt(i) === 0) {
                    result[e] = this.field.inverse(i);
                    e++;
                }
            }
            if (e !== numErrors) {
                throw ChecksumException.getChecksumInstance();
            }
            return result;
        }
        findErrorMagnitudes(errorEvaluator, errorLocator, errorLocations) {
            let errorLocatorDegree = errorLocator.getDegree();
            let formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);
            for (let i /*int*/ = 1; i <= errorLocatorDegree; i++) {
                formalDerivativeCoefficients[errorLocatorDegree - i] =
                    this.field.multiply(i, errorLocator.getCoefficient(i));
            }
            let formalDerivative = new ModulusPoly(this.field, formalDerivativeCoefficients);
            // This is directly applying Forney's Formula
            let s = errorLocations.length;
            let result = new Int32Array(s);
            for (let i /*int*/ = 0; i < s; i++) {
                let xiInverse = this.field.inverse(errorLocations[i]);
                let numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));
                let denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));
                result[i] = this.field.multiply(numerator, denominator);
            }
            return result;
        }
    }

    /*
    * Copyright 2013 ZXing authors
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    /**
     * @author Guenther Grau
     */
    /*final*/ class BoundingBox {
        constructor(image, topLeft, bottomLeft, topRight, bottomRight) {
            if (image instanceof BoundingBox) {
                this.constructor_2(image);
            }
            else {
                this.constructor_1(image, topLeft, bottomLeft, topRight, bottomRight);
            }
        }
        /**
         *
         * @param image
         * @param topLeft
         * @param bottomLeft
         * @param topRight
         * @param bottomRight
         *
         * @throws NotFoundException
         */
        constructor_1(image, topLeft, bottomLeft, topRight, bottomRight) {
            const leftUnspecified = topLeft == null || bottomLeft == null;
            const rightUnspecified = topRight == null || bottomRight == null;
            if (leftUnspecified && rightUnspecified) {
                throw new NotFoundException();
            }
            if (leftUnspecified) {
                topLeft = new ResultPoint(0, topRight.getY());
                bottomLeft = new ResultPoint(0, bottomRight.getY());
            }
            else if (rightUnspecified) {
                topRight = new ResultPoint(image.getWidth() - 1, topLeft.getY());
                bottomRight = new ResultPoint(image.getWidth() - 1, bottomLeft.getY());
            }
            this.image = image;
            this.topLeft = topLeft;
            this.bottomLeft = bottomLeft;
            this.topRight = topRight;
            this.bottomRight = bottomRight;
            this.minX = Math.trunc(Math.min(topLeft.getX(), bottomLeft.getX()));
            this.maxX = Math.trunc(Math.max(topRight.getX(), bottomRight.getX()));
            this.minY = Math.trunc(Math.min(topLeft.getY(), topRight.getY()));
            this.maxY = Math.trunc(Math.max(bottomLeft.getY(), bottomRight.getY()));
        }
        constructor_2(boundingBox) {
            this.image = boundingBox.image;
            this.topLeft = boundingBox.getTopLeft();
            this.bottomLeft = boundingBox.getBottomLeft();
            this.topRight = boundingBox.getTopRight();
            this.bottomRight = boundingBox.getBottomRight();
            this.minX = boundingBox.getMinX();
            this.maxX = boundingBox.getMaxX();
            this.minY = boundingBox.getMinY();
            this.maxY = boundingBox.getMaxY();
        }
        /**
         * @throws NotFoundException
         */
        static merge(leftBox, rightBox) {
            if (leftBox == null) {
                return rightBox;
            }
            if (rightBox == null) {
                return leftBox;
            }
            return new BoundingBox(leftBox.image, leftBox.topLeft, leftBox.bottomLeft, rightBox.topRight, rightBox.bottomRight);
        }
        /**
         * @throws NotFoundException
         */
        addMissingRows(missingStartRows, missingEndRows, isLeft) {
            let newTopLeft = this.topLeft;
            let newBottomLeft = this.bottomLeft;
            let newTopRight = this.topRight;
            let newBottomRight = this.bottomRight;
            if (missingStartRows > 0) {
                let top = isLeft ? this.topLeft : this.topRight;
                let newMinY = Math.trunc(top.getY() - missingStartRows);
                if (newMinY < 0) {
                    newMinY = 0;
                }
                let newTop = new ResultPoint(top.getX(), newMinY);
                if (isLeft) {
                    newTopLeft = newTop;
                }
                else {
                    newTopRight = newTop;
                }
            }
            if (missingEndRows > 0) {
                let bottom = isLeft ? this.bottomLeft : this.bottomRight;
                let newMaxY = Math.trunc(bottom.getY() + missingEndRows);
                if (newMaxY >= this.image.getHeight()) {
                    newMaxY = this.image.getHeight() - 1;
                }
                let newBottom = new ResultPoint(bottom.getX(), newMaxY);
                if (isLeft) {
                    newBottomLeft = newBottom;
                }
                else {
                    newBottomRight = newBottom;
                }
            }
            return new BoundingBox(this.image, newTopLeft, newBottomLeft, newTopRight, newBottomRight);
        }
        getMinX() {
            return this.minX;
        }
        getMaxX() {
            return this.maxX;
        }
        getMinY() {
            return this.minY;
        }
        getMaxY() {
            return this.maxY;
        }
        getTopLeft() {
            return this.topLeft;
        }
        getTopRight() {
            return this.topRight;
        }
        getBottomLeft() {
            return this.bottomLeft;
        }
        getBottomRight() {
            return this.bottomRight;
        }
    }

    /*
     * Copyright 2013 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // package com.google.zxing.pdf417.decoder;
    /**
     * @author Guenther Grau
     */
    /*final*/ class BarcodeMetadata {
        constructor(columnCount, rowCountUpperPart, rowCountLowerPart, errorCorrectionLevel) {
            this.columnCount = columnCount;
            this.errorCorrectionLevel = errorCorrectionLevel;
            this.rowCountUpperPart = rowCountUpperPart;
            this.rowCountLowerPart = rowCountLowerPart;
            this.rowCount = rowCountUpperPart + rowCountLowerPart;
        }
        getColumnCount() {
            return this.columnCount;
        }
        getErrorCorrectionLevel() {
            return this.errorCorrectionLevel;
        }
        getRowCount() {
            return this.rowCount;
        }
        getRowCountUpperPart() {
            return this.rowCountUpperPart;
        }
        getRowCountLowerPart() {
            return this.rowCountLowerPart;
        }
    }

    /**
     * Java Formatter class polyfill that works in the JS way.
     */
    class Formatter {
        constructor() {
            this.buffer = '';
        }
        /**
         *
         * @see https://stackoverflow.com/a/13439711/4367683
         *
         * @param str
         * @param arr
         */
        static form(str, arr) {
            let i = -1;
            function callback(exp, p0, p1, p2, p3, p4) {
                if (exp === '%%')
                    return '%';
                if (arr[++i] === undefined)
                    return undefined;
                exp = p2 ? parseInt(p2.substr(1)) : undefined;
                let base = p3 ? parseInt(p3.substr(1)) : undefined;
                let val;
                switch (p4) {
                    case 's':
                        val = arr[i];
                        break;
                    case 'c':
                        val = arr[i][0];
                        break;
                    case 'f':
                        val = parseFloat(arr[i]).toFixed(exp);
                        break;
                    case 'p':
                        val = parseFloat(arr[i]).toPrecision(exp);
                        break;
                    case 'e':
                        val = parseFloat(arr[i]).toExponential(exp);
                        break;
                    case 'x':
                        val = parseInt(arr[i]).toString(base ? base : 16);
                        break;
                    case 'd':
                        val = parseFloat(parseInt(arr[i], base ? base : 10).toPrecision(exp)).toFixed(0);
                        break;
                }
                val = typeof val === 'object' ? JSON.stringify(val) : (+val).toString(base);
                let size = parseInt(p1); /* padding size */
                let ch = p1 && (p1[0] + '') === '0' ? '0' : ' '; /* isnull? */
                while (val.length < size)
                    val = p0 !== undefined ? val + ch : ch + val; /* isminus? */
                return val;
            }
            let regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
            return str.replace(regex, callback);
        }
        /**
         *
         * @param append The new string to append.
         * @param args Argumets values to be formated.
         */
        format(append, ...args) {
            this.buffer += Formatter.form(append, args);
        }
        /**
         * Returns the Formatter string value.
         */
        toString() {
            return this.buffer;
        }
    }

    /*
     * Copyright 2013 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * @author Guenther Grau
     */
    class DetectionResultColumn {
        constructor(boundingBox) {
            this.boundingBox = new BoundingBox(boundingBox);
            // this.codewords = new Codeword[boundingBox.getMaxY() - boundingBox.getMinY() + 1];
            this.codewords = new Array(boundingBox.getMaxY() - boundingBox.getMinY() + 1);
        }
        /*final*/ getCodewordNearby(imageRow) {
            let codeword = this.getCodeword(imageRow);
            if (codeword != null) {
                return codeword;
            }
            for (let i = 1; i < DetectionResultColumn.MAX_NEARBY_DISTANCE; i++) {
                let nearImageRow = this.imageRowToCodewordIndex(imageRow) - i;
                if (nearImageRow >= 0) {
                    codeword = this.codewords[nearImageRow];
                    if (codeword != null) {
                        return codeword;
                    }
                }
                nearImageRow = this.imageRowToCodewordIndex(imageRow) + i;
                if (nearImageRow < this.codewords.length) {
                    codeword = this.codewords[nearImageRow];
                    if (codeword != null) {
                        return codeword;
                    }
                }
            }
            return null;
        }
        /*final int*/ imageRowToCodewordIndex(imageRow) {
            return imageRow - this.boundingBox.getMinY();
        }
        /*final void*/ setCodeword(imageRow, codeword) {
            this.codewords[this.imageRowToCodewordIndex(imageRow)] = codeword;
        }
        /*final*/ getCodeword(imageRow) {
            return this.codewords[this.imageRowToCodewordIndex(imageRow)];
        }
        /*final*/ getBoundingBox() {
            return this.boundingBox;
        }
        /*final*/ getCodewords() {
            return this.codewords;
        }
        // @Override
        toString() {
            const formatter = new Formatter();
            let row = 0;
            for (const codeword of this.codewords) {
                if (codeword == null) {
                    formatter.format('%3d:    |   %n', row++);
                    continue;
                }
                formatter.format('%3d: %3d|%3d%n', row++, codeword.getRowNumber(), codeword.getValue());
            }
            return formatter.toString();
        }
    }
    DetectionResultColumn.MAX_NEARBY_DISTANCE = 5;

    /*
     * Copyright 2013 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // import java.util.ArrayList;
    // import java.util.Collection;
    // import java.util.HashMap;
    // import java.util.Map;
    // import java.util.Map.Entry;
    /**
     * @author Guenther Grau
     */
    /*final*/ class BarcodeValue {
        constructor() {
            this.values = new Map();
        }
        /**
         * Add an occurrence of a value
         */
        setValue(value) {
            value = Math.trunc(value);
            let confidence = this.values.get(value);
            if (confidence == null) {
                confidence = 0;
            }
            confidence++;
            this.values.set(value, confidence);
        }
        /**
         * Determines the maximum occurrence of a set value and returns all values which were set with this occurrence.
         * @return an array of int, containing the values with the highest occurrence, or null, if no value was set
         */
        getValue() {
            let maxConfidence = -1;
            let result = new Array();
            for (const [key, value] of this.values.entries()) {
                const entry = {
                    getKey: () => key,
                    getValue: () => value,
                };
                if (entry.getValue() > maxConfidence) {
                    maxConfidence = entry.getValue();
                    result = [];
                    result.push(entry.getKey());
                }
                else if (entry.getValue() === maxConfidence) {
                    result.push(entry.getKey());
                }
            }
            return PDF417Common.toIntArray(result);
        }
        getConfidence(value) {
            return this.values.get(value);
        }
    }

    /*
     * Copyright 2013 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * @author Guenther Grau
     */
    /*final*/ class DetectionResultRowIndicatorColumn extends DetectionResultColumn {
        constructor(boundingBox, isLeft) {
            super(boundingBox);
            this._isLeft = isLeft;
        }
        setRowNumbers() {
            for (let codeword /*Codeword*/ of this.getCodewords()) {
                if (codeword != null) {
                    codeword.setRowNumberAsRowIndicatorColumn();
                }
            }
        }
        // TODO implement properly
        // TODO maybe we should add missing codewords to store the correct row number to make
        // finding row numbers for other columns easier
        // use row height count to make detection of invalid row numbers more reliable
        adjustCompleteIndicatorColumnRowNumbers(barcodeMetadata) {
            let codewords = this.getCodewords();
            this.setRowNumbers();
            this.removeIncorrectCodewords(codewords, barcodeMetadata);
            let boundingBox = this.getBoundingBox();
            let top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();
            let bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();
            let firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));
            let lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));
            // We need to be careful using the average row height. Barcode could be skewed so that we have smaller and
            // taller rows
            // float averageRowHeight = (lastRow - firstRow) / /*(float)*/ barcodeMetadata.getRowCount();
            let barcodeRow = -1;
            let maxRowHeight = 1;
            let currentRowHeight = 0;
            for (let codewordsRow /*int*/ = firstRow; codewordsRow < lastRow; codewordsRow++) {
                if (codewords[codewordsRow] == null) {
                    continue;
                }
                let codeword = codewords[codewordsRow];
                //      float expectedRowNumber = (codewordsRow - firstRow) / averageRowHeight;
                //      if (Math.abs(codeword.getRowNumber() - expectedRowNumber) > 2) {
                //        SimpleLog.log(LEVEL.WARNING,
                //            "Removing codeword, rowNumberSkew too high, codeword[" + codewordsRow + "]: Expected Row: " +
                //                expectedRowNumber + ", RealRow: " + codeword.getRowNumber() + ", value: " + codeword.getValue());
                //        codewords[codewordsRow] = null;
                //      }
                let rowDifference = codeword.getRowNumber() - barcodeRow;
                // TODO improve handling with case where first row indicator doesn't start with 0
                if (rowDifference === 0) {
                    currentRowHeight++;
                }
                else if (rowDifference === 1) {
                    maxRowHeight = Math.max(maxRowHeight, currentRowHeight);
                    currentRowHeight = 1;
                    barcodeRow = codeword.getRowNumber();
                }
                else if (rowDifference < 0 ||
                    codeword.getRowNumber() >= barcodeMetadata.getRowCount() ||
                    rowDifference > codewordsRow) {
                    codewords[codewordsRow] = null;
                }
                else {
                    let checkedRows;
                    if (maxRowHeight > 2) {
                        checkedRows = (maxRowHeight - 2) * rowDifference;
                    }
                    else {
                        checkedRows = rowDifference;
                    }
                    let closePreviousCodewordFound = checkedRows >= codewordsRow;
                    for (let i /*int*/ = 1; i <= checkedRows && !closePreviousCodewordFound; i++) {
                        // there must be (height * rowDifference) number of codewords missing. For now we assume height = 1.
                        // This should hopefully get rid of most problems already.
                        closePreviousCodewordFound = codewords[codewordsRow - i] != null;
                    }
                    if (closePreviousCodewordFound) {
                        codewords[codewordsRow] = null;
                    }
                    else {
                        barcodeRow = codeword.getRowNumber();
                        currentRowHeight = 1;
                    }
                }
            }
            // return (int) (averageRowHeight + 0.5);
        }
        getRowHeights() {
            let barcodeMetadata = this.getBarcodeMetadata();
            if (barcodeMetadata == null) {
                return null;
            }
            this.adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata);
            let result = new Int32Array(barcodeMetadata.getRowCount());
            for (let codeword /*Codeword*/ of this.getCodewords()) {
                if (codeword != null) {
                    let rowNumber = codeword.getRowNumber();
                    if (rowNumber >= result.length) {
                        // We have more rows than the barcode metadata allows for, ignore them.
                        continue;
                    }
                    result[rowNumber]++;
                } // else throw exception?
            }
            return result;
        }
        // TODO maybe we should add missing codewords to store the correct row number to make
        // finding row numbers for other columns easier
        // use row height count to make detection of invalid row numbers more reliable
        adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata) {
            let boundingBox = this.getBoundingBox();
            let top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();
            let bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();
            let firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));
            let lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));
            // float averageRowHeight = (lastRow - firstRow) / /*(float)*/ barcodeMetadata.getRowCount();
            let codewords = this.getCodewords();
            let barcodeRow = -1;
            for (let codewordsRow /*int*/ = firstRow; codewordsRow < lastRow; codewordsRow++) {
                if (codewords[codewordsRow] == null) {
                    continue;
                }
                let codeword = codewords[codewordsRow];
                codeword.setRowNumberAsRowIndicatorColumn();
                let rowDifference = codeword.getRowNumber() - barcodeRow;
                // TODO improve handling with case where first row indicator doesn't start with 0
                if (rowDifference === 0) ;
                else if (rowDifference === 1) {
                    barcodeRow = codeword.getRowNumber();
                }
                else if (codeword.getRowNumber() >= barcodeMetadata.getRowCount()) {
                    codewords[codewordsRow] = null;
                }
                else {
                    barcodeRow = codeword.getRowNumber();
                }
            }
            // return (int) (averageRowHeight + 0.5);
        }
        getBarcodeMetadata() {
            let codewords = this.getCodewords();
            let barcodeColumnCount = new BarcodeValue();
            let barcodeRowCountUpperPart = new BarcodeValue();
            let barcodeRowCountLowerPart = new BarcodeValue();
            let barcodeECLevel = new BarcodeValue();
            for (let codeword /*Codeword*/ of codewords) {
                if (codeword == null) {
                    continue;
                }
                codeword.setRowNumberAsRowIndicatorColumn();
                let rowIndicatorValue = codeword.getValue() % 30;
                let codewordRowNumber = codeword.getRowNumber();
                if (!this._isLeft) {
                    codewordRowNumber += 2;
                }
                switch (codewordRowNumber % 3) {
                    case 0:
                        barcodeRowCountUpperPart.setValue(rowIndicatorValue * 3 + 1);
                        break;
                    case 1:
                        barcodeECLevel.setValue(rowIndicatorValue / 3);
                        barcodeRowCountLowerPart.setValue(rowIndicatorValue % 3);
                        break;
                    case 2:
                        barcodeColumnCount.setValue(rowIndicatorValue + 1);
                        break;
                }
            }
            // Maybe we should check if we have ambiguous values?
            if ((barcodeColumnCount.getValue().length === 0) ||
                (barcodeRowCountUpperPart.getValue().length === 0) ||
                (barcodeRowCountLowerPart.getValue().length === 0) ||
                (barcodeECLevel.getValue().length === 0) ||
                barcodeColumnCount.getValue()[0] < 1 ||
                barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] < PDF417Common.MIN_ROWS_IN_BARCODE ||
                barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] > PDF417Common.MAX_ROWS_IN_BARCODE) {
                return null;
            }
            let barcodeMetadata = new BarcodeMetadata(barcodeColumnCount.getValue()[0], barcodeRowCountUpperPart.getValue()[0], barcodeRowCountLowerPart.getValue()[0], barcodeECLevel.getValue()[0]);
            this.removeIncorrectCodewords(codewords, barcodeMetadata);
            return barcodeMetadata;
        }
        removeIncorrectCodewords(codewords, barcodeMetadata) {
            // Remove codewords which do not match the metadata
            // TODO Maybe we should keep the incorrect codewords for the start and end positions?
            for (let codewordRow /*int*/ = 0; codewordRow < codewords.length; codewordRow++) {
                let codeword = codewords[codewordRow];
                if (codewords[codewordRow] == null) {
                    continue;
                }
                let rowIndicatorValue = codeword.getValue() % 30;
                let codewordRowNumber = codeword.getRowNumber();
                if (codewordRowNumber > barcodeMetadata.getRowCount()) {
                    codewords[codewordRow] = null;
                    continue;
                }
                if (!this._isLeft) {
                    codewordRowNumber += 2;
                }
                switch (codewordRowNumber % 3) {
                    case 0:
                        if (rowIndicatorValue * 3 + 1 !== barcodeMetadata.getRowCountUpperPart()) {
                            codewords[codewordRow] = null;
                        }
                        break;
                    case 1:
                        if (Math.trunc(rowIndicatorValue / 3) !== barcodeMetadata.getErrorCorrectionLevel() ||
                            rowIndicatorValue % 3 !== barcodeMetadata.getRowCountLowerPart()) {
                            codewords[codewordRow] = null;
                        }
                        break;
                    case 2:
                        if (rowIndicatorValue + 1 !== barcodeMetadata.getColumnCount()) {
                            codewords[codewordRow] = null;
                        }
                        break;
                }
            }
        }
        isLeft() {
            return this._isLeft;
        }
        // @Override
        toString() {
            return 'IsLeft: ' + this._isLeft + '\n' + super.toString();
        }
    }

    /*
     * Copyright 2013 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * @author Guenther Grau
     */
    /*final*/ class DetectionResult {
        constructor(barcodeMetadata, boundingBox) {
            /*final*/ this.ADJUST_ROW_NUMBER_SKIP = 2;
            this.barcodeMetadata = barcodeMetadata;
            this.barcodeColumnCount = barcodeMetadata.getColumnCount();
            this.boundingBox = boundingBox;
            // this.detectionResultColumns = new DetectionResultColumn[this.barcodeColumnCount + 2];
            this.detectionResultColumns = new Array(this.barcodeColumnCount + 2);
        }
        getDetectionResultColumns() {
            this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]);
            this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[this.barcodeColumnCount + 1]);
            let unadjustedCodewordCount = PDF417Common.MAX_CODEWORDS_IN_BARCODE;
            let previousUnadjustedCount;
            do {
                previousUnadjustedCount = unadjustedCodewordCount;
                unadjustedCodewordCount = this.adjustRowNumbersAndGetCount();
            } while (unadjustedCodewordCount > 0 && unadjustedCodewordCount < previousUnadjustedCount);
            return this.detectionResultColumns;
        }
        adjustIndicatorColumnRowNumbers(detectionResultColumn) {
            if (detectionResultColumn != null) {
                detectionResultColumn
                    .adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata);
            }
        }
        // TODO ensure that no detected codewords with unknown row number are left
        // we should be able to estimate the row height and use it as a hint for the row number
        // we should also fill the rows top to bottom and bottom to top
        /**
         * @return number of codewords which don't have a valid row number. Note that the count is not accurate as codewords
         * will be counted several times. It just serves as an indicator to see when we can stop adjusting row numbers
         */
        adjustRowNumbersAndGetCount() {
            let unadjustedCount = this.adjustRowNumbersByRow();
            if (unadjustedCount === 0) {
                return 0;
            }
            for (let barcodeColumn /*int*/ = 1; barcodeColumn < this.barcodeColumnCount + 1; barcodeColumn++) {
                let codewords = this.detectionResultColumns[barcodeColumn].getCodewords();
                for (let codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {
                    if (codewords[codewordsRow] == null) {
                        continue;
                    }
                    if (!codewords[codewordsRow].hasValidRowNumber()) {
                        this.adjustRowNumbers(barcodeColumn, codewordsRow, codewords);
                    }
                }
            }
            return unadjustedCount;
        }
        adjustRowNumbersByRow() {
            this.adjustRowNumbersFromBothRI();
            // TODO we should only do full row adjustments if row numbers of left and right row indicator column match.
            // Maybe it's even better to calculated the height (rows: d) and divide it by the number of barcode
            // rows. This, together with the LRI and RRI row numbers should allow us to get a good estimate where a row
            // number starts and ends.
            let unadjustedCount = this.adjustRowNumbersFromLRI();
            return unadjustedCount + this.adjustRowNumbersFromRRI();
        }
        adjustRowNumbersFromBothRI() {
            if (this.detectionResultColumns[0] == null || this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {
                return;
            }
            let LRIcodewords = this.detectionResultColumns[0].getCodewords();
            let RRIcodewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();
            for (let codewordsRow /*int*/ = 0; codewordsRow < LRIcodewords.length; codewordsRow++) {
                if (LRIcodewords[codewordsRow] != null &&
                    RRIcodewords[codewordsRow] != null &&
                    LRIcodewords[codewordsRow].getRowNumber() === RRIcodewords[codewordsRow].getRowNumber()) {
                    for (let barcodeColumn /*int*/ = 1; barcodeColumn <= this.barcodeColumnCount; barcodeColumn++) {
                        let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
                        if (codeword == null) {
                            continue;
                        }
                        codeword.setRowNumber(LRIcodewords[codewordsRow].getRowNumber());
                        if (!codeword.hasValidRowNumber()) {
                            this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow] = null;
                        }
                    }
                }
            }
        }
        adjustRowNumbersFromRRI() {
            if (this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {
                return 0;
            }
            let unadjustedCount = 0;
            let codewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();
            for (let codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {
                if (codewords[codewordsRow] == null) {
                    continue;
                }
                let rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();
                let invalidRowCounts = 0;
                for (let barcodeColumn /*int*/ = this.barcodeColumnCount + 1; barcodeColumn > 0 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn--) {
                    let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
                    if (codeword != null) {
                        invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);
                        if (!codeword.hasValidRowNumber()) {
                            unadjustedCount++;
                        }
                    }
                }
            }
            return unadjustedCount;
        }
        adjustRowNumbersFromLRI() {
            if (this.detectionResultColumns[0] == null) {
                return 0;
            }
            let unadjustedCount = 0;
            let codewords = this.detectionResultColumns[0].getCodewords();
            for (let codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {
                if (codewords[codewordsRow] == null) {
                    continue;
                }
                let rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();
                let invalidRowCounts = 0;
                for (let barcodeColumn /*int*/ = 1; barcodeColumn < this.barcodeColumnCount + 1 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn++) {
                    let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
                    if (codeword != null) {
                        invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);
                        if (!codeword.hasValidRowNumber()) {
                            unadjustedCount++;
                        }
                    }
                }
            }
            return unadjustedCount;
        }
        static adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword) {
            if (codeword == null) {
                return invalidRowCounts;
            }
            if (!codeword.hasValidRowNumber()) {
                if (codeword.isValidRowNumber(rowIndicatorRowNumber)) {
                    codeword.setRowNumber(rowIndicatorRowNumber);
                    invalidRowCounts = 0;
                }
                else {
                    ++invalidRowCounts;
                }
            }
            return invalidRowCounts;
        }
        adjustRowNumbers(barcodeColumn, codewordsRow, codewords) {
            if (this.detectionResultColumns[barcodeColumn - 1] == null) {
                return;
            }
            let codeword = codewords[codewordsRow];
            let previousColumnCodewords = this.detectionResultColumns[barcodeColumn - 1].getCodewords();
            let nextColumnCodewords = previousColumnCodewords;
            if (this.detectionResultColumns[barcodeColumn + 1] != null) {
                nextColumnCodewords = this.detectionResultColumns[barcodeColumn + 1].getCodewords();
            }
            // let otherCodewords: Codeword[] = new Codeword[14];
            let otherCodewords = new Array(14);
            otherCodewords[2] = previousColumnCodewords[codewordsRow];
            otherCodewords[3] = nextColumnCodewords[codewordsRow];
            if (codewordsRow > 0) {
                otherCodewords[0] = codewords[codewordsRow - 1];
                otherCodewords[4] = previousColumnCodewords[codewordsRow - 1];
                otherCodewords[5] = nextColumnCodewords[codewordsRow - 1];
            }
            if (codewordsRow > 1) {
                otherCodewords[8] = codewords[codewordsRow - 2];
                otherCodewords[10] = previousColumnCodewords[codewordsRow - 2];
                otherCodewords[11] = nextColumnCodewords[codewordsRow - 2];
            }
            if (codewordsRow < codewords.length - 1) {
                otherCodewords[1] = codewords[codewordsRow + 1];
                otherCodewords[6] = previousColumnCodewords[codewordsRow + 1];
                otherCodewords[7] = nextColumnCodewords[codewordsRow + 1];
            }
            if (codewordsRow < codewords.length - 2) {
                otherCodewords[9] = codewords[codewordsRow + 2];
                otherCodewords[12] = previousColumnCodewords[codewordsRow + 2];
                otherCodewords[13] = nextColumnCodewords[codewordsRow + 2];
            }
            for (let otherCodeword of otherCodewords) {
                if (DetectionResult.adjustRowNumber(codeword, otherCodeword)) {
                    return;
                }
            }
        }
        /**
         * @return true, if row number was adjusted, false otherwise
         */
        static adjustRowNumber(codeword, otherCodeword) {
            if (otherCodeword == null) {
                return false;
            }
            if (otherCodeword.hasValidRowNumber() && otherCodeword.getBucket() === codeword.getBucket()) {
                codeword.setRowNumber(otherCodeword.getRowNumber());
                return true;
            }
            return false;
        }
        getBarcodeColumnCount() {
            return this.barcodeColumnCount;
        }
        getBarcodeRowCount() {
            return this.barcodeMetadata.getRowCount();
        }
        getBarcodeECLevel() {
            return this.barcodeMetadata.getErrorCorrectionLevel();
        }
        setBoundingBox(boundingBox) {
            this.boundingBox = boundingBox;
        }
        getBoundingBox() {
            return this.boundingBox;
        }
        setDetectionResultColumn(barcodeColumn, detectionResultColumn) {
            this.detectionResultColumns[barcodeColumn] = detectionResultColumn;
        }
        getDetectionResultColumn(barcodeColumn) {
            return this.detectionResultColumns[barcodeColumn];
        }
        // @Override
        toString() {
            let rowIndicatorColumn = this.detectionResultColumns[0];
            if (rowIndicatorColumn == null) {
                rowIndicatorColumn = this.detectionResultColumns[this.barcodeColumnCount + 1];
            }
            // try (
            let formatter = new Formatter();
            // ) {
            for (let codewordsRow /*int*/ = 0; codewordsRow < rowIndicatorColumn.getCodewords().length; codewordsRow++) {
                formatter.format('CW %3d:', codewordsRow);
                for (let barcodeColumn /*int*/ = 0; barcodeColumn < this.barcodeColumnCount + 2; barcodeColumn++) {
                    if (this.detectionResultColumns[barcodeColumn] == null) {
                        formatter.format('    |   ');
                        continue;
                    }
                    let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
                    if (codeword == null) {
                        formatter.format('    |   ');
                        continue;
                    }
                    formatter.format(' %3d|%3d', codeword.getRowNumber(), codeword.getValue());
                }
                formatter.format('%n');
            }
            return formatter.toString();
            // }
        }
    }

    /*
     * Copyright 2013 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // package com.google.zxing.pdf417.decoder;
    /**
     * @author Guenther Grau
     */
    /*final*/ class Codeword {
        constructor(startX, endX, bucket, value) {
            this.rowNumber = Codeword.BARCODE_ROW_UNKNOWN;
            this.startX = Math.trunc(startX);
            this.endX = Math.trunc(endX);
            this.bucket = Math.trunc(bucket);
            this.value = Math.trunc(value);
        }
        hasValidRowNumber() {
            return this.isValidRowNumber(this.rowNumber);
        }
        isValidRowNumber(rowNumber) {
            return rowNumber !== Codeword.BARCODE_ROW_UNKNOWN && this.bucket === (rowNumber % 3) * 3;
        }
        setRowNumberAsRowIndicatorColumn() {
            this.rowNumber = Math.trunc((Math.trunc(this.value / 30)) * 3 + Math.trunc(this.bucket / 3));
        }
        getWidth() {
            return this.endX - this.startX;
        }
        getStartX() {
            return this.startX;
        }
        getEndX() {
            return this.endX;
        }
        getBucket() {
            return this.bucket;
        }
        getValue() {
            return this.value;
        }
        getRowNumber() {
            return this.rowNumber;
        }
        setRowNumber(rowNumber) {
            this.rowNumber = rowNumber;
        }
        //   @Override
        toString() {
            return this.rowNumber + '|' + this.value;
        }
    }
    Codeword.BARCODE_ROW_UNKNOWN = -1;

    /*
    * Copyright 2013 ZXing authors
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    /**
     * @author Guenther Grau
     * @author creatale GmbH (christoph.schulz@creatale.de)
     */
    /*final*/ class PDF417CodewordDecoder {
        /* @note
         * this action have to be performed before first use of class
         * - static constructor
         * working with 32bit float (based from Java logic)
        */
        static initialize() {
            // Pre-computes the symbol ratio table.
            for ( /*int*/let i = 0; i < PDF417Common.SYMBOL_TABLE.length; i++) {
                let currentSymbol = PDF417Common.SYMBOL_TABLE[i];
                let currentBit = currentSymbol & 0x1;
                for ( /*int*/let j = 0; j < PDF417Common.BARS_IN_MODULE; j++) {
                    let size = 0.0;
                    while ((currentSymbol & 0x1) === currentBit) {
                        size += 1.0;
                        currentSymbol >>= 1;
                    }
                    currentBit = currentSymbol & 0x1;
                    if (!PDF417CodewordDecoder.RATIOS_TABLE[i]) {
                        PDF417CodewordDecoder.RATIOS_TABLE[i] = new Array(PDF417Common.BARS_IN_MODULE);
                    }
                    PDF417CodewordDecoder.RATIOS_TABLE[i][PDF417Common.BARS_IN_MODULE - j - 1] = Math.fround(size / PDF417Common.MODULES_IN_CODEWORD);
                }
            }
            this.bSymbolTableReady = true;
        }
        static getDecodedValue(moduleBitCount) {
            let decodedValue = PDF417CodewordDecoder.getDecodedCodewordValue(PDF417CodewordDecoder.sampleBitCounts(moduleBitCount));
            if (decodedValue !== -1) {
                return decodedValue;
            }
            return PDF417CodewordDecoder.getClosestDecodedValue(moduleBitCount);
        }
        static sampleBitCounts(moduleBitCount) {
            let bitCountSum = MathUtils.sum(moduleBitCount);
            let result = new Int32Array(PDF417Common.BARS_IN_MODULE);
            let bitCountIndex = 0;
            let sumPreviousBits = 0;
            for ( /*int*/let i = 0; i < PDF417Common.MODULES_IN_CODEWORD; i++) {
                let sampleIndex = bitCountSum / (2 * PDF417Common.MODULES_IN_CODEWORD) +
                    (i * bitCountSum) / PDF417Common.MODULES_IN_CODEWORD;
                if (sumPreviousBits + moduleBitCount[bitCountIndex] <= sampleIndex) {
                    sumPreviousBits += moduleBitCount[bitCountIndex];
                    bitCountIndex++;
                }
                result[bitCountIndex]++;
            }
            return result;
        }
        static getDecodedCodewordValue(moduleBitCount) {
            let decodedValue = PDF417CodewordDecoder.getBitValue(moduleBitCount);
            return PDF417Common.getCodeword(decodedValue) === -1 ? -1 : decodedValue;
        }
        static getBitValue(moduleBitCount) {
            let result = /*long*/ 0;
            for (let /*int*/ i = 0; i < moduleBitCount.length; i++) {
                for ( /*int*/let bit = 0; bit < moduleBitCount[i]; bit++) {
                    result = (result << 1) | (i % 2 === 0 ? 1 : 0);
                }
            }
            return Math.trunc(result);
        }
        // working with 32bit float (as in Java)
        static getClosestDecodedValue(moduleBitCount) {
            let bitCountSum = MathUtils.sum(moduleBitCount);
            let bitCountRatios = new Array(PDF417Common.BARS_IN_MODULE);
            if (bitCountSum > 1) {
                for (let /*int*/ i = 0; i < bitCountRatios.length; i++) {
                    bitCountRatios[i] = Math.fround(moduleBitCount[i] / bitCountSum);
                }
            }
            let bestMatchError = Float.MAX_VALUE;
            let bestMatch = -1;
            if (!this.bSymbolTableReady) {
                PDF417CodewordDecoder.initialize();
            }
            for ( /*int*/let j = 0; j < PDF417CodewordDecoder.RATIOS_TABLE.length; j++) {
                let error = 0.0;
                let ratioTableRow = PDF417CodewordDecoder.RATIOS_TABLE[j];
                for ( /*int*/let k = 0; k < PDF417Common.BARS_IN_MODULE; k++) {
                    let diff = Math.fround(ratioTableRow[k] - bitCountRatios[k]);
                    error += Math.fround(diff * diff);
                    if (error >= bestMatchError) {
                        break;
                    }
                }
                if (error < bestMatchError) {
                    bestMatchError = error;
                    bestMatch = PDF417Common.SYMBOL_TABLE[j];
                }
            }
            return bestMatch;
        }
    }
    // flag that the table is ready for use
    PDF417CodewordDecoder.bSymbolTableReady = false;
    PDF417CodewordDecoder.RATIOS_TABLE = new Array(PDF417Common.SYMBOL_TABLE.length).map(x => x = new Array(PDF417Common.BARS_IN_MODULE));

    /*
     * Copyright 2013 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // package com.google.zxing.pdf417;
    /**
     * @author Guenther Grau
     */
    /*public final*/ class PDF417ResultMetadata {
        constructor() {
            this.segmentCount = -1;
            this.fileSize = -1;
            this.timestamp = -1;
            this.checksum = -1;
        }
        /**
         * The Segment ID represents the segment of the whole file distributed over different symbols.
         *
         * @return File segment index
         */
        getSegmentIndex() {
            return this.segmentIndex;
        }
        setSegmentIndex(segmentIndex) {
            this.segmentIndex = segmentIndex;
        }
        /**
         * Is the same for each related PDF417 symbol
         *
         * @return File ID
         */
        getFileId() {
            return this.fileId;
        }
        setFileId(fileId) {
            this.fileId = fileId;
        }
        /**
         * @return always null
         * @deprecated use dedicated already parsed fields
         */
        //   @Deprecated
        getOptionalData() {
            return this.optionalData;
        }
        /**
         * @param optionalData old optional data format as int array
         * @deprecated parse and use new fields
         */
        //   @Deprecated
        setOptionalData(optionalData) {
            this.optionalData = optionalData;
        }
        /**
         * @return true if it is the last segment
         */
        isLastSegment() {
            return this.lastSegment;
        }
        setLastSegment(lastSegment) {
            this.lastSegment = lastSegment;
        }
        /**
         * @return count of segments, -1 if not set
         */
        getSegmentCount() {
            return this.segmentCount;
        }
        setSegmentCount(segmentCount /*int*/) {
            this.segmentCount = segmentCount;
        }
        getSender() {
            return this.sender || null;
        }
        setSender(sender) {
            this.sender = sender;
        }
        getAddressee() {
            return this.addressee || null;
        }
        setAddressee(addressee) {
            this.addressee = addressee;
        }
        /**
         * Filename of the encoded file
         *
         * @return filename
         */
        getFileName() {
            return this.fileName;
        }
        setFileName(fileName) {
            this.fileName = fileName;
        }
        /**
         * filesize in bytes of the encoded file
         *
         * @return filesize in bytes, -1 if not set
         */
        getFileSize() {
            return this.fileSize;
        }
        setFileSize(fileSize /*long*/) {
            this.fileSize = fileSize;
        }
        /**
         * 16-bit CRC checksum using CCITT-16
         *
         * @return crc checksum, -1 if not set
         */
        getChecksum() {
            return this.checksum;
        }
        setChecksum(checksum /*int*/) {
            this.checksum = checksum;
        }
        /**
         * unix epock timestamp, elapsed seconds since 1970-01-01
         *
         * @return elapsed seconds, -1 if not set
         */
        getTimestamp() {
            return this.timestamp;
        }
        setTimestamp(timestamp /*long*/) {
            this.timestamp = timestamp;
        }
    }

    /**
     * Ponyfill for Java's Long class.
     */
    class Long {
        /**
         * Parses a string to a number, since JS has no really Int64.
         *
         * @param num Numeric string.
         * @param radix Destination radix.
         */
        static parseLong(num, radix = undefined) {
            return parseInt(num, radix);
        }
    }

    /**
     * Custom Error class of type Exception.
     */
    class NullPointerException extends Exception {
    }
    NullPointerException.kind = 'NullPointerException';

    /*
     * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.
     * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
     *
     * This code is free software; you can redistribute it and/or modify it
     * under the terms of the GNU General Public License version 2 only, as
     * published by the Free Software Foundation.  Oracle designates this
     * particular file as subject to the "Classpath" exception as provided
     * by Oracle in the LICENSE file that accompanied this code.
     *
     * This code is distributed in the hope that it will be useful, but WITHOUT
     * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
     * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
     * version 2 for more details (a copy is included in the LICENSE file that
     * accompanied this code).
     *
     * You should have received a copy of the GNU General Public License version
     * 2 along with this work; if not, write to the Free Software Foundation,
     * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
     *
     * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
     * or visit www.oracle.com if you need additional information or have any
     * questions.
     */
    // package java.io;
    /**
     * This abstract class is the superclass of all classes representing
     * an output stream of bytes. An output stream accepts output bytes
     * and sends them to some sink.
     * <p>
     * Applications that need to define a subclass of
     * <code>OutputStream</code> must always provide at least a method
     * that writes one byte of output.
     *
     * @author  Arthur van Hoff
     * @see     java.io.BufferedOutputStream
     * @see     java.io.ByteArrayOutputStream
     * @see     java.io.DataOutputStream
     * @see     java.io.FilterOutputStream
     * @see     java.io.InputStream
     * @see     java.io.OutputStream#write(int)
     * @since   JDK1.0
     */
    /*public*/ class OutputStream /*implements Closeable, Flushable*/ {
        /**
         * Writes <code>b.length</code> bytes from the specified byte array
         * to this output stream. The general contract for <code>write(b)</code>
         * is that it should have exactly the same effect as the call
         * <code>write(b, 0, b.length)</code>.
         *
         * @param      b   the data.
         * @exception  IOException  if an I/O error occurs.
         * @see        java.io.OutputStream#write(byte[], int, int)
         */
        writeBytes(b) {
            this.writeBytesOffset(b, 0, b.length);
        }
        /**
         * Writes <code>len</code> bytes from the specified byte array
         * starting at offset <code>off</code> to this output stream.
         * The general contract for <code>write(b, off, len)</code> is that
         * some of the bytes in the array <code>b</code> are written to the
         * output stream in order; element <code>b[off]</code> is the first
         * byte written and <code>b[off+len-1]</code> is the last byte written
         * by this operation.
         * <p>
         * The <code>write</code> method of <code>OutputStream</code> calls
         * the write method of one argument on each of the bytes to be
         * written out. Subclasses are encouraged to override this method and
         * provide a more efficient implementation.
         * <p>
         * If <code>b</code> is <code>null</code>, a
         * <code>NullPointerException</code> is thrown.
         * <p>
         * If <code>off</code> is negative, or <code>len</code> is negative, or
         * <code>off+len</code> is greater than the length of the array
         * <code>b</code>, then an <tt>IndexOutOfBoundsException</tt> is thrown.
         *
         * @param      b     the data.
         * @param      off   the start offset in the data.
         * @param      len   the number of bytes to write.
         * @exception  IOException  if an I/O error occurs. In particular,
         *             an <code>IOException</code> is thrown if the output
         *             stream is closed.
         */
        writeBytesOffset(b, off, len) {
            if (b == null) {
                throw new NullPointerException();
            }
            else if ((off < 0) || (off > b.length) || (len < 0) ||
                ((off + len) > b.length) || ((off + len) < 0)) {
                throw new IndexOutOfBoundsException();
            }
            else if (len === 0) {
                return;
            }
            for (let i = 0; i < len; i++) {
                this.write(b[off + i]);
            }
        }
        /**
         * Flushes this output stream and forces any buffered output bytes
         * to be written out. The general contract of <code>flush</code> is
         * that calling it is an indication that, if any bytes previously
         * written have been buffered by the implementation of the output
         * stream, such bytes should immediately be written to their
         * intended destination.
         * <p>
         * If the intended destination of this stream is an abstraction provided by
         * the underlying operating system, for example a file, then flushing the
         * stream guarantees only that bytes previously written to the stream are
         * passed to the operating system for writing; it does not guarantee that
         * they are actually written to a physical device such as a disk drive.
         * <p>
         * The <code>flush</code> method of <code>OutputStream</code> does nothing.
         *
         * @exception  IOException  if an I/O error occurs.
         */
        flush() {
        }
        /**
         * Closes this output stream and releases any system resources
         * associated with this stream. The general contract of <code>close</code>
         * is that it closes the output stream. A closed stream cannot perform
         * output operations and cannot be reopened.
         * <p>
         * The <code>close</code> method of <code>OutputStream</code> does nothing.
         *
         * @exception  IOException  if an I/O error occurs.
         */
        close() {
        }
    }

    /**
     * Custom Error class of type Exception.
     */
    class OutOfMemoryError extends Exception {
    }

    /*
     * Copyright (c) 1994, 2010, Oracle and/or its affiliates. All rights reserved.
     * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
     *
     * This code is free software; you can redistribute it and/or modify it
     * under the terms of the GNU General Public License version 2 only, as
     * published by the Free Software Foundation.  Oracle designates this
     * particular file as subject to the "Classpath" exception as provided
     * by Oracle in the LICENSE file that accompanied this code.
     *
     * This code is distributed in the hope that it will be useful, but WITHOUT
     * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
     * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
     * version 2 for more details (a copy is included in the LICENSE file that
     * accompanied this code).
     *
     * You should have received a copy of the GNU General Public License version
     * 2 along with this work; if not, write to the Free Software Foundation,
     * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
     *
     * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
     * or visit www.oracle.com if you need additional information or have any
     * questions.
     */
    /**
     * This class implements an output stream in which the data is
     * written into a byte array. The buffer automatically grows as data
     * is written to it.
     * The data can be retrieved using <code>toByteArray()</code> and
     * <code>toString()</code>.
     * <p>
     * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in
     * this class can be called after the stream has been closed without
     * generating an <tt>IOException</tt>.
     *
     * @author  Arthur van Hoff
     * @since   JDK1.0
     */
    /*public*/ class ByteArrayOutputStream extends OutputStream {
        /**
         * Creates a new byte array output stream. The buffer capacity is
         * initially 32 bytes, though its size increases if necessary.
         */
        // public constructor() {
        //     this(32);
        // }
        /**
         * Creates a new byte array output stream, with a buffer capacity of
         * the specified size, in bytes.
         *
         * @param   size   the initial size.
         * @exception  IllegalArgumentException if size is negative.
         */
        constructor(size = 32) {
            super();
            /**
             * The number of valid bytes in the buffer.
             */
            this.count = 0;
            if (size < 0) {
                throw new IllegalArgumentException('Negative initial size: '
                    + size);
            }
            this.buf = new Uint8Array(size);
        }
        /**
         * Increases the capacity if necessary to ensure that it can hold
         * at least the number of elements specified by the minimum
         * capacity argument.
         *
         * @param minCapacity the desired minimum capacity
         * @throws OutOfMemoryError if {@code minCapacity < 0}.  This is
         * interpreted as a request for the unsatisfiably large capacity
         * {@code (long) Integer.MAX_VALUE + (minCapacity - Integer.MAX_VALUE)}.
         */
        ensureCapacity(minCapacity) {
            // overflow-conscious code
            if (minCapacity - this.buf.length > 0)
                this.grow(minCapacity);
        }
        /**
         * Increases the capacity to ensure that it can hold at least the
         * number of elements specified by the minimum capacity argument.
         *
         * @param minCapacity the desired minimum capacity
         */
        grow(minCapacity) {
            // overflow-conscious code
            let oldCapacity = this.buf.length;
            let newCapacity = oldCapacity << 1;
            if (newCapacity - minCapacity < 0)
                newCapacity = minCapacity;
            if (newCapacity < 0) {
                if (minCapacity < 0) // overflow
                    throw new OutOfMemoryError();
                newCapacity = Integer.MAX_VALUE;
            }
            this.buf = Arrays.copyOfUint8Array(this.buf, newCapacity);
        }
        /**
         * Writes the specified byte to this byte array output stream.
         *
         * @param   b   the byte to be written.
         */
        write(b) {
            this.ensureCapacity(this.count + 1);
            this.buf[this.count] = /*(byte)*/ b;
            this.count += 1;
        }
        /**
         * Writes <code>len</code> bytes from the specified byte array
         * starting at offset <code>off</code> to this byte array output stream.
         *
         * @param   b     the data.
         * @param   off   the start offset in the data.
         * @param   len   the number of bytes to write.
         */
        writeBytesOffset(b, off, len) {
            if ((off < 0) || (off > b.length) || (len < 0) ||
                ((off + len) - b.length > 0)) {
                throw new IndexOutOfBoundsException();
            }
            this.ensureCapacity(this.count + len);
            System.arraycopy(b, off, this.buf, this.count, len);
            this.count += len;
        }
        /**
         * Writes the complete contents of this byte array output stream to
         * the specified output stream argument, as if by calling the output
         * stream's write method using <code>out.write(buf, 0, count)</code>.
         *
         * @param      out   the output stream to which to write the data.
         * @exception  IOException  if an I/O error occurs.
         */
        writeTo(out) {
            out.writeBytesOffset(this.buf, 0, this.count);
        }
        /**
         * Resets the <code>count</code> field of this byte array output
         * stream to zero, so that all currently accumulated output in the
         * output stream is discarded. The output stream can be used again,
         * reusing the already allocated buffer space.
         *
         * @see     java.io.ByteArrayInputStream#count
         */
        reset() {
            this.count = 0;
        }
        /**
         * Creates a newly allocated byte array. Its size is the current
         * size of this output stream and the valid contents of the buffer
         * have been copied into it.
         *
         * @return  the current contents of this output stream, as a byte array.
         * @see     java.io.ByteArrayOutputStream#size()
         */
        toByteArray() {
            return Arrays.copyOfUint8Array(this.buf, this.count);
        }
        /**
         * Returns the current size of the buffer.
         *
         * @return  the value of the <code>count</code> field, which is the number
         *          of valid bytes in this output stream.
         * @see     java.io.ByteArrayOutputStream#count
         */
        size() {
            return this.count;
        }
        toString(param) {
            if (!param) {
                return this.toString_void();
            }
            if (typeof param === 'string') {
                return this.toString_string(param);
            }
            return this.toString_number(param);
        }
        /**
         * Converts the buffer's contents into a string decoding bytes using the
         * platform's default character set. The length of the new <tt>String</tt>
         * is a function of the character set, and hence may not be equal to the
         * size of the buffer.
         *
         * <p> This method always replaces malformed-input and unmappable-character
         * sequences with the default replacement string for the platform's
         * default character set. The {@linkplain java.nio.charset.CharsetDecoder}
         * class should be used when more control over the decoding process is
         * required.
         *
         * @return String decoded from the buffer's contents.
         * @since  JDK1.1
         */
        toString_void() {
            return new String(this.buf /*, 0, this.count*/).toString();
        }
        /**
         * Converts the buffer's contents into a string by decoding the bytes using
         * the specified {@link java.nio.charset.Charset charsetName}. The length of
         * the new <tt>String</tt> is a function of the charset, and hence may not be
         * equal to the length of the byte array.
         *
         * <p> This method always replaces malformed-input and unmappable-character
         * sequences with this charset's default replacement string. The {@link
            * java.nio.charset.CharsetDecoder} class should be used when more control
         * over the decoding process is required.
         *
         * @param  charsetName  the name of a supported
         *              {@linkplain java.nio.charset.Charset </code>charset<code>}
         * @return String decoded from the buffer's contents.
         * @exception  UnsupportedEncodingException
         *             If the named charset is not supported
         * @since   JDK1.1
         */
        toString_string(charsetName) {
            return new String(this.buf /*, 0, this.count, charsetName*/).toString();
        }
        /**
         * Creates a newly allocated string. Its size is the current size of
         * the output stream and the valid contents of the buffer have been
         * copied into it. Each character <i>c</i> in the resulting string is
         * constructed from the corresponding element <i>b</i> in the byte
         * array such that:
         * <blockquote><pre>
         *     c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))
         * </pre></blockquote>
         *
         * @deprecated This method does not properly convert bytes into characters.
         * As of JDK&nbsp;1.1, the preferred way to do this is via the
         * <code>toString(String enc)</code> method, which takes an encoding-name
         * argument, or the <code>toString()</code> method, which uses the
         * platform's default character encoding.
         *
         * @param      hibyte    the high byte of each resulting Unicode character.
         * @return     the current contents of the output stream, as a string.
         * @see        java.io.ByteArrayOutputStream#size()
         * @see        java.io.ByteArrayOutputStream#toString(String)
         * @see        java.io.ByteArrayOutputStream#toString()
         */
        // @Deprecated
        toString_number(hibyte) {
            return new String(this.buf /*, hibyte, 0, this.count*/).toString();
        }
        /**
         * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in
         * this class can be called after the stream has been closed without
         * generating an <tt>IOException</tt>.
         * <p>
         *
         * @throws IOException
         */
        close() {
        }
    }

    /*
     * Copyright 2009 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*private*/ var Mode$2;
    (function (Mode) {
        Mode[Mode["ALPHA"] = 0] = "ALPHA";
        Mode[Mode["LOWER"] = 1] = "LOWER";
        Mode[Mode["MIXED"] = 2] = "MIXED";
        Mode[Mode["PUNCT"] = 3] = "PUNCT";
        Mode[Mode["ALPHA_SHIFT"] = 4] = "ALPHA_SHIFT";
        Mode[Mode["PUNCT_SHIFT"] = 5] = "PUNCT_SHIFT";
    })(Mode$2 || (Mode$2 = {}));
    /**
     * Indirectly access the global BigInt constructor, it
     * allows browsers that doesn't support BigInt to run
     * the library without breaking due to "undefined BigInt"
     * errors.
     */
    function getBigIntConstructor() {
        if (typeof window !== 'undefined') {
            return window['BigInt'] || null;
        }
        if (typeof global !== 'undefined') {
            return global['BigInt'] || null;
        }
        if (typeof self !== 'undefined') {
            return self['BigInt'] || null;
        }
        throw new Error('Can\'t search globals for BigInt!');
    }
    /**
     * Used to store the BigInt constructor.
     */
    let BigInteger;
    /**
     * This function creates a bigint value. It allows browsers
     * that doesn't support BigInt to run the rest of the library
     * by not directly accessing the BigInt constructor.
     */
    function createBigInt(num) {
        if (typeof BigInteger === 'undefined') {
            BigInteger = getBigIntConstructor();
        }
        if (BigInteger === null) {
            throw new Error('BigInt is not supported!');
        }
        return BigInteger(num);
    }
    function getEXP900() {
        // in Java - array with length = 16
        let EXP900 = [];
        EXP900[0] = createBigInt(1);
        let nineHundred = createBigInt(900);
        EXP900[1] = nineHundred;
        // in Java - array with length = 16
        for (let i /*int*/ = 2; i < 16; i++) {
            EXP900[i] = EXP900[i - 1] * nineHundred;
        }
        return EXP900;
    }
    /**
     * <p>This class contains the methods for decoding the PDF417 codewords.</p>
     *
     * @author SITA Lab (kevin.osullivan@sita.aero)
     * @author Guenther Grau
     */
    /*final*/ class DecodedBitStreamParser$2 {
        //   private DecodedBitStreamParser() {
        // }
        /**
         *
         * @param codewords
         * @param ecLevel
         *
         * @throws FormatException
         */
        static decode(codewords, ecLevel) {
            // pass encoding to result (will be used for decode symbols in byte mode)
            let result = new StringBuilder('');
            // let encoding: Charset = StandardCharsets.ISO_8859_1;
            let encoding = CharacterSetECI.ISO8859_1;
            /**
             * @note the next command is specific from this TypeScript library
             * because TS can't properly cast some values to char and
             * convert it to string later correctly due to encoding
             * differences from Java version. As reported here:
             * https://github.com/zxing-js/library/pull/264/files#r382831593
             */
            result.enableDecoding(encoding);
            // Get compaction mode
            let codeIndex = 1;
            let code = codewords[codeIndex++];
            let resultMetadata = new PDF417ResultMetadata();
            while (codeIndex < codewords[0]) {
                switch (code) {
                    case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                        codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, result);
                        break;
                    case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                    case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                        codeIndex = DecodedBitStreamParser$2.byteCompaction(code, codewords, encoding, codeIndex, result);
                        break;
                    case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                        result.append(/*(char)*/ codewords[codeIndex++]);
                        break;
                    case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                        codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex, result);
                        break;
                    case DecodedBitStreamParser$2.ECI_CHARSET:
                        let charsetECI = CharacterSetECI.getCharacterSetECIByValue(codewords[codeIndex++]);
                        // encoding = Charset.forName(charsetECI.getName());
                        break;
                    case DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE:
                        // Can't do anything with generic ECI; skip its 2 characters
                        codeIndex += 2;
                        break;
                    case DecodedBitStreamParser$2.ECI_USER_DEFINED:
                        // Can't do anything with user ECI; skip its 1 character
                        codeIndex++;
                        break;
                    case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                        codeIndex = DecodedBitStreamParser$2.decodeMacroBlock(codewords, codeIndex, resultMetadata);
                        break;
                    case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                    case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                        // Should not see these outside a macro block
                        throw new FormatException();
                    default:
                        // Default to text compaction. During testing numerous barcodes
                        // appeared to be missing the starting mode. In these cases defaulting
                        // to text compaction seems to work.
                        codeIndex--;
                        codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, result);
                        break;
                }
                if (codeIndex < codewords.length) {
                    code = codewords[codeIndex++];
                }
                else {
                    throw FormatException.getFormatInstance();
                }
            }
            if (result.length() === 0) {
                throw FormatException.getFormatInstance();
            }
            let decoderResult = new DecoderResult(null, result.toString(), null, ecLevel);
            decoderResult.setOther(resultMetadata);
            return decoderResult;
        }
        /**
         *
         * @param int
         * @param param1
         * @param codewords
         * @param int
         * @param codeIndex
         * @param PDF417ResultMetadata
         * @param resultMetadata
         *
         * @throws FormatException
         */
        // @SuppressWarnings("deprecation")
        static decodeMacroBlock(codewords, codeIndex, resultMetadata) {
            if (codeIndex + DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {
                // we must have at least two bytes left for the segment index
                throw FormatException.getFormatInstance();
            }
            let segmentIndexArray = new Int32Array(DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS);
            for (let i /*int*/ = 0; i < DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS; i++, codeIndex++) {
                segmentIndexArray[i] = codewords[codeIndex];
            }
            resultMetadata.setSegmentIndex(Integer.parseInt(DecodedBitStreamParser$2.decodeBase900toBase10(segmentIndexArray, DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS)));
            let fileId = new StringBuilder();
            codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, fileId);
            resultMetadata.setFileId(fileId.toString());
            let optionalFieldsStart = -1;
            if (codewords[codeIndex] === DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {
                optionalFieldsStart = codeIndex + 1;
            }
            while (codeIndex < codewords[0]) {
                switch (codewords[codeIndex]) {
                    case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                        codeIndex++;
                        switch (codewords[codeIndex]) {
                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:
                                let fileName = new StringBuilder();
                                codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, fileName);
                                resultMetadata.setFileName(fileName.toString());
                                break;
                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER:
                                let sender = new StringBuilder();
                                codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, sender);
                                resultMetadata.setSender(sender.toString());
                                break;
                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:
                                let addressee = new StringBuilder();
                                codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, addressee);
                                resultMetadata.setAddressee(addressee.toString());
                                break;
                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:
                                let segmentCount = new StringBuilder();
                                codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, segmentCount);
                                resultMetadata.setSegmentCount(Integer.parseInt(segmentCount.toString()));
                                break;
                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:
                                let timestamp = new StringBuilder();
                                codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, timestamp);
                                resultMetadata.setTimestamp(Long.parseLong(timestamp.toString()));
                                break;
                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:
                                let checksum = new StringBuilder();
                                codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, checksum);
                                resultMetadata.setChecksum(Integer.parseInt(checksum.toString()));
                                break;
                            case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:
                                let fileSize = new StringBuilder();
                                codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, fileSize);
                                resultMetadata.setFileSize(Long.parseLong(fileSize.toString()));
                                break;
                            default:
                                throw FormatException.getFormatInstance();
                        }
                        break;
                    case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                        codeIndex++;
                        resultMetadata.setLastSegment(true);
                        break;
                    default:
                        throw FormatException.getFormatInstance();
                }
            }
            // copy optional fields to additional options
            if (optionalFieldsStart !== -1) {
                let optionalFieldsLength = codeIndex - optionalFieldsStart;
                if (resultMetadata.isLastSegment()) {
                    // do not include terminator
                    optionalFieldsLength--;
                }
                resultMetadata.setOptionalData(Arrays.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));
            }
            return codeIndex;
        }
        /**
         * Text Compaction mode (see 5.4.1.5) permits all printable ASCII characters to be
         * encoded, i.e. values 32 - 126 inclusive in accordance with ISO/IEC 646 (IRV), as
         * well as selected control characters.
         *
         * @param codewords The array of codewords (data + error)
         * @param codeIndex The current index into the codeword array.
         * @param result    The decoded data is appended to the result.
         * @return The next index into the codeword array.
         */
        static textCompaction(codewords, codeIndex, result) {
            // 2 character per codeword
            let textCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
            // Used to hold the byte compaction value if there is a mode shift
            let byteCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
            let index = 0;
            let end = false;
            while ((codeIndex < codewords[0]) && !end) {
                let code = codewords[codeIndex++];
                if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
                    textCompactionData[index] = code / 30;
                    textCompactionData[index + 1] = code % 30;
                    index += 2;
                }
                else {
                    switch (code) {
                        case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                            // reinitialize text compaction mode to alpha sub mode
                            textCompactionData[index++] = DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH;
                            break;
                        case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                        case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                        case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                        case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                        case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                        case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                            codeIndex--;
                            end = true;
                            break;
                        case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                            // The Mode Shift codeword 913 shall cause a temporary
                            // switch from Text Compaction mode to Byte Compaction mode.
                            // This switch shall be in effect for only the next codeword,
                            // after which the mode shall revert to the prevailing sub-mode
                            // of the Text Compaction mode. Codeword 913 is only available
                            // in Text Compaction mode; its use is described in 5.4.2.4.
                            textCompactionData[index] = DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;
                            code = codewords[codeIndex++];
                            byteCompactionData[index] = code;
                            index++;
                            break;
                    }
                }
            }
            DecodedBitStreamParser$2.decodeTextCompaction(textCompactionData, byteCompactionData, index, result);
            return codeIndex;
        }
        /**
         * The Text Compaction mode includes all the printable ASCII characters
         * (i.e. values from 32 to 126) and three ASCII control characters: HT or tab
         * (9: e), LF or line feed (10: e), and CR or carriage
         * return (13: e). The Text Compaction mode also includes various latch
         * and shift characters which are used exclusively within the mode. The Text
         * Compaction mode encodes up to 2 characters per codeword. The compaction rules
         * for converting data into PDF417 codewords are defined in 5.4.2.2. The sub-mode
         * switches are defined in 5.4.2.3.
         *
         * @param textCompactionData The text compaction data.
         * @param byteCompactionData The byte compaction data if there
         *                           was a mode shift.
         * @param length             The size of the text compaction and byte compaction data.
         * @param result             The decoded data is appended to the result.
         */
        static decodeTextCompaction(textCompactionData, byteCompactionData, length, result) {
            // Beginning from an initial state of the Alpha sub-mode
            // The default compaction mode for PDF417 in effect at the start of each symbol shall always be Text
            // Compaction mode Alpha sub-mode (alphabetic: uppercase). A latch codeword from another mode to the Text
            // Compaction mode shall always switch to the Text Compaction Alpha sub-mode.
            let subMode = Mode$2.ALPHA;
            let priorToShiftMode = Mode$2.ALPHA;
            let i = 0;
            while (i < length) {
                let subModeCh = textCompactionData[i];
                let ch = /*char*/ '';
                switch (subMode) {
                    case Mode$2.ALPHA:
                        // Alpha (alphabetic: uppercase)
                        if (subModeCh < 26) {
                            // Upper case Alpha Character
                            // Note: 65 = 'A' ASCII -> there is byte code of symbol
                            ch = /*(char)('A' + subModeCh) */ String.fromCharCode(65 + subModeCh);
                        }
                        else {
                            switch (subModeCh) {
                                case 26:
                                    ch = ' ';
                                    break;
                                case DecodedBitStreamParser$2.LL:
                                    subMode = Mode$2.LOWER;
                                    break;
                                case DecodedBitStreamParser$2.ML:
                                    subMode = Mode$2.MIXED;
                                    break;
                                case DecodedBitStreamParser$2.PS:
                                    // Shift to punctuation
                                    priorToShiftMode = subMode;
                                    subMode = Mode$2.PUNCT_SHIFT;
                                    break;
                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                    result.append(/*(char)*/ byteCompactionData[i]);
                                    break;
                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                                    subMode = Mode$2.ALPHA;
                                    break;
                            }
                        }
                        break;
                    case Mode$2.LOWER:
                        // Lower (alphabetic: lowercase)
                        if (subModeCh < 26) {
                            ch = /*(char)('a' + subModeCh)*/ String.fromCharCode(97 + subModeCh);
                        }
                        else {
                            switch (subModeCh) {
                                case 26:
                                    ch = ' ';
                                    break;
                                case DecodedBitStreamParser$2.AS:
                                    // Shift to alpha
                                    priorToShiftMode = subMode;
                                    subMode = Mode$2.ALPHA_SHIFT;
                                    break;
                                case DecodedBitStreamParser$2.ML:
                                    subMode = Mode$2.MIXED;
                                    break;
                                case DecodedBitStreamParser$2.PS:
                                    // Shift to punctuation
                                    priorToShiftMode = subMode;
                                    subMode = Mode$2.PUNCT_SHIFT;
                                    break;
                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                    // TODO Does this need to use the current character encoding? See other occurrences below
                                    result.append(/*(char)*/ byteCompactionData[i]);
                                    break;
                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                                    subMode = Mode$2.ALPHA;
                                    break;
                            }
                        }
                        break;
                    case Mode$2.MIXED:
                        // Mixed (punctuation: e)
                        if (subModeCh < DecodedBitStreamParser$2.PL) {
                            ch = DecodedBitStreamParser$2.MIXED_CHARS[subModeCh];
                        }
                        else {
                            switch (subModeCh) {
                                case DecodedBitStreamParser$2.PL:
                                    subMode = Mode$2.PUNCT;
                                    break;
                                case 26:
                                    ch = ' ';
                                    break;
                                case DecodedBitStreamParser$2.LL:
                                    subMode = Mode$2.LOWER;
                                    break;
                                case DecodedBitStreamParser$2.AL:
                                    subMode = Mode$2.ALPHA;
                                    break;
                                case DecodedBitStreamParser$2.PS:
                                    // Shift to punctuation
                                    priorToShiftMode = subMode;
                                    subMode = Mode$2.PUNCT_SHIFT;
                                    break;
                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                    result.append(/*(char)*/ byteCompactionData[i]);
                                    break;
                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                                    subMode = Mode$2.ALPHA;
                                    break;
                            }
                        }
                        break;
                    case Mode$2.PUNCT:
                        // Punctuation
                        if (subModeCh < DecodedBitStreamParser$2.PAL) {
                            ch = DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];
                        }
                        else {
                            switch (subModeCh) {
                                case DecodedBitStreamParser$2.PAL:
                                    subMode = Mode$2.ALPHA;
                                    break;
                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                    result.append(/*(char)*/ byteCompactionData[i]);
                                    break;
                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                                    subMode = Mode$2.ALPHA;
                                    break;
                            }
                        }
                        break;
                    case Mode$2.ALPHA_SHIFT:
                        // Restore sub-mode
                        subMode = priorToShiftMode;
                        if (subModeCh < 26) {
                            ch = /*(char)('A' + subModeCh)*/ String.fromCharCode(65 + subModeCh);
                        }
                        else {
                            switch (subModeCh) {
                                case 26:
                                    ch = ' ';
                                    break;
                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                                    subMode = Mode$2.ALPHA;
                                    break;
                            }
                        }
                        break;
                    case Mode$2.PUNCT_SHIFT:
                        // Restore sub-mode
                        subMode = priorToShiftMode;
                        if (subModeCh < DecodedBitStreamParser$2.PAL) {
                            ch = DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];
                        }
                        else {
                            switch (subModeCh) {
                                case DecodedBitStreamParser$2.PAL:
                                    subMode = Mode$2.ALPHA;
                                    break;
                                case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                    // PS before Shift-to-Byte is used as a padding character,
                                    // see 5.4.2.4 of the specification
                                    result.append(/*(char)*/ byteCompactionData[i]);
                                    break;
                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                                    subMode = Mode$2.ALPHA;
                                    break;
                            }
                        }
                        break;
                }
                // if (ch !== 0) {
                if (ch !== '') {
                    // Append decoded character to result
                    result.append(ch);
                }
                i++;
            }
        }
        /**
         * Byte Compaction mode (see 5.4.3) permits all 256 possible 8-bit byte values to be encoded.
         * This includes all ASCII characters value 0 to 127 inclusive and provides for international
         * character set support.
         *
         * @param mode      The byte compaction mode i.e. 901 or 924
         * @param codewords The array of codewords (data + error)
         * @param encoding  Currently active character encoding
         * @param codeIndex The current index into the codeword array.
         * @param result    The decoded data is appended to the result.
         * @return The next index into the codeword array.
         */
        static /*int*/ byteCompaction(mode, codewords, encoding, codeIndex, result) {
            let decodedBytes = new ByteArrayOutputStream();
            let count = 0;
            let value = /*long*/ 0;
            let end = false;
            switch (mode) {
                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                    // Total number of Byte Compaction characters to be encoded
                    // is not a multiple of 6
                    let byteCompactedCodewords = new Int32Array(6);
                    let nextCode = codewords[codeIndex++];
                    while ((codeIndex < codewords[0]) && !end) {
                        byteCompactedCodewords[count++] = nextCode;
                        // Base 900
                        value = 900 * value + nextCode;
                        nextCode = codewords[codeIndex++];
                        // perhaps it should be ok to check only nextCode >= TEXT_COMPACTION_MODE_LATCH
                        switch (nextCode) {
                            case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                            case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                            case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                            case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                            case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                            case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                            case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                                codeIndex--;
                                end = true;
                                break;
                            default:
                                if ((count % 5 === 0) && (count > 0)) {
                                    // Decode every 5 codewords
                                    // Convert to Base 256
                                    for (let j /*int*/ = 0; j < 6; ++j) {
                                        /* @note
                                         * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.
                                         * So the next bitwise operation could not be done with simple numbers
                                         */
                                        decodedBytes.write(/*(byte)*/ Number(createBigInt(value) >> createBigInt(8 * (5 - j))));
                                    }
                                    value = 0;
                                    count = 0;
                                }
                                break;
                        }
                    }
                    // if the end of all codewords is reached the last codeword needs to be added
                    if (codeIndex === codewords[0] && nextCode < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
                        byteCompactedCodewords[count++] = nextCode;
                    }
                    // If Byte Compaction mode is invoked with codeword 901,
                    // the last group of codewords is interpreted directly
                    // as one byte per codeword, without compaction.
                    for (let i /*int*/ = 0; i < count; i++) {
                        decodedBytes.write(/*(byte)*/ byteCompactedCodewords[i]);
                    }
                    break;
                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                    // Total number of Byte Compaction characters to be encoded
                    // is an integer multiple of 6
                    while (codeIndex < codewords[0] && !end) {
                        let code = codewords[codeIndex++];
                        if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
                            count++;
                            // Base 900
                            value = 900 * value + code;
                        }
                        else {
                            switch (code) {
                                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                                case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                                case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                                    codeIndex--;
                                    end = true;
                                    break;
                            }
                        }
                        if ((count % 5 === 0) && (count > 0)) {
                            // Decode every 5 codewords
                            // Convert to Base 256
                            /* @note
                             * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.
                             * So the next bitwise operation could not be done with simple numbers
                            */
                            for (let j /*int*/ = 0; j < 6; ++j) {
                                decodedBytes.write(/*(byte)*/ Number(createBigInt(value) >> createBigInt(8 * (5 - j))));
                            }
                            value = 0;
                            count = 0;
                        }
                    }
                    break;
            }
            result.append(StringEncoding.decode(decodedBytes.toByteArray(), encoding));
            return codeIndex;
        }
        /**
         * Numeric Compaction mode (see 5.4.4) permits efficient encoding of numeric data strings.
         *
         * @param codewords The array of codewords (data + error)
         * @param codeIndex The current index into the codeword array.
         * @param result    The decoded data is appended to the result.
         * @return The next index into the codeword array.
         *
         * @throws FormatException
         */
        static numericCompaction(codewords, codeIndex /*int*/, result) {
            let count = 0;
            let end = false;
            let numericCodewords = new Int32Array(DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS);
            while (codeIndex < codewords[0] && !end) {
                let code = codewords[codeIndex++];
                if (codeIndex === codewords[0]) {
                    end = true;
                }
                if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
                    numericCodewords[count] = code;
                    count++;
                }
                else {
                    switch (code) {
                        case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                        case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                        case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                        case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                        case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                        case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                            codeIndex--;
                            end = true;
                            break;
                    }
                }
                if ((count % DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS === 0 || code === DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH || end) && count > 0) {
                    // Re-invoking Numeric Compaction mode (by using codeword 902
                    // while in Numeric Compaction mode) serves  to terminate the
                    // current Numeric Compaction mode grouping as described in 5.4.4.2,
                    // and then to start a new one grouping.
                    result.append(DecodedBitStreamParser$2.decodeBase900toBase10(numericCodewords, count));
                    count = 0;
                }
            }
            return codeIndex;
        }
        /**
         * Convert a list of Numeric Compacted codewords from Base 900 to Base 10.
         *
         * @param codewords The array of codewords
         * @param count     The number of codewords
         * @return The decoded string representing the Numeric data.
         *
         * EXAMPLE
         * Encode the fifteen digit numeric string 000213298174000
         * Prefix the numeric string with a 1 and set the initial value of
         * t = 1 000 213 298 174 000
         * Calculate codeword 0
         * d0 = 1 000 213 298 174 000 mod 900 = 200
         *
         * t = 1 000 213 298 174 000 div 900 = 1 111 348 109 082
         * Calculate codeword 1
         * d1 = 1 111 348 109 082 mod 900 = 282
         *
         * t = 1 111 348 109 082 div 900 = 1 234 831 232
         * Calculate codeword 2
         * d2 = 1 234 831 232 mod 900 = 632
         *
         * t = 1 234 831 232 div 900 = 1 372 034
         * Calculate codeword 3
         * d3 = 1 372 034 mod 900 = 434
         *
         * t = 1 372 034 div 900 = 1 524
         * Calculate codeword 4
         * d4 = 1 524 mod 900 = 624
         *
         * t = 1 524 div 900 = 1
         * Calculate codeword 5
         * d5 = 1 mod 900 = 1
         * t = 1 div 900 = 0
         * Codeword sequence is: 1, 624, 434, 632, 282, 200
         *
         * Decode the above codewords involves
         *   1 x 900 power of 5 + 624 x 900 power of 4 + 434 x 900 power of 3 +
         * 632 x 900 power of 2 + 282 x 900 power of 1 + 200 x 900 power of 0 = 1000213298174000
         *
         * Remove leading 1 =>  Result is 000213298174000
         *
         * @throws FormatException
         */
        static decodeBase900toBase10(codewords, count) {
            let result = createBigInt(0);
            for (let i /*int*/ = 0; i < count; i++) {
                result += DecodedBitStreamParser$2.EXP900[count - i - 1] * createBigInt(codewords[i]);
            }
            let resultString = result.toString();
            if (resultString.charAt(0) !== '1') {
                throw new FormatException();
            }
            return resultString.substring(1);
        }
    }
    DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH = 900;
    DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH = 901;
    DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH = 902;
    DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6 = 924;
    DecodedBitStreamParser$2.ECI_USER_DEFINED = 925;
    DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE = 926;
    DecodedBitStreamParser$2.ECI_CHARSET = 927;
    DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;
    DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;
    DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR = 922;
    DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;
    DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS = 15;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;
    DecodedBitStreamParser$2.PL = 25;
    DecodedBitStreamParser$2.LL = 27;
    DecodedBitStreamParser$2.AS = 27;
    DecodedBitStreamParser$2.ML = 28;
    DecodedBitStreamParser$2.AL = 28;
    DecodedBitStreamParser$2.PS = 29;
    DecodedBitStreamParser$2.PAL = 29;
    DecodedBitStreamParser$2.PUNCT_CHARS = ';<>@[\\]_`~!\r\t,:\n-.$/"|*()?{}\'';
    DecodedBitStreamParser$2.MIXED_CHARS = '0123456789&\r\t,:#-.$/+%*=^';
    /**
     * Table containing values for the exponent of 900.
     * This is used in the numeric compaction decode algorithm.
     */
    DecodedBitStreamParser$2.EXP900 = getBigIntConstructor() ? getEXP900() : [];
    DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS = 2;

    /*
    * Copyright 2013 ZXing authors
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    // import java.util.ArrayList;
    // import java.util.Collection;
    // import java.util.Formatter;
    // import java.util.List;
    /**
     * @author Guenther Grau
     */
    /*public final*/ class PDF417ScanningDecoder {
        constructor() { }
        /**
         * @TODO don't pass in minCodewordWidth and maxCodewordWidth, pass in barcode columns for start and stop pattern
         *
         * columns. That way width can be deducted from the pattern column.
         * This approach also allows to detect more details about the barcode, e.g. if a bar type (white or black) is wider
         * than it should be. This can happen if the scanner used a bad blackpoint.
         *
         * @param BitMatrix
         * @param image
         * @param ResultPoint
         * @param imageTopLeft
         * @param ResultPoint
         * @param imageBottomLeft
         * @param ResultPoint
         * @param imageTopRight
         * @param ResultPoint
         * @param imageBottomRight
         * @param int
         * @param minCodewordWidth
         * @param int
         * @param maxCodewordWidth
         *
         * @throws NotFoundException
         * @throws FormatException
         * @throws ChecksumException
         */
        static decode(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {
            let boundingBox = new BoundingBox(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);
            let leftRowIndicatorColumn = null;
            let rightRowIndicatorColumn = null;
            let detectionResult;
            for (let firstPass /*boolean*/ = true;; firstPass = false) {
                if (imageTopLeft != null) {
                    leftRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);
                }
                if (imageTopRight != null) {
                    rightRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);
                }
                detectionResult = PDF417ScanningDecoder.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);
                if (detectionResult == null) {
                    throw NotFoundException.getNotFoundInstance();
                }
                let resultBox = detectionResult.getBoundingBox();
                if (firstPass && resultBox != null &&
                    (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {
                    boundingBox = resultBox;
                }
                else {
                    break;
                }
            }
            detectionResult.setBoundingBox(boundingBox);
            let maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;
            detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);
            detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);
            let leftToRight = leftRowIndicatorColumn != null;
            for (let barcodeColumnCount /*int*/ = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {
                let barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;
                if (detectionResult.getDetectionResultColumn(barcodeColumn) !== /* null */ undefined) {
                    // This will be the case for the opposite row indicator column, which doesn't need to be decoded again.
                    continue;
                }
                let detectionResultColumn;
                if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {
                    detectionResultColumn = new DetectionResultRowIndicatorColumn(boundingBox, barcodeColumn === 0);
                }
                else {
                    detectionResultColumn = new DetectionResultColumn(boundingBox);
                }
                detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);
                let startColumn = -1;
                let previousStartColumn = startColumn;
                // TODO start at a row for which we know the start position, then detect upwards and downwards from there.
                for (let imageRow /*int*/ = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {
                    startColumn = PDF417ScanningDecoder.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);
                    if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {
                        if (previousStartColumn === -1) {
                            continue;
                        }
                        startColumn = previousStartColumn;
                    }
                    let codeword = PDF417ScanningDecoder.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
                    if (codeword != null) {
                        detectionResultColumn.setCodeword(imageRow, codeword);
                        previousStartColumn = startColumn;
                        minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());
                        maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());
                    }
                }
            }
            return PDF417ScanningDecoder.createDecoderResult(detectionResult);
        }
        /**
         *
         * @param leftRowIndicatorColumn
         * @param rightRowIndicatorColumn
         *
         * @throws NotFoundException
         */
        static merge(leftRowIndicatorColumn, rightRowIndicatorColumn) {
            if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {
                return null;
            }
            let barcodeMetadata = PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);
            if (barcodeMetadata == null) {
                return null;
            }
            let boundingBox = BoundingBox.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));
            return new DetectionResult(barcodeMetadata, boundingBox);
        }
        /**
         *
         * @param rowIndicatorColumn
         *
         * @throws NotFoundException
         */
        static adjustBoundingBox(rowIndicatorColumn) {
            if (rowIndicatorColumn == null) {
                return null;
            }
            let rowHeights = rowIndicatorColumn.getRowHeights();
            if (rowHeights == null) {
                return null;
            }
            let maxRowHeight = PDF417ScanningDecoder.getMax(rowHeights);
            let missingStartRows = 0;
            for (let rowHeight /*int*/ of rowHeights) {
                missingStartRows += maxRowHeight - rowHeight;
                if (rowHeight > 0) {
                    break;
                }
            }
            let codewords = rowIndicatorColumn.getCodewords();
            for (let row /*int*/ = 0; missingStartRows > 0 && codewords[row] == null; row++) {
                missingStartRows--;
            }
            let missingEndRows = 0;
            for (let row /*int*/ = rowHeights.length - 1; row >= 0; row--) {
                missingEndRows += maxRowHeight - rowHeights[row];
                if (rowHeights[row] > 0) {
                    break;
                }
            }
            for (let row /*int*/ = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {
                missingEndRows--;
            }
            return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());
        }
        static getMax(values) {
            let maxValue = -1;
            for (let value /*int*/ of values) {
                maxValue = Math.max(maxValue, value);
            }
            return maxValue;
        }
        static getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn) {
            let leftBarcodeMetadata;
            if (leftRowIndicatorColumn == null ||
                (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {
                return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();
            }
            let rightBarcodeMetadata;
            if (rightRowIndicatorColumn == null ||
                (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {
                return leftBarcodeMetadata;
            }
            if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() &&
                leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() &&
                leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {
                return null;
            }
            return leftBarcodeMetadata;
        }
        static getRowIndicatorColumn(image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {
            let rowIndicatorColumn = new DetectionResultRowIndicatorColumn(boundingBox, leftToRight);
            for (let i /*int*/ = 0; i < 2; i++) {
                let increment = i === 0 ? 1 : -1;
                let startColumn = Math.trunc(Math.trunc(startPoint.getX()));
                for (let imageRow /*int*/ = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() &&
                imageRow >= boundingBox.getMinY(); imageRow += increment) {
                    let codeword = PDF417ScanningDecoder.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
                    if (codeword != null) {
                        rowIndicatorColumn.setCodeword(imageRow, codeword);
                        if (leftToRight) {
                            startColumn = codeword.getStartX();
                        }
                        else {
                            startColumn = codeword.getEndX();
                        }
                    }
                }
            }
            return rowIndicatorColumn;
        }
        /**
         *
         * @param detectionResult
         * @param BarcodeValue
         * @param param2
         * @param param3
         * @param barcodeMatrix
         *
         * @throws NotFoundException
         */
        static adjustCodewordCount(detectionResult, barcodeMatrix) {
            let barcodeMatrix01 = barcodeMatrix[0][1];
            let numberOfCodewords = barcodeMatrix01.getValue();
            let calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() *
                detectionResult.getBarcodeRowCount() -
                PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());
            if (numberOfCodewords.length === 0) {
                if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common.MAX_CODEWORDS_IN_BARCODE) {
                    throw NotFoundException.getNotFoundInstance();
                }
                barcodeMatrix01.setValue(calculatedNumberOfCodewords);
            }
            else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {
                // The calculated one is more reliable as it is derived from the row indicator columns
                barcodeMatrix01.setValue(calculatedNumberOfCodewords);
            }
        }
        /**
         *
         * @param detectionResult
         *
         * @throws FormatException
         * @throws ChecksumException
         * @throws NotFoundException
         */
        static createDecoderResult(detectionResult) {
            let barcodeMatrix = PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);
            PDF417ScanningDecoder.adjustCodewordCount(detectionResult, barcodeMatrix);
            let erasures /*Collection<Integer>*/ = new Array();
            let codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());
            let ambiguousIndexValuesList = /*List<int[]>*/ [];
            let ambiguousIndexesList = /*Collection<Integer>*/ new Array();
            for (let row /*int*/ = 0; row < detectionResult.getBarcodeRowCount(); row++) {
                for (let column /*int*/ = 0; column < detectionResult.getBarcodeColumnCount(); column++) {
                    let values = barcodeMatrix[row][column + 1].getValue();
                    let codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;
                    if (values.length === 0) {
                        erasures.push(codewordIndex);
                    }
                    else if (values.length === 1) {
                        codewords[codewordIndex] = values[0];
                    }
                    else {
                        ambiguousIndexesList.push(codewordIndex);
                        ambiguousIndexValuesList.push(values);
                    }
                }
            }
            let ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);
            for (let i /*int*/ = 0; i < ambiguousIndexValues.length; i++) {
                ambiguousIndexValues[i] = ambiguousIndexValuesList[i];
            }
            return PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common.toIntArray(erasures), PDF417Common.toIntArray(ambiguousIndexesList), ambiguousIndexValues);
        }
        /**
         * This method deals with the fact, that the decoding process doesn't always yield a single most likely value. The
         * current error correction implementation doesn't deal with erasures very well, so it's better to provide a value
         * for these ambiguous codewords instead of treating it as an erasure. The problem is that we don't know which of
         * the ambiguous values to choose. We try decode using the first value, and if that fails, we use another of the
         * ambiguous values and try to decode again. This usually only happens on very hard to read and decode barcodes,
         * so decoding the normal barcodes is not affected by this.
         *
         * @param erasureArray contains the indexes of erasures
         * @param ambiguousIndexes array with the indexes that have more than one most likely value
         * @param ambiguousIndexValues two dimensional array that contains the ambiguous values. The first dimension must
         * be the same length as the ambiguousIndexes array
         *
         * @throws FormatException
         * @throws ChecksumException
         */
        static createDecoderResultFromAmbiguousValues(ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {
            let ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);
            let tries = 100;
            while (tries-- > 0) {
                for (let i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {
                    codewords[ambiguousIndexes[i]] = ambiguousIndexValues[i][ambiguousIndexCount[i]];
                }
                try {
                    return PDF417ScanningDecoder.decodeCodewords(codewords, ecLevel, erasureArray);
                }
                catch (err) {
                    let ignored = err instanceof ChecksumException;
                    if (!ignored) {
                        throw err;
                    }
                }
                if (ambiguousIndexCount.length === 0) {
                    throw ChecksumException.getChecksumInstance();
                }
                for (let i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {
                    if (ambiguousIndexCount[i] < ambiguousIndexValues[i].length - 1) {
                        ambiguousIndexCount[i]++;
                        break;
                    }
                    else {
                        ambiguousIndexCount[i] = 0;
                        if (i === ambiguousIndexCount.length - 1) {
                            throw ChecksumException.getChecksumInstance();
                        }
                    }
                }
            }
            throw ChecksumException.getChecksumInstance();
        }
        static createBarcodeMatrix(detectionResult) {
            // let barcodeMatrix: BarcodeValue[][] =
            // new BarcodeValue[detectionResult.getBarcodeRowCount()][detectionResult.getBarcodeColumnCount() + 2];
            let barcodeMatrix = Array.from({ length: detectionResult.getBarcodeRowCount() }, () => new Array(detectionResult.getBarcodeColumnCount() + 2));
            for (let row /*int*/ = 0; row < barcodeMatrix.length; row++) {
                for (let column /*int*/ = 0; column < barcodeMatrix[row].length; column++) {
                    barcodeMatrix[row][column] = new BarcodeValue();
                }
            }
            let column = 0;
            for (let detectionResultColumn /*DetectionResultColumn*/ of detectionResult.getDetectionResultColumns()) {
                if (detectionResultColumn != null) {
                    for (let codeword /*Codeword*/ of detectionResultColumn.getCodewords()) {
                        if (codeword != null) {
                            let rowNumber = codeword.getRowNumber();
                            if (rowNumber >= 0) {
                                if (rowNumber >= barcodeMatrix.length) {
                                    // We have more rows than the barcode metadata allows for, ignore them.
                                    continue;
                                }
                                barcodeMatrix[rowNumber][column].setValue(codeword.getValue());
                            }
                        }
                    }
                }
                column++;
            }
            return barcodeMatrix;
        }
        static isValidBarcodeColumn(detectionResult, barcodeColumn) {
            return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;
        }
        static getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight) {
            let offset = leftToRight ? 1 : -1;
            let codeword = null;
            if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
                codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodeword(imageRow);
            }
            if (codeword != null) {
                return leftToRight ? codeword.getEndX() : codeword.getStartX();
            }
            codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);
            if (codeword != null) {
                return leftToRight ? codeword.getStartX() : codeword.getEndX();
            }
            if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
                codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodewordNearby(imageRow);
            }
            if (codeword != null) {
                return leftToRight ? codeword.getEndX() : codeword.getStartX();
            }
            let skippedColumns = 0;
            while (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
                barcodeColumn -= offset;
                for (let previousRowCodeword /*Codeword*/ of detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords()) {
                    if (previousRowCodeword != null) {
                        return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) +
                            offset *
                            skippedColumns *
                            (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());
                    }
                }
                skippedColumns++;
            }
            return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();
        }
        static detectCodeword(image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {
            startColumn = PDF417ScanningDecoder.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
            // we usually know fairly exact now how long a codeword is. We should provide minimum and maximum expected length
            // and try to adjust the read pixels, e.g. remove single pixel errors or try to cut off exceeding pixels.
            // min and maxCodewordWidth should not be used as they are calculated for the whole barcode an can be inaccurate
            // for the current position
            let moduleBitCount = PDF417ScanningDecoder.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
            if (moduleBitCount == null) {
                return null;
            }
            let endColumn;
            let codewordBitCount = MathUtils.sum(moduleBitCount);
            if (leftToRight) {
                endColumn = startColumn + codewordBitCount;
            }
            else {
                for (let i /*int*/ = 0; i < moduleBitCount.length / 2; i++) {
                    let tmpCount = moduleBitCount[i];
                    moduleBitCount[i] = moduleBitCount[moduleBitCount.length - 1 - i];
                    moduleBitCount[moduleBitCount.length - 1 - i] = tmpCount;
                }
                endColumn = startColumn;
                startColumn = endColumn - codewordBitCount;
            }
            // TODO implement check for width and correction of black and white bars
            // use start (and maybe stop pattern) to determine if black bars are wider than white bars. If so, adjust.
            // should probably done only for codewords with a lot more than 17 bits.
            // The following fixes 10-1.png, which has wide black bars and small white bars
            //    for (let i /*int*/ = 0; i < moduleBitCount.length; i++) {
            //      if (i % 2 === 0) {
            //        moduleBitCount[i]--;
            //      } else {
            //        moduleBitCount[i]++;
            //      }
            //    }
            // We could also use the width of surrounding codewords for more accurate results, but this seems
            // sufficient for now
            if (!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {
                // We could try to use the startX and endX position of the codeword in the same column in the previous row,
                // create the bit count from it and normalize it to 8. This would help with single pixel errors.
                return null;
            }
            let decodedValue = PDF417CodewordDecoder.getDecodedValue(moduleBitCount);
            let codeword = PDF417Common.getCodeword(decodedValue);
            if (codeword === -1) {
                return null;
            }
            return new Codeword(startColumn, endColumn, PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue), codeword);
        }
        static getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {
            let imageColumn = startColumn;
            let moduleBitCount = new Int32Array(8);
            let moduleNumber = 0;
            let increment = leftToRight ? 1 : -1;
            let previousPixelValue = leftToRight;
            while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) &&
            moduleNumber < moduleBitCount.length) {
                if (image.get(imageColumn, imageRow) === previousPixelValue) {
                    moduleBitCount[moduleNumber]++;
                    imageColumn += increment;
                }
                else {
                    moduleNumber++;
                    previousPixelValue = !previousPixelValue;
                }
            }
            if (moduleNumber === moduleBitCount.length ||
                ((imageColumn === (leftToRight ? maxColumn : minColumn)) &&
                    moduleNumber === moduleBitCount.length - 1)) {
                return moduleBitCount;
            }
            return null;
        }
        static getNumberOfECCodeWords(barcodeECLevel) {
            return 2 << barcodeECLevel;
        }
        static adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {
            let correctedStartColumn = codewordStartColumn;
            let increment = leftToRight ? -1 : 1;
            // there should be no black pixels before the start column. If there are, then we need to start earlier.
            for (let i /*int*/ = 0; i < 2; i++) {
                while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) &&
                leftToRight === image.get(correctedStartColumn, imageRow)) {
                    if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder.CODEWORD_SKEW_SIZE) {
                        return codewordStartColumn;
                    }
                    correctedStartColumn += increment;
                }
                increment = -increment;
                leftToRight = !leftToRight;
            }
            return correctedStartColumn;
        }
        static checkCodewordSkew(codewordSize, minCodewordWidth, maxCodewordWidth) {
            return minCodewordWidth - PDF417ScanningDecoder.CODEWORD_SKEW_SIZE <= codewordSize &&
                codewordSize <= maxCodewordWidth + PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;
        }
        /**
         * @throws FormatException,
         * @throws ChecksumException
         */
        static decodeCodewords(codewords, ecLevel, erasures) {
            if (codewords.length === 0) {
                throw FormatException.getFormatInstance();
            }
            let numECCodewords = 1 << (ecLevel + 1);
            let correctedErrorsCount = PDF417ScanningDecoder.correctErrors(codewords, erasures, numECCodewords);
            PDF417ScanningDecoder.verifyCodewordCount(codewords, numECCodewords);
            // Decode the codewords
            let decoderResult = DecodedBitStreamParser$2.decode(codewords, '' + ecLevel);
            decoderResult.setErrorsCorrected(correctedErrorsCount);
            decoderResult.setErasures(erasures.length);
            return decoderResult;
        }
        /**
         * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
         * correct the errors in-place.</p>
         *
         * @param codewords   data and error correction codewords
         * @param erasures positions of any known erasures
         * @param numECCodewords number of error correction codewords that are available in codewords
         * @throws ChecksumException if error correction fails
         */
        static correctErrors(codewords, erasures, numECCodewords) {
            if (erasures != null &&
                erasures.length > numECCodewords / 2 + PDF417ScanningDecoder.MAX_ERRORS ||
                numECCodewords < 0 ||
                numECCodewords > PDF417ScanningDecoder.MAX_EC_CODEWORDS) {
                // Too many errors or EC Codewords is corrupted
                throw ChecksumException.getChecksumInstance();
            }
            return PDF417ScanningDecoder.errorCorrection.decode(codewords, numECCodewords, erasures);
        }
        /**
         * Verify that all is OK with the codeword array.
         * @throws FormatException
         */
        static verifyCodewordCount(codewords, numECCodewords) {
            if (codewords.length < 4) {
                // Codeword array size should be at least 4 allowing for
                // Count CW, At least one Data CW, Error Correction CW, Error Correction CW
                throw FormatException.getFormatInstance();
            }
            // The first codeword, the Symbol Length Descriptor, shall always encode the total number of data
            // codewords in the symbol, including the Symbol Length Descriptor itself, data codewords and pad
            // codewords, but excluding the number of error correction codewords.
            let numberOfCodewords = codewords[0];
            if (numberOfCodewords > codewords.length) {
                throw FormatException.getFormatInstance();
            }
            if (numberOfCodewords === 0) {
                // Reset to the length of the array - 8 (Allow for at least level 3 Error Correction (8 Error Codewords)
                if (numECCodewords < codewords.length) {
                    codewords[0] = codewords.length - numECCodewords;
                }
                else {
                    throw FormatException.getFormatInstance();
                }
            }
        }
        static getBitCountForCodeword(codeword) {
            let result = new Int32Array(8);
            let previousValue = 0;
            let i = result.length - 1;
            while (true) {
                if ((codeword & 0x1) !== previousValue) {
                    previousValue = codeword & 0x1;
                    i--;
                    if (i < 0) {
                        break;
                    }
                }
                result[i]++;
                codeword >>= 1;
            }
            return result;
        }
        static getCodewordBucketNumber(codeword) {
            if (codeword instanceof Int32Array) {
                return this.getCodewordBucketNumber_Int32Array(codeword);
            }
            return this.getCodewordBucketNumber_number(codeword);
        }
        static getCodewordBucketNumber_number(codeword) {
            return PDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));
        }
        static getCodewordBucketNumber_Int32Array(moduleBitCount) {
            return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;
        }
        static toString(barcodeMatrix) {
            let formatter = new Formatter();
            // try (let formatter = new Formatter()) {
            for (let row /*int*/ = 0; row < barcodeMatrix.length; row++) {
                formatter.format('Row %2d: ', row);
                for (let column /*int*/ = 0; column < barcodeMatrix[row].length; column++) {
                    let barcodeValue = barcodeMatrix[row][column];
                    if (barcodeValue.getValue().length === 0) {
                        formatter.format('        ', null);
                    }
                    else {
                        formatter.format('%4d(%2d)', barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));
                    }
                }
                formatter.format('%n');
            }
            return formatter.toString();
            // }
        }
    }
    /*final*/ PDF417ScanningDecoder.CODEWORD_SKEW_SIZE = 2;
    /*final*/ PDF417ScanningDecoder.MAX_ERRORS = 3;
    /*final*/ PDF417ScanningDecoder.MAX_EC_CODEWORDS = 512;
    /*final*/ PDF417ScanningDecoder.errorCorrection = new ErrorCorrection();

    /*
     * Copyright 2009 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // import java.util.ArrayList;
    // import java.util.List;
    // import java.util.Map;
    /**
     * This implementation can detect and decode PDF417 codes in an image.
     *
     * @author Guenther Grau
     */
    /*public final*/ class PDF417Reader {
        // private static /*final Result[]*/ EMPTY_RESULT_ARRAY: Result[] = new Result([0]);
        /**
         * Locates and decodes a PDF417 code in an image.
         *
         * @return a String representing the content encoded by the PDF417 code
         * @throws NotFoundException if a PDF417 code cannot be found,
         * @throws FormatException if a PDF417 cannot be decoded
         * @throws ChecksumException
         */
        // @Override
        decode(image, hints = null) {
            let result = PDF417Reader.decode(image, hints, false);
            if (result == null || result.length === 0 || result[0] == null) {
                throw NotFoundException.getNotFoundInstance();
            }
            return result[0];
        }
        /**
         *
         * @param BinaryBitmap
         * @param image
         * @throws NotFoundException
         */
        //   @Override
        decodeMultiple(image, hints = null) {
            try {
                return PDF417Reader.decode(image, hints, true);
            }
            catch (ignored) {
                if (ignored instanceof FormatException || ignored instanceof ChecksumException) {
                    throw NotFoundException.getNotFoundInstance();
                }
                throw ignored;
            }
        }
        /**
         *
         * @param image
         * @param hints
         * @param multiple
         *
         * @throws NotFoundException
         * @throws FormatExceptionß
         * @throws ChecksumException
         */
        static decode(image, hints, multiple) {
            const results = new Array();
            const detectorResult = Detector$3.detectMultiple(image, hints, multiple);
            for (const points of detectorResult.getPoints()) {
                const decoderResult = PDF417ScanningDecoder.decode(detectorResult.getBits(), points[4], points[5], points[6], points[7], PDF417Reader.getMinCodewordWidth(points), PDF417Reader.getMaxCodewordWidth(points));
                const result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat$1.PDF_417);
                result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, decoderResult.getECLevel());
                const pdf417ResultMetadata = decoderResult.getOther();
                if (pdf417ResultMetadata != null) {
                    result.putMetadata(ResultMetadataType$1.PDF417_EXTRA_METADATA, pdf417ResultMetadata);
                }
                results.push(result);
            }
            return results.map(x => x);
        }
        static getMaxWidth(p1, p2) {
            if (p1 == null || p2 == null) {
                return 0;
            }
            return Math.trunc(Math.abs(p1.getX() - p2.getX()));
        }
        static getMinWidth(p1, p2) {
            if (p1 == null || p2 == null) {
                return Integer.MAX_VALUE;
            }
            return Math.trunc(Math.abs(p1.getX() - p2.getX()));
        }
        static getMaxCodewordWidth(p) {
            return Math.floor(Math.max(Math.max(PDF417Reader.getMaxWidth(p[0], p[4]), PDF417Reader.getMaxWidth(p[6], p[2]) * PDF417Common.MODULES_IN_CODEWORD /
                PDF417Common.MODULES_IN_STOP_PATTERN), Math.max(PDF417Reader.getMaxWidth(p[1], p[5]), PDF417Reader.getMaxWidth(p[7], p[3]) * PDF417Common.MODULES_IN_CODEWORD /
                PDF417Common.MODULES_IN_STOP_PATTERN)));
        }
        static getMinCodewordWidth(p) {
            return Math.floor(Math.min(Math.min(PDF417Reader.getMinWidth(p[0], p[4]), PDF417Reader.getMinWidth(p[6], p[2]) * PDF417Common.MODULES_IN_CODEWORD /
                PDF417Common.MODULES_IN_STOP_PATTERN), Math.min(PDF417Reader.getMinWidth(p[1], p[5]), PDF417Reader.getMinWidth(p[7], p[3]) * PDF417Common.MODULES_IN_CODEWORD /
                PDF417Common.MODULES_IN_STOP_PATTERN)));
        }
        // @Override
        reset() {
            // nothing needs to be reset
        }
    }

    /**
     * Custom Error class of type Exception.
     */
    class ReaderException extends Exception {
    }
    ReaderException.kind = 'ReaderException';

    /*
     * Copyright 2009 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*namespace com.google.zxing {*/
    /**
     * MultiFormatReader is a convenience class and the main entry point into the library for most uses.
     * By default it attempts to decode all barcode formats that the library supports. Optionally, you
     * can provide a hints object to request different behavior, for example only decoding QR codes.
     *
     * @author Sean Owen
     * @author dswitkin@google.com (Daniel Switkin)
     */
    class MultiFormatReader {
        /**
         * This version of decode honors the intent of Reader.decode(BinaryBitmap) in that it
         * passes null as a hint to the decoders. However, that makes it inefficient to call repeatedly.
         * Use setHints() followed by decodeWithState() for continuous scan applications.
         *
         * @param image The pixel data to decode
         * @return The contents of the image
         *
         * @throws NotFoundException Any errors which occurred
         */
        /*@Override*/
        // public decode(image: BinaryBitmap): Result {
        //   setHints(null)
        //   return decodeInternal(image)
        // }
        /**
         * Decode an image using the hints provided. Does not honor existing state.
         *
         * @param image The pixel data to decode
         * @param hints The hints to use, clearing the previous state.
         * @return The contents of the image
         *
         * @throws NotFoundException Any errors which occurred
         */
        /*@Override*/
        decode(image, hints) {
            this.setHints(hints);
            return this.decodeInternal(image);
        }
        /**
         * Decode an image using the state set up by calling setHints() previously. Continuous scan
         * clients will get a <b>large</b> speed increase by using this instead of decode().
         *
         * @param image The pixel data to decode
         * @return The contents of the image
         *
         * @throws NotFoundException Any errors which occurred
         */
        decodeWithState(image) {
            // Make sure to set up the default state so we don't crash
            if (this.readers === null || this.readers === undefined) {
                this.setHints(null);
            }
            return this.decodeInternal(image);
        }
        /**
         * This method adds state to the MultiFormatReader. By setting the hints once, subsequent calls
         * to decodeWithState(image) can reuse the same set of readers without reallocating memory. This
         * is important for performance in continuous scan clients.
         *
         * @param hints The set of hints to use for subsequent calls to decode(image)
         */
        setHints(hints) {
            this.hints = hints;
            const tryHarder = hints !== null && hints !== undefined && undefined !== hints.get(DecodeHintType$1.TRY_HARDER);
            /*@SuppressWarnings("unchecked")*/
            const formats = hints === null || hints === undefined ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
            const readers = new Array();
            if (formats !== null && formats !== undefined) {
                const addOneDReader = formats.some(f => f === BarcodeFormat$1.UPC_A ||
                    f === BarcodeFormat$1.UPC_E ||
                    f === BarcodeFormat$1.EAN_13 ||
                    f === BarcodeFormat$1.EAN_8 ||
                    f === BarcodeFormat$1.CODABAR ||
                    f === BarcodeFormat$1.CODE_39 ||
                    f === BarcodeFormat$1.CODE_93 ||
                    f === BarcodeFormat$1.CODE_128 ||
                    f === BarcodeFormat$1.ITF ||
                    f === BarcodeFormat$1.RSS_14 ||
                    f === BarcodeFormat$1.RSS_EXPANDED);
                // Put 1D readers upfront in "normal" mode
                // TYPESCRIPTPORT: TODO: uncomment below as they are ported
                if (addOneDReader && !tryHarder) {
                    readers.push(new MultiFormatOneDReader(hints));
                }
                if (formats.includes(BarcodeFormat$1.QR_CODE)) {
                    readers.push(new QRCodeReader());
                }
                if (formats.includes(BarcodeFormat$1.DATA_MATRIX)) {
                    readers.push(new DataMatrixReader());
                }
                if (formats.includes(BarcodeFormat$1.AZTEC)) {
                    readers.push(new AztecReader());
                }
                if (formats.includes(BarcodeFormat$1.PDF_417)) {
                    readers.push(new PDF417Reader());
                }
                // if (formats.includes(BarcodeFormat.MAXICODE)) {
                //    readers.push(new MaxiCodeReader())
                // }
                // At end in "try harder" mode
                if (addOneDReader && tryHarder) {
                    readers.push(new MultiFormatOneDReader(hints));
                }
            }
            if (readers.length === 0) {
                if (!tryHarder) {
                    readers.push(new MultiFormatOneDReader(hints));
                }
                readers.push(new QRCodeReader());
                readers.push(new DataMatrixReader());
                readers.push(new AztecReader());
                readers.push(new PDF417Reader());
                // readers.push(new MaxiCodeReader())
                if (tryHarder) {
                    readers.push(new MultiFormatOneDReader(hints));
                }
            }
            this.readers = readers; // .toArray(new Reader[readers.size()])
        }
        /*@Override*/
        reset() {
            if (this.readers !== null) {
                for (const reader of this.readers) {
                    reader.reset();
                }
            }
        }
        /**
         * @throws NotFoundException
         */
        decodeInternal(image) {
            if (this.readers === null) {
                throw new ReaderException('No readers where selected, nothing can be read.');
            }
            for (const reader of this.readers) {
                // Trying to decode with ${reader} reader.
                try {
                    return reader.decode(image, this.hints);
                }
                catch (ex) {
                    if (ex instanceof ReaderException) {
                        continue;
                    }
                    // Bad Exception.
                }
            }
            throw new NotFoundException('No MultiFormat Readers were able to detect the code.');
        }
    }

    class BrowserMultiFormatReader extends BrowserCodeReader {
        constructor(hints = null, timeBetweenScansMillis = 500) {
            const reader = new MultiFormatReader();
            reader.setHints(hints);
            super(reader, timeBetweenScansMillis);
        }
        /**
         * Overwrite decodeBitmap to call decodeWithState, which will pay
         * attention to the hints set in the constructor function
         */
        decodeBitmap(binaryBitmap) {
            return this.reader.decodeWithState(binaryBitmap);
        }
    }

    /**
     * @deprecated Moving to @zxing/browser
     *
     * QR Code reader to use from browser.
     */
    class BrowserPDF417Reader extends BrowserCodeReader {
        /**
         * Creates an instance of BrowserPDF417Reader.
         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
         */
        constructor(timeBetweenScansMillis = 500) {
            super(new PDF417Reader(), timeBetweenScansMillis);
        }
    }

    /**
     * @deprecated Moving to @zxing/browser
     *
     * QR Code reader to use from browser.
     */
    class BrowserQRCodeReader extends BrowserCodeReader {
        /**
         * Creates an instance of BrowserQRCodeReader.
         * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
         */
        constructor(timeBetweenScansMillis = 500) {
            super(new QRCodeReader(), timeBetweenScansMillis);
        }
    }

    /*
     * Copyright 2009 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*namespace com.google.zxing {*/
    /**
     * These are a set of hints that you may pass to Writers to specify their behavior.
     *
     * @author dswitkin@google.com (Daniel Switkin)
     */
    var EncodeHintType;
    (function (EncodeHintType) {
        /**
         * Specifies what degree of error correction to use, for example in QR Codes.
         * Type depends on the encoder. For example for QR codes it's type
         * {@link com.google.zxing.qrcode.decoder.ErrorCorrectionLevel ErrorCorrectionLevel}.
         * For Aztec it is of type {@link Integer}, representing the minimal percentage of error correction words.
         * For PDF417 it is of type {@link Integer}, valid values being 0 to 8.
         * In all cases, it can also be a {@link String} representation of the desired value as well.
         * Note: an Aztec symbol should have a minimum of 25% EC words.
         */
        EncodeHintType[EncodeHintType["ERROR_CORRECTION"] = 0] = "ERROR_CORRECTION";
        /**
         * Specifies what character encoding to use where applicable (type {@link String})
         */
        EncodeHintType[EncodeHintType["CHARACTER_SET"] = 1] = "CHARACTER_SET";
        /**
         * Specifies the matrix shape for Data Matrix (type {@link com.google.zxing.datamatrix.encoder.SymbolShapeHint})
         */
        EncodeHintType[EncodeHintType["DATA_MATRIX_SHAPE"] = 2] = "DATA_MATRIX_SHAPE";
        /**
         * Specifies a minimum barcode size (type {@link Dimension}). Only applicable to Data Matrix now.
         *
         * @deprecated use width/height params in
         * {@link com.google.zxing.datamatrix.DataMatrixWriter#encode(String, BarcodeFormat, int, int)}
         */
        /*@Deprecated*/
        EncodeHintType[EncodeHintType["MIN_SIZE"] = 3] = "MIN_SIZE";
        /**
         * Specifies a maximum barcode size (type {@link Dimension}). Only applicable to Data Matrix now.
         *
         * @deprecated without replacement
         */
        /*@Deprecated*/
        EncodeHintType[EncodeHintType["MAX_SIZE"] = 4] = "MAX_SIZE";
        /**
         * Specifies margin, in pixels, to use when generating the barcode. The meaning can vary
         * by format; for example it controls margin before and after the barcode horizontally for
         * most 1D formats. (Type {@link Integer}, or {@link String} representation of the integer value).
         */
        EncodeHintType[EncodeHintType["MARGIN"] = 5] = "MARGIN";
        /**
         * Specifies whether to use compact mode for PDF417 (type {@link Boolean}, or "true" or "false"
         * {@link String} value).
         */
        EncodeHintType[EncodeHintType["PDF417_COMPACT"] = 6] = "PDF417_COMPACT";
        /**
         * Specifies what compaction mode to use for PDF417 (type
         * {@link com.google.zxing.pdf417.encoder.Compaction Compaction} or {@link String} value of one of its
         * enum values).
         */
        EncodeHintType[EncodeHintType["PDF417_COMPACTION"] = 7] = "PDF417_COMPACTION";
        /**
         * Specifies the minimum and maximum number of rows and columns for PDF417 (type
         * {@link com.google.zxing.pdf417.encoder.Dimensions Dimensions}).
         */
        EncodeHintType[EncodeHintType["PDF417_DIMENSIONS"] = 8] = "PDF417_DIMENSIONS";
        /**
         * Specifies the required number of layers for an Aztec code.
         * A negative number (-1, -2, -3, -4) specifies a compact Aztec code.
         * 0 indicates to use the minimum number of layers (the default).
         * A positive number (1, 2, .. 32) specifies a normal (non-compact) Aztec code.
         * (Type {@link Integer}, or {@link String} representation of the integer value).
         */
        EncodeHintType[EncodeHintType["AZTEC_LAYERS"] = 9] = "AZTEC_LAYERS";
        /**
         * Specifies the exact version of QR code to be encoded.
         * (Type {@link Integer}, or {@link String} representation of the integer value).
         */
        EncodeHintType[EncodeHintType["QR_VERSION"] = 10] = "QR_VERSION";
    })(EncodeHintType || (EncodeHintType = {}));
    var EncodeHintType$1 = EncodeHintType;

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * <p>Implements Reed-Solomon encoding, as the name implies.</p>
     *
     * @author Sean Owen
     * @author William Rucklidge
     */
    class ReedSolomonEncoder {
        /**
         * A reed solomon error-correcting encoding constructor is created by
         * passing as Galois Field with of size equal to the number of code
         * words (symbols) in the alphabet (the number of values in each
         * element of arrays that are encoded/decoded).
         * @param field A galois field with a number of elements equal to the size
         * of the alphabet of symbols to encode.
         */
        constructor(field) {
            this.field = field;
            this.cachedGenerators = [];
            this.cachedGenerators.push(new GenericGFPoly(field, Int32Array.from([1])));
        }
        buildGenerator(degree /*int*/) {
            const cachedGenerators = this.cachedGenerators;
            if (degree >= cachedGenerators.length) {
                let lastGenerator = cachedGenerators[cachedGenerators.length - 1];
                const field = this.field;
                for (let d = cachedGenerators.length; d <= degree; d++) {
                    const nextGenerator = lastGenerator.multiply(new GenericGFPoly(field, Int32Array.from([1, field.exp(d - 1 + field.getGeneratorBase())])));
                    cachedGenerators.push(nextGenerator);
                    lastGenerator = nextGenerator;
                }
            }
            return cachedGenerators[degree];
        }
        /**
         * <p>Encode a sequence of code words (symbols) using Reed-Solomon to allow decoders
         * to detect and correct errors that may have been introduced when the resulting
         * data is stored or transmitted.</p>
         *
         * @param toEncode array used for both and output. Caller initializes the array with
         * the code words (symbols) to be encoded followed by empty elements allocated to make
         * space for error-correction code words in the encoded output. The array contains
         * the encdoded output when encode returns. Code words are encoded as numbers from
         * 0 to n-1, where n is the number of possible code words (symbols), as determined
         * by the size of the Galois Field passed in the constructor of this object.
         * @param ecBytes the number of elements reserved in the array (first parameter)
         * to store error-correction code words. Thus, the number of code words (symbols)
         * to encode in the first parameter is thus toEncode.length - ecBytes.
         * Note, the use of "bytes" in the name of this parameter is misleading, as there may
         * be more or fewer than 256 symbols being encoded, as determined by the number of
         * elements in the Galois Field passed as a constructor to this object.
         * @throws IllegalArgumentException thrown in response to validation errros.
         */
        encode(toEncode, ecBytes /*int*/) {
            if (ecBytes === 0) {
                throw new IllegalArgumentException('No error correction bytes');
            }
            const dataBytes = toEncode.length - ecBytes;
            if (dataBytes <= 0) {
                throw new IllegalArgumentException('No data bytes provided');
            }
            const generator = this.buildGenerator(ecBytes);
            const infoCoefficients = new Int32Array(dataBytes);
            System.arraycopy(toEncode, 0, infoCoefficients, 0, dataBytes);
            let info = new GenericGFPoly(this.field, infoCoefficients);
            info = info.multiplyByMonomial(ecBytes, 1);
            const remainder = info.divide(generator)[1];
            const coefficients = remainder.getCoefficients();
            const numZeroCoefficients = ecBytes - coefficients.length;
            for (let i = 0; i < numZeroCoefficients; i++) {
                toEncode[dataBytes + i] = 0;
            }
            System.arraycopy(coefficients, 0, toEncode, dataBytes + numZeroCoefficients, coefficients.length);
        }
    }

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * @author Satoru Takabayashi
     * @author Daniel Switkin
     * @author Sean Owen
     */
    class MaskUtil {
        constructor() {
            // do nothing
        }
        /**
         * Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and
         * give penalty to them. Example: 00000 or 11111.
         */
        static applyMaskPenaltyRule1(matrix) {
            return MaskUtil.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil.applyMaskPenaltyRule1Internal(matrix, false);
        }
        /**
         * Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give
         * penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a
         * penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.
         */
        static applyMaskPenaltyRule2(matrix) {
            let penalty = 0;
            const array = matrix.getArray();
            const width = matrix.getWidth();
            const height = matrix.getHeight();
            for (let y = 0; y < height - 1; y++) {
                const arrayY = array[y];
                for (let x = 0; x < width - 1; x++) {
                    const value = arrayY[x];
                    if (value === arrayY[x + 1] && value === array[y + 1][x] && value === array[y + 1][x + 1]) {
                        penalty++;
                    }
                }
            }
            return MaskUtil.N2 * penalty;
        }
        /**
         * Apply mask penalty rule 3 and return the penalty. Find consecutive runs of 1:1:3:1:1:4
         * starting with black, or 4:1:1:3:1:1 starting with white, and give penalty to them.  If we
         * find patterns like 000010111010000, we give penalty once.
         */
        static applyMaskPenaltyRule3(matrix) {
            let numPenalties = 0;
            const array = matrix.getArray();
            const width = matrix.getWidth();
            const height = matrix.getHeight();
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const arrayY = array[y]; // We can at least optimize this access
                    if (x + 6 < width &&
                        arrayY[x] === 1 &&
                        arrayY[x + 1] === 0 &&
                        arrayY[x + 2] === 1 &&
                        arrayY[x + 3] === 1 &&
                        arrayY[x + 4] === 1 &&
                        arrayY[x + 5] === 0 &&
                        arrayY[x + 6] === 1 &&
                        (MaskUtil.isWhiteHorizontal(arrayY, x - 4, x) || MaskUtil.isWhiteHorizontal(arrayY, x + 7, x + 11))) {
                        numPenalties++;
                    }
                    if (y + 6 < height &&
                        array[y][x] === 1 &&
                        array[y + 1][x] === 0 &&
                        array[y + 2][x] === 1 &&
                        array[y + 3][x] === 1 &&
                        array[y + 4][x] === 1 &&
                        array[y + 5][x] === 0 &&
                        array[y + 6][x] === 1 &&
                        (MaskUtil.isWhiteVertical(array, x, y - 4, y) || MaskUtil.isWhiteVertical(array, x, y + 7, y + 11))) {
                        numPenalties++;
                    }
                }
            }
            return numPenalties * MaskUtil.N3;
        }
        static isWhiteHorizontal(rowArray, from /*int*/, to /*int*/) {
            from = Math.max(from, 0);
            to = Math.min(to, rowArray.length);
            for (let i = from; i < to; i++) {
                if (rowArray[i] === 1) {
                    return false;
                }
            }
            return true;
        }
        static isWhiteVertical(array, col /*int*/, from /*int*/, to /*int*/) {
            from = Math.max(from, 0);
            to = Math.min(to, array.length);
            for (let i = from; i < to; i++) {
                if (array[i][col] === 1) {
                    return false;
                }
            }
            return true;
        }
        /**
         * Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give
         * penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.
         */
        static applyMaskPenaltyRule4(matrix) {
            let numDarkCells = 0;
            const array = matrix.getArray();
            const width = matrix.getWidth();
            const height = matrix.getHeight();
            for (let y = 0; y < height; y++) {
                const arrayY = array[y];
                for (let x = 0; x < width; x++) {
                    if (arrayY[x] === 1) {
                        numDarkCells++;
                    }
                }
            }
            const numTotalCells = matrix.getHeight() * matrix.getWidth();
            const fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);
            return fivePercentVariances * MaskUtil.N4;
        }
        /**
         * Return the mask bit for "getMaskPattern" at "x" and "y". See 8.8 of JISX0510:2004 for mask
         * pattern conditions.
         */
        static getDataMaskBit(maskPattern /*int*/, x /*int*/, y /*int*/) {
            let intermediate; /*int*/
            let temp; /*int*/
            switch (maskPattern) {
                case 0:
                    intermediate = (y + x) & 0x1;
                    break;
                case 1:
                    intermediate = y & 0x1;
                    break;
                case 2:
                    intermediate = x % 3;
                    break;
                case 3:
                    intermediate = (y + x) % 3;
                    break;
                case 4:
                    intermediate = (Math.floor(y / 2) + Math.floor(x / 3)) & 0x1;
                    break;
                case 5:
                    temp = y * x;
                    intermediate = (temp & 0x1) + (temp % 3);
                    break;
                case 6:
                    temp = y * x;
                    intermediate = ((temp & 0x1) + (temp % 3)) & 0x1;
                    break;
                case 7:
                    temp = y * x;
                    intermediate = ((temp % 3) + ((y + x) & 0x1)) & 0x1;
                    break;
                default:
                    throw new IllegalArgumentException('Invalid mask pattern: ' + maskPattern);
            }
            return intermediate === 0;
        }
        /**
         * Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both
         * vertical and horizontal orders respectively.
         */
        static applyMaskPenaltyRule1Internal(matrix, isHorizontal) {
            let penalty = 0;
            const iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();
            const jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();
            const array = matrix.getArray();
            for (let i = 0; i < iLimit; i++) {
                let numSameBitCells = 0;
                let prevBit = -1;
                for (let j = 0; j < jLimit; j++) {
                    const bit = isHorizontal ? array[i][j] : array[j][i];
                    if (bit === prevBit) {
                        numSameBitCells++;
                    }
                    else {
                        if (numSameBitCells >= 5) {
                            penalty += MaskUtil.N1 + (numSameBitCells - 5);
                        }
                        numSameBitCells = 1; // Include the cell itself.
                        prevBit = bit;
                    }
                }
                if (numSameBitCells >= 5) {
                    penalty += MaskUtil.N1 + (numSameBitCells - 5);
                }
            }
            return penalty;
        }
    }
    // Penalty weights from section 6.8.2.1
    MaskUtil.N1 = 3;
    MaskUtil.N2 = 3;
    MaskUtil.N3 = 40;
    MaskUtil.N4 = 10;

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * JAVAPORT: The original code was a 2D array of ints, but since it only ever gets assigned
     * -1, 0, and 1, I'm going to use less memory and go with bytes.
     *
     * @author dswitkin@google.com (Daniel Switkin)
     */
    class ByteMatrix {
        constructor(width /*int*/, height /*int*/) {
            this.width = width;
            this.height = height;
            const bytes = new Array(height); // [height][width]
            for (let i = 0; i !== height; i++) {
                bytes[i] = new Uint8Array(width);
            }
            this.bytes = bytes;
        }
        getHeight() {
            return this.height;
        }
        getWidth() {
            return this.width;
        }
        get(x /*int*/, y /*int*/) {
            return this.bytes[y][x];
        }
        /**
         * @return an internal representation as bytes, in row-major order. array[y][x] represents point (x,y)
         */
        getArray() {
            return this.bytes;
        }
        // TYPESCRIPTPORT: preffer to let two methods instead of override to avoid type comparison inside
        setNumber(x /*int*/, y /*int*/, value /*byte|int*/) {
            this.bytes[y][x] = value;
        }
        // public set(x: number /*int*/, y: number /*int*/, value: number /*int*/): void {
        //   bytes[y][x] = (byte) value
        // }
        setBoolean(x /*int*/, y /*int*/, value) {
            this.bytes[y][x] = /*(byte) */ (value ? 1 : 0);
        }
        clear(value /*byte*/) {
            for (const aByte of this.bytes) {
                Arrays.fill(aByte, value);
            }
        }
        equals(o) {
            if (!(o instanceof ByteMatrix)) {
                return false;
            }
            const other = o;
            if (this.width !== other.width) {
                return false;
            }
            if (this.height !== other.height) {
                return false;
            }
            for (let y = 0, height = this.height; y < height; ++y) {
                const bytesY = this.bytes[y];
                const otherBytesY = other.bytes[y];
                for (let x = 0, width = this.width; x < width; ++x) {
                    if (bytesY[x] !== otherBytesY[x]) {
                        return false;
                    }
                }
            }
            return true;
        }
        /*@Override*/
        toString() {
            const result = new StringBuilder(); // (2 * width * height + 2)
            for (let y = 0, height = this.height; y < height; ++y) {
                const bytesY = this.bytes[y];
                for (let x = 0, width = this.width; x < width; ++x) {
                    switch (bytesY[x]) {
                        case 0:
                            result.append(' 0');
                            break;
                        case 1:
                            result.append(' 1');
                            break;
                        default:
                            result.append('  ');
                            break;
                    }
                }
                result.append('\n');
            }
            return result.toString();
        }
    }

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * @author satorux@google.com (Satoru Takabayashi) - creator
     * @author dswitkin@google.com (Daniel Switkin) - ported from C++
     */
    class QRCode {
        constructor() {
            this.maskPattern = -1;
        }
        getMode() {
            return this.mode;
        }
        getECLevel() {
            return this.ecLevel;
        }
        getVersion() {
            return this.version;
        }
        getMaskPattern() {
            return this.maskPattern;
        }
        getMatrix() {
            return this.matrix;
        }
        /*@Override*/
        toString() {
            const result = new StringBuilder(); // (200)
            result.append('<<\n');
            result.append(' mode: ');
            result.append(this.mode ? this.mode.toString() : 'null');
            result.append('\n ecLevel: ');
            result.append(this.ecLevel ? this.ecLevel.toString() : 'null');
            result.append('\n version: ');
            result.append(this.version ? this.version.toString() : 'null');
            result.append('\n maskPattern: ');
            result.append(this.maskPattern.toString());
            if (this.matrix) {
                result.append('\n matrix:\n');
                result.append(this.matrix.toString());
            }
            else {
                result.append('\n matrix: null\n');
            }
            result.append('>>\n');
            return result.toString();
        }
        setMode(value) {
            this.mode = value;
        }
        setECLevel(value) {
            this.ecLevel = value;
        }
        setVersion(version) {
            this.version = version;
        }
        setMaskPattern(value /*int*/) {
            this.maskPattern = value;
        }
        setMatrix(value) {
            this.matrix = value;
        }
        // Check if "mask_pattern" is valid.
        static isValidMaskPattern(maskPattern /*int*/) {
            return maskPattern >= 0 && maskPattern < QRCode.NUM_MASK_PATTERNS;
        }
    }
    QRCode.NUM_MASK_PATTERNS = 8;

    /**
     * Custom Error class of type Exception.
     */
    class WriterException extends Exception {
    }
    WriterException.kind = 'WriterException';

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * @author satorux@google.com (Satoru Takabayashi) - creator
     * @author dswitkin@google.com (Daniel Switkin) - ported from C++
     */
    class MatrixUtil {
        constructor() {
            // do nothing
        }
        // Set all cells to -1 (TYPESCRIPTPORT: 255).  -1 (TYPESCRIPTPORT: 255) means that the cell is empty (not set yet).
        //
        // JAVAPORT: We shouldn't need to do this at all. The code should be rewritten to begin encoding
        // with the ByteMatrix initialized all to zero.
        static clearMatrix(matrix) {
            // TYPESCRIPTPORT: we use UintArray se changed here from -1 to 255
            matrix.clear(/*(byte) */ /*-1*/ 255);
        }
        // Build 2D matrix of QR Code from "dataBits" with "ecLevel", "version" and "getMaskPattern". On
        // success, store the result in "matrix" and return true.
        static buildMatrix(dataBits, ecLevel, version, maskPattern /*int*/, matrix) {
            MatrixUtil.clearMatrix(matrix);
            MatrixUtil.embedBasicPatterns(version, matrix);
            // Type information appear with any version.
            MatrixUtil.embedTypeInfo(ecLevel, maskPattern, matrix);
            // Version info appear if version >= 7.
            MatrixUtil.maybeEmbedVersionInfo(version, matrix);
            // Data should be embedded at end.
            MatrixUtil.embedDataBits(dataBits, maskPattern, matrix);
        }
        // Embed basic patterns. On success, modify the matrix and return true.
        // The basic patterns are:
        // - Position detection patterns
        // - Timing patterns
        // - Dark dot at the left bottom corner
        // - Position adjustment patterns, if need be
        static embedBasicPatterns(version, matrix) {
            // Let's get started with embedding big squares at corners.
            MatrixUtil.embedPositionDetectionPatternsAndSeparators(matrix);
            // Then, embed the dark dot at the left bottom corner.
            MatrixUtil.embedDarkDotAtLeftBottomCorner(matrix);
            // Position adjustment patterns appear if version >= 2.
            MatrixUtil.maybeEmbedPositionAdjustmentPatterns(version, matrix);
            // Timing patterns should be embedded after position adj. patterns.
            MatrixUtil.embedTimingPatterns(matrix);
        }
        // Embed type information. On success, modify the matrix.
        static embedTypeInfo(ecLevel, maskPattern /*int*/, matrix) {
            const typeInfoBits = new BitArray();
            MatrixUtil.makeTypeInfoBits(ecLevel, maskPattern, typeInfoBits);
            for (let i = 0, size = typeInfoBits.getSize(); i < size; ++i) {
                // Place bits in LSB to MSB order.  LSB (least significant bit) is the last value in
                // "typeInfoBits".
                const bit = typeInfoBits.get(typeInfoBits.getSize() - 1 - i);
                // Type info bits at the left top corner. See 8.9 of JISX0510:2004 (p.46).
                const coordinates = MatrixUtil.TYPE_INFO_COORDINATES[i];
                const x1 = coordinates[0];
                const y1 = coordinates[1];
                matrix.setBoolean(x1, y1, bit);
                if (i < 8) {
                    // Right top corner.
                    const x2 = matrix.getWidth() - i - 1;
                    const y2 = 8;
                    matrix.setBoolean(x2, y2, bit);
                }
                else {
                    // Left bottom corner.
                    const x2 = 8;
                    const y2 = matrix.getHeight() - 7 + (i - 8);
                    matrix.setBoolean(x2, y2, bit);
                }
            }
        }
        // Embed version information if need be. On success, modify the matrix and return true.
        // See 8.10 of JISX0510:2004 (p.47) for how to embed version information.
        static maybeEmbedVersionInfo(version, matrix) {
            if (version.getVersionNumber() < 7) { // Version info is necessary if version >= 7.
                return; // Don't need version info.
            }
            const versionInfoBits = new BitArray();
            MatrixUtil.makeVersionInfoBits(version, versionInfoBits);
            let bitIndex = 6 * 3 - 1; // It will decrease from 17 to 0.
            for (let i = 0; i < 6; ++i) {
                for (let j = 0; j < 3; ++j) {
                    // Place bits in LSB (least significant bit) to MSB order.
                    const bit = versionInfoBits.get(bitIndex);
                    bitIndex--;
                    // Left bottom corner.
                    matrix.setBoolean(i, matrix.getHeight() - 11 + j, bit);
                    // Right bottom corner.
                    matrix.setBoolean(matrix.getHeight() - 11 + j, i, bit);
                }
            }
        }
        // Embed "dataBits" using "getMaskPattern". On success, modify the matrix and return true.
        // For debugging purposes, it skips masking process if "getMaskPattern" is -1(TYPESCRIPTPORT: 255).
        // See 8.7 of JISX0510:2004 (p.38) for how to embed data bits.
        static embedDataBits(dataBits, maskPattern /*int*/, matrix) {
            let bitIndex = 0;
            let direction = -1;
            // Start from the right bottom cell.
            let x = matrix.getWidth() - 1;
            let y = matrix.getHeight() - 1;
            while (x > 0) {
                // Skip the vertical timing pattern.
                if (x === 6) {
                    x -= 1;
                }
                while (y >= 0 && y < matrix.getHeight()) {
                    for (let i = 0; i < 2; ++i) {
                        const xx = x - i;
                        // Skip the cell if it's not empty.
                        if (!MatrixUtil.isEmpty(matrix.get(xx, y))) {
                            continue;
                        }
                        let bit;
                        if (bitIndex < dataBits.getSize()) {
                            bit = dataBits.get(bitIndex);
                            ++bitIndex;
                        }
                        else {
                            // Padding bit. If there is no bit left, we'll fill the left cells with 0, as described
                            // in 8.4.9 of JISX0510:2004 (p. 24).
                            bit = false;
                        }
                        // Skip masking if mask_pattern is -1 (TYPESCRIPTPORT: 255).
                        if (maskPattern !== 255 && MaskUtil.getDataMaskBit(maskPattern, xx, y)) {
                            bit = !bit;
                        }
                        matrix.setBoolean(xx, y, bit);
                    }
                    y += direction;
                }
                direction = -direction; // Reverse the direction.
                y += direction;
                x -= 2; // Move to the left.
            }
            // All bits should be consumed.
            if (bitIndex !== dataBits.getSize()) {
                throw new WriterException('Not all bits consumed: ' + bitIndex + '/' + dataBits.getSize());
            }
        }
        // Return the position of the most significant bit set (one: to) in the "value". The most
        // significant bit is position 32. If there is no bit set, return 0. Examples:
        // - findMSBSet(0) => 0
        // - findMSBSet(1) => 1
        // - findMSBSet(255) => 8
        static findMSBSet(value /*int*/) {
            return 32 - Integer.numberOfLeadingZeros(value);
        }
        // Calculate BCH (Bose-Chaudhuri-Hocquenghem) code for "value" using polynomial "poly". The BCH
        // code is used for encoding type information and version information.
        // Example: Calculation of version information of 7.
        // f(x) is created from 7.
        //   - 7 = 000111 in 6 bits
        //   - f(x) = x^2 + x^1 + x^0
        // g(x) is given by the standard (p. 67)
        //   - g(x) = x^12 + x^11 + x^10 + x^9 + x^8 + x^5 + x^2 + 1
        // Multiply f(x) by x^(18 - 6)
        //   - f'(x) = f(x) * x^(18 - 6)
        //   - f'(x) = x^14 + x^13 + x^12
        // Calculate the remainder of f'(x) / g(x)
        //         x^2
        //         __________________________________________________
        //   g(x) )x^14 + x^13 + x^12
        //         x^14 + x^13 + x^12 + x^11 + x^10 + x^7 + x^4 + x^2
        //         --------------------------------------------------
        //                              x^11 + x^10 + x^7 + x^4 + x^2
        //
        // The remainder is x^11 + x^10 + x^7 + x^4 + x^2
        // Encode it in binary: 110010010100
        // The return value is 0xc94 (1100 1001 0100)
        //
        // Since all coefficients in the polynomials are 1 or 0, we can do the calculation by bit
        // operations. We don't care if coefficients are positive or negative.
        static calculateBCHCode(value /*int*/, poly /*int*/) {
            if (poly === 0) {
                throw new IllegalArgumentException('0 polynomial');
            }
            // If poly is "1 1111 0010 0101" (version info poly), msbSetInPoly is 13. We'll subtract 1
            // from 13 to make it 12.
            const msbSetInPoly = MatrixUtil.findMSBSet(poly);
            value <<= msbSetInPoly - 1;
            // Do the division business using exclusive-or operations.
            while (MatrixUtil.findMSBSet(value) >= msbSetInPoly) {
                value ^= poly << (MatrixUtil.findMSBSet(value) - msbSetInPoly);
            }
            // Now the "value" is the remainder (i.e. the BCH code)
            return value;
        }
        // Make bit vector of type information. On success, store the result in "bits" and return true.
        // Encode error correction level and mask pattern. See 8.9 of
        // JISX0510:2004 (p.45) for details.
        static makeTypeInfoBits(ecLevel, maskPattern /*int*/, bits) {
            if (!QRCode.isValidMaskPattern(maskPattern)) {
                throw new WriterException('Invalid mask pattern');
            }
            const typeInfo = (ecLevel.getBits() << 3) | maskPattern;
            bits.appendBits(typeInfo, 5);
            const bchCode = MatrixUtil.calculateBCHCode(typeInfo, MatrixUtil.TYPE_INFO_POLY);
            bits.appendBits(bchCode, 10);
            const maskBits = new BitArray();
            maskBits.appendBits(MatrixUtil.TYPE_INFO_MASK_PATTERN, 15);
            bits.xor(maskBits);
            if (bits.getSize() !== 15) { // Just in case.
                throw new WriterException('should not happen but we got: ' + bits.getSize());
            }
        }
        // Make bit vector of version information. On success, store the result in "bits" and return true.
        // See 8.10 of JISX0510:2004 (p.45) for details.
        static makeVersionInfoBits(version, bits) {
            bits.appendBits(version.getVersionNumber(), 6);
            const bchCode = MatrixUtil.calculateBCHCode(version.getVersionNumber(), MatrixUtil.VERSION_INFO_POLY);
            bits.appendBits(bchCode, 12);
            if (bits.getSize() !== 18) { // Just in case.
                throw new WriterException('should not happen but we got: ' + bits.getSize());
            }
        }
        // Check if "value" is empty.
        static isEmpty(value /*int*/) {
            return value === 255; // -1
        }
        static embedTimingPatterns(matrix) {
            // -8 is for skipping position detection patterns (7: size), and two horizontal/vertical
            // separation patterns (1: size). Thus, 8 = 7 + 1.
            for (let i = 8; i < matrix.getWidth() - 8; ++i) {
                const bit = (i + 1) % 2;
                // Horizontal line.
                if (MatrixUtil.isEmpty(matrix.get(i, 6))) {
                    matrix.setNumber(i, 6, bit);
                }
                // Vertical line.
                if (MatrixUtil.isEmpty(matrix.get(6, i))) {
                    matrix.setNumber(6, i, bit);
                }
            }
        }
        // Embed the lonely dark dot at left bottom corner. JISX0510:2004 (p.46)
        static embedDarkDotAtLeftBottomCorner(matrix) {
            if (matrix.get(8, matrix.getHeight() - 8) === 0) {
                throw new WriterException();
            }
            matrix.setNumber(8, matrix.getHeight() - 8, 1);
        }
        static embedHorizontalSeparationPattern(xStart /*int*/, yStart /*int*/, matrix) {
            for (let x = 0; x < 8; ++x) {
                if (!MatrixUtil.isEmpty(matrix.get(xStart + x, yStart))) {
                    throw new WriterException();
                }
                matrix.setNumber(xStart + x, yStart, 0);
            }
        }
        static embedVerticalSeparationPattern(xStart /*int*/, yStart /*int*/, matrix) {
            for (let y = 0; y < 7; ++y) {
                if (!MatrixUtil.isEmpty(matrix.get(xStart, yStart + y))) {
                    throw new WriterException();
                }
                matrix.setNumber(xStart, yStart + y, 0);
            }
        }
        static embedPositionAdjustmentPattern(xStart /*int*/, yStart /*int*/, matrix) {
            for (let y = 0; y < 5; ++y) {
                const patternY = MatrixUtil.POSITION_ADJUSTMENT_PATTERN[y];
                for (let x = 0; x < 5; ++x) {
                    matrix.setNumber(xStart + x, yStart + y, patternY[x]);
                }
            }
        }
        static embedPositionDetectionPattern(xStart /*int*/, yStart /*int*/, matrix) {
            for (let y = 0; y < 7; ++y) {
                const patternY = MatrixUtil.POSITION_DETECTION_PATTERN[y];
                for (let x = 0; x < 7; ++x) {
                    matrix.setNumber(xStart + x, yStart + y, patternY[x]);
                }
            }
        }
        // Embed position detection patterns and surrounding vertical/horizontal separators.
        static embedPositionDetectionPatternsAndSeparators(matrix) {
            // Embed three big squares at corners.
            const pdpWidth = MatrixUtil.POSITION_DETECTION_PATTERN[0].length;
            // Left top corner.
            MatrixUtil.embedPositionDetectionPattern(0, 0, matrix);
            // Right top corner.
            MatrixUtil.embedPositionDetectionPattern(matrix.getWidth() - pdpWidth, 0, matrix);
            // Left bottom corner.
            MatrixUtil.embedPositionDetectionPattern(0, matrix.getWidth() - pdpWidth, matrix);
            // Embed horizontal separation patterns around the squares.
            const hspWidth = 8;
            // Left top corner.
            MatrixUtil.embedHorizontalSeparationPattern(0, hspWidth - 1, matrix);
            // Right top corner.
            MatrixUtil.embedHorizontalSeparationPattern(matrix.getWidth() - hspWidth, hspWidth - 1, matrix);
            // Left bottom corner.
            MatrixUtil.embedHorizontalSeparationPattern(0, matrix.getWidth() - hspWidth, matrix);
            // Embed vertical separation patterns around the squares.
            const vspSize = 7;
            // Left top corner.
            MatrixUtil.embedVerticalSeparationPattern(vspSize, 0, matrix);
            // Right top corner.
            MatrixUtil.embedVerticalSeparationPattern(matrix.getHeight() - vspSize - 1, 0, matrix);
            // Left bottom corner.
            MatrixUtil.embedVerticalSeparationPattern(vspSize, matrix.getHeight() - vspSize, matrix);
        }
        // Embed position adjustment patterns if need be.
        static maybeEmbedPositionAdjustmentPatterns(version, matrix) {
            if (version.getVersionNumber() < 2) { // The patterns appear if version >= 2
                return;
            }
            const index = version.getVersionNumber() - 1;
            const coordinates = MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index];
            for (let i = 0, length = coordinates.length; i !== length; i++) {
                const y = coordinates[i];
                if (y >= 0) {
                    for (let j = 0; j !== length; j++) {
                        const x = coordinates[j];
                        if (x >= 0 && MatrixUtil.isEmpty(matrix.get(x, y))) {
                            // If the cell is unset, we embed the position adjustment pattern here.
                            // -2 is necessary since the x/y coordinates point to the center of the pattern, not the
                            // left top corner.
                            MatrixUtil.embedPositionAdjustmentPattern(x - 2, y - 2, matrix);
                        }
                    }
                }
            }
        }
    }
    MatrixUtil.POSITION_DETECTION_PATTERN = Array.from([
        Int32Array.from([1, 1, 1, 1, 1, 1, 1]),
        Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
        Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
        Int32Array.from([1, 1, 1, 1, 1, 1, 1]),
    ]);
    MatrixUtil.POSITION_ADJUSTMENT_PATTERN = Array.from([
        Int32Array.from([1, 1, 1, 1, 1]),
        Int32Array.from([1, 0, 0, 0, 1]),
        Int32Array.from([1, 0, 1, 0, 1]),
        Int32Array.from([1, 0, 0, 0, 1]),
        Int32Array.from([1, 1, 1, 1, 1]),
    ]);
    // From Appendix E. Table 1, JIS0510X:2004 (71: p). The table was double-checked by komatsu.
    MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([
        Int32Array.from([-1, -1, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 18, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 22, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 26, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 30, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 34, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 22, 38, -1, -1, -1, -1]),
        Int32Array.from([6, 24, 42, -1, -1, -1, -1]),
        Int32Array.from([6, 26, 46, -1, -1, -1, -1]),
        Int32Array.from([6, 28, 50, -1, -1, -1, -1]),
        Int32Array.from([6, 30, 54, -1, -1, -1, -1]),
        Int32Array.from([6, 32, 58, -1, -1, -1, -1]),
        Int32Array.from([6, 34, 62, -1, -1, -1, -1]),
        Int32Array.from([6, 26, 46, 66, -1, -1, -1]),
        Int32Array.from([6, 26, 48, 70, -1, -1, -1]),
        Int32Array.from([6, 26, 50, 74, -1, -1, -1]),
        Int32Array.from([6, 30, 54, 78, -1, -1, -1]),
        Int32Array.from([6, 30, 56, 82, -1, -1, -1]),
        Int32Array.from([6, 30, 58, 86, -1, -1, -1]),
        Int32Array.from([6, 34, 62, 90, -1, -1, -1]),
        Int32Array.from([6, 28, 50, 72, 94, -1, -1]),
        Int32Array.from([6, 26, 50, 74, 98, -1, -1]),
        Int32Array.from([6, 30, 54, 78, 102, -1, -1]),
        Int32Array.from([6, 28, 54, 80, 106, -1, -1]),
        Int32Array.from([6, 32, 58, 84, 110, -1, -1]),
        Int32Array.from([6, 30, 58, 86, 114, -1, -1]),
        Int32Array.from([6, 34, 62, 90, 118, -1, -1]),
        Int32Array.from([6, 26, 50, 74, 98, 122, -1]),
        Int32Array.from([6, 30, 54, 78, 102, 126, -1]),
        Int32Array.from([6, 26, 52, 78, 104, 130, -1]),
        Int32Array.from([6, 30, 56, 82, 108, 134, -1]),
        Int32Array.from([6, 34, 60, 86, 112, 138, -1]),
        Int32Array.from([6, 30, 58, 86, 114, 142, -1]),
        Int32Array.from([6, 34, 62, 90, 118, 146, -1]),
        Int32Array.from([6, 30, 54, 78, 102, 126, 150]),
        Int32Array.from([6, 24, 50, 76, 102, 128, 154]),
        Int32Array.from([6, 28, 54, 80, 106, 132, 158]),
        Int32Array.from([6, 32, 58, 84, 110, 136, 162]),
        Int32Array.from([6, 26, 54, 82, 110, 138, 166]),
        Int32Array.from([6, 30, 58, 86, 114, 142, 170]),
    ]);
    // Type info cells at the left top corner.
    MatrixUtil.TYPE_INFO_COORDINATES = Array.from([
        Int32Array.from([8, 0]),
        Int32Array.from([8, 1]),
        Int32Array.from([8, 2]),
        Int32Array.from([8, 3]),
        Int32Array.from([8, 4]),
        Int32Array.from([8, 5]),
        Int32Array.from([8, 7]),
        Int32Array.from([8, 8]),
        Int32Array.from([7, 8]),
        Int32Array.from([5, 8]),
        Int32Array.from([4, 8]),
        Int32Array.from([3, 8]),
        Int32Array.from([2, 8]),
        Int32Array.from([1, 8]),
        Int32Array.from([0, 8]),
    ]);
    // From Appendix D in JISX0510:2004 (p. 67)
    MatrixUtil.VERSION_INFO_POLY = 0x1f25; // 1 1111 0010 0101
    // From Appendix C in JISX0510:2004 (p.65).
    MatrixUtil.TYPE_INFO_POLY = 0x537;
    MatrixUtil.TYPE_INFO_MASK_PATTERN = 0x5412;

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*namespace com.google.zxing.qrcode.encoder {*/
    class BlockPair {
        constructor(dataBytes, errorCorrectionBytes) {
            this.dataBytes = dataBytes;
            this.errorCorrectionBytes = errorCorrectionBytes;
        }
        getDataBytes() {
            return this.dataBytes;
        }
        getErrorCorrectionBytes() {
            return this.errorCorrectionBytes;
        }
    }

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*import java.io.UnsupportedEncodingException;*/
    /*import java.util.ArrayList;*/
    /*import java.util.Collection;*/
    /*import java.util.Map;*/
    /**
     * @author satorux@google.com (Satoru Takabayashi) - creator
     * @author dswitkin@google.com (Daniel Switkin) - ported from C++
     */
    class Encoder {
        // TYPESCRIPTPORT: changed to UTF8, the default for js
        constructor() { }
        // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details.
        // Basically it applies four rules and summate all penalties.
        static calculateMaskPenalty(matrix) {
            return MaskUtil.applyMaskPenaltyRule1(matrix)
                + MaskUtil.applyMaskPenaltyRule2(matrix)
                + MaskUtil.applyMaskPenaltyRule3(matrix)
                + MaskUtil.applyMaskPenaltyRule4(matrix);
        }
        /**
         * @param content text to encode
         * @param ecLevel error correction level to use
         * @return {@link QRCode} representing the encoded QR code
         * @throws WriterException if encoding can't succeed, because of for example invalid content
         *   or configuration
         */
        // public static encode(content: string, ecLevel: ErrorCorrectionLevel): QRCode /*throws WriterException*/ {
        //   return encode(content, ecLevel, null)
        // }
        static encode(content, ecLevel, hints = null) {
            // Determine what character encoding has been specified by the caller, if any
            let encoding = Encoder.DEFAULT_BYTE_MODE_ENCODING;
            const hasEncodingHint = hints !== null && undefined !== hints.get(EncodeHintType$1.CHARACTER_SET);
            if (hasEncodingHint) {
                encoding = hints.get(EncodeHintType$1.CHARACTER_SET).toString();
            }
            // Pick an encoding mode appropriate for the content. Note that this will not attempt to use
            // multiple modes / segments even if that were more efficient. Twould be nice.
            const mode = this.chooseMode(content, encoding);
            // This will store the header information, like mode and
            // length, as well as "header" segments like an ECI segment.
            const headerBits = new BitArray();
            // Append ECI segment if applicable
            if (mode === Mode$1.BYTE && (hasEncodingHint || Encoder.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {
                const eci = CharacterSetECI.getCharacterSetECIByName(encoding);
                if (eci !== undefined) {
                    this.appendECI(eci, headerBits);
                }
            }
            // (With ECI in place,) Write the mode marker
            this.appendModeInfo(mode, headerBits);
            // Collect data within the main segment, separately, to count its size if needed. Don't add it to
            // main payload yet.
            const dataBits = new BitArray();
            this.appendBytes(content, mode, dataBits, encoding);
            let version;
            if (hints !== null && undefined !== hints.get(EncodeHintType$1.QR_VERSION)) {
                const versionNumber = Number.parseInt(hints.get(EncodeHintType$1.QR_VERSION).toString(), 10);
                version = Version$1.getVersionForNumber(versionNumber);
                const bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);
                if (!this.willFit(bitsNeeded, version, ecLevel)) {
                    throw new WriterException('Data too big for requested version');
                }
            }
            else {
                version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);
            }
            const headerAndDataBits = new BitArray();
            headerAndDataBits.appendBitArray(headerBits);
            // Find "length" of main segment and write it
            const numLetters = mode === Mode$1.BYTE ? dataBits.getSizeInBytes() : content.length;
            this.appendLengthInfo(numLetters, version, mode, headerAndDataBits);
            // Put data together into the overall payload
            headerAndDataBits.appendBitArray(dataBits);
            const ecBlocks = version.getECBlocksForLevel(ecLevel);
            const numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords();
            // Terminate the bits properly.
            this.terminateBits(numDataBytes, headerAndDataBits);
            // Interleave data bits with error correction code.
            const finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());
            const qrCode = new QRCode();
            qrCode.setECLevel(ecLevel);
            qrCode.setMode(mode);
            qrCode.setVersion(version);
            //  Choose the mask pattern and set to "qrCode".
            const dimension = version.getDimensionForVersion();
            const matrix = new ByteMatrix(dimension, dimension);
            const maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);
            qrCode.setMaskPattern(maskPattern);
            // Build the matrix and set it to "qrCode".
            MatrixUtil.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);
            qrCode.setMatrix(matrix);
            return qrCode;
        }
        /**
         * Decides the smallest version of QR code that will contain all of the provided data.
         *
         * @throws WriterException if the data cannot fit in any version
         */
        static recommendVersion(ecLevel, mode, headerBits, dataBits) {
            // Hard part: need to know version to know how many bits length takes. But need to know how many
            // bits it takes to know version. First we take a guess at version by assuming version will be
            // the minimum, 1:
            const provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version$1.getVersionForNumber(1));
            const provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);
            // Use that guess to calculate the right version. I am still not sure this works in 100% of cases.
            const bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);
            return this.chooseVersion(bitsNeeded, ecLevel);
        }
        static calculateBitsNeeded(mode, headerBits, dataBits, version) {
            return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();
        }
        /**
         * @return the code point of the table used in alphanumeric mode or
         *  -1 if there is no corresponding code in the table.
         */
        static getAlphanumericCode(code /*int*/) {
            if (code < Encoder.ALPHANUMERIC_TABLE.length) {
                return Encoder.ALPHANUMERIC_TABLE[code];
            }
            return -1;
        }
        // public static chooseMode(content: string): Mode {
        //   return chooseMode(content, null);
        // }
        /**
         * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;
         * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.
         */
        static chooseMode(content, encoding = null) {
            if (CharacterSetECI.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {
                // Choose Kanji mode if all input are double-byte characters
                return Mode$1.KANJI;
            }
            let hasNumeric = false;
            let hasAlphanumeric = false;
            for (let i = 0, length = content.length; i < length; ++i) {
                const c = content.charAt(i);
                if (Encoder.isDigit(c)) {
                    hasNumeric = true;
                }
                else if (this.getAlphanumericCode(c.charCodeAt(0)) !== -1) {
                    hasAlphanumeric = true;
                }
                else {
                    return Mode$1.BYTE;
                }
            }
            if (hasAlphanumeric) {
                return Mode$1.ALPHANUMERIC;
            }
            if (hasNumeric) {
                return Mode$1.NUMERIC;
            }
            return Mode$1.BYTE;
        }
        static isOnlyDoubleByteKanji(content) {
            let bytes;
            try {
                bytes = StringEncoding.encode(content, CharacterSetECI.SJIS); // content.getBytes("Shift_JIS"))
            }
            catch (ignored /*: UnsupportedEncodingException*/) {
                return false;
            }
            const length = bytes.length;
            if (length % 2 !== 0) {
                return false;
            }
            for (let i = 0; i < length; i += 2) {
                const byte1 = bytes[i] & 0xFF;
                if ((byte1 < 0x81 || byte1 > 0x9F) && (byte1 < 0xE0 || byte1 > 0xEB)) {
                    return false;
                }
            }
            return true;
        }
        static chooseMaskPattern(bits, ecLevel, version, matrix) {
            let minPenalty = Number.MAX_SAFE_INTEGER; // Lower penalty is better.
            let bestMaskPattern = -1;
            // We try all mask patterns to choose the best one.
            for (let maskPattern = 0; maskPattern < QRCode.NUM_MASK_PATTERNS; maskPattern++) {
                MatrixUtil.buildMatrix(bits, ecLevel, version, maskPattern, matrix);
                let penalty = this.calculateMaskPenalty(matrix);
                if (penalty < minPenalty) {
                    minPenalty = penalty;
                    bestMaskPattern = maskPattern;
                }
            }
            return bestMaskPattern;
        }
        static chooseVersion(numInputBits /*int*/, ecLevel) {
            for (let versionNum = 1; versionNum <= 40; versionNum++) {
                const version = Version$1.getVersionForNumber(versionNum);
                if (Encoder.willFit(numInputBits, version, ecLevel)) {
                    return version;
                }
            }
            throw new WriterException('Data too big');
        }
        /**
         * @return true if the number of input bits will fit in a code with the specified version and
         * error correction level.
         */
        static willFit(numInputBits /*int*/, version, ecLevel) {
            // In the following comments, we use numbers of Version 7-H.
            // numBytes = 196
            const numBytes = version.getTotalCodewords();
            // getNumECBytes = 130
            const ecBlocks = version.getECBlocksForLevel(ecLevel);
            const numEcBytes = ecBlocks.getTotalECCodewords();
            // getNumDataBytes = 196 - 130 = 66
            const numDataBytes = numBytes - numEcBytes;
            const totalInputBytes = (numInputBits + 7) / 8;
            return numDataBytes >= totalInputBytes;
        }
        /**
         * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).
         */
        static terminateBits(numDataBytes /*int*/, bits) {
            const capacity = numDataBytes * 8;
            if (bits.getSize() > capacity) {
                throw new WriterException('data bits cannot fit in the QR Code' + bits.getSize() + ' > ' +
                    capacity);
            }
            for (let i = 0; i < 4 && bits.getSize() < capacity; ++i) {
                bits.appendBit(false);
            }
            // Append termination bits. See 8.4.8 of JISX0510:2004 (p.24) for details.
            // If the last byte isn't 8-bit aligned, we'll add padding bits.
            const numBitsInLastByte = bits.getSize() & 0x07;
            if (numBitsInLastByte > 0) {
                for (let i = numBitsInLastByte; i < 8; i++) {
                    bits.appendBit(false);
                }
            }
            // If we have more space, we'll fill the space with padding patterns defined in 8.4.9 (p.24).
            const numPaddingBytes = numDataBytes - bits.getSizeInBytes();
            for (let i = 0; i < numPaddingBytes; ++i) {
                bits.appendBits((i & 0x01) === 0 ? 0xEC : 0x11, 8);
            }
            if (bits.getSize() !== capacity) {
                throw new WriterException('Bits size does not equal capacity');
            }
        }
        /**
         * Get number of data bytes and number of error correction bytes for block id "blockID". Store
         * the result in "numDataBytesInBlock", and "numECBytesInBlock". See table 12 in 8.5.1 of
         * JISX0510:2004 (p.30)
         */
        static getNumDataBytesAndNumECBytesForBlockID(numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/, blockID /*int*/, numDataBytesInBlock, numECBytesInBlock) {
            if (blockID >= numRSBlocks) {
                throw new WriterException('Block ID too large');
            }
            // numRsBlocksInGroup2 = 196 % 5 = 1
            const numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;
            // numRsBlocksInGroup1 = 5 - 1 = 4
            const numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;
            // numTotalBytesInGroup1 = 196 / 5 = 39
            const numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);
            // numTotalBytesInGroup2 = 39 + 1 = 40
            const numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;
            // numDataBytesInGroup1 = 66 / 5 = 13
            const numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);
            // numDataBytesInGroup2 = 13 + 1 = 14
            const numDataBytesInGroup2 = numDataBytesInGroup1 + 1;
            // numEcBytesInGroup1 = 39 - 13 = 26
            const numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;
            // numEcBytesInGroup2 = 40 - 14 = 26
            const numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;
            // Sanity checks.
            // 26 = 26
            if (numEcBytesInGroup1 !== numEcBytesInGroup2) {
                throw new WriterException('EC bytes mismatch');
            }
            // 5 = 4 + 1.
            if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {
                throw new WriterException('RS blocks mismatch');
            }
            // 196 = (13 + 26) * 4 + (14 + 26) * 1
            if (numTotalBytes !==
                ((numDataBytesInGroup1 + numEcBytesInGroup1) *
                    numRsBlocksInGroup1) +
                ((numDataBytesInGroup2 + numEcBytesInGroup2) *
                    numRsBlocksInGroup2)) {
                throw new WriterException('Total bytes mismatch');
            }
            if (blockID < numRsBlocksInGroup1) {
                numDataBytesInBlock[0] = numDataBytesInGroup1;
                numECBytesInBlock[0] = numEcBytesInGroup1;
            }
            else {
                numDataBytesInBlock[0] = numDataBytesInGroup2;
                numECBytesInBlock[0] = numEcBytesInGroup2;
            }
        }
        /**
         * Interleave "bits" with corresponding error correction bytes. On success, store the result in
         * "result". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.
         */
        static interleaveWithECBytes(bits, numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/) {
            // "bits" must have "getNumDataBytes" bytes of data.
            if (bits.getSizeInBytes() !== numDataBytes) {
                throw new WriterException('Number of bits and data bytes does not match');
            }
            // Step 1.  Divide data bytes into blocks and generate error correction bytes for them. We'll
            // store the divided data bytes blocks and error correction bytes blocks into "blocks".
            let dataBytesOffset = 0;
            let maxNumDataBytes = 0;
            let maxNumEcBytes = 0;
            // Since, we know the number of reedsolmon blocks, we can initialize the vector with the number.
            const blocks = new Array(); // new Array<BlockPair>(numRSBlocks)
            for (let i = 0; i < numRSBlocks; ++i) {
                const numDataBytesInBlock = new Int32Array(1);
                const numEcBytesInBlock = new Int32Array(1);
                Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i, numDataBytesInBlock, numEcBytesInBlock);
                const size = numDataBytesInBlock[0];
                const dataBytes = new Uint8Array(size);
                bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);
                const ecBytes = Encoder.generateECBytes(dataBytes, numEcBytesInBlock[0]);
                blocks.push(new BlockPair(dataBytes, ecBytes));
                maxNumDataBytes = Math.max(maxNumDataBytes, size);
                maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);
                dataBytesOffset += numDataBytesInBlock[0];
            }
            if (numDataBytes !== dataBytesOffset) {
                throw new WriterException('Data bytes does not match offset');
            }
            const result = new BitArray();
            // First, place data blocks.
            for (let i = 0; i < maxNumDataBytes; ++i) {
                for (const block of blocks) {
                    const dataBytes = block.getDataBytes();
                    if (i < dataBytes.length) {
                        result.appendBits(dataBytes[i], 8);
                    }
                }
            }
            // Then, place error correction blocks.
            for (let i = 0; i < maxNumEcBytes; ++i) {
                for (const block of blocks) {
                    const ecBytes = block.getErrorCorrectionBytes();
                    if (i < ecBytes.length) {
                        result.appendBits(ecBytes[i], 8);
                    }
                }
            }
            if (numTotalBytes !== result.getSizeInBytes()) { // Should be same.
                throw new WriterException('Interleaving error: ' + numTotalBytes + ' and ' +
                    result.getSizeInBytes() + ' differ.');
            }
            return result;
        }
        static generateECBytes(dataBytes, numEcBytesInBlock /*int*/) {
            const numDataBytes = dataBytes.length;
            const toEncode = new Int32Array(numDataBytes + numEcBytesInBlock); // int[numDataBytes + numEcBytesInBlock]
            for (let i = 0; i < numDataBytes; i++) {
                toEncode[i] = dataBytes[i] & 0xFF;
            }
            new ReedSolomonEncoder(GenericGF.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);
            const ecBytes = new Uint8Array(numEcBytesInBlock);
            for (let i = 0; i < numEcBytesInBlock; i++) {
                ecBytes[i] = /*(byte) */ toEncode[numDataBytes + i];
            }
            return ecBytes;
        }
        /**
         * Append mode info. On success, store the result in "bits".
         */
        static appendModeInfo(mode, bits) {
            bits.appendBits(mode.getBits(), 4);
        }
        /**
         * Append length info. On success, store the result in "bits".
         */
        static appendLengthInfo(numLetters /*int*/, version, mode, bits) {
            const numBits = mode.getCharacterCountBits(version);
            if (numLetters >= (1 << numBits)) {
                throw new WriterException(numLetters + ' is bigger than ' + ((1 << numBits) - 1));
            }
            bits.appendBits(numLetters, numBits);
        }
        /**
         * Append "bytes" in "mode" mode (encoding) into "bits". On success, store the result in "bits".
         */
        static appendBytes(content, mode, bits, encoding) {
            switch (mode) {
                case Mode$1.NUMERIC:
                    Encoder.appendNumericBytes(content, bits);
                    break;
                case Mode$1.ALPHANUMERIC:
                    Encoder.appendAlphanumericBytes(content, bits);
                    break;
                case Mode$1.BYTE:
                    Encoder.append8BitBytes(content, bits, encoding);
                    break;
                case Mode$1.KANJI:
                    Encoder.appendKanjiBytes(content, bits);
                    break;
                default:
                    throw new WriterException('Invalid mode: ' + mode);
            }
        }
        static getDigit(singleCharacter) {
            return singleCharacter.charCodeAt(0) - 48;
        }
        static isDigit(singleCharacter) {
            const cn = Encoder.getDigit(singleCharacter);
            return cn >= 0 && cn <= 9;
        }
        static appendNumericBytes(content, bits) {
            const length = content.length;
            let i = 0;
            while (i < length) {
                const num1 = Encoder.getDigit(content.charAt(i));
                if (i + 2 < length) {
                    // Encode three numeric letters in ten bits.
                    const num2 = Encoder.getDigit(content.charAt(i + 1));
                    const num3 = Encoder.getDigit(content.charAt(i + 2));
                    bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);
                    i += 3;
                }
                else if (i + 1 < length) {
                    // Encode two numeric letters in seven bits.
                    const num2 = Encoder.getDigit(content.charAt(i + 1));
                    bits.appendBits(num1 * 10 + num2, 7);
                    i += 2;
                }
                else {
                    // Encode one numeric letter in four bits.
                    bits.appendBits(num1, 4);
                    i++;
                }
            }
        }
        static appendAlphanumericBytes(content, bits) {
            const length = content.length;
            let i = 0;
            while (i < length) {
                const code1 = Encoder.getAlphanumericCode(content.charCodeAt(i));
                if (code1 === -1) {
                    throw new WriterException();
                }
                if (i + 1 < length) {
                    const code2 = Encoder.getAlphanumericCode(content.charCodeAt(i + 1));
                    if (code2 === -1) {
                        throw new WriterException();
                    }
                    // Encode two alphanumeric letters in 11 bits.
                    bits.appendBits(code1 * 45 + code2, 11);
                    i += 2;
                }
                else {
                    // Encode one alphanumeric letter in six bits.
                    bits.appendBits(code1, 6);
                    i++;
                }
            }
        }
        static append8BitBytes(content, bits, encoding) {
            let bytes;
            try {
                bytes = StringEncoding.encode(content, encoding);
            }
            catch (uee /*: UnsupportedEncodingException*/) {
                throw new WriterException(uee);
            }
            for (let i = 0, length = bytes.length; i !== length; i++) {
                const b = bytes[i];
                bits.appendBits(b, 8);
            }
        }
        /**
         * @throws WriterException
         */
        static appendKanjiBytes(content, bits) {
            let bytes;
            try {
                bytes = StringEncoding.encode(content, CharacterSetECI.SJIS);
            }
            catch (uee /*: UnsupportedEncodingException*/) {
                throw new WriterException(uee);
            }
            const length = bytes.length;
            for (let i = 0; i < length; i += 2) {
                const byte1 = bytes[i] & 0xFF;
                const byte2 = bytes[i + 1] & 0xFF;
                const code = ((byte1 << 8) & 0xFFFFFFFF) | byte2;
                let subtracted = -1;
                if (code >= 0x8140 && code <= 0x9ffc) {
                    subtracted = code - 0x8140;
                }
                else if (code >= 0xe040 && code <= 0xebbf) {
                    subtracted = code - 0xc140;
                }
                if (subtracted === -1) {
                    throw new WriterException('Invalid byte sequence');
                }
                const encoded = ((subtracted >> 8) * 0xc0) + (subtracted & 0xff);
                bits.appendBits(encoded, 13);
            }
        }
        static appendECI(eci, bits) {
            bits.appendBits(Mode$1.ECI.getBits(), 4);
            // This is correct for values up to 127, which is all we need now.
            bits.appendBits(eci.getValue(), 8);
        }
    }
    // The original table is defined in the table 5 of JISX0510:2004 (p.19).
    Encoder.ALPHANUMERIC_TABLE = Int32Array.from([
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43,
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1,
        -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,
    ]);
    Encoder.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI.UTF8.getName(); // "ISO-8859-1"

    /**
     * @deprecated Moving to @zxing/browser
     */
    class BrowserQRCodeSvgWriter {
        /**
         * Writes and renders a QRCode SVG element.
         *
         * @param contents
         * @param width
         * @param height
         * @param hints
         */
        write(contents, width, height, hints = null) {
            if (contents.length === 0) {
                throw new IllegalArgumentException('Found empty contents');
            }
            // if (format != BarcodeFormat.QR_CODE) {
            //   throw new IllegalArgumentException("Can only encode QR_CODE, but got " + format)
            // }
            if (width < 0 || height < 0) {
                throw new IllegalArgumentException('Requested dimensions are too small: ' + width + 'x' + height);
            }
            let errorCorrectionLevel = ErrorCorrectionLevel.L;
            let quietZone = BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE;
            if (hints !== null) {
                if (undefined !== hints.get(EncodeHintType$1.ERROR_CORRECTION)) {
                    errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
                }
                if (undefined !== hints.get(EncodeHintType$1.MARGIN)) {
                    quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);
                }
            }
            const code = Encoder.encode(contents, errorCorrectionLevel, hints);
            return this.renderResult(code, width, height, quietZone);
        }
        /**
         * Renders the result and then appends it to the DOM.
         */
        writeToDom(containerElement, contents, width, height, hints = null) {
            if (typeof containerElement === 'string') {
                containerElement = document.querySelector(containerElement);
            }
            const svgElement = this.write(contents, width, height, hints);
            if (containerElement)
                containerElement.appendChild(svgElement);
        }
        /**
         * Note that the input matrix uses 0 == white, 1 == black.
         * The output matrix uses 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).
         */
        renderResult(code, width /*int*/, height /*int*/, quietZone /*int*/) {
            const input = code.getMatrix();
            if (input === null) {
                throw new IllegalStateException();
            }
            const inputWidth = input.getWidth();
            const inputHeight = input.getHeight();
            const qrWidth = inputWidth + (quietZone * 2);
            const qrHeight = inputHeight + (quietZone * 2);
            const outputWidth = Math.max(width, qrWidth);
            const outputHeight = Math.max(height, qrHeight);
            const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
            // Padding includes both the quiet zone and the extra white pixels to accommodate the requested
            // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.
            // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will
            // handle all the padding from 100x100 (the actual QR) up to 200x160.
            const leftPadding = Math.floor((outputWidth - (inputWidth * multiple)) / 2);
            const topPadding = Math.floor((outputHeight - (inputHeight * multiple)) / 2);
            const svgElement = this.createSVGElement(outputWidth, outputHeight);
            for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
                // Write the contents of this row of the barcode
                for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
                    if (input.get(inputX, inputY) === 1) {
                        const svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);
                        svgElement.appendChild(svgRectElement);
                    }
                }
            }
            return svgElement;
        }
        /**
         * Creates a SVG element.
         *
         * @param w SVG's width attribute
         * @param h SVG's height attribute
         */
        createSVGElement(w, h) {
            const svgElement = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, 'svg');
            svgElement.setAttributeNS(null, 'height', w.toString());
            svgElement.setAttributeNS(null, 'width', h.toString());
            return svgElement;
        }
        /**
         * Creates a SVG rect element.
         *
         * @param x Element's x coordinate
         * @param y Element's y coordinate
         * @param w Element's width attribute
         * @param h Element's height attribute
         */
        createSvgRectElement(x, y, w, h) {
            const rect = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, 'rect');
            rect.setAttributeNS(null, 'x', x.toString());
            rect.setAttributeNS(null, 'y', y.toString());
            rect.setAttributeNS(null, 'height', w.toString());
            rect.setAttributeNS(null, 'width', h.toString());
            rect.setAttributeNS(null, 'fill', '#000000');
            return rect;
        }
    }
    BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE = 4;
    /**
     * SVG markup NameSpace
     */
    BrowserQRCodeSvgWriter.SVG_NS = 'http://www.w3.org/2000/svg';

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*import java.util.Map;*/
    /**
     * This object renders a QR Code as a BitMatrix 2D array of greyscale values.
     *
     * @author dswitkin@google.com (Daniel Switkin)
     */
    class QRCodeWriter {
        /*@Override*/
        // public encode(contents: string, format: BarcodeFormat, width: number /*int*/, height: number /*int*/): BitMatrix
        //     /*throws WriterException */ {
        //   return encode(contents, format, width, height, null)
        // }
        /*@Override*/
        encode(contents, format, width /*int*/, height /*int*/, hints) {
            if (contents.length === 0) {
                throw new IllegalArgumentException('Found empty contents');
            }
            if (format !== BarcodeFormat$1.QR_CODE) {
                throw new IllegalArgumentException('Can only encode QR_CODE, but got ' + format);
            }
            if (width < 0 || height < 0) {
                throw new IllegalArgumentException(`Requested dimensions are too small: ${width}x${height}`);
            }
            let errorCorrectionLevel = ErrorCorrectionLevel.L;
            let quietZone = QRCodeWriter.QUIET_ZONE_SIZE;
            if (hints !== null) {
                if (undefined !== hints.get(EncodeHintType$1.ERROR_CORRECTION)) {
                    errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
                }
                if (undefined !== hints.get(EncodeHintType$1.MARGIN)) {
                    quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);
                }
            }
            const code = Encoder.encode(contents, errorCorrectionLevel, hints);
            return QRCodeWriter.renderResult(code, width, height, quietZone);
        }
        // Note that the input matrix uses 0 == white, 1 == black, while the output matrix uses
        // 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).
        static renderResult(code, width /*int*/, height /*int*/, quietZone /*int*/) {
            const input = code.getMatrix();
            if (input === null) {
                throw new IllegalStateException();
            }
            const inputWidth = input.getWidth();
            const inputHeight = input.getHeight();
            const qrWidth = inputWidth + (quietZone * 2);
            const qrHeight = inputHeight + (quietZone * 2);
            const outputWidth = Math.max(width, qrWidth);
            const outputHeight = Math.max(height, qrHeight);
            const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
            // Padding includes both the quiet zone and the extra white pixels to accommodate the requested
            // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.
            // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will
            // handle all the padding from 100x100 (the actual QR) up to 200x160.
            const leftPadding = Math.floor((outputWidth - (inputWidth * multiple)) / 2);
            const topPadding = Math.floor((outputHeight - (inputHeight * multiple)) / 2);
            const output = new BitMatrix(outputWidth, outputHeight);
            for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
                // Write the contents of this row of the barcode
                for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
                    if (input.get(inputX, inputY) === 1) {
                        output.setRegion(outputX, outputY, multiple, multiple);
                    }
                }
            }
            return output;
        }
    }
    QRCodeWriter.QUIET_ZONE_SIZE = 4;

    /*
     * Copyright 2008 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /*import java.util.Map;*/
    /**
     * This is a factory class which finds the appropriate Writer subclass for the BarcodeFormat
     * requested and encodes the barcode with the supplied contents.
     *
     * @author dswitkin@google.com (Daniel Switkin)
     */
    class MultiFormatWriter {
        /*@Override*/
        // public encode(contents: string,
        //                         format: BarcodeFormat,
        //                         width: number /*int*/,
        //                         height: number /*int*/): BitMatrix /*throws WriterException */ {
        //   return encode(contents, format, width, height, null)
        // }
        /*@Override*/
        encode(contents, format, width /*int*/, height /*int*/, hints) {
            let writer;
            switch (format) {
                // case BarcodeFormat.EAN_8:
                //   writer = new EAN8Writer()
                //   break
                // case BarcodeFormat.UPC_E:
                //   writer = new UPCEWriter()
                //   break
                // case BarcodeFormat.EAN_13:
                //   writer = new EAN13Writer()
                //   break
                // case BarcodeFormat.UPC_A:
                //   writer = new UPCAWriter()
                //   break
                case BarcodeFormat$1.QR_CODE:
                    writer = new QRCodeWriter();
                    break;
                // case BarcodeFormat.CODE_39:
                //   writer = new Code39Writer()
                //   break
                // case BarcodeFormat.CODE_93:
                //   writer = new Code93Writer()
                //   break
                // case BarcodeFormat.CODE_128:
                //   writer = new Code128Writer()
                //   break
                // case BarcodeFormat.ITF:
                //   writer = new ITFWriter()
                //   break
                // case BarcodeFormat.PDF_417:
                //   writer = new PDF417Writer()
                //   break
                // case BarcodeFormat.CODABAR:
                //   writer = new CodaBarWriter()
                //   break
                // case BarcodeFormat.DATA_MATRIX:
                //   writer = new DataMatrixWriter()
                //   break
                // case BarcodeFormat.AZTEC:
                //   writer = new AztecWriter()
                //   break
                default:
                    throw new IllegalArgumentException('No encoder available for format ' + format);
            }
            return writer.encode(contents, format, width, height, hints);
        }
    }

    /*
     * Copyright 2009 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * This object extends LuminanceSource around an array of YUV data returned from the camera driver,
     * with the option to crop to a rectangle within the full data. This can be used to exclude
     * superfluous pixels around the perimeter and speed up decoding.
     *
     * It works for any pixel format where the Y channel is planar and appears first, including
     * YCbCr_420_SP and YCbCr_422_SP.
     *
     * @author dswitkin@google.com (Daniel Switkin)
     */
    class PlanarYUVLuminanceSource extends LuminanceSource {
        constructor(yuvData, dataWidth /*int*/, dataHeight /*int*/, left /*int*/, top /*int*/, width /*int*/, height /*int*/, reverseHorizontal) {
            super(width, height);
            this.yuvData = yuvData;
            this.dataWidth = dataWidth;
            this.dataHeight = dataHeight;
            this.left = left;
            this.top = top;
            if (left + width > dataWidth || top + height > dataHeight) {
                throw new IllegalArgumentException('Crop rectangle does not fit within image data.');
            }
            if (reverseHorizontal) {
                this.reverseHorizontal(width, height);
            }
        }
        /*@Override*/
        getRow(y /*int*/, row) {
            if (y < 0 || y >= this.getHeight()) {
                throw new IllegalArgumentException('Requested row is outside the image: ' + y);
            }
            const width = this.getWidth();
            if (row === null || row === undefined || row.length < width) {
                row = new Uint8ClampedArray(width);
            }
            const offset = (y + this.top) * this.dataWidth + this.left;
            System.arraycopy(this.yuvData, offset, row, 0, width);
            return row;
        }
        /*@Override*/
        getMatrix() {
            const width = this.getWidth();
            const height = this.getHeight();
            // If the caller asks for the entire underlying image, save the copy and give them the
            // original data. The docs specifically warn that result.length must be ignored.
            if (width === this.dataWidth && height === this.dataHeight) {
                return this.yuvData;
            }
            const area = width * height;
            const matrix = new Uint8ClampedArray(area);
            let inputOffset = this.top * this.dataWidth + this.left;
            // If the width matches the full width of the underlying data, perform a single copy.
            if (width === this.dataWidth) {
                System.arraycopy(this.yuvData, inputOffset, matrix, 0, area);
                return matrix;
            }
            // Otherwise copy one cropped row at a time.
            for (let y = 0; y < height; y++) {
                const outputOffset = y * width;
                System.arraycopy(this.yuvData, inputOffset, matrix, outputOffset, width);
                inputOffset += this.dataWidth;
            }
            return matrix;
        }
        /*@Override*/
        isCropSupported() {
            return true;
        }
        /*@Override*/
        crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
            return new PlanarYUVLuminanceSource(this.yuvData, this.dataWidth, this.dataHeight, this.left + left, this.top + top, width, height, false);
        }
        renderThumbnail() {
            const width = this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
            const height = this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
            const pixels = new Int32Array(width * height);
            const yuv = this.yuvData;
            let inputOffset = this.top * this.dataWidth + this.left;
            for (let y = 0; y < height; y++) {
                const outputOffset = y * width;
                for (let x = 0; x < width; x++) {
                    const grey = yuv[inputOffset + x * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR] & 0xff;
                    pixels[outputOffset + x] = 0xFF000000 | (grey * 0x00010101);
                }
                inputOffset += this.dataWidth * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
            }
            return pixels;
        }
        /**
         * @return width of image from {@link #renderThumbnail()}
         */
        getThumbnailWidth() {
            return this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
        }
        /**
         * @return height of image from {@link #renderThumbnail()}
         */
        getThumbnailHeight() {
            return this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
        }
        reverseHorizontal(width /*int*/, height /*int*/) {
            const yuvData = this.yuvData;
            for (let y = 0, rowStart = this.top * this.dataWidth + this.left; y < height; y++, rowStart += this.dataWidth) {
                const middle = rowStart + width / 2;
                for (let x1 = rowStart, x2 = rowStart + width - 1; x1 < middle; x1++, x2--) {
                    const temp = yuvData[x1];
                    yuvData[x1] = yuvData[x2];
                    yuvData[x2] = temp;
                }
            }
        }
        invert() {
            return new InvertedLuminanceSource(this);
        }
    }
    PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR = 2;

    /*
     * Copyright 2009 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * This class is used to help decode images from files which arrive as RGB data from
     * an ARGB pixel array. It does not support rotation.
     *
     * @author dswitkin@google.com (Daniel Switkin)
     * @author Betaminos
     */
    class RGBLuminanceSource extends LuminanceSource {
        constructor(luminances, width /*int*/, height /*int*/, dataWidth /*int*/, dataHeight /*int*/, left /*int*/, top /*int*/) {
            super(width, height);
            this.dataWidth = dataWidth;
            this.dataHeight = dataHeight;
            this.left = left;
            this.top = top;
            if (luminances.BYTES_PER_ELEMENT === 4) { // Int32Array
                const size = width * height;
                const luminancesUint8Array = new Uint8ClampedArray(size);
                for (let offset = 0; offset < size; offset++) {
                    const pixel = luminances[offset];
                    const r = (pixel >> 16) & 0xff; // red
                    const g2 = (pixel >> 7) & 0x1fe; // 2 * green
                    const b = pixel & 0xff; // blue
                    // Calculate green-favouring average cheaply
                    luminancesUint8Array[offset] = /*(byte) */ ((r + g2 + b) / 4) & 0xFF;
                }
                this.luminances = luminancesUint8Array;
            }
            else {
                this.luminances = luminances;
            }
            if (undefined === dataWidth) {
                this.dataWidth = width;
            }
            if (undefined === dataHeight) {
                this.dataHeight = height;
            }
            if (undefined === left) {
                this.left = 0;
            }
            if (undefined === top) {
                this.top = 0;
            }
            if (this.left + width > this.dataWidth || this.top + height > this.dataHeight) {
                throw new IllegalArgumentException('Crop rectangle does not fit within image data.');
            }
        }
        /*@Override*/
        getRow(y /*int*/, row) {
            if (y < 0 || y >= this.getHeight()) {
                throw new IllegalArgumentException('Requested row is outside the image: ' + y);
            }
            const width = this.getWidth();
            if (row === null || row === undefined || row.length < width) {
                row = new Uint8ClampedArray(width);
            }
            const offset = (y + this.top) * this.dataWidth + this.left;
            System.arraycopy(this.luminances, offset, row, 0, width);
            return row;
        }
        /*@Override*/
        getMatrix() {
            const width = this.getWidth();
            const height = this.getHeight();
            // If the caller asks for the entire underlying image, save the copy and give them the
            // original data. The docs specifically warn that result.length must be ignored.
            if (width === this.dataWidth && height === this.dataHeight) {
                return this.luminances;
            }
            const area = width * height;
            const matrix = new Uint8ClampedArray(area);
            let inputOffset = this.top * this.dataWidth + this.left;
            // If the width matches the full width of the underlying data, perform a single copy.
            if (width === this.dataWidth) {
                System.arraycopy(this.luminances, inputOffset, matrix, 0, area);
                return matrix;
            }
            // Otherwise copy one cropped row at a time.
            for (let y = 0; y < height; y++) {
                const outputOffset = y * width;
                System.arraycopy(this.luminances, inputOffset, matrix, outputOffset, width);
                inputOffset += this.dataWidth;
            }
            return matrix;
        }
        /*@Override*/
        isCropSupported() {
            return true;
        }
        /*@Override*/
        crop(left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
            return new RGBLuminanceSource(this.luminances, width, height, this.dataWidth, this.dataHeight, this.left + left, this.top + top);
        }
        invert() {
            return new InvertedLuminanceSource(this);
        }
    }

    /**
     * Just to make a shortcut between Java code and TS code.
     */
    class Charset extends CharacterSetECI {
        static forName(name) {
            return this.getCharacterSetECIByName(name);
        }
    }

    /**
     * Just to make a shortcut between Java code and TS code.
     */
    class StandardCharsets {
    }
    StandardCharsets.ISO_8859_1 = CharacterSetECI.ISO8859_1;

    /*
    * Copyright 2013 ZXing authors
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    /**
     * Aztec 2D code representation
     *
     * @author Rustam Abdullaev
     */
    /*public final*/ class AztecCode {
        /**
         * @return {@code true} if compact instead of full mode
         */
        isCompact() {
            return this.compact;
        }
        setCompact(compact) {
            this.compact = compact;
        }
        /**
         * @return size in pixels (width and height)
         */
        getSize() {
            return this.size;
        }
        setSize(size) {
            this.size = size;
        }
        /**
         * @return number of levels
         */
        getLayers() {
            return this.layers;
        }
        setLayers(layers) {
            this.layers = layers;
        }
        /**
         * @return number of data codewords
         */
        getCodeWords() {
            return this.codeWords;
        }
        setCodeWords(codeWords) {
            this.codeWords = codeWords;
        }
        /**
         * @return the symbol image
         */
        getMatrix() {
            return this.matrix;
        }
        setMatrix(matrix) {
            this.matrix = matrix;
        }
    }

    class Collections {
        /**
         * The singletonList(T) method is used to return an immutable list containing only the specified object.
         */
        static singletonList(item) {
            return [item];
        }
        /**
         * The min(Collection<? extends T>, Comparator<? super T>) method is used to return the minimum element of the given collection, according to the order induced by the specified comparator.
         */
        static min(collection, comparator) {
            return collection.sort(comparator)[0];
        }
    }

    /*
    * Copyright 2013 ZXing authors
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    class Token {
        constructor(previous) {
            this.previous = previous;
        }
        getPrevious() {
            return this.previous;
        }
    }

    /*
    * Copyright 2013 ZXing authors
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    /*final*/ class SimpleToken extends Token {
        constructor(previous, value, bitCount) {
            super(previous);
            this.value = value;
            this.bitCount = bitCount;
        }
        /**
         * @Override
         */
        appendTo(bitArray, text) {
            bitArray.appendBits(this.value, this.bitCount);
        }
        add(value, bitCount) {
            return new SimpleToken(this, value, bitCount);
        }
        addBinaryShift(start, byteCount) {
            // no-op can't binary shift a simple token
            console.warn('addBinaryShift on SimpleToken, this simply returns a copy of this token');
            return new SimpleToken(this, start, byteCount);
        }
        /**
         * @Override
         */
        toString() {
            let value = this.value & ((1 << this.bitCount) - 1);
            value |= 1 << this.bitCount;
            return '<' + Integer.toBinaryString(value | (1 << this.bitCount)).substring(1) + '>';
        }
    }

    /*
    * Copyright 2013 ZXing authors
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    /*final*/ class BinaryShiftToken extends SimpleToken {
        constructor(previous, binaryShiftStart, binaryShiftByteCount) {
            super(previous, 0, 0);
            this.binaryShiftStart = binaryShiftStart;
            this.binaryShiftByteCount = binaryShiftByteCount;
        }
        /**
         * @Override
         */
        appendTo(bitArray, text) {
            for (let i = 0; i < this.binaryShiftByteCount; i++) {
                if (i === 0 || (i === 31 && this.binaryShiftByteCount <= 62)) {
                    // We need a header before the first character, and before
                    // character 31 when the total byte code is <= 62
                    bitArray.appendBits(31, 5); // BINARY_SHIFT
                    if (this.binaryShiftByteCount > 62) {
                        bitArray.appendBits(this.binaryShiftByteCount - 31, 16);
                    }
                    else if (i === 0) {
                        // 1 <= binaryShiftByteCode <= 62
                        bitArray.appendBits(Math.min(this.binaryShiftByteCount, 31), 5);
                    }
                    else {
                        // 32 <= binaryShiftCount <= 62 and i == 31
                        bitArray.appendBits(this.binaryShiftByteCount - 31, 5);
                    }
                }
                bitArray.appendBits(text[this.binaryShiftStart + i], 8);
            }
        }
        addBinaryShift(start, byteCount) {
            // int bitCount = (byteCount * 8) + (byteCount <= 31 ? 10 : byteCount <= 62 ? 20 : 21);
            return new BinaryShiftToken(this, start, byteCount);
        }
        /**
         * @Override
         */
        toString() {
            return '<' + this.binaryShiftStart + '::' + (this.binaryShiftStart + this.binaryShiftByteCount - 1) + '>';
        }
    }

    function addBinaryShift(token, start, byteCount) {
        // int bitCount = (byteCount * 8) + (byteCount <= 31 ? 10 : byteCount <= 62 ? 20 : 21);
        return new BinaryShiftToken(token, start, byteCount);
    }
    function add(token, value, bitCount) {
        return new SimpleToken(token, value, bitCount);
    }

    const /*final*/ MODE_NAMES = [
        'UPPER',
        'LOWER',
        'DIGIT',
        'MIXED',
        'PUNCT'
    ];
    const /*final*/ MODE_UPPER = 0; // 5 bits
    const /*final*/ MODE_LOWER = 1; // 5 bits
    const /*final*/ MODE_DIGIT = 2; // 4 bits
    const /*final*/ MODE_MIXED = 3; // 5 bits
    const /*final*/ MODE_PUNCT = 4; // 5 bits
    const EMPTY_TOKEN = new SimpleToken(null, 0, 0);

    // The Latch Table shows, for each pair of Modes, the optimal method for
    // getting from one mode to another.  In the worst possible case, this can
    // be up to 14 bits.  In the best possible case, we are already there!
    // The high half-word of each entry gives the number of bits.
    // The low half-word of each entry are the actual bits necessary to change
    const LATCH_TABLE = [
        Int32Array.from([
            0,
            (5 << 16) + 28,
            (5 << 16) + 30,
            (5 << 16) + 29,
            (10 << 16) + (29 << 5) + 30 // UPPER -> MIXED -> PUNCT
        ]),
        Int32Array.from([
            (9 << 16) + (30 << 4) + 14,
            0,
            (5 << 16) + 30,
            (5 << 16) + 29,
            (10 << 16) + (29 << 5) + 30 // LOWER -> MIXED -> PUNCT
        ]),
        Int32Array.from([
            (4 << 16) + 14,
            (9 << 16) + (14 << 5) + 28,
            0,
            (9 << 16) + (14 << 5) + 29,
            (14 << 16) + (14 << 10) + (29 << 5) + 30
            // DIGIT -> UPPER -> MIXED -> PUNCT
        ]),
        Int32Array.from([
            (5 << 16) + 29,
            (5 << 16) + 28,
            (10 << 16) + (29 << 5) + 30,
            0,
            (5 << 16) + 30 // MIXED -> PUNCT
        ]),
        Int32Array.from([
            (5 << 16) + 31,
            (10 << 16) + (31 << 5) + 28,
            (10 << 16) + (31 << 5) + 30,
            (10 << 16) + (31 << 5) + 29,
            0
        ])
    ];

    function static_SHIFT_TABLE(SHIFT_TABLE) {
        for (let table /*Int32Array*/ of SHIFT_TABLE) {
            Arrays.fill(table, -1);
        }
        SHIFT_TABLE[MODE_UPPER][MODE_PUNCT] = 0;
        SHIFT_TABLE[MODE_LOWER][MODE_PUNCT] = 0;
        SHIFT_TABLE[MODE_LOWER][MODE_UPPER] = 28;
        SHIFT_TABLE[MODE_MIXED][MODE_PUNCT] = 0;
        SHIFT_TABLE[MODE_DIGIT][MODE_PUNCT] = 0;
        SHIFT_TABLE[MODE_DIGIT][MODE_UPPER] = 15;
        return SHIFT_TABLE;
    }
    const /*final*/ SHIFT_TABLE = static_SHIFT_TABLE(Arrays.createInt32Array(6, 6)); // mode shift codes, per table

    /*
     * Copyright 2013 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * State represents all information about a sequence necessary to generate the current output.
     * Note that a state is immutable.
     */
    /*final*/ class State {
        constructor(token, mode, binaryBytes, bitCount) {
            this.token = token;
            this.mode = mode;
            this.binaryShiftByteCount = binaryBytes;
            this.bitCount = bitCount;
            // Make sure we match the token
            // int binaryShiftBitCount = (binaryShiftByteCount * 8) +
            //    (binaryShiftByteCount === 0 ? 0 :
            //     binaryShiftByteCount <= 31 ? 10 :
            //     binaryShiftByteCount <= 62 ? 20 : 21);
            // assert this.bitCount === token.getTotalBitCount() + binaryShiftBitCount;
        }
        getMode() {
            return this.mode;
        }
        getToken() {
            return this.token;
        }
        getBinaryShiftByteCount() {
            return this.binaryShiftByteCount;
        }
        getBitCount() {
            return this.bitCount;
        }
        // Create a new state representing this state with a latch to a (not
        // necessary different) mode, and then a code.
        latchAndAppend(mode, value) {
            // assert binaryShiftByteCount === 0;
            let bitCount = this.bitCount;
            let token = this.token;
            if (mode !== this.mode) {
                let latch = LATCH_TABLE[this.mode][mode];
                token = add(token, latch & 0xffff, latch >> 16);
                bitCount += latch >> 16;
            }
            let latchModeBitCount = mode === MODE_DIGIT ? 4 : 5;
            token = add(token, value, latchModeBitCount);
            return new State(token, mode, 0, bitCount + latchModeBitCount);
        }
        // Create a new state representing this state, with a temporary shift
        // to a different mode to output a single value.
        shiftAndAppend(mode, value) {
            // assert binaryShiftByteCount === 0 && this.mode !== mode;
            let token = this.token;
            let thisModeBitCount = this.mode === MODE_DIGIT ? 4 : 5;
            // Shifts exist only to UPPER and PUNCT, both with tokens size 5.
            token = add(token, SHIFT_TABLE[this.mode][mode], thisModeBitCount);
            token = add(token, value, 5);
            return new State(token, this.mode, 0, this.bitCount + thisModeBitCount + 5);
        }
        // Create a new state representing this state, but an additional character
        // output in Binary Shift mode.
        addBinaryShiftChar(index) {
            let token = this.token;
            let mode = this.mode;
            let bitCount = this.bitCount;
            if (this.mode === MODE_PUNCT || this.mode === MODE_DIGIT) {
                // assert binaryShiftByteCount === 0;
                let latch = LATCH_TABLE[mode][MODE_UPPER];
                token = add(token, latch & 0xffff, latch >> 16);
                bitCount += latch >> 16;
                mode = MODE_UPPER;
            }
            let deltaBitCount = this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31
                ? 18
                : this.binaryShiftByteCount === 62
                    ? 9
                    : 8;
            let result = new State(token, mode, this.binaryShiftByteCount + 1, bitCount + deltaBitCount);
            if (result.binaryShiftByteCount === 2047 + 31) {
                // The string is as long as it's allowed to be.  We should end it.
                result = result.endBinaryShift(index + 1);
            }
            return result;
        }
        // Create the state identical to this one, but we are no longer in
        // Binary Shift mode.
        endBinaryShift(index) {
            if (this.binaryShiftByteCount === 0) {
                return this;
            }
            let token = this.token;
            token = addBinaryShift(token, index - this.binaryShiftByteCount, this.binaryShiftByteCount);
            // assert token.getTotalBitCount() === this.bitCount;
            return new State(token, this.mode, 0, this.bitCount);
        }
        // Returns true if "this" state is better (equal: or) to be in than "that"
        // state under all possible circumstances.
        isBetterThanOrEqualTo(other) {
            let newModeBitCount = this.bitCount + (LATCH_TABLE[this.mode][other.mode] >> 16);
            if (this.binaryShiftByteCount < other.binaryShiftByteCount) {
                // add additional B/S encoding cost of other, if any
                newModeBitCount +=
                    State.calculateBinaryShiftCost(other) -
                    State.calculateBinaryShiftCost(this);
            }
            else if (this.binaryShiftByteCount > other.binaryShiftByteCount &&
                other.binaryShiftByteCount > 0) {
                // maximum possible additional cost (it: h)
                newModeBitCount += 10;
            }
            return newModeBitCount <= other.bitCount;
        }
        toBitArray(text) {
            // Reverse the tokens, so that they are in the order that they should
            // be output
            let symbols = [];
            for (let token = this.endBinaryShift(text.length).token; token !== null; token = token.getPrevious()) {
                symbols.unshift(token);
            }
            let bitArray = new BitArray();
            // Add each token to the result.
            for (const symbol of symbols) {
                symbol.appendTo(bitArray, text);
            }
            // assert bitArray.getSize() === this.bitCount;
            return bitArray;
        }
        /**
         * @Override
         */
        toString() {
            return StringUtils.format('%s bits=%d bytes=%d', MODE_NAMES[this.mode], this.bitCount, this.binaryShiftByteCount);
        }
        static calculateBinaryShiftCost(state) {
            if (state.binaryShiftByteCount > 62) {
                return 21; // B/S with extended length
            }
            if (state.binaryShiftByteCount > 31) {
                return 20; // two B/S
            }
            if (state.binaryShiftByteCount > 0) {
                return 10; // one B/S
            }
            return 0;
        }
    }
    State.INITIAL_STATE = new State(EMPTY_TOKEN, MODE_UPPER, 0, 0);

    function static_CHAR_MAP(CHAR_MAP) {
        const spaceCharCode = StringUtils.getCharCode(' ');
        const pointCharCode = StringUtils.getCharCode('.');
        const commaCharCode = StringUtils.getCharCode(',');
        CHAR_MAP[MODE_UPPER][spaceCharCode] = 1;
        const zUpperCharCode = StringUtils.getCharCode('Z');
        const aUpperCharCode = StringUtils.getCharCode('A');
        for (let c = aUpperCharCode; c <= zUpperCharCode; c++) {
            CHAR_MAP[MODE_UPPER][c] = c - aUpperCharCode + 2;
        }
        CHAR_MAP[MODE_LOWER][spaceCharCode] = 1;
        const zLowerCharCode = StringUtils.getCharCode('z');
        const aLowerCharCode = StringUtils.getCharCode('a');
        for (let c = aLowerCharCode; c <= zLowerCharCode; c++) {
            CHAR_MAP[MODE_LOWER][c] = c - aLowerCharCode + 2;
        }
        CHAR_MAP[MODE_DIGIT][spaceCharCode] = 1;
        const nineCharCode = StringUtils.getCharCode('9');
        const zeroCharCode = StringUtils.getCharCode('0');
        for (let c = zeroCharCode; c <= nineCharCode; c++) {
            CHAR_MAP[MODE_DIGIT][c] = c - zeroCharCode + 2;
        }
        CHAR_MAP[MODE_DIGIT][commaCharCode] = 12;
        CHAR_MAP[MODE_DIGIT][pointCharCode] = 13;
        const mixedTable = [
            '\x00',
            ' ',
            '\x01',
            '\x02',
            '\x03',
            '\x04',
            '\x05',
            '\x06',
            '\x07',
            '\b',
            '\t',
            '\n',
            '\x0b',
            '\f',
            '\r',
            '\x1b',
            '\x1c',
            '\x1d',
            '\x1e',
            '\x1f',
            '@',
            '\\',
            '^',
            '_',
            '`',
            '|',
            '~',
            '\x7f'
        ];
        for (let i = 0; i < mixedTable.length; i++) {
            CHAR_MAP[MODE_MIXED][StringUtils.getCharCode(mixedTable[i])] = i;
        }
        const punctTable = [
            '\x00',
            '\r',
            '\x00',
            '\x00',
            '\x00',
            '\x00',
            '!',
            '\'',
            '#',
            '$',
            '%',
            '&',
            '\'',
            '(',
            ')',
            '*',
            '+',
            ',',
            '-',
            '.',
            '/',
            ':',
            ';',
            '<',
            '=',
            '>',
            '?',
            '[',
            ']',
            '{',
            '}'
        ];
        for (let i = 0; i < punctTable.length; i++) {
            if (StringUtils.getCharCode(punctTable[i]) > 0) {
                CHAR_MAP[MODE_PUNCT][StringUtils.getCharCode(punctTable[i])] = i;
            }
        }
        return CHAR_MAP;
    }
    const CHAR_MAP = static_CHAR_MAP(Arrays.createInt32Array(5, 256));

    /*
     * Copyright 2013 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * This produces nearly optimal encodings of text into the first-level of
     * encoding used by Aztec code.
     *
     * It uses a dynamic algorithm.  For each prefix of the string, it determines
     * a set of encodings that could lead to this prefix.  We repeatedly add a
     * character and generate a new set of optimal encodings until we have read
     * through the entire input.
     *
     * @author Frank Yellin
     * @author Rustam Abdullaev
     */
    /*public final*/ class HighLevelEncoder {
        constructor(text) {
            this.text = text;
        }
        /**
         * @return text represented by this encoder encoded as a {@link BitArray}
         */
        encode() {
            const spaceCharCode = StringUtils.getCharCode(' ');
            const lineBreakCharCode = StringUtils.getCharCode('\n');
            let states = Collections.singletonList(State.INITIAL_STATE);
            for (let index = 0; index < this.text.length; index++) {
                let pairCode;
                let nextChar = index + 1 < this.text.length ? this.text[index + 1] : 0;
                switch (this.text[index]) {
                    case StringUtils.getCharCode('\r'):
                        pairCode = nextChar === lineBreakCharCode ? 2 : 0;
                        break;
                    case StringUtils.getCharCode('.'):
                        pairCode = nextChar === spaceCharCode ? 3 : 0;
                        break;
                    case StringUtils.getCharCode(','):
                        pairCode = nextChar === spaceCharCode ? 4 : 0;
                        break;
                    case StringUtils.getCharCode(':'):
                        pairCode = nextChar === spaceCharCode ? 5 : 0;
                        break;
                    default:
                        pairCode = 0;
                }
                if (pairCode > 0) {
                    // We have one of the four special PUNCT pairs.  Treat them specially.
                    // Get a new set of states for the two new characters.
                    states = HighLevelEncoder.updateStateListForPair(states, index, pairCode);
                    index++;
                }
                else {
                    // Get a new set of states for the new character.
                    states = this.updateStateListForChar(states, index);
                }
            }
            // We are left with a set of states.  Find the shortest one.
            const minState = Collections.min(states, (a, b) => {
                return a.getBitCount() - b.getBitCount();
            });
            // Convert it to a bit array, and return.
            return minState.toBitArray(this.text);
        }
        // We update a set of states for a new character by updating each state
        // for the new character, merging the results, and then removing the
        // non-optimal states.
        updateStateListForChar(states, index) {
            const result = [];
            for (let state /*State*/ of states) {
                this.updateStateForChar(state, index, result);
            }
            return HighLevelEncoder.simplifyStates(result);
        }
        // Return a set of states that represent the possible ways of updating this
        // state for the next character.  The resulting set of states are added to
        // the "result" list.
        updateStateForChar(state, index, result) {
            let ch = (this.text[index] & 0xff);
            let charInCurrentTable = CHAR_MAP[state.getMode()][ch] > 0;
            let stateNoBinary = null;
            for (let mode /*int*/ = 0; mode <= MODE_PUNCT; mode++) {
                let charInMode = CHAR_MAP[mode][ch];
                if (charInMode > 0) {
                    if (stateNoBinary == null) {
                        // Only create stateNoBinary the first time it's required.
                        stateNoBinary = state.endBinaryShift(index);
                    }
                    // Try generating the character by latching to its mode
                    if (!charInCurrentTable ||
                        mode === state.getMode() ||
                        mode === MODE_DIGIT) {
                        // If the character is in the current table, we don't want to latch to
                        // any other mode except possibly digit (which uses only 4 bits).  Any
                        // other latch would be equally successful *after* this character, and
                        // so wouldn't save any bits.
                        const latchState = stateNoBinary.latchAndAppend(mode, charInMode);
                        result.push(latchState);
                    }
                    // Try generating the character by switching to its mode.
                    if (!charInCurrentTable &&
                        SHIFT_TABLE[state.getMode()][mode] >= 0) {
                        // It never makes sense to temporarily shift to another mode if the
                        // character exists in the current mode.  That can never save bits.
                        const shiftState = stateNoBinary.shiftAndAppend(mode, charInMode);
                        result.push(shiftState);
                    }
                }
            }
            if (state.getBinaryShiftByteCount() > 0 ||
                CHAR_MAP[state.getMode()][ch] === 0) {
                // It's never worthwhile to go into binary shift mode if you're not already
                // in binary shift mode, and the character exists in your current mode.
                // That can never save bits over just outputting the char in the current mode.
                let binaryState = state.addBinaryShiftChar(index);
                result.push(binaryState);
            }
        }
        static updateStateListForPair(states, index, pairCode) {
            const result = [];
            for (let state /*State*/ of states) {
                this.updateStateForPair(state, index, pairCode, result);
            }
            return this.simplifyStates(result);
        }
        static updateStateForPair(state, index, pairCode, result) {
            let stateNoBinary = state.endBinaryShift(index);
            // Possibility 1.  Latch to C.MODE_PUNCT, and then append this code
            result.push(stateNoBinary.latchAndAppend(MODE_PUNCT, pairCode));
            if (state.getMode() !== MODE_PUNCT) {
                // Possibility 2.  Shift to C.MODE_PUNCT, and then append this code.
                // Every state except C.MODE_PUNCT (handled above) can shift
                result.push(stateNoBinary.shiftAndAppend(MODE_PUNCT, pairCode));
            }
            if (pairCode === 3 || pairCode === 4) {
                // both characters are in DIGITS.  Sometimes better to just add two digits
                let digitState = stateNoBinary
                    .latchAndAppend(MODE_DIGIT, 16 - pairCode) // period or comma in DIGIT
                    .latchAndAppend(MODE_DIGIT, 1); // space in DIGIT
                result.push(digitState);
            }
            if (state.getBinaryShiftByteCount() > 0) {
                // It only makes sense to do the characters as binary if we're already
                // in binary mode.
                let binaryState = state
                    .addBinaryShiftChar(index)
                    .addBinaryShiftChar(index + 1);
                result.push(binaryState);
            }
        }
        static simplifyStates(states) {
            let result = [];
            for (const newState of states) {
                let add = true;
                for (const oldState of result) {
                    if (oldState.isBetterThanOrEqualTo(newState)) {
                        add = false;
                        break;
                    }
                    if (newState.isBetterThanOrEqualTo(oldState)) {
                        // iterator.remove();
                        result = result.filter(x => x !== oldState); // remove old state
                    }
                }
                if (add) {
                    result.push(newState);
                }
            }
            return result;
        }
    }

    /*
     * Copyright 2013 ZXing authors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // package com.google.zxing.aztec.encoder;
    // import com.google.zxing.common.BitArray;
    // import com.google.zxing.common.BitMatrix;
    // import com.google.zxing.common.reedsolomon.GenericGF;
    // import com.google.zxing.common.reedsolomon.ReedSolomonEncoder;
    /**
     * Generates Aztec 2D barcodes.
     *
     * @author Rustam Abdullaev
     */
    /*public final*/ class Encoder$1 {
        constructor() {
        }
        /**
         * Encodes the given binary content as an Aztec symbol
         *
         * @param data input data string
         * @return Aztec symbol matrix with metadata
         */
        static encodeBytes(data) {
            return Encoder$1.encode(data, Encoder$1.DEFAULT_EC_PERCENT, Encoder$1.DEFAULT_AZTEC_LAYERS);
        }
        /**
         * Encodes the given binary content as an Aztec symbol
         *
         * @param data input data string
         * @param minECCPercent minimal percentage of error check words (According to ISO/IEC 24778:2008,
         *                      a minimum of 23% + 3 words is recommended)
         * @param userSpecifiedLayers if non-zero, a user-specified value for the number of layers
         * @return Aztec symbol matrix with metadata
         */
        static encode(data, minECCPercent, userSpecifiedLayers) {
            // High-level encode
            let bits = new HighLevelEncoder(data).encode();
            // stuff bits and choose symbol size
            let eccBits = Integer.truncDivision((bits.getSize() * minECCPercent), 100) + 11;
            let totalSizeBits = bits.getSize() + eccBits;
            let compact;
            let layers;
            let totalBitsInLayer;
            let wordSize;
            let stuffedBits;
            if (userSpecifiedLayers !== Encoder$1.DEFAULT_AZTEC_LAYERS) {
                compact = userSpecifiedLayers < 0;
                layers = Math.abs(userSpecifiedLayers);
                if (layers > (compact ? Encoder$1.MAX_NB_BITS_COMPACT : Encoder$1.MAX_NB_BITS)) {
                    throw new IllegalArgumentException(StringUtils.format('Illegal value %s for layers', userSpecifiedLayers));
                }
                totalBitsInLayer = Encoder$1.totalBitsInLayer(layers, compact);
                wordSize = Encoder$1.WORD_SIZE[layers];
                let usableBitsInLayers = totalBitsInLayer - (totalBitsInLayer % wordSize);
                stuffedBits = Encoder$1.stuffBits(bits, wordSize);
                if (stuffedBits.getSize() + eccBits > usableBitsInLayers) {
                    throw new IllegalArgumentException('Data to large for user specified layer');
                }
                if (compact && stuffedBits.getSize() > wordSize * 64) {
                    // Compact format only allows 64 data words, though C4 can hold more words than that
                    throw new IllegalArgumentException('Data to large for user specified layer');
                }
            }
            else {
                wordSize = 0;
                stuffedBits = null;
                // We look at the possible table sizes in the order Compact1, Compact2, Compact3,
                // Compact4, Normal4,...  Normal(i) for i < 4 isn't typically used since Compact(i+1)
                // is the same size, but has more data.
                for (let i /*int*/ = 0;; i++) {
                    if (i > Encoder$1.MAX_NB_BITS) {
                        throw new IllegalArgumentException('Data too large for an Aztec code');
                    }
                    compact = i <= 3;
                    layers = compact ? i + 1 : i;
                    totalBitsInLayer = Encoder$1.totalBitsInLayer(layers, compact);
                    if (totalSizeBits > totalBitsInLayer) {
                        continue;
                    }
                    // [Re]stuff the bits if this is the first opportunity, or if the
                    // wordSize has changed
                    if (stuffedBits == null || wordSize !== Encoder$1.WORD_SIZE[layers]) {
                        wordSize = Encoder$1.WORD_SIZE[layers];
                        stuffedBits = Encoder$1.stuffBits(bits, wordSize);
                    }
                    let usableBitsInLayers = totalBitsInLayer - (totalBitsInLayer % wordSize);
                    if (compact && stuffedBits.getSize() > wordSize * 64) {
                        // Compact format only allows 64 data words, though C4 can hold more words than that
                        continue;
                    }
                    if (stuffedBits.getSize() + eccBits <= usableBitsInLayers) {
                        break;
                    }
                }
            }
            let messageBits = Encoder$1.generateCheckWords(stuffedBits, totalBitsInLayer, wordSize);
            // generate mode message
            let messageSizeInWords = stuffedBits.getSize() / wordSize;
            let modeMessage = Encoder$1.generateModeMessage(compact, layers, messageSizeInWords);
            // allocate symbol
            let baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines
            let alignmentMap = new Int32Array(baseMatrixSize);
            let matrixSize;
            if (compact) {
                // no alignment marks in compact mode, alignmentMap is a no-op
                matrixSize = baseMatrixSize;
                for (let i /*int*/ = 0; i < alignmentMap.length; i++) {
                    alignmentMap[i] = i;
                }
            }
            else {
                matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision((Integer.truncDivision(baseMatrixSize, 2) - 1), 15);
                let origCenter = Integer.truncDivision(baseMatrixSize, 2);
                let center = Integer.truncDivision(matrixSize, 2);
                for (let i /*int*/ = 0; i < origCenter; i++) {
                    let newOffset = i + Integer.truncDivision(i, 15);
                    alignmentMap[origCenter - i - 1] = center - newOffset - 1;
                    alignmentMap[origCenter + i] = center + newOffset + 1;
                }
            }
            let matrix = new BitMatrix(matrixSize);
            // draw data bits
            for (let i /*int*/ = 0, rowOffset = 0; i < layers; i++) {
                let rowSize = (layers - i) * 4 + (compact ? 9 : 12);
                for (let j /*int*/ = 0; j < rowSize; j++) {
                    let columnOffset = j * 2;
                    for (let k /*int*/ = 0; k < 2; k++) {
                        if (messageBits.get(rowOffset + columnOffset + k)) {
                            matrix.set(alignmentMap[i * 2 + k], alignmentMap[i * 2 + j]);
                        }
                        if (messageBits.get(rowOffset + rowSize * 2 + columnOffset + k)) {
                            matrix.set(alignmentMap[i * 2 + j], alignmentMap[baseMatrixSize - 1 - i * 2 - k]);
                        }
                        if (messageBits.get(rowOffset + rowSize * 4 + columnOffset + k)) {
                            matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - k], alignmentMap[baseMatrixSize - 1 - i * 2 - j]);
                        }
                        if (messageBits.get(rowOffset + rowSize * 6 + columnOffset + k)) {
                            matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - j], alignmentMap[i * 2 + k]);
                        }
                    }
                }
                rowOffset += rowSize * 8;
            }
            // draw mode message
            Encoder$1.drawModeMessage(matrix, compact, matrixSize, modeMessage);
            // draw alignment marks
            if (compact) {
                Encoder$1.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 5);
            }
            else {
                Encoder$1.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 7);
                for (let i /*int*/ = 0, j = 0; i < Integer.truncDivision(baseMatrixSize, 2) - 1; i += 15, j += 16) {
                    for (let k /*int*/ = Integer.truncDivision(matrixSize, 2) & 1; k < matrixSize; k += 2) {
                        matrix.set(Integer.truncDivision(matrixSize, 2) - j, k);
                        matrix.set(Integer.truncDivision(matrixSize, 2) + j, k);
                        matrix.set(k, Integer.truncDivision(matrixSize, 2) - j);
                        matrix.set(k, Integer.truncDivision(matrixSize, 2) + j);
                    }
                }
            }
            let aztec = new AztecCode();
            aztec.setCompact(compact);
            aztec.setSize(matrixSize);
            aztec.setLayers(layers);
            aztec.setCodeWords(messageSizeInWords);
            aztec.setMatrix(matrix);
            return aztec;
        }
        static drawBullsEye(matrix, center, size) {
            for (let i /*int*/ = 0; i < size; i += 2) {
                for (let j /*int*/ = center - i; j <= center + i; j++) {
                    matrix.set(j, center - i);
                    matrix.set(j, center + i);
                    matrix.set(center - i, j);
                    matrix.set(center + i, j);
                }
            }
            matrix.set(center - size, center - size);
            matrix.set(center - size + 1, center - size);
            matrix.set(center - size, center - size + 1);
            matrix.set(center + size, center - size);
            matrix.set(center + size, center - size + 1);
            matrix.set(center + size, center + size - 1);
        }
        static generateModeMessage(compact, layers, messageSizeInWords) {
            let modeMessage = new BitArray();
            if (compact) {
                modeMessage.appendBits(layers - 1, 2);
                modeMessage.appendBits(messageSizeInWords - 1, 6);
                modeMessage = Encoder$1.generateCheckWords(modeMessage, 28, 4);
            }
            else {
                modeMessage.appendBits(layers - 1, 5);
                modeMessage.appendBits(messageSizeInWords - 1, 11);
                modeMessage = Encoder$1.generateCheckWords(modeMessage, 40, 4);
            }
            return modeMessage;
        }
        static drawModeMessage(matrix, compact, matrixSize, modeMessage) {
            let center = Integer.truncDivision(matrixSize, 2);
            if (compact) {
                for (let i /*int*/ = 0; i < 7; i++) {
                    let offset = center - 3 + i;
                    if (modeMessage.get(i)) {
                        matrix.set(offset, center - 5);
                    }
                    if (modeMessage.get(i + 7)) {
                        matrix.set(center + 5, offset);
                    }
                    if (modeMessage.get(20 - i)) {
                        matrix.set(offset, center + 5);
                    }
                    if (modeMessage.get(27 - i)) {
                        matrix.set(center - 5, offset);
                    }
                }
            }
            else {
                for (let i /*int*/ = 0; i < 10; i++) {
                    let offset = center - 5 + i + Integer.truncDivision(i, 5);
                    if (modeMessage.get(i)) {
                        matrix.set(offset, center - 7);
                    }
                    if (modeMessage.get(i + 10)) {
                        matrix.set(center + 7, offset);
                    }
                    if (modeMessage.get(29 - i)) {
                        matrix.set(offset, center + 7);
                    }
                    if (modeMessage.get(39 - i)) {
                        matrix.set(center - 7, offset);
                    }
                }
            }
        }
        static generateCheckWords(bitArray, totalBits, wordSize) {
            // bitArray is guaranteed to be a multiple of the wordSize, so no padding needed
            let messageSizeInWords = bitArray.getSize() / wordSize;
            let rs = new ReedSolomonEncoder(Encoder$1.getGF(wordSize));
            let totalWords = Integer.truncDivision(totalBits, wordSize);
            let messageWords = Encoder$1.bitsToWords(bitArray, wordSize, totalWords);
            rs.encode(messageWords, totalWords - messageSizeInWords);
            let startPad = totalBits % wordSize;
            let messageBits = new BitArray();
            messageBits.appendBits(0, startPad);
            for (const messageWord /*: int*/ of Array.from(messageWords)) {
                messageBits.appendBits(messageWord, wordSize);
            }
            return messageBits;
        }
        static bitsToWords(stuffedBits, wordSize, totalWords) {
            let message = new Int32Array(totalWords);
            let i;
            let n;
            for (i = 0, n = stuffedBits.getSize() / wordSize; i < n; i++) {
                let value = 0;
                for (let j /*int*/ = 0; j < wordSize; j++) {
                    value |= stuffedBits.get(i * wordSize + j) ? (1 << wordSize - j - 1) : 0;
                }
                message[i] = value;
            }
            return message;
        }
        static getGF(wordSize) {
            switch (wordSize) {
                case 4:
                    return GenericGF.AZTEC_PARAM;
                case 6:
                    return GenericGF.AZTEC_DATA_6;
                case 8:
                    return GenericGF.AZTEC_DATA_8;
                case 10:
                    return GenericGF.AZTEC_DATA_10;
                case 12:
                    return GenericGF.AZTEC_DATA_12;
                default:
                    throw new IllegalArgumentException('Unsupported word size ' + wordSize);
            }
        }
        static stuffBits(bits, wordSize) {
            let out = new BitArray();
            let n = bits.getSize();
            let mask = (1 << wordSize) - 2;
            for (let i /*int*/ = 0; i < n; i += wordSize) {
                let word = 0;
                for (let j /*int*/ = 0; j < wordSize; j++) {
                    if (i + j >= n || bits.get(i + j)) {
                        word |= 1 << (wordSize - 1 - j);
                    }
                }
                if ((word & mask) === mask) {
                    out.appendBits(word & mask, wordSize);
                    i--;
                }
                else if ((word & mask) === 0) {
                    out.appendBits(word | 1, wordSize);
                    i--;
                }
                else {
                    out.appendBits(word, wordSize);
                }
            }
            return out;
        }
        static totalBitsInLayer(layers, compact) {
            return ((compact ? 88 : 112) + 16 * layers) * layers;
        }
    }
    Encoder$1.DEFAULT_EC_PERCENT = 33; // default minimal percentage of error check words
    Encoder$1.DEFAULT_AZTEC_LAYERS = 0;
    Encoder$1.MAX_NB_BITS = 32;
    Encoder$1.MAX_NB_BITS_COMPACT = 4;
    Encoder$1.WORD_SIZE = Int32Array.from([
        4, 6, 6, 8, 8, 8, 8, 8, 8, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
        12, 12, 12, 12, 12, 12, 12, 12, 12, 12
    ]);

    /*
    * Copyright 2013 ZXing authors
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    */
    /**
     * Renders an Aztec code as a {@link BitMatrix}.
     */
    /*public final*/ class AztecWriter {
        // @Override
        encode(contents, format, width, height) {
            return this.encodeWithHints(contents, format, width, height, null);
        }
        // @Override
        encodeWithHints(contents, format, width, height, hints) {
            let charset = StandardCharsets.ISO_8859_1;
            let eccPercent = Encoder$1.DEFAULT_EC_PERCENT;
            let layers = Encoder$1.DEFAULT_AZTEC_LAYERS;
            if (hints != null) {
                if (hints.has(EncodeHintType$1.CHARACTER_SET)) {
                    charset = Charset.forName(hints.get(EncodeHintType$1.CHARACTER_SET).toString());
                }
                if (hints.has(EncodeHintType$1.ERROR_CORRECTION)) {
                    eccPercent = Integer.parseInt(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
                }
                if (hints.has(EncodeHintType$1.AZTEC_LAYERS)) {
                    layers = Integer.parseInt(hints.get(EncodeHintType$1.AZTEC_LAYERS).toString());
                }
            }
            return AztecWriter.encodeLayers(contents, format, width, height, charset, eccPercent, layers);
        }
        static encodeLayers(contents, format, width, height, charset, eccPercent, layers) {
            if (format !== BarcodeFormat$1.AZTEC) {
                throw new IllegalArgumentException('Can only encode AZTEC, but got ' + format);
            }
            let aztec = Encoder$1.encode(StringUtils.getBytes(contents, charset), eccPercent, layers);
            return AztecWriter.renderResult(aztec, width, height);
        }
        static renderResult(code, width, height) {
            let input = code.getMatrix();
            if (input == null) {
                throw new IllegalStateException();
            }
            let inputWidth = input.getWidth();
            let inputHeight = input.getHeight();
            let outputWidth = Math.max(width, inputWidth);
            let outputHeight = Math.max(height, inputHeight);
            let multiple = Math.min(outputWidth / inputWidth, outputHeight / inputHeight);
            let leftPadding = (outputWidth - (inputWidth * multiple)) / 2;
            let topPadding = (outputHeight - (inputHeight * multiple)) / 2;
            let output = new BitMatrix(outputWidth, outputHeight);
            for (let inputY /*int*/ = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
                // Write the contents of this row of the barcode
                for (let inputX /*int*/ = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
                    if (input.get(inputX, inputY)) {
                        output.setRegion(outputX, outputY, multiple, multiple);
                    }
                }
            }
            return output;
        }
    }

    exports.AbstractExpandedDecoder = AbstractExpandedDecoder;
    exports.ArgumentException = ArgumentException;
    exports.ArithmeticException = ArithmeticException;
    exports.AztecCode = AztecCode;
    exports.AztecCodeReader = AztecReader;
    exports.AztecCodeWriter = AztecWriter;
    exports.AztecDecoder = Decoder;
    exports.AztecDetector = Detector;
    exports.AztecDetectorResult = AztecDetectorResult;
    exports.AztecEncoder = Encoder$1;
    exports.AztecHighLevelEncoder = HighLevelEncoder;
    exports.AztecPoint = Point;
    exports.BarcodeFormat = BarcodeFormat$1;
    exports.Binarizer = Binarizer;
    exports.BinaryBitmap = BinaryBitmap;
    exports.BitArray = BitArray;
    exports.BitMatrix = BitMatrix;
    exports.BitSource = BitSource;
    exports.BrowserAztecCodeReader = BrowserAztecCodeReader;
    exports.BrowserBarcodeReader = BrowserBarcodeReader;
    exports.BrowserCodeReader = BrowserCodeReader;
    exports.BrowserDatamatrixCodeReader = BrowserDatamatrixCodeReader;
    exports.BrowserMultiFormatReader = BrowserMultiFormatReader;
    exports.BrowserPDF417Reader = BrowserPDF417Reader;
    exports.BrowserQRCodeReader = BrowserQRCodeReader;
    exports.BrowserQRCodeSvgWriter = BrowserQRCodeSvgWriter;
    exports.CharacterSetECI = CharacterSetECI;
    exports.ChecksumException = ChecksumException;
    exports.Code128Reader = Code128Reader;
    exports.Code39Reader = Code39Reader;
    exports.DataMatrixDecodedBitStreamParser = DecodedBitStreamParser;
    exports.DataMatrixReader = DataMatrixReader;
    exports.DecodeHintType = DecodeHintType$1;
    exports.DecoderResult = DecoderResult;
    exports.DefaultGridSampler = DefaultGridSampler;
    exports.DetectorResult = DetectorResult;
    exports.EAN13Reader = EAN13Reader;
    exports.EncodeHintType = EncodeHintType$1;
    exports.Exception = Exception;
    exports.FormatException = FormatException;
    exports.GenericGF = GenericGF;
    exports.GenericGFPoly = GenericGFPoly;
    exports.GlobalHistogramBinarizer = GlobalHistogramBinarizer;
    exports.GridSampler = GridSampler;
    exports.GridSamplerInstance = GridSamplerInstance;
    exports.HTMLCanvasElementLuminanceSource = HTMLCanvasElementLuminanceSource;
    exports.HybridBinarizer = HybridBinarizer;
    exports.ITFReader = ITFReader;
    exports.IllegalArgumentException = IllegalArgumentException;
    exports.IllegalStateException = IllegalStateException;
    exports.InvertedLuminanceSource = InvertedLuminanceSource;
    exports.LuminanceSource = LuminanceSource;
    exports.MathUtils = MathUtils;
    exports.MultiFormatOneDReader = MultiFormatOneDReader;
    exports.MultiFormatReader = MultiFormatReader;
    exports.MultiFormatWriter = MultiFormatWriter;
    exports.NotFoundException = NotFoundException;
    exports.OneDReader = OneDReader;
    exports.PDF417DecodedBitStreamParser = DecodedBitStreamParser$2;
    exports.PDF417DecoderErrorCorrection = ErrorCorrection;
    exports.PDF417Reader = PDF417Reader;
    exports.PDF417ResultMetadata = PDF417ResultMetadata;
    exports.PerspectiveTransform = PerspectiveTransform;
    exports.PlanarYUVLuminanceSource = PlanarYUVLuminanceSource;
    exports.QRCodeByteMatrix = ByteMatrix;
    exports.QRCodeDataMask = DataMask;
    exports.QRCodeDecodedBitStreamParser = DecodedBitStreamParser$1;
    exports.QRCodeDecoderErrorCorrectionLevel = ErrorCorrectionLevel;
    exports.QRCodeDecoderFormatInformation = FormatInformation;
    exports.QRCodeEncoder = Encoder;
    exports.QRCodeEncoderQRCode = QRCode;
    exports.QRCodeMaskUtil = MaskUtil;
    exports.QRCodeMatrixUtil = MatrixUtil;
    exports.QRCodeMode = Mode$1;
    exports.QRCodeReader = QRCodeReader;
    exports.QRCodeVersion = Version$1;
    exports.QRCodeWriter = QRCodeWriter;
    exports.RGBLuminanceSource = RGBLuminanceSource;
    exports.RSS14Reader = RSS14Reader;
    exports.RSSExpandedReader = RSSExpandedReader;
    exports.ReaderException = ReaderException;
    exports.ReedSolomonDecoder = ReedSolomonDecoder;
    exports.ReedSolomonEncoder = ReedSolomonEncoder;
    exports.ReedSolomonException = ReedSolomonException;
    exports.Result = Result;
    exports.ResultMetadataType = ResultMetadataType$1;
    exports.ResultPoint = ResultPoint;
    exports.StringUtils = StringUtils;
    exports.UnsupportedOperationException = UnsupportedOperationException;
    exports.VideoInputDevice = VideoInputDevice;
    exports.WhiteRectangleDetector = WhiteRectangleDetector;
    exports.WriterException = WriterException;
    exports.ZXingArrays = Arrays;
    exports.ZXingCharset = Charset;
    exports.ZXingInteger = Integer;
    exports.ZXingStandardCharsets = StandardCharsets;
    exports.ZXingStringBuilder = StringBuilder;
    exports.ZXingStringEncoding = StringEncoding;
    exports.ZXingSystem = System;
    exports.createAbstractExpandedDecoder = createDecoder;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.js.map
;

/********************************************************************
*  Filepath: /pos_epson_printer/static/src/js/pos_epson_printer.js  *
*  Lines: 21                                                        *
********************************************************************/
odoo.define('pos_epson_printer.pos_epson_printer', function (require) {
"use strict";

var { PosGlobalState } = require('point_of_sale.models');
var EpsonPrinter = require('pos_epson_printer.Printer');
const Registries = require('point_of_sale.Registries');


const PosEpsonPosGlobalState = (PosGlobalState) => class PosEpsonPosGlobalState extends PosGlobalState {
    after_load_server_data() {
        var self = this;
        return super.after_load_server_data(...arguments).then(function () {
            if (self.config.other_devices && self.config.epson_printer_ip) {
                self.env.proxy.printer = new EpsonPrinter(self.config.epson_printer_ip , self);
            }
        });
    }
}
Registries.Model.extend(PosGlobalState, PosEpsonPosGlobalState);

});
;

/***********************************************************
*  Filepath: /pos_epson_printer/static/src/js/printers.js  *
*  Lines: 193                                              *
***********************************************************/

odoo.define('pos_epson_printer.Printer', function (require) {
"use strict";

var core = require('web.core');
var { PrinterMixin, PrintResult, PrintResultGenerator } = require('point_of_sale.Printer');

var QWeb = core.qweb;
var _t = core._t;

class EpsonPrintResultGenerator extends PrintResultGenerator {
    constructor(address) {
        super();
        this.address = address;
    }

    IoTActionError() {
        var printRes = new PrintResult({
            successful: false,
            message: {
                title: _t('Connection to the printer failed'),
                body: _t('Please check if the printer is still connected. \n' +
                    'Some browsers don\'t allow HTTP calls from websites to devices in the network (for security reasons). ' +
                    'If it is the case, you will need to follow Odoo\'s documentation for ' +
                    '\'Self-signed certificate for ePOS printers\' and \'Secure connection (HTTPS)\' to solve the issue'
                ),
            }
        });

        if (window.location.protocol === 'https:') {
            printRes.message.body += _.str.sprintf(
                _t('If you are on a secure server (HTTPS) please make sure you manually accepted the certificate by accessing %s'),
                this.address
            );
        }

        return printRes;
    }

    IoTResultError(printerErrorCode) {
        let message = _t("The printer was successfully reached, but it wasn't able to print.") + '\n';
        if (printerErrorCode) {
            message += '\n' + _t("The following error code was given by the printer:") + '\n' + printerErrorCode;

            const extra_messages = {
                'DeviceNotFound':
                    _t("Check on the printer configuration for the 'Device ID' setting. " +
                        "It should be set to: ") + "\nlocal_printer",
                'EPTR_REC_EMPTY':
                    _t("No paper was detected by the printer"),
            };
            if (printerErrorCode in extra_messages) {
                message += '\n' + extra_messages[printerErrorCode];
            }
            message += "\n" + _t("To find more details on the error reason, please search online for:") + '\n' +
                " Epson Server Direct Print " + printerErrorCode;
        } else {
            message += _t('Please check if the printer has enough paper and is ready to print.');
        }
        return new PrintResult({
            successful: false,
            message: {
                title: _t('Printing failed'),
                body: message,
            },
        });
    }
}

var EpsonPrinter = core.Class.extend(PrinterMixin, {
    init(ip, pos) {
        PrinterMixin.init.call(this, pos);
        var url = window.location.protocol + '//' + ip;
        this.address = url + '/cgi-bin/epos/service.cgi?devid=local_printer';
        this.printResultGenerator = new EpsonPrintResultGenerator(url);
    },


    /**
     * Transform a (potentially colored) canvas into a monochrome raster image.
     * We will use Floyd-Steinberg dithering.
     */
    _canvasToRaster(canvas) {
        var imageData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
        var pixels = imageData.data;
        var width = imageData.width;
        var height = imageData.height;
        var errors = Array.from(Array(width), _ => Array(height).fill(0));
        var rasterData = new Array(width * height).fill(0);

        for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
                var idx, oldColor, newColor;

                // Compute grayscale level. Those coefficients were found online
                // as R, G and B have different impacts on the darkness
                // perception (e.g. pure blue is darker than red or green).
                idx = (y * width + x) * 4;
                oldColor = pixels[idx] * 0.299 + pixels[idx+1] * 0.587 + pixels[idx+2] * 0.114;

                // Propagate the error from neighbor pixels 
                oldColor += errors[x][y];
                oldColor = Math.min(255, Math.max(0, oldColor));

                if (oldColor < 128) {
                    // This pixel should be black
                    newColor = 0;
                    rasterData[y * width + x] = 1;
                } else {
                    // This pixel should be white
                    newColor = 255;
                    rasterData[y * width + x] = 0;
                }

                // Propagate the error to the following pixels, based on
                // Floyd-Steinberg dithering.
                var error = oldColor - newColor;
                if (error) {
                    if (x < width - 1) {
                        // Pixel on the right
                        errors[x + 1][y] += 7/16 * error;
                    }
                    if (x > 0 && y < height - 1) {
                        // Pixel on the bottom left
                        errors[x - 1][y + 1] += 3/16 * error;
                    }
                    if (y < height - 1) {
                        // Pixel below
                        errors[x][y + 1] += 5/16 * error;
                    }
                    if (x < width - 1 && y < height - 1) {
                        // Pixel on the bottom right
                        errors[x + 1][y + 1] += 1/16 * error;
                    }
                }
            }
        }

        return rasterData.join('');
    },

    /**
     * Base 64 encode a raster image
     */
    _encodeRaster(rasterData) {
        var encodedData = '';
        for(var i = 0; i < rasterData.length; i+=8){
            var sub = rasterData.substr(i, 8);
            encodedData += String.fromCharCode(parseInt(sub, 2));
        }
        return btoa(encodedData);
    },

    /**
     * Create the raster data from a canvas
     * 
     * @override
     */
    process_canvas(canvas) {
        var rasterData = this._canvasToRaster(canvas);
        var encodedData = this._encodeRaster(rasterData);
        return QWeb.render('ePOSPrintImage', {
            image: encodedData,
            width: canvas.width,
            height: canvas.height,
        });
    },

    /**
     * @override
     */
    open_cashbox() {
        var pulse = QWeb.render('ePOSDrawer');
        this.send_printing_job(pulse);
    },

    /**
     * @override
     */
    async send_printing_job(img) {
        const res = await $.ajax({
            url: this.address,
            method: 'POST',
            data: img,
        });
        const response = $(res).find('response');
        return {"result": response.attr('success') === 'true', "printerErrorCode": response.attr('code')};
    },
});

return EpsonPrinter;

});
;

/************************************************
*  Filepath: /pos_sale/static/src/js/models.js  *
*  Lines: 83                                    *
************************************************/
odoo.define('pos_sale.models', function (require) {
    "use strict";

var { Order, Orderline } = require('point_of_sale.models');
const Registries = require('point_of_sale.Registries');


const PosSaleOrder = (Order) => class PosSaleOrder extends Order {
    //@override
    select_orderline(orderline) {
        super.select_orderline(...arguments);
        if (orderline && orderline.product.id === this.pos.config.down_payment_product_id[0]) {
            this.pos.numpadMode = 'price';
        }
    }
    //@override
    _get_ignored_product_ids_total_discount() {
        const productIds = super._get_ignored_product_ids_total_discount(...arguments);
        productIds.push(this.pos.config.down_payment_product_id[0]);
        return productIds;
    }
}
Registries.Model.extend(Order, PosSaleOrder);

const PosSaleOrderline = (Orderline) => class PosSaleOrderline extends Orderline {
  constructor(obj, options) {
      super(...arguments);
      // It is possible that this orderline is initialized using `init_from_JSON`,
      // meaning, it is loaded from localStorage or from export_for_ui. This means
      // that some fields has already been assigned. Therefore, we only set the options
      // when the original value is falsy.
      this.sale_order_origin_id = this.sale_order_origin_id || options.sale_order_origin_id;
      this.sale_order_line_id = this.sale_order_line_id || options.sale_order_line_id;
      this.down_payment_details = this.down_payment_details || options.down_payment_details;
      this.customerNote = this.customerNote || options.customer_note;
  }
  init_from_JSON(json) {
      super.init_from_JSON(...arguments);
      this.sale_order_origin_id = json.sale_order_origin_id;
      this.sale_order_line_id = json.sale_order_line_id;
      this.down_payment_details = json.down_payment_details && JSON.parse(json.down_payment_details);
  }
  export_as_JSON() {
      const json = super.export_as_JSON(...arguments);
      json.sale_order_origin_id = this.sale_order_origin_id;
      json.sale_order_line_id = this.sale_order_line_id;
      json.down_payment_details = this.down_payment_details && JSON.stringify(this.down_payment_details);
      return json;
  }
  get_sale_order(){
      if(this.sale_order_origin_id) {
        let value = {
            'name': this.sale_order_origin_id.name,
            'details': this.down_payment_details || false
        }

        return value;
      }
      return false;
  }
  export_for_printing() {
    var json = super.export_for_printing(...arguments);
    json.down_payment_details =  this.down_payment_details;
    if (this.sale_order_origin_id) {
        json.so_reference = this.sale_order_origin_id.name;
    }
    return json;
  }
  /**
   * Set quantity based on the give sale order line.
   * @param {'sale.order.line'} saleOrderLine
   */
  setQuantityFromSOL(saleOrderLine) {
      if (this.product.type === 'service') {
        this.set_quantity(saleOrderLine.qty_to_invoice);
      } else {
        this.set_quantity(saleOrderLine.product_uom_qty - Math.max(saleOrderLine.qty_delivered, saleOrderLine.qty_invoiced));
      }
  }
}
Registries.Model.extend(Orderline, PosSaleOrderline);

});
;

/************************************************************
*  Filepath: /pos_sale/static/src/js/SetSaleOrderButton.js  *
*  Lines: 59                                                *
************************************************************/
odoo.define('pos_sale.SetSaleOrderButton', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const ProductScreen = require('point_of_sale.ProductScreen');
    const { useListener } = require("@web/core/utils/hooks");
    const Registries = require('point_of_sale.Registries');
    const { isConnectionError } = require('point_of_sale.utils');
    const { Gui } = require('point_of_sale.Gui');

    class SetSaleOrderButton extends PosComponent {
        setup() {
            super.setup();
            useListener('click', this.onClick);
        }
        get currentOrder() {
            return this.env.pos.get_order();
        }
        async onClick() {
          try {
              // ping the server, if no error, show the screen
              // Use rpc from services which resolves even when this
              // component is destroyed (removed together with the popup).
              await this.env.services.rpc({
                  model: 'sale.order',
                  method: 'browse',
                  args: [[]],
                  kwargs: { context: this.env.session.user_context },
              });
              // LegacyComponent doesn't work the same way as before.
              // We need to use Gui here to show the screen. This will work
              // because ui methods in Gui is bound to the root component.
              const screen = this.env.isMobile ? 'MobileSaleOrderManagementScreen' : 'SaleOrderManagementScreen';
              Gui.showScreen(screen);
          } catch (error) {
              if (isConnectionError(error)) {
                  this.showPopup('ErrorPopup', {
                      title: this.env._t('Network Error'),
                      body: this.env._t('Cannot access order management screen if offline.'),
                  });
              } else {
                  throw error;
              }
          }
        }
    }
    SetSaleOrderButton.template = 'SetSaleOrderButton';

    ProductScreen.addControlButton({
        component: SetSaleOrderButton,
        condition: function() {
            return true;
        },
    });

    Registries.Component.add(SetSaleOrderButton);

    return SetSaleOrderButton;
});
;

/***********************************************************************************************
*  Filepath: /pos_sale/static/src/js/OrderManagementScreen/MobileSaleOrderManagementScreen.js  *
*  Lines: 26                                                                                   *
***********************************************************************************************/
odoo.define('point_of_sale.MobileSaleOrderManagementScreen', function (require) {
    const SaleOrderManagementScreen = require('pos_sale.SaleOrderManagementScreen');
    const Registries = require('point_of_sale.Registries');
    const { useListener } = require("@web/core/utils/hooks");

    const { useState } = owl;

    const MobileSaleOrderManagementScreen = (SaleOrderManagementScreen) => {
        class MobileSaleOrderManagementScreen extends SaleOrderManagementScreen {
            setup() {
                super.setup();
                useListener('click-order', this._onShowDetails)
                this.mobileState = useState({ showDetails: false });
            }
            _onShowDetails() {
                this.mobileState.showDetails = true;
            }
        }
        MobileSaleOrderManagementScreen.template = 'MobileSaleOrderManagementScreen';
        return MobileSaleOrderManagementScreen;
    };

    Registries.Component.addByExtending(MobileSaleOrderManagementScreen, SaleOrderManagementScreen);

    return MobileSaleOrderManagementScreen;
});
;

/********************************************************************************
*  Filepath: /pos_sale/static/src/js/OrderManagementScreen/SaleOrderFetcher.js  *
*  Lines: 134                                                                   *
********************************************************************************/
odoo.define('pos_sale.SaleOrderFetcher', function (require) {
    'use strict';

    const { Gui } = require('point_of_sale.Gui');
    const { isConnectionError } = require('point_of_sale.utils');

    const { EventBus } = owl;

    class SaleOrderFetcher extends EventBus {
        constructor() {
            super();
            this.currentPage = 1;
            this.ordersToShow = [];
            this.totalCount = 0;
        }


        /**
         * for nPerPage = 10
         * +--------+----------+
         * | nItems | lastPage |
         * +--------+----------+
         * |     2  |       1  |
         * |    10  |       1  |
         * |    11  |       2  |
         * |    30  |       3  |
         * |    35  |       4  |
         * +--------+----------+
         */
        get lastPage() {
            const nItems = this.totalCount;
            return Math.trunc(nItems / (this.nPerPage + 1)) + 1;
        }
        /**
         * Calling this methods populates the `ordersToShow` then trigger `update` event.
         * @related get
         *
         * NOTE: This is tightly-coupled with pagination. So if the current page contains all
         * active orders, it will not fetch anything from the server but only sets `ordersToShow`
         * to the active orders that fits the current page.
         */
        async fetch() {
            try {
                let limit, offset;
                // Show orders from the backend.
                offset =
                    this.nPerPage +
                    (this.currentPage - 1 - 1) *
                        this.nPerPage;
                limit = this.nPerPage;
                this.ordersToShow = await this._fetch(limit, offset);

                this.trigger('update');
            } catch (error) {
                if (isConnectionError(error)) {
                    Gui.showPopup('ErrorPopup', {
                        title: this.comp.env._t('Network Error'),
                        body: this.comp.env._t('Unable to fetch orders if offline.'),
                    });
                    Gui.setSyncStatus('error');
                } else {
                    throw error;
                }
            }
        }
        /**
         * This returns the orders from the backend that needs to be shown.
         * If the order is already in cache, the full information about that
         * order is not fetched anymore, instead, we use info from cache.
         *
         * @param {number} limit
         * @param {number} offset
         */
        async _fetch(limit, offset) {
            const sale_orders = await this._getOrderIdsForCurrentPage(limit, offset);

            this.totalCount = sale_orders.length;
            return sale_orders;
        }
        async _getOrderIdsForCurrentPage(limit, offset) {
            let domain = [['currency_id', '=', this.comp.env.pos.currency.id]].concat(this.searchDomain || []);
            const saleOrders = await this.rpc({
                model: 'sale.order',
                method: 'search_read',
                args: [domain, ['name', 'partner_id', 'amount_total', 'date_order', 'state', 'user_id', 'amount_unpaid'], offset, limit],
                context: this.comp.env.session.user_context,
            });

            return saleOrders;
        }

        nextPage() {
            if (this.currentPage < this.lastPage) {
                this.currentPage += 1;
                this.fetch();
            }
        }
        prevPage() {
            if (this.currentPage > 1) {
                this.currentPage -= 1;
                this.fetch();
            }
        }
        /**
         * @param {integer|undefined} id id of the cached order
         * @returns {Array<models.Order>}
         */
        get(id) {
            return this.ordersToShow;
        }
        setSearchDomain(searchDomain) {
            this.searchDomain = searchDomain;
        }
        setComponent(comp) {
            this.comp = comp;
            return this;
        }
        setNPerPage(val) {
            this.nPerPage = val;
        }
        setPage(page) {
            this.currentPage = page;
        }

        async rpc() {
            Gui.setSyncStatus('connecting');
            const result = await this.comp.rpc(...arguments);
            Gui.setSyncStatus('connected');
            return result;
        }
    }

    return new SaleOrderFetcher();
});
;

/*****************************************************************************
*  Filepath: /pos_sale/static/src/js/OrderManagementScreen/SaleOrderList.js  *
*  Lines: 32                                                                 *
*****************************************************************************/
odoo.define('pos_sale.SaleOrderList', function (require) {
    'use strict';

    const { useListener } = require("@web/core/utils/hooks");
    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    const { useState } = owl;

    /**
     * @props {models.Order} [initHighlightedOrder] initially highligted order
     * @props {Array<models.Order>} orders
     */
    class SaleOrderList extends PosComponent {
        setup() {
            super.setup();
            useListener('click-order', this._onClickOrder);
            this.state = useState({ highlightedOrder: this.props.initHighlightedOrder || null });
        }
        get highlightedOrder() {
            return this.state.highlightedOrder;
        }
        _onClickOrder({ detail: order }) {
            this.state.highlightedOrder = order;
        }
    }
    SaleOrderList.template = 'SaleOrderList';

    Registries.Component.add(SaleOrderList);

    return SaleOrderList;
});
;

/***********************************************************************************************
*  Filepath: /pos_sale/static/src/js/OrderManagementScreen/SaleOrderManagementControlPanel.js  *
*  Lines: 127                                                                                  *
***********************************************************************************************/
odoo.define('pos_sale.SaleOrderManagementControlPanel', function (require) {
    'use strict';

    const { useAutofocus, useListener } = require("@web/core/utils/hooks");
    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');
    const SaleOrderFetcher = require('pos_sale.SaleOrderFetcher');
    const contexts = require('point_of_sale.PosContext');

    const { useState } = owl;

    // NOTE: These are constants so that they are only instantiated once
    // and they can be used efficiently by the OrderManagementControlPanel.
    const VALID_SEARCH_TAGS = new Set(['date', 'customer', 'client', 'name', 'order']);
    const FIELD_MAP = {
        date: 'date_order',
        customer: 'partner_id.display_name',
        client: 'partner_id.display_name',
        name: 'name',
        order: 'name',
    };
    const SEARCH_FIELDS = ['name', 'partner_id.display_name', 'date_order'];

    /**
     * @emits close-screen
     * @emits prev-page
     * @emits next-page
     * @emits search
     */
    class SaleOrderManagementControlPanel extends PosComponent {
        setup() {
            super.setup();
            this.orderManagementContext = useState(contexts.orderManagement);
            useListener('clear-search', this._onClearSearch);
            useAutofocus();

            let currentPartner = this.env.pos.get_order().get_partner();
            if (currentPartner) {
                this.orderManagementContext.searchString = currentPartner.name;
            }
            SaleOrderFetcher.setSearchDomain(this._computeDomain());
        }
        onInputKeydown(event) {
            if (event.key === 'Enter') {
                this.trigger('search', this._computeDomain());
            }
        }
        get showPageControls() {
            return SaleOrderFetcher.lastPage > 1;
        }
        get pageNumber() {
            const currentPage = SaleOrderFetcher.currentPage;
            const lastPage = SaleOrderFetcher.lastPage;
            return isNaN(lastPage) ? '' : `(${currentPage}/${lastPage})`;
        }
        get validSearchTags() {
            return VALID_SEARCH_TAGS;
        }
        get fieldMap() {
            return FIELD_MAP;
        }
        get searchFields() {
            return SEARCH_FIELDS;
        }
        /**
         * E.g. 1
         * ```
         *   searchString = 'Customer 1'
         *   result = [
         *      '|',
         *      '|',
         *      ['pos_reference', 'ilike', '%Customer 1%'],
         *      ['partner_id.display_name', 'ilike', '%Customer 1%'],
         *      ['date_order', 'ilike', '%Customer 1%']
         *   ]
         * ```
         *
         * E.g. 2
         * ```
         *   searchString = 'date: 2020-05'
         *   result = [
         *      ['date_order', 'ilike', '%2020-05%']
         *   ]
         * ```
         *
         * E.g. 3
         * ```
         *   searchString = 'customer: Steward, date: 2020-05-01'
         *   result = [
         *      ['partner_id.display_name', 'ilike', '%Steward%'],
         *      ['date_order', 'ilike', '%2020-05-01%']
         *   ]
         * ```
         */
        _computeDomain() {
            let domain = [['state', '!=', 'cancel'],['invoice_status', '!=', 'invoiced']];
            const input = this.orderManagementContext.searchString.trim();
            if (!input) return domain;

            const searchConditions = this.orderManagementContext.searchString.split(/[,&]\s*/);
            if (searchConditions.length === 1) {
                let cond = searchConditions[0].split(/:\s*/);
                if (cond.length === 1) {
                  domain = domain.concat(Array(this.searchFields.length - 1).fill('|'));
                  domain = domain.concat(this.searchFields.map((field) => [field, 'ilike', `%${cond[0]}%`]));
                  return domain;
                }
            }

            for (let cond of searchConditions) {
                let [tag, value] = cond.split(/:\s*/);
                if (!this.validSearchTags.has(tag)) continue;
                domain.push([this.fieldMap[tag], 'ilike', `%${value}%`]);
            }
            return domain;
        }
        _onClearSearch() {
            this.orderManagementContext.searchString = '';
            this.onInputKeydown({ key: 'Enter' });
        }
    }
    SaleOrderManagementControlPanel.template = 'SaleOrderManagementControlPanel';

    Registries.Component.add(SaleOrderManagementControlPanel);

    return SaleOrderManagementControlPanel;
});
;

/*****************************************************************************************
*  Filepath: /pos_sale/static/src/js/OrderManagementScreen/SaleOrderManagementScreen.js  *
*  Lines: 343                                                                            *
*****************************************************************************************/
odoo.define('pos_sale.SaleOrderManagementScreen', function (require) {
    'use strict';

    const { sprintf } = require('web.utils');
    const { parse } = require('web.field_utils');
    const { useListener } = require("@web/core/utils/hooks");
    const ControlButtonsMixin = require('point_of_sale.ControlButtonsMixin');
    const NumberBuffer = require('point_of_sale.NumberBuffer');
    const Registries = require('point_of_sale.Registries');
    const SaleOrderFetcher = require('pos_sale.SaleOrderFetcher');
    const IndependentToOrderScreen = require('point_of_sale.IndependentToOrderScreen');
    const contexts = require('point_of_sale.PosContext');
    const { Orderline } = require('point_of_sale.models');

    const { onMounted, onWillUnmount, useState } = owl;

    /**
     * ID getter to take into account falsy many2one value.
     * @param {[id: number, display_name: string] | false} fieldVal many2one field value
     * @returns {number | false}
     */
    function getId(fieldVal) {
        return fieldVal && fieldVal[0];
    }

    class SaleOrderManagementScreen extends ControlButtonsMixin(IndependentToOrderScreen) {
        setup() {
            super.setup();
            useListener('close-screen', this.close);
            useListener('click-sale-order', this._onClickSaleOrder);
            useListener('next-page', this._onNextPage);
            useListener('prev-page', this._onPrevPage);
            useListener('search', this._onSearch);

            SaleOrderFetcher.setComponent(this);
            this.orderManagementContext = useState(contexts.orderManagement);

            onMounted(this.onMounted);
            onWillUnmount(this.onWillUnmount);
        }
        onMounted() {
            SaleOrderFetcher.on('update', this, this.render);

            // calculate how many can fit in the screen.
            // It is based on the height of the header element.
            // So the result is only accurate if each row is just single line.
            const flexContainer = this.el.querySelector('.flex-container');
            const cpEl = this.el.querySelector('.control-panel');
            const headerEl = this.el.querySelector('.header-row');
            const val = Math.trunc(
                (flexContainer.offsetHeight - cpEl.offsetHeight - headerEl.offsetHeight) /
                    headerEl.offsetHeight
            );
            SaleOrderFetcher.setNPerPage(val);

            // Fetch the order after mounting so that order management screen
            // is shown while fetching.
            setTimeout(() => SaleOrderFetcher.fetch(), 0);
        }
        onWillUnmount() {
            SaleOrderFetcher.off('update', this);
        }
        get selectedPartner() {
            const order = this.orderManagementContext.selectedOrder;
            return order ? order.get_partner() : null;
        }
        get orders() {
            return SaleOrderFetcher.get();
        }
        async _setNumpadMode(event) {
            const { mode } = event.detail;
            this.numpadMode = mode;
            NumberBuffer.reset();
        }
        _onNextPage() {
            SaleOrderFetcher.nextPage();
        }
        _onPrevPage() {
            SaleOrderFetcher.prevPage();
        }
        _onSearch({ detail: domain }) {
            SaleOrderFetcher.setSearchDomain(domain);
            SaleOrderFetcher.setPage(1);
            SaleOrderFetcher.fetch();
        }
        _getSaleOrderOrigin(order) {
            for (const line of order.get_orderlines()) {
                if (line.sale_order_origin_id) {
                    return line.sale_order_origin_id
                }
            }
            return false;
        }
        async _onClickSaleOrder(event) {
            const clickedOrder = event.detail;
            const { confirmed, payload: selectedOption } = await this.showPopup('SelectionPopup',
                {
                    title: this.env._t('What do you want to do?'),
                    list: [{id:"0", label: this.env._t("Apply a down payment"), item: false}, {id:"1", label: this.env._t("Settle the order"), item: true}],
                });

            if(confirmed){
              let currentPOSOrder = this.env.pos.get_order();
              let sale_order = await this._getSaleOrder(clickedOrder.id);
              const currentSaleOrigin = this._getSaleOrderOrigin(currentPOSOrder);
              const currentSaleOriginId = currentSaleOrigin && currentSaleOrigin.id;

              if (currentSaleOriginId) {
                const linkedSO = await this._getSaleOrder(currentSaleOriginId);
                if (
                    getId(linkedSO.partner_id) !== getId(sale_order.partner_id) ||
                    getId(linkedSO.partner_invoice_id) !== getId(sale_order.partner_invoice_id) ||
                    getId(linkedSO.partner_shipping_id) !== getId(sale_order.partner_shipping_id)
                ) {
                    currentPOSOrder = this.env.pos.add_new_order();
                    this.showNotification(this.env._t("A new order has been created."));
                }
              }

              try {
                await this.env.pos.load_new_partners();
              }
              catch (_error){
              }
              let order_partner = this.env.pos.db.get_partner_by_id(sale_order.partner_id[0])
              if(order_partner){
                currentPOSOrder.set_partner(order_partner);
              } else {
                try {
                    await this.env.pos._loadPartners([sale_order.partner_id[0]]);
                }
                catch (_error){
                    const title = this.env._t('Customer loading error');
                    const body = _.str.sprintf(this.env._t('There was a problem in loading the %s customer.'), sale_order.partner_id[1]);
                    await this.showPopup('ErrorPopup', { title, body });
                }
                currentPOSOrder.set_partner(this.env.pos.db.get_partner_by_id(sale_order.partner_id[0]));
              }

              let orderFiscalPos = sale_order.fiscal_position_id ? this.env.pos.fiscal_positions.find(
                  (position) => position.id === sale_order.fiscal_position_id[0]
              )
              : false;
              if (orderFiscalPos){
                  currentPOSOrder.fiscal_position = orderFiscalPos;
              }
              let orderPricelist = sale_order.pricelist_id ? this.env.pos.pricelists.find(
                  (pricelist) => pricelist.id === sale_order.pricelist_id[0]
              )
              : false;
              if (orderPricelist){
                  currentPOSOrder.set_pricelist(orderPricelist);
              }

              if (selectedOption){
                // settle the order
                let lines = sale_order.order_line;
                let product_to_add_in_pos = lines.filter(line => !this.env.pos.db.get_product_by_id(line.product_id[0])).map(line => line.product_id[0]);
                if (product_to_add_in_pos.length){
                    const { confirmed } = await this.showPopup('ConfirmPopup', {
                        title: this.env._t('Products not available in POS'),
                        body:
                            this.env._t(
                                'Some of the products in your Sale Order are not available in POS, do you want to import them?'
                            ),
                        confirmText: this.env._t('Yes'),
                        cancelText: this.env._t('No'),
                    });
                    if (confirmed){
                        await this.env.pos._addProducts(product_to_add_in_pos);
                    }

                }

                /**
                 * This variable will have 3 values, `undefined | false | true`.
                 * Initially, it is `undefined`. When looping thru each sale.order.line,
                 * when a line comes with lots (`.lot_names`), we use these lot names
                 * as the pack lot of the generated pos.order.line. We ask the user
                 * if he wants to use the lots that come with the sale.order.lines to
                 * be used on the corresponding pos.order.line only once. So, once the
                 * `useLoadedLots` becomes true, it will be true for the succeeding lines,
                 * and vice versa.
                 */
                let useLoadedLots;

                for (var i = 0; i < lines.length; i++) {
                    let line = lines[i];
                    if (!this.env.pos.db.get_product_by_id(line.product_id[0])){
                        continue;
                    }

                    let new_line = Orderline.create({}, {
                        pos: this.env.pos,
                        order: this.env.pos.get_order(),
                        product: this.env.pos.db.get_product_by_id(line.product_id[0]),
                        description: line.name,
                        price: line.price_unit,
                        tax_ids: orderFiscalPos ? undefined : line.tax_id,
                        price_manually_set: true,
                        sale_order_origin_id: clickedOrder,
                        sale_order_line_id: line,
                        customer_note: line.customer_note,
                    });

                    if (
                        new_line.get_product().tracking !== 'none' &&
                        (this.env.pos.picking_type.use_create_lots || this.env.pos.picking_type.use_existing_lots) &&
                        line.lot_names.length > 0
                    ) {
                        // Ask once when `useLoadedLots` is undefined, then reuse it's value on the succeeding lines.
                        const { confirmed } =
                            useLoadedLots === undefined
                                ? await this.showPopup('ConfirmPopup', {
                                      title: this.env._t('SN/Lots Loading'),
                                      body: this.env._t(
                                          'Do you want to load the SN/Lots linked to the Sales Order?'
                                      ),
                                      confirmText: this.env._t('Yes'),
                                      cancelText: this.env._t('No'),
                                  })
                                : { confirmed: useLoadedLots };
                        useLoadedLots = confirmed;
                        if (useLoadedLots) {
                            new_line.setPackLotLines({
                                modifiedPackLotLines: [],
                                newPackLotLines: (line.lot_names || []).map((name) => ({ lot_name: name })),
                            });
                        }
                    }
                    new_line.setQuantityFromSOL(line);
                    new_line.set_unit_price(line.price_unit);
                    new_line.set_discount(line.discount);
                    this.env.pos.get_order().add_orderline(new_line);
                }
              }
              else {
                // apply a downpayment
                if (this.env.pos.config.down_payment_product_id){

                    let lines = sale_order.order_line;
                    let tab = [];

                    for (let i=0; i<lines.length; i++) {
                        tab[i] = {
                            'product_name': lines[i].product_id[1],
                            'product_uom_qty': lines[i].product_uom_qty,
                            'price_unit': lines[i].price_unit,
                            'total': lines[i].price_total,
                        };
                    }
                    let down_payment_product = this.env.pos.db.get_product_by_id(this.env.pos.config.down_payment_product_id[0]);
                    if (!down_payment_product) {
                        await this.env.pos._addProducts([this.env.pos.config.down_payment_product_id[0]]);
                        down_payment_product = this.env.pos.db.get_product_by_id(this.env.pos.config.down_payment_product_id[0]);
                    }
                    let down_payment_tax = this.env.pos.taxes_by_id[down_payment_product.taxes_id] || false ;
                    let down_payment;
                    if (down_payment_tax) {
                        down_payment = down_payment_tax.price_include ? sale_order.amount_total : sale_order.amount_untaxed;
                    }
                    else{
                        down_payment = sale_order.amount_total;
                    }

                    const { confirmed, payload } = await this.showPopup('NumberPopup', {
                        title: sprintf(this.env._t("Percentage of %s"), this.env.pos.format_currency(sale_order.amount_total)),
                        startingValue: 0,
                    });
                    if (confirmed){
                        down_payment = down_payment * parse.float(payload) / 100;
                    }

                    if (down_payment > sale_order.amount_unpaid) {
                        const errorBody = sprintf(
                            this.env._t("You have tried to charge a down payment of %s but only %s remains to be paid, %s will be applied to the purchase order line."),
                            this.env.pos.format_currency(down_payment),
                            this.env.pos.format_currency(sale_order.amount_unpaid),
                            sale_order.amount_unpaid > 0 ? this.env.pos.format_currency(sale_order.amount_unpaid) : this.env.pos.format_currency(0),
                        );
                        await this.showPopup('ErrorPopup', { title: 'Error amount too high', body: errorBody });
                        down_payment = sale_order.amount_unpaid > 0 ? sale_order.amount_unpaid : 0;
                    }

                    let new_line = Orderline.create({}, {
                        pos: this.env.pos,
                        order: this.env.pos.get_order(),
                        product: down_payment_product,
                        price: down_payment,
                        price_automatically_set: true,
                        sale_order_origin_id: clickedOrder,
                        down_payment_details: tab,
                    });
                    new_line.set_unit_price(down_payment);
                    this.env.pos.get_order().add_orderline(new_line);
                }
                else {
                    const title = this.env._t('No down payment product');
                    const body = this.env._t(
                        "It seems that you didn't configure a down payment product in your point of sale.\
                        You can go to your point of sale configuration to choose one."
                    );
                    await this.showPopup('ErrorPopup', { title, body });
                }
              }

              this.close();
            }

        }

        async _getSaleOrder(id) {
            const sale_order = await this.rpc({
                model: 'sale.order',
                method: 'read',
                args: [[id],['order_line', 'partner_id', 'pricelist_id', 'fiscal_position_id', 'amount_total', 'amount_untaxed', 'amount_unpaid', 'partner_shipping_id', 'partner_invoice_id']],
                context: this.env.session.user_context,
            });

            const sale_lines = await this._getSOLines(sale_order[0].order_line);
            sale_order[0].order_line = sale_lines;

            return sale_order[0];
        }

        async _getSOLines(ids) {
          let so_lines = await this.rpc({
              model: 'sale.order.line',
              method: 'read_converted',
              args: [ids],
              context: this.env.session.user_context,
          });
          return so_lines;
        }

    }
    SaleOrderManagementScreen.template = 'SaleOrderManagementScreen';
    SaleOrderManagementScreen.hideOrderSelector = true;

    Registries.Component.add(SaleOrderManagementScreen);

    return SaleOrderManagementScreen;
});
;

/****************************************************************************
*  Filepath: /pos_sale/static/src/js/OrderManagementScreen/SaleOrderRow.js  *
*  Lines: 70                                                                *
****************************************************************************/
odoo.define('pos_sale.SaleOrderRow', function (require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');
    const utils = require('web.utils');

    /**
     * @props {models.Order} order
     * @props columns
     * @emits click-order
     */
    class SaleOrderRow extends PosComponent {
        get order() {
            return this.props.order;
        }
        get highlighted() {
            const highlightedOrder = this.props.highlightedOrder;
            return !highlightedOrder ? false : highlightedOrder.backendId === this.props.order.backendId;
        }

        // Column getters //

        get name() {
            return this.order.name;
        }
        get date() {
            return moment(this.order.date_order).format('YYYY-MM-DD hh:mm A');
        }
        get partner() {
            const partner = this.order.partner_id;
            return partner ? partner[1] : null;
        }
        get total() {
            return this.env.pos.format_currency(this.order.amount_total);
        }
        /**
         * Returns true if the order has unpaid amount, but the unpaid amount
         * should not be the same as the total amount.
         * @returns {boolean}
         */
        get showAmountUnpaid() {
            const isFullAmountUnpaid = utils.float_is_zero(Math.abs(this.order.amount_total - this.order.amount_unpaid), this.env.pos.currency.decimal_places);
            return !isFullAmountUnpaid && !utils.float_is_zero(this.order.amount_unpaid, this.env.pos.currency.decimal_places);
        }
        get amountUnpaidRepr() {
            return this.env.pos.format_currency(this.order.amount_unpaid);
        }
        get state() {
            let state_mapping = {
              'draft': this.env._t('Quotation'),
              'sent': this.env._t('Quotation Sent'),
              'sale': this.env._t('Sales Order'),
              'done': this.env._t('Locked'),
              'cancel': this.env._t('Cancelled'),
            };

            return state_mapping[this.order.state];
        }
        get salesman() {
            const salesman = this.order.user_id;
            return salesman ? salesman[1] : null;
        }
    }
    SaleOrderRow.template = 'SaleOrderRow';

    Registries.Component.add(SaleOrderRow);

    return SaleOrderRow;
});
;

/**************************************************
*  Filepath: /pos_stripe/static/src/js/models.js  *
*  Lines: 6                                       *
**************************************************/
odoo.define('pos_stripe.models', function (require) {
var models = require('point_of_sale.models');
var PaymentStripe = require('pos_stripe.payment');

models.register_payment_method('stripe', PaymentStripe);
});
;

/**********************************************************
*  Filepath: /pos_stripe/static/src/js/payment_stripe.js  *
*  Lines: 267                                             *
**********************************************************/
/* global StripeTerminal */
odoo.define('pos_stripe.payment', function (require) {
"use strict";

const core = require('web.core');
const rpc = require('web.rpc');
const PaymentInterface = require('point_of_sale.PaymentInterface');
const { Gui } = require('point_of_sale.Gui');

const _t = core._t;

let PaymentStripe = PaymentInterface.extend({
    init: function (pos, payment_method) {
        this._super(...arguments);
        this.createStripeTerminal();
    },

    stripeUnexpectedDisconnect: function () {
      // Include a way to attempt to reconnect to a reader ?
        this._showError(_t('Reader disconnected'));
    },

    stripeFetchConnectionToken: async function () {
        // Do not cache or hardcode the ConnectionToken.
        try {
            let data = await rpc.query({
                model: 'pos.payment.method',
                method: 'stripe_connection_token',
            }, {
                silent: true,
            });
            if (data.error) {
                throw data.error;
            }
            return data.secret;
        } catch (error) {
            this._showError(error.message.message, 'Fetch Token');
            this.terminal = false;
        };
    },

    discoverReaders: async function () {
        let discoverResult = await this.terminal.discoverReaders({});
        if (discoverResult.error) {
            this._showError(_.str.sprintf(_t('Failed to discover: %s'), discoverResult.error));
        } else if (discoverResult.discoveredReaders.length === 0) {
            this._showError(_t('No available Stripe readers.'));
        } else {
            // Need to stringify all Readers to avoid to put the array into a proxy Object not interpretable
            // for the Stripe SDK
            this.pos.discoveredReaders = JSON.stringify(discoverResult.discoveredReaders);
        }
    },

    checkReader: async function () {
        try {
            if ( !this.terminal ) {
                let createStripeTerminal = this.createStripeTerminal();
                if ( !createStripeTerminal ) {
                    throw _t('Failed to load resource: net::ERR_INTERNET_DISCONNECTED.');
                }
            }
        } catch (error) {
            this._showError(error);
            return false;
        }
        let line = this.pos.get_order().selected_paymentline;
        // Because the reader can only connect to one instance of the SDK at a time.
        // We need the disconnect this reader if we want to use another one
        if (
            this.pos.connectedReader != this.payment_method.stripe_serial_number &&
            this.terminal.getConnectionStatus() == 'connected'
            ) {
            let disconnectResult = await this.terminal.disconnectReader();
            if (disconnectResult.error) {
                this._showError(disconnectResult.error.message, disconnectResult.error.code);
                line.set_payment_status('retry');
                return false;
            } else {
                return await this.connectReader();
            }
        } else if (this.terminal.getConnectionStatus() == 'not_connected') {
            return await this.connectReader();
        } else {
            return true;
        }
    },

    connectReader: async function () {
        let line = this.pos.get_order().selected_paymentline;
        let discoveredReaders = JSON.parse(this.pos.discoveredReaders);
        for (const selectedReader of discoveredReaders) {
            if (selectedReader.serial_number == this.payment_method.stripe_serial_number) {
                try {
                    let connectResult = await this.terminal.connectReader(selectedReader, {fail_if_in_use: true});
                    if (connectResult.error) {
                        throw connectResult;
                    }
                    this.pos.connectedReader = this.payment_method.stripe_serial_number;
                    return true;
                } catch (error) {
                    if (error.error) {
                        this._showError(error.error.message, error.code);
                    } else {
                        this._showError(error);
                    }
                    line.set_payment_status('retry');
                    return false;
                }
            }
        }
        this._showError(_.str.sprintf(
            _t('Stripe readers %s not listed in your account'), 
            this.payment_method.stripe_serial_number
        ));
    },

    collectPayment: async function (amount) {
        let line = this.pos.get_order().selected_paymentline;
        let clientSecret = await this.fetchPaymentIntentClientSecret(line.payment_method, amount);
        if (!clientSecret) {
            line.set_payment_status('retry');
            return false;
        }
        line.set_payment_status('waitingCard');
        let collectPaymentMethod = await this.terminal.collectPaymentMethod(clientSecret);
        if (collectPaymentMethod.error) {
            this._showError(collectPaymentMethod.error.message, collectPaymentMethod.error.code);
            line.set_payment_status('retry');
            return false;
        } else {
            line.set_payment_status('waitingCapture');
            let processPayment = await this.terminal.processPayment(collectPaymentMethod.paymentIntent);
            line.transaction_id = collectPaymentMethod.paymentIntent.id;
            if (processPayment.error) {
                this._showError(processPayment.error.message, processPayment.error.code);
                line.set_payment_status('retry');
                return false;
            } else if (processPayment.paymentIntent) {
                line.set_payment_status('waitingCapture');
                await this.captureAfterPayment(processPayment, line);
                line.set_payment_status('done');
                return true;
            }
        }
    },

    createStripeTerminal: function () {
        try {
            this.terminal = StripeTerminal.create({
                onFetchConnectionToken: this.stripeFetchConnectionToken.bind(this),
                onUnexpectedReaderDisconnect: this.stripeUnexpectedDisconnect.bind(this),
            });
            this.discoverReaders();
            return true;
        } catch (error) {
            this._showError(_t('Failed to load resource: net::ERR_INTERNET_DISCONNECTED.'), error);
            this.terminal = false;
            return false;
        }
    },

    captureAfterPayment: async function (processPayment, line) {
        let capturePayment = await this.capturePayment(processPayment.paymentIntent.id);
        if (capturePayment.charges)
            line.card_type = capturePayment.charges.data[0].payment_method_details.card_present.brand;
        line.transaction_id = capturePayment.id;
    },

    capturePayment: async function (paymentIntentId) {
        try {
            let data = await rpc.query({
                model: 'pos.payment.method',
                method: 'stripe_capture_payment',
                args: [paymentIntentId],
            }, {
                silent: true,
            });
            if (data.error) {
                throw data.error;
            }
            return data;
        } catch (error) {
            this._showError(error.message.message, 'Capture Payment');
            return false;
        };
    },

    fetchPaymentIntentClientSecret: async function (payment_method, amount) {
        try {
            let data = await rpc.query({
                model: 'pos.payment.method',
                method: 'stripe_payment_intent',
                args: [[payment_method.id], amount],
            }, {
                silent: true,
            });
            if (data.error) {
                throw data.error;
            }
            return data.client_secret;
        } catch (error) {
            this._showError(error.message.message, 'Fetch Secret');
            return false;
        };
    },

    send_payment_request: async function (cid) {
        /**
         * Override
         */
        await this._super.apply(this, arguments);
        let line = this.pos.get_order().selected_paymentline;
        line.set_payment_status('waiting');
        try {
            if (await this.checkReader()) {
                return await this.collectPayment(line.amount);
            }
        } catch (error) {
            this._showError(error);
            return false;
        }
    },

    send_payment_cancel: async function (order, cid) {
        /**
         * Override
         */
        this._super.apply(this, arguments);
        let line = this.pos.get_order().selected_paymentline;
        let stripeCancel = await this.stripeCancel();
        if (stripeCancel) {
            line.set_payment_status('retry');
            return true;
        }
    },

    stripeCancel: async function () {
        if (!this.terminal) {
            return true;
        } else if (this.terminal.getConnectionStatus() != 'connected') {
            this._showError(_t('Payment canceled because not reader connected'));
            return true;
        } else {
            let cancelCollectPaymentMethod = await this.terminal.cancelCollectPaymentMethod();
            if (cancelCollectPaymentMethod.error) {
                this._showError(cancelCollectPaymentMethod.error.message, cancelCollectPaymentMethod.error.code);
            }
            return true;
        }
    },

    // private methods

    _showError: function (msg, title) {
        if (!title) {
            title =  _t('Stripe Error');
        }
        Gui.showPopup('ErrorPopup',{
            'title': title,
            'body': msg,
        });
    },
});

return PaymentStripe;
});
;

/**********************************************
*  Filepath: /pos_hr/static/src/js/models.js  *
*  Lines: 82                                  *
**********************************************/
odoo.define('pos_hr.employees', function (require) {
    "use strict";

var { PosGlobalState, Order } = require('point_of_sale.models');
const Registries = require('point_of_sale.Registries');


const PosHrPosGlobalState = (PosGlobalState) => class PosHrPosGlobalState extends PosGlobalState {
    async _processData(loadedData) {
        await super._processData(...arguments);
        if (this.config.module_pos_hr) {
            this.employees = loadedData['hr.employee'];
            this.employee_by_id = loadedData['employee_by_id'];
            this.reset_cashier();
        }
    }
    async after_load_server_data() {
        await super.after_load_server_data(...arguments);
        if (this.config.module_pos_hr) {
            this.hasLoggedIn = !this.config.module_pos_hr;
        }
    }
    reset_cashier() {
        this.cashier = {name: null, id: null, barcode: null, user_id: null, pin: null, role: null};
    }
    set_cashier(employee) {
        this.cashier = employee;
        const selectedOrder = this.get_order();
        if (selectedOrder && !selectedOrder.get_orderlines().length) {
            // Order without lines can be considered to be un-owned by any employee.
            // We set the cashier on that order to the currently set employee.
            selectedOrder.cashier = employee;
        }
        if (!this.cashierHasPriceControlRights() && this.numpadMode === 'price') {
            this.numpadMode = 'quantity';
        }
    }

    /**{name: null, id: null, barcode: null, user_id:null, pin:null}
     * If pos_hr is activated, return {name: string, id: int, barcode: string, pin: string, user_id: int}
     * @returns {null|*}
     */
    get_cashier() {
        if (this.config.module_pos_hr) {
            return this.cashier;
        }
        return super.get_cashier();
    }
    get_cashier_user_id() {
        if (this.config.module_pos_hr) {
            return this.cashier.user_id ? this.cashier.user_id : null;
        }
        return super.get_cashier_user_id();
    }
}
Registries.Model.extend(PosGlobalState, PosHrPosGlobalState);


const PosHrOrder = (Order) => class PosHrOrder extends Order {
    constructor(obj, options) {
        super(...arguments);
        if (!options.json && this.pos.config.module_pos_hr) {
            this.cashier = this.pos.get_cashier();
        }
    }
    init_from_JSON(json) {
        super.init_from_JSON(...arguments);
        if (this.pos.config.module_pos_hr && json.employee_id) {
            this.cashier = this.pos.employee_by_id[json.employee_id];
        }
    }
    export_as_JSON() {
        const json = super.export_as_JSON(...arguments);
        if (this.pos.config.module_pos_hr) {
            json.employee_id = this.cashier ? this.cashier.id : false;
        }
        return json;
    }
}
Registries.Model.extend(Order, PosHrOrder);

});
;

/**********************************************************
*  Filepath: /pos_hr/static/src/js/SelectCashierMixin.js  *
*  Lines: 71                                              *
**********************************************************/
/* global Sha1 */
odoo.define('pos_hr.SelectCashierMixin', function (require) {
    'use strict';

    const SelectCashierMixin = (PosComponent) => class ComponentWithSelectCashierMixin extends PosComponent {
        async askPin(employee) {
            const { confirmed, payload: inputPin } = await this.showPopup('NumberPopup', {
                isPassword: true,
                title: this.env._t('Password ?'),
                startingValue: null,
            });

            if (!confirmed) return;

            if (employee.pin === Sha1.hash(inputPin)) {
                return employee;
            } else {
                await this.showPopup('ErrorPopup', {
                    title: this.env._t('Incorrect Password'),
                });
                return;
            }
        }

        /**
         * Select a cashier, the returning value will either be an object or nothing (undefined)
         */
        async selectCashier() {
            if (this.env.pos.config.module_pos_hr) {
                const employeesList = this.env.pos.employees
                    .filter((employee) => employee.id !== this.env.pos.get_cashier().id)
                    .map((employee) => {
                        return {
                            id: employee.id,
                            item: employee,
                            label: employee.name,
                            isSelected: false,
                        };
                    });
                let {confirmed, payload: employee} = await this.showPopup('SelectionPopup', {
                    title: this.env._t('Change Cashier'),
                    list: employeesList,
                });

                if (!confirmed) {
                    return;
                }

                if (employee && employee.pin) {
                    employee = await this.askPin(employee);
                }
                if (employee) {
                    this.env.pos.set_cashier(employee);
                }
                return employee;
            }
        }

        async barcodeCashierAction(code) {
            const employee = this.env.pos.employees.find(
                (emp) => emp.barcode === Sha1.hash(code.code)
            );
            if (employee && employee !== this.env.pos.get_cashier() && (!employee.pin || (await this.askPin(employee)))) {
                this.env.pos.set_cashier(employee);
            }
            return employee;
        }
    }

    return SelectCashierMixin;
});
;

/**********************************************
*  Filepath: /pos_hr/static/src/js/Chrome.js  *
*  Lines: 30                                  *
**********************************************/
odoo.define('pos_hr.chrome', function (require) {
    'use strict';

    const Chrome = require('point_of_sale.Chrome');
    const Registries = require('point_of_sale.Registries');

    const PosHrChrome = (Chrome) =>
        class extends Chrome {
            async start() {
                await super.start();
                if (this.env.pos.config.module_pos_hr) this.showTempScreen('LoginScreen');
            }
            get headerButtonIsShown() {
                return !this.env.pos.config.module_pos_hr || this.env.pos.get_cashier().role == 'manager' || this.env.pos.get_cashier_user_id() === this.env.pos.user.id;
            }
            showCashMoveButton() {
                return super.showCashMoveButton() && (!this.env.pos.cashier || this.env.pos.cashier.role == 'manager');
            }
            shouldShowCashControl() {
                if (this.env.pos.config.module_pos_hr){
                    return super.shouldShowCashControl() && this.env.pos.hasLoggedIn;
                }
                return super.shouldShowCashControl();
            }
        };

    Registries.Component.extend(Chrome, PosHrChrome);

    return Chrome;
});
;

/********************************************************
*  Filepath: /pos_hr/static/src/js/HeaderLockButton.js  *
*  Lines: 28                                            *
********************************************************/
odoo.define('point_of_sale.HeaderLockButton', function(require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');

    const { useState } = owl;

    class HeaderLockButton extends PosComponent {
        setup() {
            super.setup();
            this.state = useState({ isUnlockIcon: true, title: 'Unlocked' });
        }
        async showLoginScreen() {
            this.env.pos.reset_cashier();
            await this.showTempScreen('LoginScreen');
        }
        onMouseOver(isMouseOver) {
            this.state.isUnlockIcon = !isMouseOver;
            this.state.title = isMouseOver ? 'Lock' : 'Unlocked';
        }
    }
    HeaderLockButton.template = "HeaderLockButton";

    Registries.Component.add(HeaderLockButton);

    return HeaderLockButton;
});
;

/***************************************************
*  Filepath: /pos_hr/static/src/js/CashierName.js  *
*  Lines: 31                                       *
***************************************************/
odoo.define('pos_hr.CashierName', function (require) {
    'use strict';

    const CashierName = require('point_of_sale.CashierName');
    const Registries = require('point_of_sale.Registries');
    const SelectCashierMixin = require('pos_hr.SelectCashierMixin');
    const { useBarcodeReader } = require('point_of_sale.custom_hooks');

    const PosHrCashierName = (CashierName) =>
        class extends SelectCashierMixin(CashierName) {
            setup() {
                super.setup();
                useBarcodeReader({ cashier: this.barcodeCashierAction });
            }
            //@Override
            get avatar() {
                if (this.env.pos.config.module_pos_hr) {
                    const cashier = this.env.pos.get_cashier();
                    if (!(cashier && cashier.id)) {
                        return '';
                    }
                    return `/web/image/hr.employee/${cashier.id}/avatar_128`;
                }
                return super.avatar;
            }
        };

    Registries.Component.extend(CashierName, PosHrCashierName);

    return CashierName;
});
;

/***************************************************
*  Filepath: /pos_hr/static/src/js/LoginScreen.js  *
*  Lines: 43                                       *
***************************************************/
odoo.define('pos_hr.LoginScreen', function (require) {
    'use strict';

    const PosComponent = require('point_of_sale.PosComponent');
    const Registries = require('point_of_sale.Registries');
    const SelectCashierMixin = require('pos_hr.SelectCashierMixin');
    const { useBarcodeReader } = require('point_of_sale.custom_hooks');

    class LoginScreen extends SelectCashierMixin(PosComponent) {
        setup() {
            super.setup();
            useBarcodeReader({cashier: this.barcodeCashierAction}, true);
        }
        async selectCashier() {
            if (await super.selectCashier()) {
                this.back();
            }
        }
        async barcodeCashierAction(code) {
            if (await super.barcodeCashierAction(code) && this.env.pos.get_cashier().id) {
                this.back();
            }
        }
        back() {
            this.props.resolve({ confirmed: false, payload: false });
            this.trigger('close-temp-screen');
            this.env.pos.hasLoggedIn = true;
            this.env.posbus.trigger('start-cash-control');
        }
        confirm() {
            this.props.resolve({ confirmed: true, payload: true });
            this.trigger('close-temp-screen');
        }
        get shopName() {
            return this.env.pos.config.name;
        }
    }
    LoginScreen.template = 'LoginScreen';

    Registries.Component.add(LoginScreen);

    return LoginScreen;
});
;

/*****************************************************
*  Filepath: /pos_hr/static/src/js/PaymentScreen.js  *
*  Lines: 18                                         *
*****************************************************/
odoo.define('pos_hr.PaymentScreen', function (require) {
    'use strict';

    const PaymentScreen = require('point_of_sale.PaymentScreen');
    const Registries = require('point_of_sale.Registries');

    const PosHrPaymentScreen = (PaymentScreen_) =>
          class extends PaymentScreen_ {
              async _finalizeValidation() {
                  this.currentOrder.cashier = this.env.pos.get_cashier();
                  await super._finalizeValidation();
              }
          };

    Registries.Component.extend(PaymentScreen, PosHrPaymentScreen);

    return PaymentScreen;
});
;

/*********************************************************************
*  Filepath: /pos_sale_product_configurator/static/src/js/models.js  *
*  Lines: 48                                                         *
*********************************************************************/
odoo.define('pos_sale_product_configurator.models', function (require) {
    "use strict";

    const { Gui } = require('point_of_sale.Gui');
    var { Order } = require('point_of_sale.models');
    const Registries = require('point_of_sale.Registries');
    const { ConnectionLostError, ConnectionAbortedError } = require('@web/core/network/rpc_service')
    const { identifyError } = require('point_of_sale.utils');


    const PosSaleProductConfiguratorOrder = (Order) => class PosSaleProductConfiguratorOrder extends Order {
        async add_product(product, options) {
            super.add_product(...arguments);
            if (product.optional_product_ids.length) {
                // The `optional_product_ids` only contains ids of the product templates and not the product itself
                // We don't load all the product template in the pos, so it'll be hard to know if the id comes from
                // a product available in POS. We send a quick cal to the back end to verify.
                const isProductLoaded = await this.pos.env.services.rpc(
                    {
                        model: 'product.product',
                        method: 'has_optional_product_in_pos',
                        args: [[product.id]]
                    }
                );
                if (isProductLoaded) {
                    try {
                        const quantity = this.get_selected_orderline().get_quantity();
                        const info = await this.pos.getProductInfo(product, quantity);
                        Gui.showPopup('ProductInfoPopup', { info: info , product: product });
                    } catch (e) {
                        if (identifyError(e) instanceof ConnectionLostError||ConnectionAbortedError) {
                            Gui.showPopup('OfflineErrorPopup', {
                                title: this.env._t('Network Error'),
                                body: this.env._t('Cannot access product information screen if offline.'),
                            });
                        } else {
                            Gui.showPopup('ErrorPopup', {
                                title: this.env._t('Unknown error'),
                                body: this.env._t('An unknown error prevents us from loading product information.'),
                            });
                        }
                    }
                }
            }
        }
    }
    Registries.Model.extend(Order, PosSaleProductConfiguratorOrder);
})


                    /*******************************************
                    *  Templates                               *
                    *******************************************/

                    odoo.define('point_of_sale.assets.bundle.xml', function(require){
                        'use strict';
                        const { loadXML } = require('@web/core/assets');
                        const templates = `<?xml version="1.0" encoding="UTF-8"?>
<templates xml:space="preserve">
<!-- Filepath: /point_of_sale/static/src/xml/Chrome.xml => /pos_hr/static/src/xml/Chrome.xml -->
<t t-name="Chrome" owl="1">
        <div class="pos" t-att-class="{ 'big-scrollbars': state.hasBigScrollBars }">
            <div class="pos-receipt-print"/>
            <div class="pos-topheader" t-att-class="{ oe_hidden: state.uiState !== 'READY' }">
                <div t-if="tempScreen.isShown" class="block-top-header"/>
                <div class="pos-branding">
                    <img t-if="!env.isMobile" class="pos-logo" t-on-click="() =&gt; this.trigger('toggle-debug-widget')" src="/point_of_sale/static/src/img/logo.png" alt="Logo"/>
                    <CashMoveButton t-if="showCashMoveButton()"/>
                    <TicketButton isTicketScreenShown="isTicketScreenShown"/>
                </div>
                <div class="pos-rightheader">
                    <div class="status-buttons" t-if="state.uiState === 'READY'">
                        <CashierName/>
                        <SaleDetailsButton t-if="env.proxy.printer" isHeaderButton="true"/>
                        <ProxyStatus t-if="env.pos.config.use_proxy"/>
                        <CustomerFacingDisplayButton t-if="customerFacingDisplayButtonIsShown"/>
                        <SyncNotification/>
                        <!-- Filepath: /pos_hr/static/src/xml/Chrome.xml ; position="replace" ; {'expr': '//HeaderButton'} --><HeaderLockButton t-if="env.pos.config.module_pos_hr"/>
            <HeaderButton t-if="headerButtonIsShown"/>
        </div>
                </div>
            </div>
            <t t-if="state.uiState === 'READY'">
                <div class="pos-content">
                    <div class="window">
                        <div class="subwindow">
                            <div class="subwindow-container">
                                <div class="subwindow-container-fix screens">
                                    <t isShown="!tempScreen.isShown" t-component="mainScreen.component" t-props="mainScreenPropsFielded" t-key="mainScreen.name"/>
                                    <t t-if="tempScreen.isShown" t-component="tempScreen.component" t-props="tempScreenProps" t-key="tempScreen.name"/>
                                </div>
                            </div>
                        </div>
                    </div>
                    <Transition t-if="env.isDebug()" visible="state.debugWidgetIsShown" name="'o-fade'" leaveDuration="200" t-slot-scope="transition">
                        <DebugWidget className="transition.className"/>
                    </Transition>
                </div>
            </t>

            <Transition visible="['LOADING', 'CLOSING'].includes(state.uiState)" name="'o-swing'" leaveDuration="800" t-slot-scope="transition">
                <div class="loader" t-att-class="transition.className">
                    <div class="loader-feedback">

                        <div class="lds-ellipsis"><div/><div/><div/><div/></div>
                        <t t-if="state.loadingSkipButtonIsShown">
                            <h1 class="message">Connecting to devices</h1>
                            <div class="button skip" t-on-click="() =&gt; this.trigger('loading-skip-callback')">
                                Skip
                            </div>
                        </t>
                    </div>
                </div>
            </Transition>


            <PosPopupController/>

            <Transition name="'o-fade'" visible="state.notification.isShown" leaveDuration="200" t-slot-scope="transition">
                <Notification message="state.notification.message" duration="state.notification.duration" className="transition.className"/>
            </Transition>

            <NotificationSound t-if="state.sound.src" sound="state.sound"/>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/ChromeWidgets/CashMoveButton.xml -->

<t t-name="point_of_sale.CashMoveButton" owl="1">
        <div class="cash-move-button" t-on-click="onClick">
            <i class="fa fa-money" aria-hidden="true"/>
            <span style="padding-left: 10px;">Cash In/Out</span>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/ChromeWidgets/CashierName.xml => /pos_hr/static/src/xml/CashierName.xml -->

<t t-name="CashierName" owl="1"><!-- Filepath: /pos_hr/static/src/xml/CashierName.xml ; position="attributes" ; {'expr': '//div'} -->
        <div class="oe_status" t-on-click="selectCashier">
            <span><img t-att-src="avatar" t-att-alt="username" class="avatar"/> <span t-if="!env.isMobile" t-esc="username" class="username"/></span>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/ChromeWidgets/CustomerFacingDisplayButton.xml -->

<t t-name="CustomerFacingDisplayButton" owl="1">
        <div class="oe_status" t-on-click="onClick">
            <span class="message"><t t-esc="message"/></span>
            <div t-if="state.status === 'warning'" class="js_warning oe_icon oe_orange">
                <i class="fa fa-fw fa-desktop" role="img" aria-label="Customer Screen Warning" title="Customer Screen Warning"/>
            </div>
             <div t-if="state.status === 'failure'" class="js_disconnected oe_icon oe_red">
                <i class="fa fa-fw fa-desktop" role="img" aria-label="Customer Screen Disconnected" title="Customer Screen Disconnected"/>
            </div>
            <div t-if="state.status === 'success'" class="js_connected oe_icon oe_green">
                <i class="fa fa-fw fa-desktop" role="img" aria-label="Customer Screen Connected" title="Customer Screen Connected"/>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/ChromeWidgets/DebugWidget.xml -->

<t t-name="DebugWidget" owl="1">
        <Draggable limitArea="'.pos'">
            <div class="debug-widget" t-att-class="props.className">
                <header class="drag-handle">
                    <h1>Debug Window</h1>
                </header>
                <div class="toggle" t-on-click="() =&gt; this.trigger('toggle-debug-widget')" title="Dismiss" role="img" aria-label="Dismiss"><i class="fa fa-times"/></div>
                <div class="content">
                    <p class="category">Electronic Scale</p>
                    <ul>
                        <li>
                            <input t-model="state.weightInput" type="text" class="weight"/>
                        </li>
                        <li class="button set_weight" t-on-click="setWeight">Set Weight</li>
                        <li class="button reset_weight" t-on-click="resetWeight">Reset</li>
                    </ul>

                    <p class="category">Barcode Scanner</p>
                    <ul>
                        <li>
                            <input t-model="state.barcodeInput" type="text" class="ean"/>
                        </li>
                        <li class="button barcode" t-on-click="barcodeScan">Scan</li>
                        <li class="button custom_ean" t-on-click="barcodeScanEAN">Scan EAN-13</li>
                    </ul>

                    <p class="category">Orders</p>

                    <ul>
                        <li class="button" t-on-click="deleteOrders">
                            Delete Paid Orders
                        </li>
                        <li class="button" t-on-click="deleteUnpaidOrders">
                            Delete Unpaid Orders
                        </li>
                        <li t-if="!state.isPaidOrdersReady" class="button" t-on-click="preparePaidOrders">
                            Export Paid Orders
                        </li>
                        <a t-else="" t-att-download="paidOrdersFilename" t-att-href="paidOrdersURL" t-on-click="() =&gt; { state.isPaidOrdersReady = !state.isPaidOrdersReady }">
                            <li class="button">
                                Download Paid Orders
                            </li>
                        </a>
                        <li t-if="!state.isUnpaidOrdersReady" class="button" t-on-click="prepareUnpaidOrders">
                            Export Unpaid Orders
                        </li>
                        <a t-else="" t-att-download="unpaidOrdersFilename" t-att-href="unpaidOrdersURL" t-on-click="() =&gt; { state.isUnpaidOrdersReady = !state.isUnpaidOrdersReady }">
                            <li class="button">
                                Download Unpaid Orders
                            </li>
                        </a>
                        <li class="button import_orders" style="position:relative">
                            Import Orders
                            <input t-on-change="importOrders" type="file" style="opacity:0;position:absolute;top:0;left:0;right:0;bottom:0;margin:0;cursor:pointer"/>
                        </li>
                    </ul>

                    <p class="category">Hardware Status</p>
                    <ul>
                        <li class="status weighing">Weighing</li>
                        <li class="button display_refresh" t-on-click="refreshDisplay">
                            Refresh Display
                        </li>
                    </ul>
                    <p class="category">Hardware Events</p>
                    <ul>
                        <li class="event" t-ref="open_cashbox">Open Cashbox</li>
                        <li class="event" t-ref="print_receipt">Print Receipt</li>
                        <li class="event" t-ref="scale_read">Read Weighing Scale</li>
                    </ul>
                    <p class="category">Others</p>
                    <ul>
                        <li class="event">
                            <span>Buffer: </span>
                            <t t-esc="bufferRepr"/>
                        </li>
                    </ul>
                </div>
            </div>
        </Draggable>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/ChromeWidgets/HeaderButton.xml -->

<t t-name="HeaderButton" owl="1">
        <div class="header-button" t-on-click="onClick">
            <span><i class="fa fa-sign-out" role="img"/> <t t-if="!env.isMobile">Close</t></span>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/ChromeWidgets/ProxyStatus.xml -->

<t t-name="ProxyStatus" owl="1">
        <div class="oe_status js_proxy" t-on-click="() =&gt; this.trigger('connect-to-proxy')">
            <span t-if="state.msg and !env.isMobile" class="js_msg">
                <t t-esc="state.msg"/>
            </span>
            <span t-if="state.status === 'connected'" class="js_connected oe_green">
                <i class="fa fa-fw fa-sitemap" role="img" aria-label="Proxy Connected" title="Proxy Connected"/>
            </span>
            <span t-if="state.status === 'connecting'" class="js_connecting">
                <i class="fa fa-fw fa-spin fa-circle-o-notch" role="img" aria-label="Connecting to Proxy" title="Connecting to Proxy"/>
            </span>
            <span t-if="state.status === 'warning'" class="js_warning oe_orange">
                <i class="fa fa-fw fa-sitemap" role="img" aria-label="Proxy Warning" title="Proxy Warning"/>
            </span>
            <span t-if="state.status === 'disconnected'" class="js_disconnected oe_red">
                <i class="fa fa-fw fa-sitemap" role="img" aria-label="Proxy Disconnected" title="Proxy Disconnected"/>
            </span>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/ChromeWidgets/SaleDetailsButton.xml -->

<t t-name="SaleDetailsButton" owl="1">
        <div t-att-class="{'oe_status': props.isHeaderButton }" t-on-click="onClick">
            <div class="js_connected oe_icon" title="Print a report with all the sales of the current PoS Session">
                <i class="fa fa-fw fa-print" role="img" aria-label="Print"/>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/ChromeWidgets/SyncNotification.xml -->

<t t-name="SyncNotification" owl="1">
        <div class="oe_status" t-on-click="onClick">
            <span t-if="env.pos.synch.pending" class="js_msg">
                <t t-esc="env.pos.synch.pending"/>
                <span> </span>
            </span>
            <div t-if="env.pos.synch.status === 'connected'" class="js_connected oe_icon oe_green">
                <i class="fa fa-fw fa-wifi" role="img" aria-label="Synchronisation Connected" title="Synchronisation Connected"/>
            </div>
            <div t-if="env.pos.synch.status === 'connecting'" class="js_connecting oe_icon">
                <i class="fa fa-fw fa-spin fa-circle-o-notch" role="img" aria-label="Synchronisation Connecting" title="Synchronisation Connecting"/>
            </div>
            <div t-if="env.pos.synch.status === 'disconnected'" class="js_disconnected oe_icon oe_red">
                <i class="fa fa-fw fa-wifi" role="img" aria-label="Synchronisation Disconnected" title="Synchronisation Disconnected"/>
            </div>
            <div t-if="env.pos.synch.status === 'error'" class="js_error oe_icon oe_red">
                <i class="fa fa-fw fa-warning" role="img" aria-label="Synchronisation Error" title="Synchronisation Error"/>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/ChromeWidgets/TicketButton.xml -->

<t t-name="TicketButton" owl="1">
        <div class="ticket-button" t-att-class="{ highlight: props.isTicketScreenShown }" t-on-click="onClick">
            <div class="with-badge" t-att-badge="count">
                <i class="fa fa-ticket" aria-hidden="true"/>
            </div>
            <div t-if="!env.isMobile">Orders</div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/CustomerFacingDisplay/CustomerFacingDisplayOrder.xml -->

<t t-name="CustomerFacingDisplayHead">
        <div class="resources">
            <base t-att-href="origin"/>
            <meta http-equiv="cache-control" content="no-cache"/>
            <meta http-equiv="pragma" content="no-cache"/>
            <link rel="stylesheet" type="text/css" href="/web/static/lib/bootstrap/css/bootstrap.css"/>
            <link rel="stylesheet" type="text/css" href="/web/static/src/libs/fontawesome/css/font-awesome.css"/>
            <link rel="stylesheet" type="text/css" href="/point_of_sale/static/src/css/customer_facing_display.css"/>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/CustomerFacingDisplay/CustomerFacingDisplayOrder.xml -->

    <t t-name="CustomerFacingDisplayOrder">

        <t t-call="CustomerFacingDisplayHead"/>

        <div class="pos-customer_facing_display pos-palette_01">

            <div class="pos-customer_products" name="Products list">
                <t t-call="CustomerFacingDisplayOrderLines"/>
            </div>

            <div class="pos-payment_info">

                <div class="pos-company_logo" t-attf-style="background-image:url(/logo?company=#{pos.company.id})"/>

                <div class="pos-payment_info_details">

                    <div class="pos-total">
                        <div>
                            <span class="total-amount-formatting">TOTAL</span>
                        </div>
                        <div>
                            <span class="pos_total-amount" t-esc="pos.format_currency(order and order.get_total_with_tax() || 0)"/>
                        </div>
                    </div>


                    <t t-call="CustomerFacingDisplayPaymentLines"/>


                    <div class="pos-odoo_logo_container"/>
                </div>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/CustomerFacingDisplay/CustomerFacingDisplayOrder.xml -->

    <t t-name="CustomerFacingDisplayOrderLines">
        <div class="pos_orderlines">
            <div class="pos_orderlines_item pos_orderlines_header">
                <div/>
                <div/>
                <div>Quantity</div>
                <div>Price</div>
            </div>
            <div class="pos_orderlines_list">
                <t t-if="order">
                    <div t-foreach="order.get_orderlines()" t-as="orderline" class="pos_orderlines_item">
                        <div><div t-attf-style="background-image:url(#{productImages[orderline.product.id]})"/></div>
                        <div t-esc="orderline.get_full_product_name()"/>
                        <div t-esc="orderline.get_quantity_str()"/>
                        <div t-esc="pos.format_currency(orderline.get_display_price())"/>
                    </div>
                </t>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/CustomerFacingDisplay/CustomerFacingDisplayOrder.xml -->

    <t t-name="CustomerFacingDisplayPaymentLines">
        <div class="pos-paymentlines">
            <t t-if="order">
                <t t-foreach="order.get_paymentlines()" t-as="paymentline">
                    <div>
                        <span><t t-esc="paymentline.name"/>:</span>
                    </div>
                    <div>
                        <span t-esc="pos.format_currency(paymentline.get_amount())"/>
                    </div>
                </t>
            </t>

            <div>
                <span class="pos-change_title">Change</span>
            </div>
            <div>
                <span class="pos-change_amount" t-esc="pos.format_currency(order and order.get_change() || 0)"/>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Misc/CurrencyAmount.xml -->

<t t-name="CurrencyAmount" owl="1">
        <label t-att-for="props.forTarget" t-att-class="{'oe_link_icon': props.forTarget}">
            <t t-if="props.currency.position === 'before'"><t t-esc="props.currency.symbol"/> </t>
            <t t-esc="props.amount"/>
            <t t-if="props.currency.position === 'after'"> <t t-esc="props.currency.symbol"/></t>
        </label>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Misc/Draggable.xml -->
<t t-name="Draggable" owl="1">
        <t t-slot="default"/>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Misc/MobileOrderWidget.xml -->

<t t-name="MobileOrderWidget" owl="1">
        <div class="switchpane">
            <button class="btn-switchpane" t-on-click="() =&gt; this.trigger('click-pay')">
                <h1>Pay</h1>
                <span><t t-esc="total"/></span>
            </button>
            <button class="btn-switchpane secondary" t-on-click="props.onSwitchPane">
                <h1>Review</h1>
                <span><t t-esc="items_number"/> items</span>
            </button>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Misc/NotificationSound.xml -->

<t t-name="NotificationSound" owl="1">
        <audio t-att-src="props.sound.src" autoplay="true"/>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Misc/SearchBar.xml -->

<t t-name="point_of_sale.SearchBar" owl="1">
        <div class="pos-search-bar">
            <div class="search">
                <span class="search-icon" t-if="!env.isMobile"><i class="fa fa-search"/></span>
                <input class="radius-left" t-ref="autofocus" t-att-class="{ 'radius-right': !props.config.filter.show }" t-model="state.searchInput" t-on-keydown="onSearchInputKeydown" t-on-keyup="onSearchInputKeyup" type="text" t-att-placeholder="props.placeholder"/>
                <div t-if="state.showSearchFields and state.searchInput" class="fields">
                    <ul>
                        <t t-foreach="searchFieldsList" t-as="fieldName" t-key="fieldName">
                            <li t-att-class="{ highlight: fieldName == searchFieldsList[state.selectedSearchFieldId] }" t-on-click="() =&gt; this.trigger('click-search-field', fieldName)">
                                <span class="field">
                                    <t t-esc="props.config.searchFields.get(fieldName)"/>
                                </span>
                                <span>: </span>
                                <span class="term">
                                    <t t-esc="state.searchInput"/>
                                </span>
                            </li>
                        </t>
                    </ul>
                </div>
            </div>
            <div t-if="props.config.filter.show" class="filter radius-right" t-on-click.stop="() =&gt; { state.showFilterOptions = !state.showFilterOptions }">
                <span class="down-icon">
                    <i class="fa fa-chevron-down" aria-hidden="true"/>
                </span>
                <span>
                    <t t-esc="props.config.filter.options.get(state.selectedFilter).text"/>
                </span>
                <ul t-if="state.showFilterOptions" class="options">
                    <t t-foreach="filterOptionsList" t-as="key" t-key="key">
                        <t t-set="_option" t-value="props.config.filter.options.get(key)"/>
                        <li t-on-click="() =&gt; this.trigger('select-filter', key)" t-att-class="{ indented: _option.indented }">
                            <t t-esc="_option.text"/>
                        </li>
                    </t>
                </ul>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Notification.xml -->

<t t-name="Notification" owl="1">
        <div class="notification" t-att-class="props.className">
            <span>
                <t t-esc="props.message"/>
            </span>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/CashMovePopup.xml -->

<t t-name="point_of_sale.CashMovePopup" owl="1">
                <div class="popup cash-move-popup">
                    <main class="body">
                        <div class="cash-move">
                            <div class="input-amount">
                                <span t-on-click="() =&gt; this.onClickButton('in')" class="input-type" t-att-class="{ highlight: state.inputType == 'in' }">
                                    Cash In
                                </span>
                                <span t-on-click="() =&gt; this.onClickButton('out')" class="input-type" t-att-class="{ 'red-highlight': state.inputType == 'out' }">
                                    Cash Out
                                </span>
                                <div class="input-field" t-on-input="handleInputChange">
                                    <input type="text" name="amount" t-ref="input-amount-ref" t-on-keypress="_onAmountKeypress" t-model="state.inputAmount"/>
                                    <t t-if="env.pos.currency.symbol.length &gt; 1">
                                        <span class="left-currency" t-esc="env.pos.currency.symbol"/>
                                    </t>
                                    <t t-else="">
                                        <span class="currency" t-esc="env.pos.currency.symbol"/>
                                    </t>
                                </div>
                            </div>
                            <textarea name="reason" t-model="state.inputReason" placeholder="Reason"/>
                            <span t-if="state.inputHasError" class="error-message">
                                <t t-esc="errorMessage"/>
                            </span>
                        </div>
                    </main>
                    <footer class="footer cash-move">
                        <div class="button confirm disable highlight dynamic-size" t-on-click="confirm">
                            Confirm <span t-esc="env.pos.format_currency(state.parsedAmount)"/>
                        </div>
                        <div class="button cancel" t-on-click="cancel">
                            <t t-esc="props.cancelText"/>
                        </div>
                    </footer>
                </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/CashMoveReceipt.xml -->

<t t-name="point_of_sale.CashMoveReceipt" owl="1">
        <div class="pos-receipt">
            <t t-if="_receipt.company.logo">
                <img class="pos-receipt-logo" t-att-src="_receipt.company.logo" alt="Logo"/>
                <br/>
            </t>
            <t t-if="!_receipt.company.logo">
                <h2 class="pos-receipt-center-align">
                    <t t-esc="_receipt.company.name"/>
                </h2>
                <br/>
            </t>
            <div class="pos-receipt-contact">
                <t t-if="_receipt.company.contact_address">
                    <div>
                        <t t-esc="_receipt.company.contact_address"/>
                    </div>
                </t>
                <t t-if="_receipt.company.phone">
                    <div>Tel:
                        <t t-esc="_receipt.company.phone"/>
                    </div>
                </t>
                <t t-if="_receipt.company.vat">
                    <div>VAT:
                        <t t-esc="_receipt.company.vat"/>
                    </div>
                </t>
                <t t-if="_receipt.company.email">
                    <div>
                        <t t-esc="_receipt.company.email"/>
                    </div>
                </t>
                <t t-if="_receipt.company.website">
                    <div>
                        <t t-esc="_receipt.company.website"/>
                    </div>
                </t>
                <t t-if="_receipt.cashier">
                    <div class="cashier">
                        <div>--------------------------------</div>
                        <div>Done by
                            <t t-esc="_receipt.cashier.name"/>
                        </div>
                    </div>
                </t>
            </div>
            <br/>

            <div class="pos-receipt-center-align">
                CASH
                <t t-esc="_receipt.translatedType.toUpperCase()"/>
            </div>
            <br/>
            <div>
                AMOUNT
                <span t-esc="_receipt.formattedAmount" class="pos-receipt-right-align"/>
            </div>
            <div>
                REASON
                <span t-esc="_receipt.reason" class="pos-receipt-right-align"/>
            </div>
            <br/>
            <div class="pos-receipt-order-data">
                <div><t t-esc="_receipt.date"/></div>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/CashOpeningPopup.xml -->

<t t-name="CashOpeningPopup" owl="1">
            <div class="popup opening-cash-control">
                <header class="title drag-handle">
                    OPENING CASH CONTROL
                </header>
                <main class="body">
                    <div class="opening-cash-section">
                        <span class="info-title">Opening cash</span>
                        <div class="cash-input-sub-section" t-on-input="handleInputChange">
                            <input class="pos-input" t-ref="openingCashInput"/>
                            <div class="button icon" t-on-click="openDetailsPopup">
                                <i class="fa fa-calculator" role="img" title="Open the money details popup"/>
                            </div>
                        </div>
                    </div>
                    <textarea placeholder="Add an opening note..." class="opening-cash-notes" t-model="state.notes"/>
                </main>
                <footer class="footer">
                    <div class="button dynamic-size" t-on-click="confirm">
                        Open session <span t-esc="env.pos.format_currency(state.openingCash)"/>
                    </div>
                </footer>
            </div>
            <MoneyDetailsPopup t-if="state.displayMoneyDetailsPopup" manualInputCashCount="manualInputCashCount" onConfirm="(payload) =&gt; this.updateCashOpening(payload)" onDiscard.bind="closeDetailsPopup"/>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/ClosePosPopup.xml -->
<t t-name="ClosePosPopup" owl="1">
            <div class="popup close-pos-popup">
                <header>
                    <div class="title">Closing Session</div>
                    <div class="total-orders">
                        Total <t t-esc="ordersDetails.quantity"/> orders:
                        <span class="amount" t-esc="env.pos.format_currency(ordersDetails.amount)"/>
                    </div>
                </header>
                <main class="body">
                    <div class="payment-methods-overview">
                        <table>
                            <thead>
                                <tr>
                                    <th>Payment Method</th>
                                    <th>Expected</th>
                                    <th style="width: 25%">Counted</th>
                                    <th style="width: 20%">Difference</th>
                                </tr>
                            </thead>
                            <t t-if="cashControl">
                                <tbody>
                                    <tr>
                                        <td t-esc="defaultCashDetails.name"/>
                                        <td t-esc="env.pos.format_currency(defaultCashDetails.amount)"/>
                                        <td class="flex" t-on-input="(event) =&gt; this.handleInputChange(defaultCashDetails.id, event)">
                                            <input class="pos-input" t-ref="closingCashInput"/>
                                            <div class="button icon" t-on-click="openDetailsPopup">
                                                <i class="fa fa-calculator" role="img" title="Open the money details popup"/>
                                            </div>
                                        </td>
                                        <td t-esc="env.pos.format_currency(state.payments[defaultCashDetails.id].difference)" t-att-class="{'warning': state.payments[defaultCashDetails.id].difference}"/>
                                    </tr>
                                </tbody>
                                <tbody class="cash-overview">
                                    <tr>
                                        <td>Opening</td>
                                        <td t-esc="env.pos.format_currency(defaultCashDetails.opening)"/>
                                    </tr>
                                    <tr t-foreach="defaultCashDetails.moves" t-as="move" t-key="move_index">
                                        <td>
                                            <div class="flex">
                                                <div class="cash-sign" t-esc="move.amount &lt; 0 ? '-' : '+'"/>
                                                <t t-esc="move.name"/>
                                            </div>
                                        </td>
                                        <td t-esc="env.pos.format_currency(Math.abs(move.amount))"/>
                                    </tr>
                                    <tr t-if="defaultCashDetails.payment_amount">
                                        <td>
                                            <div class="flex">
                                                <div class="cash-sign" t-esc="defaultCashDetails.payment_amount &lt; 0 ? '-' : '+'"/>
                                                Payments in <t t-esc="defaultCashDetails.name"/>
                                            </div>
                                        </td>
                                        <td t-esc="env.pos.format_currency(Math.abs(defaultCashDetails.payment_amount))"/>
                                    </tr>
                                </tbody>
                            </t>
                            <tbody t-if="otherPaymentMethods.length &gt; 0">
                                <tr t-foreach="otherPaymentMethods" t-as="pm" t-key="pm.id">
                                    <td t-esc="pm.name"/>
                                    <td t-esc="env.pos.format_currency(pm.amount)"/>
                                    <t t-set="_showDiff" t-value="_getShowDiff(pm)"/>
                                    <td t-if="_showDiff" t-on-input="(event) =&gt; this.handleInputChange(pm.id, event)">
                                        <input class="pos-input" t-ref="closingCashInput_{{pm.id}}"/>
                                    </td>
                                    <td t-if="_showDiff" t-esc="env.pos.format_currency(state.payments[pm.id].difference)" t-att-class="{'warning': state.payments[pm.id].difference}"/>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="notes-container">
                        <div class="opening-notes" t-if="openingNotes">
                            <t t-esc="openingNotes"/>
                        </div>
                        <textarea class="closing-notes" placeholder="Add a closing note..." t-model="state.notes"/>
                    </div>
                </main>
                <footer class="footer">
                    <div class="button highlight" t-on-click="confirm">Close Session</div>
                    <div class="button" t-on-click="closePos" title="Visit the Backend but keep session open">Backend</div>
                    <div class="button" t-att-class="{'disabled': !canCancel()}" t-on-click="cancel">Discard</div>

                    <div class="small button icon" t-on-click="downloadSalesReport" title="Download a report with all the sales of the current PoS Session">
                            <i class="fa fa-download" role="img"/>
                    </div>

                    <div t-if="env.proxy.printer" class="small button icon">
                        <SaleDetailsButton/>
                    </div>
                </footer>
            </div>
            <MoneyDetailsPopup t-if="state.displayMoneyDetailsPopup" manualInputCashCount="manualInputCashCount" onConfirm.bind="updateCountedCash" onDiscard.bind="closeDetailsPopup"/>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/ConfirmPopup.xml -->

<t t-name="ConfirmPopup" owl="1">
            <Draggable>
                <div class="popup popup-confirm">
                    <header class="title drag-handle">
                        <t t-esc="props.title"/>
                    </header>
                    <main class="body">
                        <t t-esc=" props.body"/>
                    </main>
                    <footer class="footer">
                        <div class="button confirm" t-on-click="confirm">
                            <t t-esc="props.confirmText"/>
                        </div>
                        <div class="button cancel" t-on-click="cancel">
                            <t t-esc="props.cancelText"/>
                        </div>
                    </footer>
                </div>
            </Draggable>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/ControlButtonPopup.xml -->

<t t-name="ControlButtonPopup" owl="1">
            <Draggable>
                <div class="popup popup-control-buttons">

                    <div class="control-buttons" t-on-click="cancel">
                        <t t-foreach="controlButtons" t-as="cb" t-key="cb.name">
                            <t t-component="cb.component" t-key="cb.name"/>
                        </t>
                    </div>
                    <footer class="footer">
                        <div class="button cancel" t-on-click="cancel">
                            <t t-esc="props.cancelText"/>
                        </div>
                    </footer>
                </div>
            </Draggable>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/EditListInput.xml -->

<t t-name="EditListInput" owl="1">
        <div>
            <input type="text" t-model="props.item.text" class="popup-input list-line-input" placeholder="Serial/Lot Number" t-on-keyup="onKeyup"/>
            <i class="oe_link_icon fa fa-trash-o" role="img" aria-label="Remove" title="Remove" t-on-click="() =&gt; this.trigger('remove-item', props.item)"/>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/EditListPopup.xml -->

<t t-name="EditListPopup" owl="1">
            <div class="popup popup-text">
                <header class="title">
                    <t t-esc="props.title"/>
                </header>
                <main class="list-lines" t-on-remove-item="removeItem" t-on-create-new-item="createNewItem">
                    <t t-foreach="state.array" t-as="item" t-key="item._id">
                        <EditListInput item="item"/>
                    </t>
                </main>
                <footer class="footer">
                    <div class="button confirm highlight" t-on-click="confirm">
                        Ok
                    </div>
                    <div class="button cancel" t-on-click="cancel">
                        Cancel
                    </div>
                </footer>
            </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/ErrorBarcodePopup.xml -->

<t t-name="ErrorBarcodePopup" owl="1">
            <Draggable>
                <div class="popup popup-barcode">
                    <header class="title drag-handle">
                        <span>Unknown Barcode</span>
                        <br/>
                        <span class="barcode">
                            <t t-esc="props.code"/>
                        </span>
                    </header>
                    <main class="body">
                        <t t-esc="translatedMessage"/>
                    </main>
                    <footer class="footer">
                        <div class="button cancel" t-on-click="confirm">
                            Ok
                        </div>
                    </footer>
                </div>
            </Draggable>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/ErrorPopup.xml -->

<t t-name="ErrorPopup" owl="1">
            <div class="popup popup-error">
                <p class="title">
                    <t t-esc="props.title"/>
                </p>
                <p class="body">
                    <t t-esc="props.body"/>
                </p>
                <div class="footer">
                    <div class="button cancel" t-on-click="confirm">
                        <t t-esc="props.confirmText"/>
                    </div>
                </div>
            </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/ErrorTracebackPopup.xml -->

<t t-name="ErrorTracebackPopup" owl="1">
            <div class="popup popup-error">
                <header class="title">
                    <t t-esc="props.title"/>
                </header>
                <main class="body traceback">
                    <t t-esc="props.body"/>
                </main>
                <footer class="footer">
                    <div t-if="!props.exitButtonIsShown" class="button cancel" t-on-click="confirm">
                        <t t-esc="props.confirmText"/>
                    </div>
                    <div t-if="props.exitButtonIsShown" class="button cancel" t-on-click="() =&gt; this.trigger(props.exitButtonTrigger)">
                        <t t-esc="props.exitButtonText"/>
                    </div>
                    <a t-att-download="tracebackFilename" t-att-href="tracebackUrl">
                        <div class="button icon download">
                            <i class="fa fa-download" role="img" aria-label="Download error traceback" title="Download error traceback"/>
                        </div>
                    </a>
                    <div class="button icon email" t-on-click="emailTraceback">
                        <i class="fa fa-paper-plane" role="img" aria-label="Send by email" title="Send by email"/>
                    </div>
                </footer>
            </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/MoneyDetailsPopup.xml -->

<t t-name="MoneyDetailsPopup" owl="1">
        <div class="popup money-details">
            <main class="body">
                <div class="money-details-title">
                    Coins/Bills
                </div>
                <div class="money-details-info">
                    <div t-foreach="[firstHalfMoneyDetails, lastHalfMoneyDetails]" t-as="moneyDetailsList" t-key="moneyDetailsList_index">
                        <t t-foreach="moneyDetailsList" t-as="moneyValue" t-key="moneyValue">
                            <div class="money-details-value" t-on-input="updateMoneyDetailsAmount">
                                <input class="pos-input" t-att-id="moneyValue" type="number" t-model.number="state.moneyDetails[moneyValue]"/>
                                <CurrencyAmount forTarget="moneyValue" currency="currency" amount="moneyValue"/>
                            </div>
                        </t>
                    </div>
                </div>
                <div class="total-section">
                    <span>Total </span>
                    <CurrencyAmount currency="currency" amount="env.pos.format_currency_no_symbol(state.total)"/>
                </div>
            </main>
            <footer class="footer">
                <div class="button" t-on-click="discard">Discard</div>
                <div class="button" t-on-click="confirm">Confirm</div>
            </footer>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/NumberPopup.xml -->
<t t-name="NumberPopup" owl="1">
            <Draggable>
                <div class="popup popup-number" t-att-class="{ 'popup-password': props.isPassword }">
                    <header class="title drag-handle">
                        <t t-esc="props.title"/>
                    </header>
                    <div class="popup-input value active">
                        <span t-att-class="{ 'highlight': state.toStartOver }"><t t-esc="inputBuffer"/></span>
                    </div>
                    <div class="popup-numpad">
                        <button class="input-button number-char" t-on-mousedown.prevent="() =&gt; this.sendInput('1')">1</button>
                        <button class="input-button number-char" t-on-mousedown.prevent="() =&gt; this.sendInput('2')">2</button>
                        <button class="input-button number-char" t-on-mousedown.prevent="() =&gt; this.sendInput('3')">3</button>
                        <t t-if="props.cheap">
                            <button class="mode-button add" t-on-mousedown.prevent="() =&gt; this.sendInput('+1')">+1</button>
                        </t>
                        <t t-if="!props.cheap">
                            <button class="mode-button add" t-on-mousedown.prevent="() =&gt; this.sendInput('+10')">+10</button>
                        </t>
                        <br/>
                        <button class="input-button number-char" t-on-mousedown.prevent="() =&gt; this.sendInput('4')">4</button>
                        <button class="input-button number-char" t-on-mousedown.prevent="() =&gt; this.sendInput('5')">5</button>
                        <button class="input-button number-char" t-on-mousedown.prevent="() =&gt; this.sendInput('6')">6</button>
                        <t t-if="props.cheap">
                            <button class="mode-button add" t-on-mousedown.prevent="() =&gt; this.sendInput('+2')">+2</button>
                        </t>
                        <t t-if="!props.cheap">
                            <button class="mode-button add" t-on-mousedown.prevent="() =&gt; this.sendInput('+20')">+20</button>
                        </t>
                        <br/>
                        <button class="input-button number-char" t-on-mousedown.prevent="() =&gt; this.sendInput('7')">7</button>
                        <button class="input-button number-char" t-on-mousedown.prevent="() =&gt; this.sendInput('8')">8</button>
                        <button class="input-button number-char" t-on-mousedown.prevent="() =&gt; this.sendInput('9')">9</button>
                        <button t-if="!props.isPassword" class="input-button number-char" t-on-mousedown.prevent="() =&gt; this.sendInput('-')">-</button>
                        <br/>
                        <button class="input-button numpad-char" t-on-mousedown.prevent="() =&gt; this.sendInput('Delete')">C</button>
                        <button class="input-button number-char" t-on-mousedown.prevent="() =&gt; this.sendInput('0')">0</button>
                        <button class="input-button number-char dot" t-on-mousedown.prevent="() =&gt; this.sendInput(decimalSeparator)">
                            <t t-esc="decimalSeparator"/></button>
                        <button class="input-button numpad-backspace" t-on-mousedown.prevent="() =&gt; this.sendInput('Backspace')">
                            <img style="pointer-events: none;" src="/point_of_sale/static/src/img/backspace.png" width="24" height="21" alt="Backspace"/>
                        </button>
                        <br/>
                    </div>
                    <footer class="footer centered">
                        <div class="button cancel" t-on-mousedown.prevent="cancel">
                            <t t-esc="props.cancelText"/>
                        </div>
                        <div class="button confirm highlight" t-on-mousedown.prevent="confirm">
                            <t t-esc="props.confirmText"/>
                        </div>
                    </footer>
                </div>
            </Draggable>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/OfflineErrorPopup.xml -->

<t t-name="OfflineErrorPopup" owl="1">
            <Draggable>
                <div class="popup popup-error">
                    <header class="title drag-handle">
                        <t t-esc="props.title"/>
                    </header>
                    <main class="body traceback"><t t-esc="props.body"/></main>
                    <footer class="footer">
                        <div class="button confirm" t-on-click="confirm">
                            Ok
                        </div>
                        <div class="button dont-show-again" t-on-click="dontShowAgain">
                            Don't show again
                        </div>
                    </footer>
                </div>
            </Draggable>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/OrderImportPopup.xml -->

<t t-name="OrderImportPopup" owl="1">
            <Draggable>
                <div class="popup popup-import">
                    <header class="title drag-handle">
                        <span>Finished Importing Orders</span>
                    </header>
                    <ul class="body">
                        <li>Successfully imported <b><t t-esc="props.report.paid or 0"/></b> paid orders</li>
                        <li>Successfully imported <b><t t-esc="props.report.unpaid or 0"/></b> unpaid orders</li>
                        <t t-if="unpaidSkipped">
                            <li><b><t t-esc="unpaidSkipped"/></b> unpaid orders could not be imported
                                <ul>
                                    <li><b><t t-esc="props.report.unpaid_skipped_existing or 0"/></b> were duplicates of existing orders</li>
                                    <li><b><t t-esc="props.report.unpaid_skipped_session or 0"/></b> belong to another session:
                                        <t t-if="props.report.unpaid_skipped_sessions">
                                            <ul>
                                                <li>Session ids: <b><t t-esc="props.report.unpaid_skipped_sessions"/></b></li>
                                            </ul>
                                        </t>
                                    </li>
                                </ul>
                            </li>
                        </t>
                    </ul>
                    <footer class="footer">
                        <div class="button cancel" t-on-click="confirm">
                            <t t-esc="props.confirmText"/>
                        </div>
                    </footer>
                </div>
            </Draggable>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/PosPopupController.xml -->

<t t-name="point_of_sale.PosPopupController" owl="1">
        <div class="popups" t-att-hidden="!isShown()">
            <t t-foreach="popups" t-as="popup" t-key="popup.key">
                <div role="dialog" class="modal-dialog" t-att-class="{ oe_hidden: !shouldShow(popup) }">
                    <t t-component="popup.component" t-props="popup.props" t-key="popup.key"/>
                </div>
            </t>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/ProductConfiguratorPopup.xml -->

<t t-name="ProductConfiguratorPopup" owl="1">
            <div class="popup popup-text popup-med product-configurator-popup">
                <header class="title">
                    <t t-esc="props.product.display_name"/>
                </header>

                <main class="body product_configurator_attributes col-lg-4 col-md-6 col-sm-12">
                    <div t-foreach="props.attributes" t-as="attribute" t-key="attribute.id" class="attribute">
                        <div class="attribute_name" t-esc="attribute.name"/>
                        <RadioProductAttribute t-if="attribute.display_type === 'radio' or attribute.display_type === 'pills'" attribute="attribute"/>
                        <SelectProductAttribute t-elif="attribute.display_type === 'select'" attribute="attribute"/>
                        <ColorProductAttribute t-elif="attribute.display_type === 'color'" attribute="attribute"/>
                    </div>
                </main>

                <footer class="footer">
                    <div class="button highlight confirm" t-on-click="confirm">
                        Add
                    </div>
                    <div class="button cancel" t-on-click="cancel">
                        Cancel
                    </div>
                </footer>
            </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/ProductConfiguratorPopup.xml -->

    <t t-name="RadioProductAttribute" owl="1">
        <div class="configurator_radio">
            <div class="table">
                <t t-foreach="values" t-as="value" t-key="value.id">
                    <div class="attribute-name-cell">
                        <input type="radio" t-model="state.selected_value" t-att-name="attribute.id" t-attf-id="{{ attribute.id }}_{{ value.id }}" t-att-value="value.id"/>
                        <label t-attf-for="{{ attribute.id }}_{{ value.id }}">
                                <t t-esc="value.name"/>
                        </label>
                    </div>
                    <div t-if="value.price_extra" class="price-extra-cell">
                        <label t-attf-for="{{ attribute.id }}_{{ value.id }}">
                            <span class="price_extra">
                                + <t t-esc="env.pos.format_currency(value.price_extra)"/>
                            </span>
                        </label>
                    </div>
                    <div t-if="value.id == state.selected_value &amp;&amp; value.is_custom" class="custom-value-cell">
                        <label t-attf-for="{{ attribute.id }}_{{ value.id }}">
                            <input class="custom_value" type="text" t-model="state.custom_value"/>
                        </label>
                    </div>
                </t>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/ProductConfiguratorPopup.xml -->

    <t t-name="SelectProductAttribute" owl="1">
        <div>
            <t t-set="is_custom" t-value="false"/>

            <select class="configurator_select" t-model="state.selected_value">
                <option t-foreach="values" t-as="value" t-key="value.id" t-att-value="value.id">
                    <t t-set="is_custom" t-value="is_custom || (value.is_custom &amp;&amp; value.id == state.selected_value)"/>
                    <t t-esc="value.name"/>
                    <t t-if="value.price_extra">
                        + <t t-esc="env.pos.format_currency(value.price_extra)"/>
                    </t>
                </option>
            </select>

            <input class="custom_value" t-if="is_custom" type="text" t-model="state.custom_value"/>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/ProductConfiguratorPopup.xml -->

    <t t-name="ColorProductAttribute" owl="1">
        <div>
            <t t-set="is_custom" t-value="false"/>

            <ul class="color_attribute_list">
                <li t-foreach="values" t-as="value" t-key="value.id" class="color_attribute_list_item">
                    <t t-set="is_custom" t-value="is_custom || (value.is_custom &amp;&amp; value.id == state.selected_value)"/>
                    <label t-attf-class="configurator_color {{ value.id == state.selected_value ? 'active' : '' }}" t-attf-style="background-color: {{ value.html_color }};" t-att-data-color="value.name">
                        <input type="radio" t-model="state.selected_value" t-att-value="value.id" t-att-name="attribute.id"/>
                    </label>
                </li>
            </ul>

            <input class="custom_value" t-if="is_custom" type="text" t-model="state.custom_value"/>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/ProductInfoPopup.xml => /pos_sale_product_configurator/static/src/xml/Popups/ProductInfoPopup.xml -->

<t t-name="ProductInfoPopup" owl="1">
            <div class="popup product-info-popup">
                <header class="title">
                    Product information
                </header>
                <main class="body">
                    <div class="section-product-info-title">
                        <div class="column flex-start">
                            <span t-esc="props.product.display_name" class="global-info-title product-name"/>
                            <span><t t-if="props.product.default_code" t-esc="props.product.default_code"/> <t t-if="props.product.default_code and props.product.barcode"> - </t> <t t-if="props.product.barcode" t-esc="props.product.barcode"/></span>
                        </div>
                        <div class="column flex-end">
                            <span t-esc="env.pos.format_currency(productInfo.all_prices.price_with_tax)" class="global-info-title"/>
                            <t t-foreach="productInfo.all_prices.tax_details" t-as="tax" t-key="tax.name">
                                <div><t t-esc="tax.name"/>: <t t-esc="env.pos.format_currency(tax.amount)"/></div>
                            </t>
                        </div>
                    </div>
                    <div class="section-financials">
                        <div class="section-title">
                            <span>Financials</span>
                            <div class="section-title-line"/>
                        </div>
                        <div class="section-financials-body">
                            <table>
                                <tr>
                                    <td>Price excl. VAT:</td>
                                    <td><t t-esc="env.pos.format_currency(productInfo.all_prices.price_without_tax)"/></td>
                                </tr>
                                <tr t-if="_hasMarginsCostsAccessRights()">
                                    <td>Cost:</td>
                                    <td><t t-esc="costCurrency"/></td>
                                </tr>
                                <tr t-if="_hasMarginsCostsAccessRights()">
                                    <td>Margin:</td>
                                    <td><t t-esc="marginCurrency"/> (<t t-esc="marginPercent"/>%) </td>
                                </tr>
                            </table>
                            <table>
                                <t t-foreach="productInfo.pricelists" t-as="pricelist" t-key="pricelist.name">
                                    <tr>
                                        <td t-esc="pricelist.name"/>
                                        <td t-esc="env.pos.format_currency(pricelist.price)"/>
                                    </tr>
                                </t>
                            </table>
                        </div>
                    </div>
                    <div class="section-inventory" t-if="productInfo.warehouses.length &gt; 0">
                        <div class="section-title">
                            <span>Inventory <t t-if="env.pos.pos_session.update_stock_at_closing">(as of opening)</t></span>
                            <div class="section-title-line"/>
                        </div>
                        <div class="section-inventory-body">
                            <table class="mobile-table">
                                <t t-foreach="productInfo.warehouses" t-as="warehouse" t-key="warehouse.name">
                                    <tr>
                                        <td><span t-esc="warehouse.name" class="table-name"/>:</td>
                                        <td><t t-esc="warehouse.available_quantity"/> <t t-esc="warehouse.uom"/> available,</td>
                                        <td><t t-esc="warehouse.forecasted_quantity"/> forecasted</td>
                                    </tr>
                                </t>
                            </table>
                        </div>
                    </div>
                    <div class="section-supplier" t-if="productInfo.suppliers.length &gt; 0">
                        <div class="section-title">
                            <span>Replenishment</span>
                            <div class="section-title-line"/>
                        </div>
                        <div class="section-supplier-body">
                            <table class="mobile-table">
                                <t t-foreach="productInfo.suppliers" t-as="supplier" t-key="supplier.name">
                                    <tr>
                                        <td><span t-esc="supplier.name" class="table-name"/>:</td>
                                        <div class="mobile-line">
                                            <td><t t-esc="supplier.delay"/> Days</td>
                                            <td t-if="_hasMarginsCostsAccessRights()"><t t-esc="env.pos.format_currency(supplier.price)"/></td>
                                        </div>
                                    </tr>
                                </t>
                            </table>
                        </div>
                    </div>
                    <div class="extra">
                        <div class="section-variants" t-if="productInfo.variants.length &gt; 0">
                            <div class="section-title">
                                <span>Attributes</span>
                                <div class="section-title-line"/>
                            </div>
                            <div class="section-variants-body">
                                <table class="mobile-table">
                                    <t t-foreach="productInfo.variants" t-as="variant" t-key="variant.name">
                                        <tr>
                                            <td><span t-esc="variant.name" class="table-name"/>:</td>
                                            <td class="table-value">
                                                <t t-foreach="variant.values" t-as="attribute_value" t-key="attribute_value.name">
                                                    <span class="searchable" t-on-click="() =&gt; this.searchProduct(attribute_value.search)"><t t-esc="attribute_value.name"/></span> <t t-if="attribute_value_index lt variant.values.length - 1">, </t>
                                                </t>
                                            </td>
                                        </tr>
                                    </t>
                                </table>
                            </div>
                        </div>
            <!-- Filepath: /pos_sale_product_configurator/static/src/xml/Popups/ProductInfoPopup.xml ; position="inside" ; {'expr': "//div[hasclass('extra')]"} --><div class="section-optional-product" t-if="productInfo.optional_products.length &gt; 0">
                <div class="section-title">
                    <span>Optional Products</span>
                    <div class="section-title-line"/>
                </div>
                <div class="section-optional-product-body">
                    <table>
                        <t t-foreach="productInfo.optional_products" t-as="optional" t-key="optional.name">
                            <tr>
                                <td><span class="searchable" t-esc="optional.name" t-on-click="() =&gt; this.searchProduct(optional.name)"/></td>
                                <td class="table-value">
                                    from <t t-esc="env.pos.format_currency(optional.price)"/>
                                </td>
                            </tr>
                        </t>
                    </table>
                </div>
            </div>
                    </div>
                    <div class="section-order">
                        <div class="section-title">
                            <span>Order</span>
                            <div class="section-title-line"/>
                        </div>
                        <div class="section-order-body">
                            <table>
                                <tr>
                                    <td>Total Price excl. VAT:</td>
                                    <td t-esc="orderPriceWithoutTaxCurrency" class="table-value"/>
                                </tr>
                                <tr t-if="_hasMarginsCostsAccessRights()">
                                    <td>Total Cost:</td>
                                    <td t-esc="orderCostCurrency" class="table-value"/>
                                </tr>
                                <tr t-if="_hasMarginsCostsAccessRights()">
                                    <td>Total Margin:</td>
                                    <td class="table-value"><t t-esc="orderMarginCurrency"/> (<t t-esc="orderMarginPercent"/>%)</td>
                                </tr>
                            </table>
                        </div>
                    </div>
                </main>
                <footer class="footer">
                    <div class="button cancel" t-on-click="cancel">
                        Close
                    </div>
                </footer>
            </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/SelectionPopup.xml -->
<t t-name="SelectionPopup" owl="1">
            <Draggable>
                <div class="popup popup-selection">
                    <header class="title drag-handle">
                        <t t-esc="props.title"/>
                    </header>
                    <div class="selection scrollable-y">
                        <t t-foreach="props.list" t-as="item" t-key="item.id">
                            <div class="selection-item" t-att-class="{ selected: item.isSelected }" t-on-click="() =&gt; this.selectItem(item.id)">
                                <t t-esc="item.label"/>
                            </div>
                        </t>
                    </div>
                    <footer class="footer">
                        <div class="button cancel" t-on-click="cancel">
                            <t t-esc="props.cancelText"/>
                        </div>
                    </footer>
                </div>
            </Draggable>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/TextAreaPopup.xml -->

<t t-name="TextAreaPopup" owl="1">
            <Draggable>
                <div class="popup popup-textarea">
                    <header class="title drag-handle">
                        <t t-esc="props.title"/>
                    </header>
                    <div class="popup-textarea-wrap">
                        <textarea t-model="state.inputValue" t-ref="input"/>
                    </div>
                    <footer class="footer">
                        <div class="button confirm highlight" t-on-click="confirm">
                            <t t-esc="props.confirmText"/>
                        </div>
                        <div class="button cancel" t-on-click="cancel">
                            <t t-esc="props.cancelText"/>
                        </div>
                    </footer>
                </div>
            </Draggable>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Popups/TextInputPopup.xml -->

<t t-name="TextInputPopup" owl="1">
            <div class="popup popup-textinput">
                <header class="title">
                    <t t-esc="props.title"/>
                </header>
                <div class="body">
                    <p>
                        <t t-esc="props.body"/>
                    </p>
                    <input type="text" t-model="state.inputValue" t-ref="input" t-att-placeholder="props.placeholder"/>
                </div>
                <div class="footer">
                    <div class="button confirm highlight" t-on-click="confirm">
                        <t t-esc="props.confirmText"/>
                    </div>
                    <div class="button cancel" t-on-click="cancel">
                        <t t-esc="props.cancelText"/>
                    </div>
                </div>
            </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/SaleDetailsReport.xml -->

<t t-name="SaleDetailsReport" owl="1">
        <div class="pos-receipt">
            <t t-if="pos.company_logo_base64">
                <img class="pos-receipt-logo" t-att-src="pos.company_logo_base64" alt="Logo"/>
                <br/>
            </t>
            <t t-if="!pos.company_logo_base64" class="pos-receipt-center-align">
                <h1 t-esc="pos.company.name"/>
                <br/>
            </t>
            <br/><br/>

            <div class="orderlines">
                <t t-foreach="products" t-as="line" t-key="line.product_id">
                    <div class="responsive-price">
                        <t t-esc="line.product_name.substr(0,20)"/>
                        <span class="pos-receipt-right-align">
                            <t t-esc="Math.round(line.quantity * Math.pow(10, pos.dp['Product Unit of Measure'])) / Math.pow(10, pos.dp['Product Unit of Measure'])"/>
                            <t t-if="line.uom !== 'Units'">
                                <t t-esc="line.uom"/>
                            </t>
                            x
                            <t t-esc="pos.format_currency_no_symbol(line.price_unit)"/>
                        </span>
                    </div>
                    <t t-if="line.discount !== 0">
                        <div class="pos-receipt-left-padding">Discount: <t t-esc="line.discount"/>%</div>
                    </t>
                </t>
            </div>

            <br/>
            <div>------------------------</div>
            <br/>

            <div>
                Payments:
            </div>
            <div t-foreach="payments" t-as="payment" t-key="payment_index">
                <t t-esc="payment['name']"/>
                <span t-esc="pos.format_currency_no_symbol(payment['total'])" class="pos-receipt-right-align"/>
            </div>

            <br/>
            <div>------------------------</div>
            <br/>

            <div>
                Taxes:
            </div>
            <div t-foreach="taxes" t-as="tax" t-key="tax_index">
                <t t-esc="tax.name"/>
                <span t-esc="pos.format_currency_no_symbol(tax.tax_amount)" class="pos-receipt-right-align"/>
            </div>

            <br/>
            <div>------------------------</div>
            <br/>

            <div>
                Total:
                <span t-esc="pos.format_currency_no_symbol(total_paid)" class="pos-receipt-right-align"/>
            </div>

            <br/>
            <div class="pos-receipt-order-data">
                <div><t t-esc="date"/></div>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/PartnerListScreen/PartnerDetailsEdit.xml -->

<t t-name="PartnerDetailsEdit" owl="1">
        <section class="partner-details edit">
            <div class="partner-picture">
                <t t-if="partnerImageUrl">
                    <img t-att-src="partnerImageUrl" alt="Partner" style="width: 64px; height: 64px; object-fit: cover;"/>
                </t>
                <t t-else="">
                    <i class="fa fa-camera" role="img" aria-label="Picture" title="Picture"/>
                </t>
                <input type="file" class="image-uploader" t-on-change="uploadImage"/>
            </div>
            <input class="detail partner-name" name="name" t-model="changes.name" placeholder="Name" t-on-change="captureChange"/>
            <div class="partner-details-box clearfix">
                <div class="partner-details-left">
                    <div class="partner-detail">
                        <span class="label">Street</span>
                        <input class="detail" name="street" t-model="changes.street" t-on-change="captureChange" placeholder="Street"/>
                    </div>
                    <div class="partner-detail">
                        <span class="label">City</span>
                        <input class="detail" name="city" t-model="changes.city" t-on-change="captureChange" placeholder="City"/>
                    </div>
                    <div class="partner-detail">
                        <span class="label">Postcode</span>
                        <input class="detail" name="zip" t-model="changes.zip" t-on-change="captureChange" placeholder="ZIP"/>
                    </div>
                    <div class="partner-detail" t-if="env.pos.states.some((state) =&gt; state.country_id[0] == changes.country_id)">
                        <span class="label">State</span>
                        <select class="detail" name="state_id" t-model="changes.state_id" t-on-change="captureChange">
                            <option value="">None</option>
                            <t t-foreach="env.pos.states" t-as="state" t-key="state.id">
                                <option t-if="changes.country_id == state.country_id[0]" t-att-value="state.id">
                                    <t t-esc="state.name"/>
                                </option>
                            </t>
                        </select>
                    </div>
                    <div class="partner-detail">
                        <span class="label">Country</span>
                        <select class="detail" name="country_id" t-model="changes.country_id" t-on-change="captureChange">
                            <option value="">None</option>
                            <t t-foreach="env.pos.countries" t-as="country" t-key="country.id">
                                <option t-att-value="country.id">
                                    <t t-esc="country.name"/>
                                </option>
                            </t>
                        </select>
                    </div>
                </div>
                <div class="partner-details-right">
                    <div class="partner-detail">
                        <span class="label">Language</span>
                        <select class="detail" name="lang" t-model="changes.lang" t-on-change="captureChange">
                            <t t-foreach="env.pos.langs" t-as="lang" t-key="lang.id">
                                <option t-att-value="lang.code">
                                    <t t-esc="lang.name"/>
                                </option>
                            </t>
                        </select>
                    </div>
                    <div class="partner-detail">
                        <span class="label">Email</span>
                        <input class="detail" name="email" type="email" t-model="changes.email" t-on-change="captureChange"/>
                    </div>
                    <div class="partner-detail">
                        <span class="label">Phone</span>
                        <input class="detail" name="phone" type="tel" t-model="changes.phone" t-on-change="captureChange"/>
                    </div>
                    <div class="partner-detail">
                        <span class="label">Mobile</span>
                        <input class="detail" name="mobile" type="tel" t-model="changes.mobile" t-on-change="captureChange"/>
                    </div>
                    <div class="partner-detail">
                        <span class="label">Barcode</span>
                        <input class="detail barcode" name="barcode" t-model="changes.barcode" t-on-change="captureChange"/>
                    </div>
                    <div class="partner-detail">
                        <span class="label">Tax ID</span>
                        <input class="detail vat" name="vat" t-model="changes.vat" t-on-change="captureChange"/>
                    </div>
                    <div t-if="env.pos.pricelists.length gt 1" class="partner-detail">
                        <span class="label">Pricelist</span>
                        <select class="detail" name="property_product_pricelist" t-on-change="captureChange" t-model="changes.property_product_pricelist">
                            <t t-foreach="env.pos.pricelists" t-as="pricelist" t-key="pricelist.id">
                                <option t-att-value="pricelist.id">
                                    <t t-esc="pricelist.display_name"/>
                                </option>
                            </t>
                        </select>
                    </div>
                </div>
            </div>
        </section>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/PartnerListScreen/PartnerLine.xml -->

<t t-name="PartnerLine" owl="1">
        <tr t-attf-class="partner-line {{highlight}}" t-att-data-id="props.partner.id" t-on-click="() =&gt; this.props.onClickPartner(props.partner)">
            <td>
                <div>
                    <t t-esc="props.partner.name or ''"/>
                </div>
                <div class="company-field">
                    <t t-esc="props.partner.parent_name or ''"/>
                </div>
                <div t-if="_isPartnerSelected" class="unselect-tag">
                    <i class="fa fa-times"/>
                    <span> unselect </span>
                </div>
            </td>
            <td t-if="!env.isMobile">
                <t t-esc="shortAddress"/>
            </td>
            <td class="partner-line-email" t-if="!env.isMobile">
                <div t-if="props.partner.phone">
                    <i class="fa fa-phone fa-fw"/><t t-esc="props.partner.phone"/>
                </div>
                <div t-if="props.partner.mobile">
                    <i class="fa fa-mobile fa-lg fa-fw"/><t t-esc="props.partner.mobile"/>
                </div>
                <div t-if="props.partner.email" class="email-field">
                    <i class="fa fa-paper-plane-o fa-fw"/><t t-esc="props.partner.email"/>
                </div>
            </td>
            <td t-if="env.isMobile">
                <t t-esc="props.partner.zip or ''"/>
                <span t-if="highlight"><br/></span>
            </td>
            <td class="partner-line-balance" t-if="props.isBalanceDisplayed"/>
            <td>
                <button class="edit-partner-button" t-on-click.stop="() =&gt; props.onClickEdit(props.partner)">DETAILS</button>
            </td>
            <td class="partner-line-last-column-placeholder oe_invisible"/>
        </tr>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/PartnerListScreen/PartnerListScreen.xml -->

<t t-name="PartnerListScreen" owl="1">
        <div class="partnerlist-screen screen">
            <div class="screen-content">
                <div class="top-content">
                    <div class="button highlight" t-if="state.detailIsShown" t-on-click="() =&gt; this.trigger('click-save')">
                        <i t-if="env.isMobile" class="fa fa-floppy-o"/>
                        <t t-if="!env.isMobile">
                            <span> Save</span>
                        </t>
                    </div>
                    <div t-if="!state.detailIsShown" class="button new-customer highlight" role="img" aria-label="Add a customer" t-on-click="createPartner" title="Add a customer">
                        <i t-if="env.isMobile" class="fa fa-plus"/>
                        <t t-if="!env.isMobile"> Create</t>
                    </div>
                    <div class="button back" t-on-click="back">
                        <i t-if="env.isMobile" class="fa fa-angle-double-left"/>
                        <t t-if="!env.isMobile"> Discard</t>
                    </div>
                    <div class="top-right-buttons">
                    <div t-if="state.detailIsShown &amp;&amp; state.editModeProps.partner.id" class="button more-info">
                        <a t-att-href="partnerLink" target="_blank"> More info</a>
                    </div>
                    <div class="search-bar-container sb-partner" t-if="!state.detailIsShown">
                        <div class="pos-search-bar">
                            <i class="fa fa-search" t-on-click="_onPressEnterKey"/>
                            <input t-ref="search-word-input-partner" placeholder="Search Customers..." size="1" t-on-keyup="updatePartnerList"/>
                            <i class="fa fa-times" t-on-click="_clearSearch"/>
                        </div>
                    </div>
                    </div>
                </div>
                <section class="full-content">
                    <div class="partner-window">
                        <section class="subwindow collapsed">
                            <div class="subwindow-container collapsed">
                                <div t-if="state.detailIsShown" class="partner-details-contents subwindow-container-fix">
                                    <PartnerDetailsEdit t-props="state.editModeProps"/>
                                </div>
                            </div>
                        </section>
                        <section class="subwindow list">
                            <div class="subwindow-container">
                                <div t-if="!state.detailIsShown" class="subwindow-container-fix scrollable-y">
                                    <table class="partner-list">
                                        <thead>
                                            <tr>
                                                <th>Name</th>
                                                <th t-if="!env.isMobile">Address</th>
                                                <th t-if="!env.isMobile" class="partner-line-email">Contact</th>
                                                <th t-if="env.isMobile">ZIP</th>
                                                <th class="pos-right-align" t-if="isBalanceDisplayed">Balance</th>
                                                <th class="partner-line-details"/>
                                                <th class="partner-line-last-column-placeholder oe_invisible"/>
                                            </tr>
                                        </thead>
                                        <tbody class="partner-list-contents">
                                            <t t-foreach="partners" t-as="partner" t-key="partner.id">
                                                <PartnerLine partner="partner" selectedPartner="state.selectedPartner" detailIsShown="state.detailIsShown" isBalanceDisplayed="isBalanceDisplayed" onClickEdit.bind="editPartner" onClickPartner.bind="clickPartner"/>
                                            </t>
                                        </tbody>
                                    </table>
                                    <div t-if="state.query" class="search-more-button">
                                        <div class="button" t-on-click="_onPressEnterKey">Search more</div>
                                    </div>
                                </div>
                            </div>
                        </section>
                    </div>
                </section>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/PaymentScreen/PSNumpadInputButton.xml -->

<t t-name="PSNumpadInputButton" owl="1">
        <button t-attf-class="{{ _class }}" t-on-click="() =&gt; this.trigger('input-from-numpad', { key: props.value })">
            <t t-slot="default">
                <t t-if="props.text">
                    <t t-esc="props.text"/>
                </t>
                <t t-else="">
                    <t t-esc="props.value"/>
                </t>
            </t>
        </button>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/PaymentScreen/PaymentScreen.xml -->

<t t-name="PaymentScreen" owl="1">
        <div class="payment-screen screen" t-att-class="{ oe_hidden: !props.isShown }">
            <div class="screen-content">
                <t t-if="!env.isMobile">
                    <div class="top-content">
                        <div class="button back" t-on-click="() =&gt; this.showScreen('ProductScreen')">
                            <i class="fa fa-angle-double-left fa-fw"/>
                            <span class="back_text">Back</span>
                        </div>
                        <div class="top-content-center"><h1>Payment</h1></div>
                    </div>
                </t>
                <div class="main-content">
                    <div class="left-content">
                        <t t-if="env.isMobile">
                            <section class="paymentlines-container">
                                <PaymentScreenStatus order="currentOrder"/>
                            </section>
                        </t>
                        <div class="paymentmethods-container">
                            <div class="paymentmethods">
                                <p class="title-category">Payment method</p>
                                <t t-foreach="payment_methods_from_config" t-as="paymentMethod" t-key="paymentMethod.id">
                                    <div class="button paymentmethod" t-on-click="() =&gt; this.trigger('new-payment-line', paymentMethod)">
                                        <div class="payment-name">
                                            <t t-esc="paymentMethod.name"/>
                                        </div>
                                    </div>
                                </t>
                            </div>
                            <PaymentScreenPaymentLines paymentLines="paymentLines"/>
                        </div>
                        <div t-if="!env.isMobile" class="button next validation" t-att-class="{ highlight: currentOrder.is_paid() and currentOrder._isValidEmptyOrder() }" t-on-click="() =&gt; this.trigger('validate-order')">
                            <div class="pay-circle">
                                <i class="fa fa-chevron-right" role="img" aria-label="Pay" title="Pay"/>
                            </div>
                            <span class="next_text">Validate</span>
                        </div>
                    </div>
                    <div class="center-content">
                        <t t-if="!env.isMobile">
                            <section class="paymentlines-container">
                                <PaymentScreenStatus order="currentOrder"/>
                            </section>
                        </t>

                        <div class="payment-buttons-container">
                            <section class="payment-numpad">
                                <PaymentScreenNumpad/>
                            </section>
                        </div>
                    </div>
                    <div class="right-content">
                        <div class="payment-buttons">
                            <div class="partner-button">
                                <div class="button" t-att-class="{ highlight: currentOrder.get_partner() }" t-on-click="selectPartner">
                                    <i class="fa fa-user" role="img" title="Customer"/>
                                    <t t-set="partner" t-value="currentOrder.get_partner()"/>
                                    <span>
                                        <t t-if="partner">
                                            <t t-esc="partner.name"/>
                                        </t>
                                        <t t-if="!partner">
                                            Customer
                                        </t>
                                    </span>
                                </div>
                            </div>
                            <div class="payment-controls">
                                <div class="button js_invoice" t-att-class="{ highlight: currentOrder.is_to_invoice() }" t-on-click="toggleIsToInvoice">
                                    <i class="fa fa-file-text-o"/> Invoice
                                </div>
                                <div t-if="env.pos.config.tip_product_id" class="button js_tip" t-att-class="{ highlight: currentOrder.get_tip() }" t-on-click="addTip">
                                    <i class="fa fa-heart"/> Tip <t t-if="currentOrder.get_tip() != 0">(<t t-esc="env.pos.format_currency(currentOrder.get_tip())"/>)</t>
                                </div>
                                <div t-if="env.pos.config.iface_cashdrawer" class="button js_cashdrawer" t-on-click="openCashbox">
                                    <i class="fa fa-archive"/> Open Cashbox
                                </div>
                                <div t-if="env.pos.config.ship_later" class="button" t-att-class="{ highlight: currentOrder.is_to_ship() }" t-on-click="toggleIsToShip">
                                    <i class="fa fa-clock-o"/> Ship Later
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <t t-if="env.isMobile">
                    <div class="switchpane">
                        <button class="btn-switchpane" t-att-class="{ secondary: !(currentOrder.is_paid() and currentOrder._isValidEmptyOrder()) }" t-on-click="() =&gt; this.trigger('validate-order')">
                            <h1>Validate</h1>
                        </button>
                        <button class="btn-switchpane secondary" t-on-click="() =&gt; this.showScreen('ProductScreen', {mobile_pane: 'left'})">
                            <h1>Review</h1>
                        </button>
                    </div>
                </t>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/PaymentScreen/PaymentScreenNumpad.xml -->

<t t-name="PaymentScreenNumpad" owl="1">
        <div class="numpad">
            <PSNumpadInputButton value="'1'"/>
            <PSNumpadInputButton value="'2'"/>
            <PSNumpadInputButton value="'3'"/>
            <PSNumpadInputButton value="'+10'" changeClassTo="'mode-button'"/>
            <PSNumpadInputButton value="'4'"/>
            <PSNumpadInputButton value="'5'"/>
            <PSNumpadInputButton value="'6'"/>
            <PSNumpadInputButton value="'+20'" changeClassTo="'mode-button'"/>
            <PSNumpadInputButton value="'7'"/>
            <PSNumpadInputButton value="'8'"/>
            <PSNumpadInputButton value="'9'"/>
            <PSNumpadInputButton value="'+50'" changeClassTo="'mode-button'"/>
            <PSNumpadInputButton value="'-'" text="'+/-'"/>
            <PSNumpadInputButton value="'0'"/>
            <PSNumpadInputButton value="decimalPoint"/>
            <PSNumpadInputButton value="'Backspace'">
                <img src="/point_of_sale/static/src/img/backspace.png" width="24" height="21" alt="Backspace"/>
            </PSNumpadInputButton>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/PaymentScreen/PaymentScreenPaymentLines.xml -->

<t t-name="PaymentScreenPaymentLines" owl="1">
            <div class="paymentlines">
                <p class="title-category">Summary</p>
                <t t-foreach="props.paymentLines" t-as="line" t-key="line.cid">
                    <t t-if="line.selected">
                        <div class="paymentline selected" t-att-class="selectedLineClass(line)" t-on-click="() =&gt; this.trigger('select-payment-line', { cid: line.cid })">
                             <div class="payment-name">
                                 <t t-esc="line.payment_method.name"/>
                             </div>
                            <div class="payment-amount">
                                <t t-if="line and line.payment_status and ['done', 'waitingCard', 'waiting', 'reversing', 'reversed'].includes(line.payment_status)">
                                        <t t-esc="env.pos.format_currency_no_symbol(line.get_amount())"/>
                                </t>
                                <t t-else="">
                                        <t t-esc="formatLineAmount(line)"/>
                                </t>
                            </div>
                            <t t-if="!line.payment_status or !['done', 'reversed', 'waitingCard', 'waitingCapture'].includes(line.payment_status)">
                                <div class="delete-button" t-on-click="() =&gt; this.trigger('delete-payment-line', { cid: line.cid })" aria-label="Delete" title="Delete">
                                    <i class="fa fa-times-circle"/>
                                </div>
                            </t>
                        </div>
                        <t t-if="line and line.payment_status">
                            <div class="paymentline electronic_payment">
                                <t t-if="line.payment_status == 'pending'">
                                    <div class="electronic_status">
                                        Payment request pending
                                    </div>
                                    <div class="button send_payment_request highlight" title="Send Payment Request" t-on-click="() =&gt; this.trigger('send-payment-request', line)">
                                        Send
                                    </div>
                                </t>
                                <t t-elif="line.payment_status == 'retry'">
                                    <div class="electronic_status">
                                        Transaction cancelled
                                    </div>
                                    <div class="button send_payment_request highlight" title="Send Payment Request" t-on-click="() =&gt; this.trigger('send-payment-request', line)">
                                        Retry
                                    </div>
                                </t>
                                <t t-elif="line.payment_status == 'force_done'">
                                    <div class="electronic_status">
                                        Connection error
                                    </div>
                                    <div class="button send_force_done" title="Force Done" t-on-click="() =&gt; this.trigger('send-force-done', line)">
                                        Force done
                                    </div>
                                </t>
                                <t t-elif="line.payment_status == 'waitingCard'">
                                    <div class="electronic_status">
                                        Waiting for card
                                    </div>
                                    <div class="button send_payment_cancel" title="Cancel Payment Request" t-on-click="() =&gt; this.trigger('send-payment-cancel', line)">
                                        Cancel
                                    </div>
                                </t>
                                <t t-elif="['waiting', 'waitingCancel', 'waitingCapture'].includes(line.payment_status)">
                                    <div class="electronic_status">
                                        Request sent
                                    </div>
                                    <div>
                                        <i class="fa fa-circle-o-notch fa-spin" role="img"/>
                                    </div>
                                </t>
                                <t t-elif="line.payment_status == 'reversing'">
                                    <div class="electronic_status">
                                        Reversal request sent to terminal
                                    </div>
                                    <div>
                                        <i class="fa fa-circle-o-notch fa-spin" role="img"/>
                                    </div>
                                </t>
                                <t t-elif="line.payment_status == 'done'">
                                    <div class="electronic_status">
                                        Payment Successful
                                    </div>
                                    <t t-if="line.can_be_reversed">
                                        <div class="button send_payment_reversal" title="Reverse Payment" t-on-click="() =&gt; this.trigger('send-payment-reverse', line)">
                                            Reverse
                                        </div>
                                    </t>
                                    <t t-else="">
                                        <div/>
                                    </t>
                                </t>
                                <t t-elif="line.payment_status == 'reversed'">
                                    <div class="electronic_status">
                                        Payment reversed
                                    </div>
                                    <div/>
                                </t>
                            </div>
                        </t>
                    </t>
                    <t t-else="">
                        <div class="paymentline" t-att-class="unselectedLineClass(line)" t-on-click="() =&gt; this.trigger('select-payment-line', { cid: line.cid })">
                             <div class="payment-name">
                                 <t t-esc="line.payment_method.name"/>
                             </div>
                            <div class="payment-amount">
                                <t t-if="line and line.payment_status and ['done', 'waitingCard', 'waiting', 'reversing', 'reversed'].includes(line.payment_status)">
                                        <t t-esc="env.pos.format_currency_no_symbol(line.get_amount())"/>
                                </t>
                                <t t-else="">
                                        <t t-esc="formatLineAmount(line)"/>
                                </t>
                            </div>
                            <t t-if="!line.payment_status or !['done', 'reversed'].includes(line.payment_status)">
                                <div class="delete-button" t-on-click="() =&gt; this.trigger('delete-payment-line', { cid: line.cid })" aria-label="Delete" title="Delete">
                                    <i class="fa fa-times-circle"/>
                                </div>
                            </t>
                        </div>
                    </t>
                </t>
            </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/PaymentScreen/PaymentScreenStatus.xml -->

<t t-name="PaymentScreenStatus" owl="1">
    <div t-if="props.order.get_paymentlines().length === 0" class="paymentlines-empty">
        <div class="total">
            <t t-esc="totalDueText"/>
        </div>
        <div class="message">
            Please select a payment method.
        </div>
    </div>

    <div t-else="">
        <div class="payment-status-container">
            <div>
                <div class="payment-status-remaining">
                    <span class="label">Remaining</span>
                    <span class="amount" t-att-class="{ highlight: props.order.get_due() &gt; 0 }">
                        <t t-esc="remainingText"/>
                    </span>
                </div>
                <div class="payment-status-total-due">
                    <span class="label">Total Due</span>
                    <span>
                        <t t-esc="totalDueText"/>
                    </span>
                </div>
            </div>
            <div>
                <div class="payment-status-change">
                    <span class="label">Change</span>
                    <span class="amount" t-att-class="{ highlight: props.order.get_change() &gt; 0 }">
                        <t t-esc="changeText"/>
                    </span>
                </div>
            </div>
        </div>
    </div>
</t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ProductScreen/ActionpadWidget.xml -->
<t t-name="ActionpadWidget" owl="1">
        <div class="actionpad">
            <button class="button set-partner" t-att-class="{'decentered': isLongName}" t-on-click="() =&gt; this.trigger('click-partner')">
                <t t-if="!env.isMobile"><i class="fa fa-user" role="img" aria-label="Customer" title="Customer"/></t>
                <t t-if="props.partner">
                    <t t-esc="props.partner.name"/>
                </t>
                <t t-else="">
                    Customer
                </t>
            </button>
            <button class="button pay validation" t-on-click="() =&gt; this.trigger(props.actionToTrigger or 'click-pay')">
                <div class="pay-circle" t-att-class="{ 'highlight': props.isActionButtonHighlighted }">
                    <i class="fa fa-chevron-right" role="img" aria-label="Pay" title="Pay"/>
                </div>
                <t t-esc="props.actionName"/>
            </button>
            <button t-if="env.isMobile" class="button back-button" t-on-click="props.onSwitchPane">
                <i class="fa fa-angle-double-left"/>
                Back
            </button>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ProductScreen/CategoryButton.xml -->

<t t-name="CategoryButton" owl="1">
        <span class="category-button" t-on-click="() =&gt; this.trigger('switch-category', props.category.id)">
            <div class="category-img">
                <img t-att-src="imageUrl" alt="Category"/>
            </div>
            <div class="category-name">
                <t t-esc="props.category.name"/>
            </div>
        </span>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ProductScreen/ControlButtons/OrderlineCustomerNoteButton.xml -->

<t t-name="OrderlineCustomerNoteButton" owl="1">
        <div class="control-button">
            <i class="fa fa-sticky-note"/>
            <span> </span>
            <span>Customer Note</span>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ProductScreen/ControlButtons/ProductInfoButton.xml -->

<t t-name="ProductInfoButton" owl="1">
        <div class="control-button">
            <i class="fa fa-info-circle" role="img" aria-label="Info" title="Info"/>
            Info
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ProductScreen/ControlButtons/RefundButton.xml -->

<t t-name="point_of_sale.RefundButton" owl="1">
        <div class="control-button">
            <i class="fa fa-undo" role="img" aria-label="Refund" title="Refund"/>
            Refund
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ProductScreen/ControlButtons/SetFiscalPositionButton.xml -->

<t t-name="SetFiscalPositionButton" owl="1">
        <div class="control-button o_fiscal_position_button">
            <i class="fa fa-book" role="img" aria-label="Set fiscal position" title="Set fiscal position"/>
            <t t-esc="currentFiscalPositionName"/>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ProductScreen/ControlButtons/SetPricelistButton.xml -->

<t t-name="SetPricelistButton" owl="1">
        <div class="control-button o_pricelist_button">
            <i class="fa fa-th-list" role="img" aria-label="Price list" title="Price list"/>
            <t t-esc="currentPricelistName"/>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ProductScreen/NumpadWidget.xml -->

<t t-name="NumpadWidget" owl="1">
        <div class="numpad">
            <button class="input-button number-char" t-on-click="() =&gt; this.sendInput('1')">1</button>
            <button class="input-button number-char" t-on-click="() =&gt; this.sendInput('2')">2</button>
            <button class="input-button number-char" t-on-click="() =&gt; this.sendInput('3')">3</button>
            <button class="mode-button" t-att-class="{'selected-mode': props.activeMode === 'quantity'}" t-on-click="() =&gt; this.changeMode('quantity')">Qty</button>
            <button class="input-button number-char" t-on-click="() =&gt; this.sendInput('4')">4</button>
            <button class="input-button number-char" t-on-click="() =&gt; this.sendInput('5')">5</button>
            <button class="input-button number-char" t-on-click="() =&gt; this.sendInput('6')">6</button>
            <button class="mode-button" t-att-class="{                         'selected-mode': props.activeMode === 'discount',                         'disabled-mode': !hasManualDiscount                     }" t-att-disabled="!hasManualDiscount" t-on-click="() =&gt; this.changeMode('discount')">% Disc</button>
            <button class="input-button number-char" t-on-click="() =&gt; this.sendInput('7')">7</button>
            <button class="input-button number-char" t-on-click="() =&gt; this.sendInput('8')">8</button>
            <button class="input-button number-char" t-on-click="() =&gt; this.sendInput('9')">9</button>
            <button class="mode-button" t-att-class="{                     'selected-mode': props.activeMode === 'price',                     'disabled-mode': !hasPriceControlRights                 }" t-att-disabled="!hasPriceControlRights" t-on-click="() =&gt; this.changeMode('price')">Price</button>
            <button class="input-button numpad-minus" t-att-class="{ 'disabled-mode': props.disableSign }" t-on-click="() =&gt; this.sendInput('-')">+/-</button>
            <button class="input-button number-char" t-on-click="() =&gt; this.sendInput('0')">0</button>
            <button class="input-button number-char" t-on-click="() =&gt; this.sendInput(decimalSeparator)">
                <t t-esc="decimalSeparator"/>
            </button>
            <button class="input-button numpad-backspace" t-on-click="() =&gt; this.sendInput('Backspace')">
                <img style="pointer-events: none;" src="/point_of_sale/static/src/img/backspace.png" width="24" height="21" alt="Backspace"/>
            </button>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ProductScreen/OrderSummary.xml -->

<t t-name="OrderSummary" owl="1">
        <div class="summary clearfix">
            <t t-set="_total" t-value="getTotal()"/>
            <t t-set="_tax" t-value="getTax()"/>
            <div class="line">
                <div class="entry total">
                    <span class="badge">Total: </span>
                    <span class="value">
                        <t t-esc="_total"/>
                    </span>
                    <div t-if="_tax.hasTax" class="subentry">
                        Taxes:
                        <span class="value">
                            <t t-esc="_tax.displayAmount"/>
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ProductScreen/OrderWidget.xml -->

<t t-name="OrderWidget" owl="1">
        <div class="order-container" t-ref="scrollable">
            <div class="order">
                <t t-if="orderlinesArray.length === 0">
                    <div class="order-empty">
                        <i class="fa fa-shopping-cart" role="img" aria-label="Shopping cart" title="Shopping cart"/>
                        <h1>This order is empty</h1>
                    </div>
                </t>
                <t t-else="">
                    <ul class="orderlines">
                        <t t-foreach="orderlinesArray" t-as="orderline" t-key="orderline.id">
                            <Orderline line="orderline"/>
                        </t>
                    </ul>
                    <OrderSummary order="order"/>
                </t>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ProductScreen/Orderline.xml => /pos_sale/static/src/xml/ProductScreen/Orderline.xml -->

<t t-name="Orderline" owl="1">
        <li t-on-click="selectLine" class="orderline" t-att-class="addedClasses">
            <span class="product-name">
                <t t-esc="props.line.get_full_product_name()"/>
                <span> </span>
                <t t-if="props.line.get_product().tracking!=='none' &amp;&amp; (env.pos.picking_type.use_create_lots || env.pos.picking_type.use_existing_lots)">
                    <t t-if="props.line.has_valid_product_lot()">
                        <i t-on-click.stop="lotIconClicked" class="oe_link_icon fa fa-list oe_icon line-lot-icon oe_green" aria-label="Valid product lot" role="img" title="Valid product lot"/>
                    </t>
                    <t t-else="">
                        <i t-on-click.stop="lotIconClicked" class="oe_link_icon fa fa-list oe_icon line-lot-icon oe_red" aria-label="Invalid product lot" role="img" title="Invalid product lot"/>
                    </t>
                </t>
            </span>
            <span class="price">
                <t t-esc="env.pos.format_currency(props.line.get_display_price())"/>
            </span>
            <ul class="info-list">
                <t t-if="props.line.get_quantity_str() !== '1' || props.line.selected ">
                    <li class="info">
                        <em>
                            <t t-esc="props.line.get_quantity_str()"/>
                        </em>
                        <span> </span><t t-esc="props.line.get_unit().name"/>
                        at
                        <t t-if="props.line.display_discount_policy() == 'without_discount' and                             env.pos.round_decimals_currency(props.line.get_unit_display_price()) &lt; env.pos.round_decimals_currency(props.line.get_taxed_lst_unit_price())">
                            <s>
                                <t t-esc="env.pos.format_currency(props.line.get_taxed_lst_unit_price(),'Product Price')"/>
                            </s>
                            <t t-esc="env.pos.format_currency(props.line.get_unit_display_price(),'Product Price')"/>
                        </t>
                        <t t-else="">
                            <t t-esc="env.pos.format_currency(props.line.get_unit_display_price(),'Product Price')"/>
                        </t>
                        /
                        <t t-esc="props.line.get_unit().name"/>
                    </li>
                </t>
                <t t-if="props.line.get_discount_str() !== '0'">
                    <li class="info">
                        With a
                        <em>
                            <t t-esc="props.line.get_discount_str()"/>%
                        </em>
                        discount
                    </li>
                </t>
                <t t-if="customerNote">
                    <li class="info orderline-note">
                        <i class="fa fa-sticky-note" role="img" aria-label="Customer Note" title="Customer Note"/>
                        <t t-esc="customerNote"/>
                    </li>
                </t>
            <!-- Filepath: /pos_sale/static/src/xml/ProductScreen/Orderline.xml ; position="inside" ; {'expr': "//ul[hasclass('info-list')]"} --><t t-if="props.line.get_sale_order()">
                <li class="info orderline-sale-order">
                    <i class="fa fa-basket" role="img" aria-label="SO" title="SO"/>
                    <t t-esc="props.line.get_sale_order().name"/>
                </li>
                <table t-if="props.line.get_sale_order().details" class="sale-order-info">
                    <t t-foreach="props.line.get_sale_order().details" t-as="line" t-key="line_index">
                        <tr>
                            <td><t t-esc="line['product_uom_qty']"/>x</td>
                            <td style="max-width: 275px;">
                                <t t-esc="line['product_name']"/>
                            </td>
                            <td>:</td>
                            <td><t t-esc="env.pos.format_currency(line['total'])"/> (tax incl.)</td>
                        </tr>
                    </t>
                </table>
            </t>
            </ul>
            <t t-if="props.line.pack_lot_lines">
                <ul class="info-list">
                    <t t-foreach="props.line.get_lot_lines()" t-as="lot" t-key="lot.cid">
                        <li>
                            SN <t t-esc="lot.lot_name"/>
                        </li>
                    </t>
                </ul>
            </t>
        </li>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ProductScreen/ProductItem.xml -->

<t t-name="ProductItem" owl="1">
        <article class="product" tabindex="0" t-on-keypress="spaceClickProduct" t-on-click="() =&gt; this.trigger('click-product', props.product)" t-att-data-product-id="props.product.id" t-attf-aria-labelledby="article_product_{{props.product.id}}">
                <t t-if="props.product.image_128">
                    <div class="product-img">
                        <img t-att-src="imageUrl" t-att-alt="props.product.display_name"/>
                    </div>
                </t>
                <div class="product-content">
                    <div t-attf-class="#{props.product.image_128 ? 'product-name' : 'product-name no-image' }" t-attf-id="article_product_{{props.product.id}}">
                        <t t-esc="props.product.display_name"/>
                    </div>
                    <span class="price-tag">
                        <t t-esc="price"/>
                    </span>
                </div>
        </article>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ProductScreen/ProductScreen.xml -->

<t t-name="ProductScreen" owl="1">
        <div class="product-screen screen" t-att-class="{ oe_hidden: !props.isShown }">
            <div class="screen-full-width">
                <div class="leftpane pane-border" t-if="!env.isMobile || state.mobile_pane === 'left'">
                    <OrderWidget/>
                    <div class="pads">
                        <div class="control-buttons">
                            <t t-if="env.isMobile and controlButtons.length &gt; 3">
                                <div class="control-button" t-on-click="_displayAllControlPopup">More...</div>
                            </t>
                            <t t-else="">
                                <t t-foreach="controlButtons" t-as="cb" t-key="cb.name">
                                    <t t-component="cb.component" t-key="cb.name"/>
                                </t>
                            </t>
                        </div>
                        <div class="subpads">
                            <ActionpadWidget partner="partner" actionName="constructor.numpadActionName" onSwitchPane.bind="switchPane"/>
                            <NumpadWidget activeMode="env.pos.numpadMode"/>
                        </div>
                    </div>
                </div>
                <div class="rightpane" t-if="!env.isMobile || state.mobile_pane === 'right'">
                    <ProductsWidget mobileSearchBarIsShown="props.mobileSearchBarIsShown"/>
                    <MobileOrderWidget t-if="env.isMobile" pane="state.mobile_pane" onSwitchPane.bind="switchPane"/>
                </div>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ProductScreen/ProductsWidget.xml -->

<t t-name="ProductsWidget" owl="1">
      <div class="products-widget">
            <ProductsWidgetControlPanel mobileSearchBarIsShown="props.mobileSearchBarIsShown" breadcrumbs="breadcrumbs" subcategories="subcategories" hasNoCategories="hasNoCategories"/>
            <div class="product-list-container">
                <div t-if="productsToDisplay.length != 0" class="product-list">
                    <t t-foreach="productsToDisplay" t-as="product" t-key="product.id">
                        <ProductItem product="product"/>
                    </t>
                </div>
                <div t-else="" class="product-list-empty no-results-message">
                    <p t-if="searchWord">
                        No product found for <b>"<t t-esc="searchWord"/>"</b> in this category.
                    </p>
                    <p t-else="">
                        There are no products in this category.
                    </p>
                </div>
                <div t-if="searchWord" class="search-more-button">
                    <div class="button" t-on-click="_onPressEnterKey">Search more</div>
                </div>
                <div class="portal search-database-button no-results-message" t-att-class="{ oe_hidden:  !shouldShowButton }"/>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ProductScreen/ProductsWidgetControlPanel.xml -->

<t t-name="ProductsWidgetControlPanel" owl="1">
        <div class="products-widget-control">
            <div class="rightpane-header">
                <div class="search-bar-container sb-product">
                    <span t-if="env.isMobile" class="oe_status oe_icon icon" t-on-click="_toggleMobileSearchbar">
                        <i t-attf-class="fa {{props.mobileSearchBarIsShown ? 'fa-arrow-left' : 'fa-search'}}"/>
                    </span>
                    <t t-if="!env.isMobile || props.mobileSearchBarIsShown">
                        <div class="pos-search-bar">
                            <i class="fa fa-search"/>
                            <input t-ref="search-word-input-product" placeholder="Search Products..." type="text" autofocus="autofocus" t-on-keyup="updateSearch"/>
                            <i class="fa fa-times search-clear-partner" t-on-click="_clearSearch"/>
                        </div>
                    </t>
                </div>
                <t t-if="!props.hasNoCategories">
                    <div class="categories-header">

                        <div class="breadcrumbs">
                            <span class="breadcrumb">
                                <span class="breadcrumb-button breadcrumb-home" t-on-click="() =&gt; this.trigger('switch-category', 0)">
                                    <i class="fa fa-home" role="img" aria-label="Home" title="Home"/>
                                </span>
                            </span>
                            <t t-foreach="props.breadcrumbs" t-as="category" t-key="category.id">
                                <span class="breadcrumb">
                                    <i class="breadcrumb-arrow fa fa-caret-right" aria-hidden="true"/>
                                    <span class="breadcrumb-button" t-on-click="() =&gt; this.trigger('switch-category', category.id)">
                                        <t t-esc="category.name"/>
                                    </span>
                                </span>
                            </t>
                        </div>

                        <div t-if="props.subcategories.length &gt; 0 and !displayCategImages" class="category-list simple">
                            <t t-foreach="props.subcategories" t-as="category" t-key="category.id">
                                <span class="category-simple-button" t-on-click="() =&gt; this.trigger('switch-category', category.id)">
                                    <t t-esc="category.name"/>
                                </span>
                            </t>
                        </div>
                    </div>
                </t>
            </div>
            <t t-if="props.subcategories.length &gt; 0 and displayCategImages">
                <div class="categories">
                    <div class="category-list-scroller">
                        <div class="category-list">
                            <t t-foreach="props.subcategories" t-as="category" t-key="category.id">
                                <CategoryButton category="category"/>
                            </t>
                        </div>
                    </div>
                </div>
            </t>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ReceiptScreen/OrderReceipt.xml -->

<t t-name="OrderReceipt" owl="1">
        <div class="pos-receipt">
            <t t-if="receipt.company.logo">
                <img class="pos-receipt-logo" t-att-src="receipt.company.logo" alt="Logo"/>
                <br/>
            </t>
            <t t-if="!receipt.company.logo">
                <h2 class="pos-receipt-center-align">
                    <t t-esc="receipt.company.name"/>
                </h2>
                <br/>
            </t>
            <div class="pos-receipt-contact">
                <t t-if="receipt.company.contact_address">
                    <div><t t-esc="receipt.company.contact_address"/></div>
                </t>
                <t t-if="receipt.company.phone">
                    <div>Tel:<t t-esc="receipt.company.phone"/></div>
                </t>
                <t t-if="receipt.company.vat">
                    <div><t t-esc="receipt.company.vat_label"/>:<t t-esc="receipt.company.vat"/></div>
                </t>
                <t t-if="receipt.company.email">
                    <div><t t-esc="receipt.company.email"/></div>
                </t>
                <t t-if="receipt.company.website">
                    <div><t t-esc="receipt.company.website"/></div>
                </t>
                <t t-if="receipt.header_html">
                    <t t-out="receipt.header_html"/>
                </t>
                <t t-if="!receipt.header_html and receipt.header">
                    <div style="white-space:pre-line"><t t-esc="receipt.header"/></div>
                </t>
                <t t-if="receipt.cashier">
                    <div class="cashier">
                        <div>--------------------------------</div>
                        <div>Served by <t t-esc="receipt.cashier"/></div>
                    </div>
                </t>
            </div>
            <br/><br/>



            <div class="orderlines">
                <t t-call="OrderLinesReceipt"/>
            </div>



            <t t-if="!isTaxIncluded">
                <div class="pos-receipt-right-align">--------</div>
                <br/>
                <div>Subtotal<span t-esc="env.pos.format_currency(receipt.subtotal)" class="pos-receipt-right-align"/></div>
                <t t-foreach="receipt.tax_details" t-as="tax" t-key="tax.tax.id">
                    <div class="responsive-price">
                        <t t-esc="tax.name"/>
                        <span t-esc="env.pos.format_currency_no_symbol(tax.amount)" class="pos-receipt-right-align"/>
                    </div>
                </t>
            </t>


            <div class="pos-receipt-right-align">--------</div>
            <br/>
            <div class="pos-receipt-amount">
                TOTAL
                <span t-esc="env.pos.format_currency(receipt.total_with_tax)" class="pos-receipt-right-align"/>
            </div>
            <t t-if="receipt.total_rounded != receipt.total_with_tax">
                <div class="pos-receipt-amount">
                  Rounding
                <span t-esc="env.pos.format_currency(receipt.rounding_applied)" class="pos-receipt-right-align"/>
                </div>
                <div class="pos-receipt-amount">
                  To Pay
                 <span t-esc="env.pos.format_currency(receipt.total_rounded)" class="pos-receipt-right-align"/>
              </div>
            </t>
            <br/><br/>



            <t t-foreach="receipt.paymentlines" t-as="line" t-key="line.cid">
                <div>
                    <t t-esc="line.name"/>
                    <span t-esc="env.pos.format_currency_no_symbol(line.amount)" class="pos-receipt-right-align"/>
                </div>
            </t>
            <br/>

            <div class="pos-receipt-amount receipt-change">
                CHANGE
                <span t-esc="env.pos.format_currency(receipt.change)" class="pos-receipt-right-align"/>
            </div>
            <br/>



            <t t-if="receipt.total_discount">
                <div>
                    Discounts
                    <span t-esc="env.pos.format_currency(receipt.total_discount)" class="pos-receipt-right-align"/>
                </div>
            </t>
            <t t-if="isTaxIncluded">
                <t id="tax-details" t-foreach="receipt.tax_details" t-as="tax" t-key="tax.tax.id">
                    <div>
                        <t t-esc="tax.name"/>
                        <span t-esc="env.pos.format_currency_no_symbol(tax.amount)" class="pos-receipt-right-align"/>
                    </div>
                </t>
                <div>
                    Total Taxes
                    <span t-esc="env.pos.format_currency(receipt.total_tax)" class="pos-receipt-right-align"/>
                </div>
            </t>

            <div class="before-footer"/>

            <div t-if="receipt.pos_qr_code">
                <br/><br/>
                <div class="pos-receipt-order-data">
                    Scan me to request an invoice for your purchase.
                </div>
                <img id="posqrcode" t-att-src="receipt.pos_qr_code" class="pos-receipt-logo"/>
            </div>


            <div t-if="receipt.footer_html" class="pos-receipt-center-align">
                <t t-out="receipt.footer_html"/>
            </div>

            <div t-if="!receipt.footer_html and receipt.footer" class="pos-receipt-center-align" style="white-space:pre-line">
                <br/>
                <t t-esc="receipt.footer"/>
                <br/>
                <br/>
            </div>

            <div class="after-footer">
                <t t-foreach="receipt.paymentlines" t-as="line" t-key="line_index">
                    <t t-if="line.ticket">
                        <br/>
                        <div class="pos-payment-terminal-receipt">
                            <t t-out="line.ticket"/>
                        </div>
                    </t>
                </t>
            </div>

            <br/>
            <div class="pos-receipt-order-data">
                <div><t t-esc="receipt.name"/></div>
                <t t-if="receipt.date.localestring">
                    <div><t t-esc="receipt.date.localestring"/></div>
                </t>
                <t t-else="">
                    <div><t t-esc="receipt.date.validation_date"/></div>
                </t>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ReceiptScreen/OrderReceipt.xml => /pos_sale/static/src/xml/ReceiptScreen/OrderReceipt.xml -->
    <t t-name="OrderLinesReceipt" owl="1">
        <t t-foreach="receipt.orderlines" t-as="line" t-key="line.id">
            <t t-if="isSimple(line)">
                <div class="responsive-price">
                    <t t-esc="line.product_name_wrapped[0]"/>
                    <span t-esc="env.pos.format_currency_no_symbol(line.price_display)" class="price_display pos-receipt-right-align"/>
                </div>
                <WrappedProductNameLines line="line"/>
            </t>
            <t t-else="">
                <div t-esc="line.product_name_wrapped[0]"/>
                <WrappedProductNameLines line="line"/>
                <t t-if="line.display_discount_policy == 'without_discount' and line.price != line.price_lst">
                    <div class="pos-receipt-left-padding">
                        <t t-esc="env.pos.format_currency_no_symbol(line.price_lst)"/>
                        -&gt;
                        <t t-esc="env.pos.format_currency_no_symbol(line.price)"/>
                    </div>
                </t>
                <t t-elif="line.discount !== 0">
                    <div class="pos-receipt-left-padding">
                        <t t-if="env.pos.config.iface_tax_included === 'total'">
                            <t t-esc="env.pos.format_currency_no_symbol(line.price_with_tax_before_discount)"/>
                        </t>
                        <t t-else="">
                            <t t-esc="env.pos.format_currency_no_symbol(line.price)"/>
                        </t>
                    </div>
                </t>
                <t t-if="line.discount !== 0">
                    <div class="pos-receipt-left-padding">
                        Discount: <t t-esc="line.discount"/>%
                    </div>
                </t>
                <div class="pos-receipt-left-padding">
                    <t t-esc="Math.round(line.quantity * Math.pow(10, env.pos.dp['Product Unit of Measure'])) / Math.pow(10, env.pos.dp['Product Unit of Measure'])"/>
                    <t t-if="!line.is_in_unit" t-esc="line.unit_name"/>
                    x
                    <t t-esc="env.pos.format_currency(line.price_display_one)"/>
                    <span class="price_display pos-receipt-right-align">
                        <t t-esc="env.pos.format_currency_no_symbol(line.price_display)"/>
                    </span>
                </div>
            </t>
            <t t-if="line.customer_note">
                <div class="pos-receipt-left-padding pos-receipt-customer-note">
                    <t t-esc="line.customer_note"/>
                </div>
            </t>
            <t t-if="line.pack_lot_lines">
                <div class="pos-receipt-left-padding">
                    <ul>
                        <t t-foreach="line.pack_lot_lines" t-as="lot" t-key="lot.cid">
                            <li>
                                SN <t t-esc="lot.lot_name"/>
                            </li>
                        </t>
                    </ul>
                </div>
            </t>
            <!-- Filepath: /pos_sale/static/src/xml/ReceiptScreen/OrderReceipt.xml ; position="inside" ; {'expr': '//t[@t-foreach]'} --><div class="pos-receipt-left-padding" t-if="line.so_reference">From <t t-esc="line.so_reference"/></div>
            <div class="pos-receipt-left-padding" t-if="line.down_payment_details">
                <table class="sale-order-info">
                    <tr t-foreach="line.down_payment_details" t-as="line" t-key="line_index">
                        <td><t t-esc="line['product_uom_qty']"/>x</td>
                        <td style="max-width: 200px;">
                            <t t-esc="line['product_name']"/>
                        </td>
                    </tr>
                </table>
            </div>
        </t>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ReceiptScreen/ReceiptScreen.xml -->

<t t-name="ReceiptScreen" owl="1">
        <div class="receipt-screen screen">
            <div class="screen-content">
                <div class="top-content">
                    <div class="top-content-center">
                        <h1 t-if="!env.isMobile">
                            <t t-esc="orderAmountPlusTip"/>
                        </h1>
                    </div>
                </div>
                <div class="default-view">
                    <div class="actions">
                        <h1>How would you like to receive your receipt<t t-if="currentOrder.is_to_invoice()"> &amp; invoice</t>?</h1>
                        <div class="buttons">
                            <div class="button print" t-on-click="printReceipt">
                                <i class="fa fa-print"/> Print Receipt
                            </div>
                        </div>
                        <form t-on-submit.prevent="onSendEmail" class="send-email">
                            <div class="input-email">
                                <input type="email" placeholder="Email Receipt" t-model="orderUiState.inputEmail"/>
                                <button class="send" t-att-class="{ highlight: is_email(orderUiState.inputEmail) }" type="submit">
                                    <i class="fa fa-paper-plane" aria-hidden="true"/>
                                </button>
                            </div>
                        </form>
                        <div class="notice">
                            <div t-if="orderUiState.emailSuccessful !== null" t-attf-class="{{ orderUiState.emailSuccessful ? 'successful' : 'failed' }}">
                                <t t-esc="orderUiState.emailNotice"/>
                            </div>
                            <div class="send-mail-info" t-if="currentOrder.is_to_invoice()">
                                (Both will be sent by email)
                            </div>
                        </div>
                    </div>
                    <div class="pos-receipt-container" t-ref="order-receipt">
                        <OrderReceipt order="currentOrder"/>
                    </div>
                </div>
                <div class="button next validation" t-att-class="{ highlight: !locked }" t-on-click="orderDone">
                    <div class="pay-circle">
                        <i class="fa fa-chevron-right" role="img" aria-label="Pay" title="Pay"/>
                    </div>
                    New Order
                </div>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ReceiptScreen/WrappedProductNameLines.xml -->

<t t-name="WrappedProductNameLines" owl="1">
        <span>
            <t t-foreach="props.line.product_name_wrapped.slice(1)" t-as="wrapped_line" t-key="wrapped_line_index">
                <t t-esc="wrapped_line"/>
            </t>
        </span>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/ScaleScreen/ScaleScreen.xml -->

<t t-name="ScaleScreen" owl="1">
        <div class="scale-screen screen">
            <div class="screen-content">
                <div class="top-content">
                    <span class="button back" t-on-click="back">
                        <i class="fa fa-angle-double-left"/>
                        Back
                    </span>
                    <h1 class="product-name">
                        <t t-esc="productName"/>
                    </h1>
                </div>
                <div class="centered-content">
                    <div class="weight js-weight">
                        <t t-esc="productWeightString"/>
                    </div>
                    <div class="product-price">
                        <t t-esc="env.pos.format_currency(productPrice) + '/' + productUom"/>
                    </div>
                    <div class="computed-price">
                        <t t-esc="computedPriceString"/>
                    </div>
                    <div class="buy-product" t-on-click="confirm">
                        Order
                        <i class="fa fa-angle-double-right"/>
                    </div>
                </div>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/TicketScreen/ControlButtons/InvoiceButton.xml -->

<t t-name="InvoiceButton" owl="1">
        <div class="control-button">
            <i class="fa fa-file-pdf-o"/>
            <span> </span>
            <span><t t-esc="commandName"/></span>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/TicketScreen/ControlButtons/ReprintReceiptButton.xml -->

<t t-name="ReprintReceiptButton" owl="1">
        <div class="control-button">
            <i class="fa fa-print"/>
            <span> </span>
            <span>Print Receipt</span>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/TicketScreen/OrderDetails.xml -->

<t t-name="OrderDetails" owl="1">
        <div class="order-container">
            <div t-ref="scrollable" class="order-scroller touch-scrollable">
                <div class="order">
                    <t t-if="!props.order">
                        <div class="order-empty">
                            <i class="fa fa-shopping-cart" role="img" aria-label="Shopping cart" title="Shopping cart"/>
                            <h1>Select an order</h1>
                        </div>
                    </t>
                    <t t-elif="orderlines.length === 0">
                        <div class="order-empty">
                            <i class="fa fa-shopping-cart" role="img" aria-label="Shopping cart" title="Shopping cart"/>
                            <h1>Order is empty</h1>
                        </div>
                    </t>
                    <t t-else="">
                        <div class="header-note" t-att-class="{ highlight: props.highlightHeaderNote }">
                            Select the product(s) to refund and set the quantity
                        </div>
                        <ul class="orderlines">
                            <t t-foreach="orderlines" t-as="orderline" t-key="orderline.id">
                                <OrderlineDetails line="orderline" isSelected="orderline.id == props.selectedOrderlineId"/>
                            </t>
                        </ul>

                        <div class="summary clearfix">
                            <div class="line">
                                <div class="entry total">
                                    <span class="badge">Total: </span>
                                    <span class="value">
                                        <t t-esc="total"/>
                                    </span>
                                    <div t-if="tax" class="subentry">
                                        Taxes:
                                        <span class="value">
                                            <t t-esc="tax"/>
                                        </span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </t>
                </div>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/TicketScreen/OrderlineDetails.xml -->

<t t-name="OrderlineDetails" owl="1">
        <li class="orderline" t-on-click="() =&gt; this.trigger('click-order-line', props.line)" t-att-class="{ selected: props.isSelected }">
            <span class="product-name">
                <t t-esc="productName"/>
            </span>
            <span class="price">
                <t t-esc="totalPrice"/>
            </span>
            <ul class="info-list">
                <li class="info">
                    <strong>
                        <t t-esc="quantity"/>
                    </strong>
                    <span><t t-esc="pricePerUnit"/></span>
                </li>
                <t t-if="customerNote">
                    <li class="info orderline-note">
                        <i class="fa fa-sticky-note" role="img" aria-label="Customer Note" title="Customer Note"/>
                        <t t-esc="customerNote"/>
                    </li>
                </t>
                <t t-if="hasRefundedQty()">
                    <li class="info refund-note">
                        <strong>
                            <t t-esc="getFormattedRefundedQty()"/>
                        </strong>
                        <span> Refunded</span>
                    </li>
                </t>
                <t t-if="hasToRefundQty()">
                    <li class="info to-refund-highlight refund-note">
                        <t t-set="_destinationOrderUid" t-value="getToRefundDetail().destinationOrderUid"/>
                        <t t-if="_destinationOrderUid">
                            <t t-esc="getRefundingMessage()"/>
                            <span t-esc="_destinationOrderUid" class="order-link" t-on-click.stop="() =&gt; this.trigger('click-refund-order-uid', _destinationOrderUid)"/>
                        </t>
                        <t t-else="">
                            <t t-esc="getToRefundMessage()"/>
                        </t>
                    </li>
                </t>
            </ul>
        </li>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/TicketScreen/ReprintReceiptScreen.xml -->

<t t-name="ReprintReceiptScreen" owl="1">
        <div class="receipt-screen screen">
            <div class="screen-content">
                <div class="top-content">
                    <span class="button back" t-on-click="confirm">
                        <i class="fa fa-angle-double-left"/>
                        <span> </span>
                        <span>Back</span>
                    </span>
                </div>
                <div class="centered-content">
                    <div class="button print" t-on-click="tryReprint">
                        <i class="fa fa-print"/> Print Receipt
                    </div>
                    <div class="pos-receipt-container" t-ref="order-receipt">
                        <OrderReceipt order="props.order"/>
                    </div>
                </div>
            </div>
        </div>
    </t>

<!-- Filepath: /point_of_sale/static/src/xml/Screens/TicketScreen/TicketScreen.xml -->

<t t-name="TicketScreen" owl="1">
        <div class="ticket-screen screen" t-att-class="{ oe_hidden: !props.isShown }">
            <div class="screen-full-width">
                <div class="rightpane pane-border">
                    <div class="controls">
                        <t t-if="!env.isMobile || !state.showSearchBar">
                            <div class="buttons">
                                <button class="discard" t-on-click="() =&gt; this.trigger('close-screen')">
                                    <span class="search-icon">
                                        <i class="fa fa-angle-double-left"/>
                                    </span>
                                    <t t-if="!env.isMobile">
                                        Back
                                    </t>
                                </button>
                                <button t-if="shouldShowNewOrderButton()" class="highlight" t-on-click="() =&gt; this.trigger('create-new-order')">New Order</button>
                            </div>
                        </t>
                        <t t-if="env.isMobile">
                            <t t-if="state.showSearchBar">
                                <button class="arrow-left" t-on-click="() =&gt; { state.showSearchBar = !state.showSearchBar }">
                                    <span class="search-icon">
                                        <i class="fa fa-angle-double-left"/>
                                    </span>
                                </button>
                            </t>
                            <t t-else="">
                                <button class="search" t-on-click="() =&gt; { state.showSearchBar = !state.showSearchBar }">
                                    <span class="search-icon">
                                        <i class="fa fa-search"/>
                                    </span>
                                </button>
                            </t>
                        </t>
                        <SearchBar t-if="state.showSearchBar" config="getSearchBarConfig()" placeholder="constructor.searchPlaceholder"/>
                        <div t-if="shouldShowPageControls()" class="item">
                            <div class="page-controls">
                                <div class="previous" t-on-click="() =&gt; this.trigger('prev-page')">
                                    <i class="fa fa-fw fa-caret-left" role="img" aria-label="Previous Order List" title="Previous Order List"/>
                                </div>
                                <div class="next" t-on-click="() =&gt; this.trigger('next-page')">
                                    <i class="fa fa-fw fa-caret-right" role="img" aria-label="Next Order List" title="Next Order List"/>
                                </div>
                            </div>
                            <div class="page">
                                <span><t t-esc="getPageNumber()"/></span>
                            </div>
                        </div>
                    </div>
                    <div class="orders">
                        <t t-set="_filteredOrderList" t-value="getFilteredOrderList()"/>
                        <t t-if="_filteredOrderList.length !== 0">
                            <div class="header-row" t-att-class="{ oe_hidden: env.isMobile }">
                                <div class="col wide">Date</div>
                                <div class="col wide">Receipt Number</div>
                                <div class="col">Customer</div>
                                <div class="col wide" t-if="showCardholderName()">Cardholder Name</div>
                                <div class="col">Cashier</div>
                                <div class="col end">Total</div>
                                <div class="col narrow">Status</div>
                                <div class="col very-narrow" name="delete"/>
                            </div>
                            <t t-foreach="_filteredOrderList" t-as="order" t-key="order.cid">
                                <div class="order-row" t-att-class="{ highlight: isHighlighted(order) }" t-on-click="() =&gt; this.trigger('click-order', order)">
                                    <div class="col wide">
                                        <div t-if="env.isMobile">Date</div>
                                        <div><t t-esc="getDate(order)"/></div>
                                    </div>
                                    <div class="col wide">
                                        <div t-if="env.isMobile">Receipt Number</div>
                                        <div><t t-esc="order.name"/></div>
                                    </div>
                                    <div class="col">
                                        <div t-if="env.isMobile">Customer</div>
                                        <div><t t-esc="getPartner(order)"/></div>
                                    </div>
                                    <div t-if="showCardholderName()" class="col">
                                        <div t-if="env.isMobile">Cardholder Name</div>
                                        <div><t t-esc="getCardholderName(order)"/></div>
                                    </div>
                                    <div class="col">
                                        <div t-if="env.isMobile">Cashier</div>
                                        <div><t t-esc="getCashier(order)"/></div>
                                    </div>
                                    <div class="col end">
                                        <div t-if="env.isMobile">Total</div>
                                        <div><t t-esc="getTotal(order)"/></div>
                                    </div>
                                    <div class="col narrow">
                                        <div t-if="env.isMobile">Status</div>
                                        <div><t t-esc="getStatus(order)"/></div>
                                    </div>
                                    <div t-if="!shouldHideDeleteButton(order)" class="col very-narrow delete-button" name="delete" t-on-click.stop="() =&gt; this.trigger('delete-order', order)">
                                        <i class="fa fa-trash" aria-hidden="true"/><t t-if="env.isMobile"> Delete</t>
                                    </div>
                                    <div t-else="" class="col very-narrow"/>
                                </div>
                            </t>
                        </t>
                        <t t-else="">
                            <div class="empty-order-list">
                                <i role="img" aria-label="Shopping cart" title="Shopping cart" class="fa fa-shopping-cart"/>
                                <h1>No orders found</h1>
                            </div>
                        </t>
                    </div>
                </div>
                <div class="leftpane">
                    <t t-set="_selectedSyncedOrder" t-value="getSelectedSyncedOrder()"/>
                    <t t-set="_selectedOrderlineId" t-value="getSelectedOrderlineId()"/>
                    <OrderDetails order="_selectedSyncedOrder" selectedOrderlineId="_selectedOrderlineId" highlightHeaderNote="_state.ui.highlightHeaderNote"/>
                    <div class="pads">
                        <div class="control-buttons">
                            <InvoiceButton order="_selectedSyncedOrder"/>
                            <ReprintReceiptButton order="_selectedSyncedOrder"/>
                        </div>
                        <div class="subpads">
                            <ActionpadWidget partner="getSelectedPartner()" actionName="constructor.numpadActionName" actionToTrigger="'do-refund'" isActionButtonHighlighted="getHasItemsToRefund()"/>
                            <NumpadWidget disabledModes="['price', 'discount']" activeMode="_selectedOrderlineId and 'quantity'" disableSign="true"/>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </t>

<!-- Filepath: /pos_epson_printer/static/src/xml/epos_templates.xml -->

<t t-name="ePOSTemplate">
        <s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/">
            <s:Body>
                <epos-print xmlns="http://www.epson-pos.com/schemas/2011/03/epos-print">
                    <t t-out="0"/>
                </epos-print>
            </s:Body>
        </s:Envelope>
    </t>

<!-- Filepath: /pos_epson_printer/static/src/xml/epos_templates.xml -->

    <t t-name="ePOSPrintImage">
        <t t-call="ePOSTemplate">
            <image t-att-width="width" t-att-height="height" align="center" t-esc="image"/>
            <cut type="feed"/>
        </t>
    </t>

<!-- Filepath: /pos_epson_printer/static/src/xml/epos_templates.xml -->

    <t t-name="ePOSDrawer">
        <t t-call="ePOSTemplate">
            <pulse/>
        </t>
    </t>

<!-- Filepath: /pos_sale/static/src/xml/OrderManagementScreen/MobileSaleOrderManagementScreen.xml -->
<div t-name="MobileSaleOrderManagementScreen" class="screen-full-width" owl="1">
    <div class="order-management-screen screen" t-att-class="{ oe_hidden: !props.isShown }">
        <div t-if="mobileState.showDetails" class="leftpane">
            <OrderDetails order="orderManagementContext.selectedOrder"/>
            <div class="pads">
                <div class="control-buttons">
                    <t t-foreach="controlButtons" t-as="cb" t-key="cb.name">
                        <t t-component="cb.component" t-key="cb.name"/>
                    </t>
                </div>
                <div class="subpads">
                    <ActionpadWidget partner="selectedPartner"/>
                    <NumpadWidget/>
                </div>
            </div>
            <div class="back-to-list" t-on-click="() =&gt; { mobileState.showDetails = false; }">
                <span>Back to list</span>
            </div>
        </div>
        <div t-else="" class="rightpane">
            <div class="flex-container">
                <SaleOrderManagementControlPanel/>
                <SaleOrderList orders="orders" initHighlightedOrder="orderManagementContext.selectedOrder"/>
            </div>
        </div>
    </div>
    </div>

<!-- Filepath: /pos_sale/static/src/xml/OrderManagementScreen/SaleOrderList.xml -->

<t t-name="SaleOrderList" owl="1">
        <div class="orders">
            <div class="header-row" t-att-class="{ oe_hidden: env.isMobile }">
                <div class="col name">Order</div>
                <div class="col date">Date</div>
                <div class="col customer">Customer</div>
                <div class="col salesman">Salesperson</div>
                <div class="col end total">Total</div>
                <div class="col state">State</div>
            </div>
            <div class="order-list">
                <t t-foreach="props.orders" t-as="order" t-key="order.id">
                    <SaleOrderRow order="order" highlightedOrder="highlightedOrder"/>
                </t>
            </div>
        </div>
    </t>

<!-- Filepath: /pos_sale/static/src/xml/OrderManagementScreen/SaleOrderManagementControlPanel.xml -->

<t t-name="SaleOrderManagementControlPanel" owl="1">
        <div class="control-panel">
            <div class="item button back" t-on-click="() =&gt; this.trigger('close-screen')">
                <i class="fa fa-angle-double-left"/>
                <span t-if="!env.isMobile"> Back</span>
            </div>
            <div class="item search-box">
                <span class="icon">
                    <i class="fa fa-search"/>
                </span>
                <input type="text" t-ref="autofocus" t-model="orderManagementContext.searchString" t-on-keydown="onInputKeydown" placeholder="E.g. customer: Steward, date: 2020-05-09"/>
                <span class="clear" t-on-click="() =&gt; this.trigger('clear-search')">
                    <i class="fa fa-remove"/>
                </span>
            </div>
            <div t-if="showPageControls" class="item">
                <div class="page-controls">
                    <div class="previous" t-on-click="() =&gt; this.trigger('prev-page')">
                        <i class="fa fa-fw fa-caret-left" role="img" aria-label="Previous Order List" title="Previous Order List"/>
                    </div>
                    <div class="next" t-on-click="() =&gt; this.trigger('next-page')">
                        <i class="fa fa-fw fa-caret-right" role="img" aria-label="Next Order List" title="Next Order List"/>
                    </div>
                </div>
                <div class="page">
                    <span><t t-esc="pageNumber"/></span>
                </div>
            </div>
            <div t-else="" class="item"/>
        </div>
    </t>

<!-- Filepath: /pos_sale/static/src/xml/OrderManagementScreen/SaleOrderManagementScreen.xml -->

<t t-name="SaleOrderManagementScreen" owl="1">
        <div class="order-management-screen screen" t-att-class="{ oe_hidden: !props.isShown }">
                <div class="rightpane">
                    <div class="flex-container">
                        <SaleOrderManagementControlPanel/>
                        <SaleOrderList orders="orders" initHighlightedOrder="orderManagementContext.selectedOrder"/>
                    </div>
                </div>
        </div>
    </t>

<!-- Filepath: /pos_sale/static/src/xml/OrderManagementScreen/SaleOrderRow.xml -->

<t t-name="SaleOrderRow" owl="1">
        <div class="order-row" t-att-class="{ highlight: highlighted }" t-on-click="() =&gt; this.trigger('click-sale-order', props.order)">
            <div class="col name">
                <div t-if="env.isMobile">Order</div>
                <div><t t-esc="name"/></div>
            </div>
            <div class="col date">
                <div t-if="env.isMobile">Date</div>
                <div><t t-esc="date"/></div>
            </div>
            <div class="col partner">
                <div t-if="env.isMobile">Customer</div>
                <div><t t-esc="partner"/></div>
            </div>
            <div class="col salesman">
                <div t-if="env.isMobile">Salesman</div>
                <div><t t-esc="salesman"/></div>
            </div>
            <div class="col end total">
                <div t-if="env.isMobile">Total</div>
                <div class="flex-container">
                    <div class="self-end">
                        <t t-esc="total"/>
                    </div>
                    <div t-if="showAmountUnpaid" class="self-end text-gray">
                        (left: <t t-esc="amountUnpaidRepr"/>)
                    </div>
                </div>
            </div>
            <div class="col state">
                <div t-if="env.isMobile">State</div>
                <div><t t-esc="state"/></div>
            </div>
        </div>
    </t>

<!-- Filepath: /pos_sale/static/src/xml/SetSaleOrderButton.xml -->

<t t-name="SetSaleOrderButton" owl="1">
        <div class="control-button o_sale_order_button">
            <i class="fa fa-link" role="img" aria-label="Set Sale Order" title="Set Sale Order"/> Quotation/Order
        </div>
    </t>

<!-- Filepath: /pos_hr/static/src/xml/HeaderLockButton.xml -->

<t t-name="HeaderLockButton" owl="1">
        <div class="header-button lock-button" t-on-mouseover="() =&gt; this.onMouseOver(true)" t-on-click="showLoginScreen" t-on-mouseout="() =&gt; this.onMouseOver(false)">
            <span class="lock-button">
                <i class="fa" t-att-class="{ 'fa-unlock': state.isUnlockIcon, 'fa-lock': !state.isUnlockIcon }" role="img" t-att-aria-label="state.title" t-att-title="state.title"/>
            </span>
        </div>
    </t>

<!-- Filepath: /pos_hr/static/src/xml/LoginScreen.xml -->

<t t-name="LoginScreen" owl="1">
        <div class="login-overlay">
            <div class="screen-login">
                <div class="login-title"><small>Log in to </small>
                    <t t-esc="shopName"/>
                </div>
                <div class="login-body">
                    <span class="login-element">
                        <img class="login-barcode-img" src="/point_of_sale/static/img/barcode.png"/>
                        <div class="login-barcode-text">Scan your badge</div>
                    </span>
                    <span class="login-or">or</span>
                    <span class="login-element">
                        <button class="login-button select-cashier" t-on-click="selectCashier">Select Cashier</button>
                    </span>
                </div>
            </div>
        </div>
    </t>

</templates>`;
                        return loadXML(templates);
                    });

//# sourceMappingURL=/web/assets/9082-0b9559d/point_of_sale.assets.js.map